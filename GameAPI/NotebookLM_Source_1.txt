=== START OF SOURCE 1 ===



// --- Start of File: Achievement.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class Achievement : Asset, IDescriptionAsset, ILocalizedAsset
{
	public string play_store_id;

	public string steam_id;

	public bool hidden;

	public string group = "miscellaneous";

	public string icon;

	public string locale_key;

	public AchievementCheck action;

	public bool unlocks_something;

	public List<BaseUnlockableAsset> unlock_assets;

	[NonSerialized]
	protected Sprite cached_sprite;

	[NonSerialized]
	private SignalAsset _signal;

	public bool has_signal;

	public void checkBySignal(object pCheckData = null)
	{
		SignalManager.add(_signal, pCheckData);
	}

	public bool check(object pCheckData = null)
	{
		if (AchievementLibrary.isUnlocked(this))
		{
			return true;
		}
		bool flag = true;
		if (action != null)
		{
			flag = action(pCheckData);
		}
		if (flag)
		{
			AchievementLibrary.unlock(this);
			checkUnlockables();
			return true;
		}
		return false;
	}

	private void checkUnlockables()
	{
		if (!isUnlocked() || !unlocks_something)
		{
			return;
		}
		foreach (BaseUnlockableAsset unlock_asset in unlock_assets)
		{
			unlock_asset.unlock();
		}
	}

	public bool isUnlocked()
	{
		return AchievementLibrary.isUnlocked(this);
	}

	public string getLocaleID()
	{
		return locale_key;
	}

	public string getDescriptionID()
	{
		return getLocaleID() + "_description";
	}

	public Sprite getIcon()
	{
		if (cached_sprite == null)
		{
			cached_sprite = SpriteTextureLoader.getSprite(icon);
		}
		if ((Object)(object)cached_sprite == (Object)null)
		{
			Debug.LogError((object)("Error: Sprite not found : " + icon));
		}
		return cached_sprite;
	}

	public void setSignal(SignalAsset pSignal)
	{
		_signal = pSignal;
	}

	public SignalAsset getSignal()
	{
		return _signal;
	}
}
// --- End of File: Achievement.cs ---



// --- Start of File: AchievementButton.cs ---
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class AchievementButton : MonoBehaviour
{
	private Achievement _achievement;

	[SerializeField]
	private Image _icon;

	[SerializeField]
	private Image _background_completed;

	[SerializeField]
	private Image _background_legendary;

	[SerializeField]
	private GameObject _background_default;

	[SerializeField]
	private GameObject _icon_medal;

	public void Load(Achievement pAchievement)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		_achievement = pAchievement;
		Sprite icon = _achievement.getIcon();
		if ((Object)(object)icon != (Object)null)
		{
			_icon.sprite = icon;
			if (!AchievementLibrary.isUnlocked(_achievement))
			{
				((Graphic)_icon).color = Color.black;
				_background_default.SetActive(true);
				((Behaviour)((Component)_background_completed).GetComponent<Image>()).enabled = false;
				_icon_medal.SetActive(false);
			}
		}
		if (pAchievement.unlocks_something)
		{
			((Component)_background_legendary).gameObject.SetActive(true);
		}
		else
		{
			((Component)_background_legendary).gameObject.SetActive(false);
		}
		((Object)this).name = _achievement.id;
	}

	private void Start()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Expected O, but got Unknown
		((Component)this).transform.localScale = new Vector3(0.8f, 0.8f, 0.8f);
		Button component = ((Component)this).GetComponent<Button>();
		((UnityEvent)component.onClick).AddListener(new UnityAction(showTooltip));
		component.OnHover(new UnityAction(showHoverTooltip));
		component.OnHoverOut(new UnityAction(Tooltip.hideTooltip));
	}

	private void showHoverTooltip()
	{
		if (Config.tooltips_active)
		{
			showTooltip();
		}
	}

	private void showTooltip()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Tooltip.show(this, "achievement", new TooltipData
		{
			achievement = _achievement
		});
		((Component)this).transform.localScale = new Vector3(1f, 1f, 1f);
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
		TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(((Component)this).transform, 0.8f, 0.1f), (Ease)26);
	}
}
// --- End of File: AchievementButton.cs ---



// --- Start of File: AchievementCheck.cs ---
using System;

[Serializable]
public delegate bool AchievementCheck(object pCheckData);
// --- End of File: AchievementCheck.cs ---



// --- Start of File: AchievementGoodie.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AchievementGoodie : MonoBehaviour
{
	[SerializeField]
	private Image _icon;

	[SerializeField]
	private Text _name;

	public void load(BaseUnlockableAsset pAsset, bool pUnlocked)
	{
		if (pUnlocked)
		{
			loadUnlocked(pAsset);
		}
		else
		{
			loadLocked(pAsset);
		}
	}

	private void loadLocked(BaseUnlockableAsset pAsset)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		_icon.sprite = pAsset.getSprite();
		((Graphic)_icon).color = Toolbox.color_black;
	}

	private void loadUnlocked(BaseUnlockableAsset pAssets)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		_icon.sprite = pAssets.getSprite();
		((Component)_name).GetComponent<LocalizedText>().setKeyAndUpdate(pAssets.getLocaleID());
		if (!(pAssets is ActorAsset actorAsset))
		{
			if (pAssets is BaseAugmentationAsset baseAugmentationAsset)
			{
				BaseCategoryAsset group = baseAugmentationAsset.getGroup();
				((Graphic)_name).color = group?.getColor() ?? Toolbox.color_white;
			}
			else
			{
				((Graphic)_name).color = Toolbox.color_white;
			}
		}
		else
		{
			KingdomAsset kingdomAsset = AssetManager.kingdoms.get(actorAsset.kingdom_id_wild);
			((Graphic)_name).color = kingdomAsset.default_kingdom_color.getColorText();
		}
	}
}
// --- End of File: AchievementGoodie.cs ---



// --- Start of File: AchievementGroup.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AchievementGroup : MonoBehaviour
{
	public AchievementButton achievementButtonPrefab;

	private List<AchievementButton> _elements = new List<AchievementButton>();

	public Text title;

	public Text counter;

	public Transform transformContent;

	public void showGroup(AchievementGroupAsset pAchievementGroup)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		((Component)title).GetComponent<LocalizedText>().setKeyAndUpdate(pAchievementGroup.getLocaleID());
		((Graphic)title).color = pAchievementGroup.getColor();
		if (pAchievementGroup.achievements_list.Count <= 0)
		{
			return;
		}
		int num = 0;
		foreach (Achievement item in pAchievementGroup.achievements_list)
		{
			AchievementButton achievementButton = Object.Instantiate<AchievementButton>(achievementButtonPrefab, transformContent);
			achievementButton.Load(item);
			if (AchievementLibrary.isUnlocked(item))
			{
				num++;
			}
			_elements.Add(achievementButton);
		}
		counter.text = num + " / " + pAchievementGroup.achievements_list.Count;
	}
}
// --- End of File: AchievementGroup.cs ---



// --- Start of File: AchievementGroupAsset.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class AchievementGroupAsset : BaseCategoryAsset, ILocalizedAsset
{
	[NonSerialized]
	public List<Achievement> achievements_list = new List<Achievement>();

	public override string getLocaleID()
	{
		return "achievement_group_" + id;
	}
}
// --- End of File: AchievementGroupAsset.cs ---



// --- Start of File: AchievementGroupLibrary.cs ---
using System;
using Beebyte.Obfuscator;

[Serializable]
[ObfuscateLiterals]
public class AchievementGroupLibrary : AssetLibrary<AchievementGroupAsset>
{
	public override void init()
	{
		base.init();
		add(new AchievementGroupAsset
		{
			id = "creation",
			color = "#68B3FF"
		});
		add(new AchievementGroupAsset
		{
			id = "worlds",
			color = "#BAFFC2"
		});
		add(new AchievementGroupAsset
		{
			id = "civilizations",
			color = "#BAF0F4"
		});
		add(new AchievementGroupAsset
		{
			id = "creatures",
			color = "#42FF61"
		});
		add(new AchievementGroupAsset
		{
			id = "destruction",
			color = "#FF6B86"
		});
		add(new AchievementGroupAsset
		{
			id = "nature",
			color = "#BAFFC2"
		});
		add(new AchievementGroupAsset
		{
			id = "experiments",
			color = "#FF8F44"
		});
		add(new AchievementGroupAsset
		{
			id = "collection",
			color = "#46DCE3"
		});
		add(new AchievementGroupAsset
		{
			id = "exploration",
			color = "#EFCB00"
		});
		add(new AchievementGroupAsset
		{
			id = "forbidden",
			color = "#C98CFF"
		});
		add(new AchievementGroupAsset
		{
			id = "miscellaneous",
			color = "#B4C4C0"
		});
	}

	public override void linkAssets()
	{
		foreach (Achievement item in AssetManager.achievements.list)
		{
			dict[item.group].achievements_list.Add(item);
		}
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (AchievementGroupAsset item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}
}
// --- End of File: AchievementGroupLibrary.cs ---



// --- Start of File: AchievementLibrary.cs ---
using System;
using System.Collections.Generic;
using Beebyte.Obfuscator;
using UnityEngine;

[Serializable]
[ObfuscateLiterals]
public class AchievementLibrary : AssetLibrary<Achievement>
{
	private const int ZOO_SPECIES_NEED = 33;

	private const int SPECIES_EXPLORER_ASSETS = 52;

	private const int TRAITS_EXPLORER_AMOUNT_FIRST = 40;

	private const int TRAITS_EXPLORER_AMOUNT_SECOND = 60;

	private const int TRAITS_EXPLORER_AMOUNT_THIRD = 90;

	private const int SUBSPECIES_TRAITS_EXPLORER_AMOUNT = 190;

	private const int CULTURE_TRAITS_EXPLORER_AMOUNT = 70;

	private const int LANGUAGE_TRAITS_EXPLORER_AMOUNT = 20;

	private const int CLAN_TRAITS_EXPLORER_AMOUNT = 25;

	private const int RELIGION_TRAITS_EXPLORER_AMOUNT = 33;

	private const int EQUIPMENT_EXPLORER_AMOUNT = 80;

	private const int GENES_EXPLORER_AMOUNT = 35;

	private const int PLOTS_EXPLORER_AMOUNT = 20;

	private const string ONOMASTICS_NAME_FOR_ACHIEVEMENT = "Mako Mako";

	private const int NOT_JUST_A_CULT_UNITS = 7777;

	private const int MULTIPLY_SPOKEN_UNITS = 5555;

	public static Achievement lava_strike;

	public static Achievement baby_tornado;

	public static Achievement rain_tornado;

	public static Achievement many_bombs;

	public static Achievement megapolis;

	public static Achievement wilhelm_scream;

	public static Achievement burger;

	public static Achievement mayday;

	public static Achievement destroy_worldbox;

	public static Achievement custom_world;

	public static Achievement four_race_cities;

	public static Achievement piranha_land;

	public static Achievement print_heart;

	public static Achievement sacrifice;

	public static Achievement final_resolution;

	public static Achievement tnt_and_heat;

	public static Achievement god_finger_lightning;

	public static Achievement ten_thousands_creatures;

	public static Achievement ant_world;

	public static Achievement traits_explorer_40;

	public static Achievement traits_explorer_60;

	public static Achievement traits_explorer_90;

	public static Achievement trait_explorer_subspecies;

	public static Achievement trait_explorer_culture;

	public static Achievement trait_explorer_language;

	public static Achievement trait_explorer_clan;

	public static Achievement trait_explorer_religion;

	public static Achievement equipment_explorer;

	public static Achievement genes_explorer;

	public static Achievement creatures_explorer;

	public static Achievement plots_explorer;

	public static Achievement the_builder;

	public static Achievement the_dwarf;

	public static Achievement the_creator;

	public static Achievement the_light;

	public static Achievement the_sky;

	public static Achievement the_land;

	public static Achievement the_sun;

	public static Achievement the_moon;

	public static Achievement the_living;

	public static Achievement the_rest_day;

	public static Achievement life_is_a_sim;

	public static Achievement gen_5_worlds;

	public static Achievement gen_50_worlds;

	public static Achievement gen_100_worlds;

	public static Achievement the_corrupted_trees;

	public static Achievement the_hell;

	public static Achievement lets_not;

	public static Achievement world_war;

	public static Achievement planet_of_apes;

	public static Achievement super_mushroom;

	public static Achievement the_princess;

	public static Achievement oh_my_crab;

	public static Achievement tornado;

	public static Achievement god_mode;

	public static Achievement greg;

	public static Achievement ninja_turtle;

	public static Achievement great_plague;

	public static Achievement no_hope_only_mush;

	public static Achievement touch_the_grass;

	public static Achievement the_broken;

	public static Achievement the_king;

	public static Achievement the_demon;

	public static Achievement the_accomplished;

	public static Achievement cursed_world;

	public static Achievement boats_disposal;

	public static Achievement engineered_evolution;

	public static Achievement simple_stupid_genetics;

	public static Achievement fast_living;

	public static Achievement long_living;

	public static Achievement ancient_war_of_geometry_and_evil;

	public static Achievement cant_be_too_much;

	public static Achievement zoo;

	public static Achievement mindless_husk;

	public static Achievement master_weaver;

	public static Achievement not_just_a_cult;

	public static Achievement succession;

	public static Achievement multiply_spoken;

	public static Achievement child_named_toto;

	public static Achievement flick_it;

	public static Achievement segregator;

	public static Achievement swarm;

	public static Achievement eternal_chaos;

	public static Achievement minefield;

	public static Achievement godly_smithing;

	public static Achievement master_of_combat;

	public static Achievement clannibals;

	public static Achievement social_network;

	public static Achievement not_on_my_watch;

	public static Achievement may_i_interrupt;

	public static Achievement watch_your_mouth;

	public static Achievement smelly_city;

	public static Achievement ball_to_ball;

	public static Achievement back_to_beta_testing;

	public static Achievement clone_wars;

	public static Achievement sword_with_shotgun;

	public static Achievement tldr;

	public const float LIFE_IS_SIM_HOURS = 24f;

	public override void init()
	{
		base.init();
		Debug.Log((object)"Init Achievements");
		the_accomplished = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_20",
			id = "achievementTheAccomplished",
			action = checkTheAccomplished,
			icon = "ui/Icons/achievements/achievements_theAccomplished",
			group = "creatures"
		});
		the_king = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_17",
			id = "achievementTheKing",
			action = checkTheKing,
			icon = "ui/Icons/achievements/achievements_theKing",
			group = "creatures"
		});
		the_demon = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_21",
			id = "achievementTheDemon",
			action = checkTheDemon,
			icon = "ui/Icons/achievements/achievements_theDemon",
			group = "creatures"
		});
		the_broken = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_22",
			id = "achievementTheBroken",
			action = checkTheBroken,
			icon = "ui/Icons/achievements/achievements_theBroken",
			group = "creatures"
		});
		touch_the_grass = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_10",
			id = "achievementTouchTheGrass",
			icon = "ui/Icons/achievements/achievements_touchTheGrass",
			group = "nature",
			hidden = true
		});
		gen_5_worlds = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_0",
			id = "achievementGen5Worlds",
			action = checkMapCreations5,
			icon = "ui/Icons/achievements/achievements_generate5",
			group = "worlds"
		});
		gen_50_worlds = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_1",
			id = "achievementGen50Worlds",
			action = checkMapCreations50,
			icon = "ui/Icons/achievements/achievements_generate50",
			group = "worlds"
		});
		gen_100_worlds = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_2",
			id = "achievementGen100Worlds",
			action = checkMapCreations100,
			icon = "ui/Icons/achievements/achievements_generate100",
			group = "worlds"
		});
		life_is_a_sim = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_3",
			id = "achievementLifeIsASim",
			hidden = true,
			action = checkLifeIsASim,
			icon = "ui/Icons/achievements/achievements_lifeissimulation",
			group = "miscellaneous"
		});
		the_corrupted_trees = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_31",
			id = "achievementTheCorruptedTrees",
			icon = "ui/Icons/achievements/achievements_corruptedbiome",
			group = "exploration"
		});
		the_hell = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_0",
			id = "achievementTheHell",
			hidden = true,
			action = checkTheHell,
			icon = "ui/Icons/achievements/achievements_infernalbiome",
			group = "destruction"
		});
		lets_not = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_1",
			id = "achievementLetsNot",
			hidden = true,
			action = checkLetsNot,
			icon = "ui/Icons/achievements/achievements_wastelandbiome",
			group = "destruction"
		});
		world_war = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_2",
			id = "achievementWorldWar",
			hidden = true,
			action = checkWorldWar,
			icon = "ui/Icons/achievements/achievements_worldwar",
			group = "civilizations"
		});
		planet_of_apes = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_23",
			id = "achievementPlanetOfApes",
			hidden = true,
			action = checkPlanetOfTheApes,
			icon = "ui/Icons/achievements/achievements_planetofapes",
			group = "creatures"
		});
		super_mushroom = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_24",
			id = "achievementSuperMushroom",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_supermush",
			group = "creatures"
		});
		the_princess = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_25",
			id = "achievementThePrincess",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_princess",
			group = "creatures"
		});
		tornado = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_11",
			id = "achievementTORNADO",
			locale_key = "achievement_tornado",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_cursedtornado",
			group = "nature"
		});
		god_mode = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_13",
			id = "achievementGodMode",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_godmode",
			group = "miscellaneous"
		});
		greg = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_26",
			id = "achievementGreg",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_greg",
			group = "forbidden"
		});
		ninja_turtle = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_27",
			id = "achievementNinjaTurtle",
			icon = "ui/Icons/achievements/achievements_ninjaturtle",
			action = delegate(object pActor)
			{
				Actor actor = pActor as Actor;
				if (!actor.asset.flag_turtle)
				{
					return false;
				}
				return actor.level >= 10;
			},
			group = "creatures"
		});
		great_plague = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_3",
			id = "achievementGreatPlague",
			hidden = true,
			action = checkGreatPlague,
			icon = "ui/Icons/achievements/achievements_plagueworld",
			group = "experiments"
		});
		lava_strike = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "2_4",
			id = "achievementLavaStrike",
			hidden = true,
			icon = "ui/Icons/actor_traits/iconLightning",
			group = "destruction"
		});
		baby_tornado = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAw",
			steam_id = "2_12",
			id = "achievementBabyTornado",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_babytornado",
			group = "nature"
		});
		rain_tornado = add(new Achievement
		{
			id = "achievementRainTornado",
			play_store_id = "CgkIia6M98wfEAIQAw",
			steam_id = "2_21",
			icon = "ui/Icons/achievements/achievements_raintornado",
			group = "nature",
			hidden = true,
			action = checkRainTornado
		});
		ten_thousands_creatures = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQBA",
			steam_id = "1_4",
			id = "achievement10000Creatures",
			action = check10000Creatures,
			icon = "ui/Icons/achievements/achievements_1000Creatures",
			group = "creation"
		});
		many_bombs = add(new Achievement
		{
			play_store_id = "",
			steam_id = "2_5",
			id = "achievementManyBombs",
			action = checkManyBombs,
			icon = "ui/Icons/iconBomb",
			group = "destruction"
		});
		megapolis = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQBg",
			steam_id = "1_18",
			hidden = true,
			id = "achievementMegapolis",
			action = checkMegapolis,
			icon = "ui/Icons/achievements/achievements_megapolis",
			group = "civilizations"
		});
		wilhelm_scream = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQBw",
			steam_id = "2_14",
			id = "achievementMakeWilhelmScream",
			hidden = true,
			icon = "ui/Icons/iconHumans",
			group = "exploration"
		});
		burger = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_15",
			id = "achievementBurger",
			hidden = true,
			icon = "ui/Icons/iconBurger",
			group = "exploration"
		});
		burger = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_16",
			id = "achievementPie",
			hidden = true,
			icon = "ui/Icons/iconResPie",
			group = "exploration"
		});
		mayday = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_6",
			id = "achievementMayday",
			hidden = true,
			icon = "ui/Icons/iconSanta",
			group = "destruction"
		});
		destroy_worldbox = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_17",
			id = "achievementDestroyWorldBox",
			hidden = true,
			icon = "ui/Icons/iconBrowse2",
			group = "exploration"
		});
		custom_world = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_5",
			id = "achievementCustomWorld",
			hidden = true,
			icon = "ui/Icons/iconTileSoil",
			group = "creation"
		});
		four_race_cities = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_19",
			id = "achievement4RaceCities",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_4Races",
			action = check4RaceCities,
			group = "civilizations"
		});
		piranha_land = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_28",
			id = "achievementPiranhaLand",
			hidden = true,
			icon = "ui/Icons/iconPiranha",
			action = checkPiranhaLand,
			group = "experiments"
		});
		print_heart = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_6",
			id = "achievementPrintHeart",
			hidden = true,
			action = checkPrintHeart,
			icon = "ui/Icons/achievements/achievements_printHeart",
			group = "creation"
		});
		sacrifice = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_29",
			id = "achievementSacrifice",
			hidden = true,
			icon = "ui/Icons/iconSheep",
			group = "experiments"
		});
		ant_world = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "1_30",
			id = "achievementAntWorld",
			hidden = true,
			icon = "ui/Icons/iconAntBlack",
			action = checkAntWorld,
			group = "creatures"
		});
		final_resolution = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_7",
			id = "achievementFinalResolution",
			hidden = true,
			icon = "ui/Icons/iconGreygoo",
			group = "destruction"
		});
		tnt_and_heat = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_8",
			id = "achievementTntAndHeat",
			hidden = true,
			icon = "ui/Icons/iconTnt",
			group = "destruction"
		});
		god_finger_lightning = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_9",
			id = "achievementGodFingerLightning",
			hidden = true,
			icon = "ui/Icons/iconGodFinger",
			group = "destruction"
		});
		traits_explorer_40 = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_18",
			id = "achievementTraitsExplorer40",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traitexplorer1",
			group = "collection",
			action = (object _) => checkTraitsExplorer(40)
		});
		traits_explorer_60 = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_19",
			id = "achievementTraitsExplorer60",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traitexplorer2",
			group = "collection",
			action = (object _) => checkTraitsExplorer(60)
		});
		traits_explorer_90 = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "2_20",
			id = "achievementTraitsExplorer90",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traitexplorer3",
			group = "collection",
			action = (object _) => checkTraitsExplorer(90)
		});
		trait_explorer_subspecies = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTraitExplorerSubspecies",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traits_explorer_subspecies",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(190, AssetManager.subspecies_traits)
		});
		trait_explorer_culture = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTraitExplorerCulture",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traits_explorer_culture",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(70, AssetManager.culture_traits)
		});
		trait_explorer_language = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTraitExplorerLanguage",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traits_explorer_language",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(20, AssetManager.language_traits)
		});
		trait_explorer_clan = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTraitExplorerClan",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traits_explorer_clan",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(25, AssetManager.clan_traits)
		});
		trait_explorer_religion = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTraitExplorerReligion",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_traits_explorer_religion",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(33, AssetManager.religion_traits)
		});
		equipment_explorer = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementEquipmentExplorer",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_equipment_explorer",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(80, AssetManager.items)
		});
		genes_explorer = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementGenesExplorer",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_genes_explorer",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(35, AssetManager.gene_library)
		});
		creatures_explorer = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementCreaturesExplorer",
			hidden = true,
			icon = "ui/Icons/achievements/achievements_creatures_explorer",
			group = "collection",
			action = checkCreaturesExplorer
		});
		plots_explorer = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementPlotsExplorer",
			hidden = false,
			icon = "ui/Icons/achievements/achievements_plots_explorer",
			group = "collection",
			action = (object _) => checkUnlockAugmentations(20, AssetManager.plots_library)
		});
		cursed_world = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementCursedWorld",
			hidden = true,
			icon = "ui/Icons/achievements/achievement_cursed_world",
			action = checkCursedWorld,
			group = "forbidden"
		});
		boats_disposal = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementBoatsDisposal",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_boats_disposal",
			group = "destruction",
			action = checkBoatDisposal
		});
		engineered_evolution = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementEngineeredEvolution",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_engineered_evolution",
			group = "experiments"
		});
		simple_stupid_genetics = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSimpleStupidGenetics",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_simple_stupid_genetics",
			group = "experiments",
			action = checkSimpleStupidGenetics
		});
		fast_living = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementFastLiving",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_fast_living",
			group = "experiments",
			action = checkFastLiving
		});
		long_living = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementLongLiving",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_long_living",
			group = "experiments",
			action = checkLongLiving
		});
		ancient_war_of_geometry_and_evil = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementAncientWarOfGeometryAndEvil",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_ancient_war_of_geometry_and_evil",
			group = "civilizations",
			action = checkAncientWarOfGeometryAndEvil
		});
		cant_be_too_much = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementCantBeTooMuch",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_cant_be_too_much",
			group = "creation",
			action = checkCantBeTooMuch
		});
		zoo = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementZoo",
			hidden = true,
			icon = "ui/Icons/achievements/achievement_zoo",
			group = "civilizations",
			action = checkZoo
		});
		mindless_husk = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMindlessHusk",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_mindless_husk",
			group = "experiments",
			action = checkMindlessHusk
		});
		master_weaver = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMasterWeaver",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_master_weaver",
			group = "experiments",
			action = checkMasterWeaver
		});
		not_just_a_cult = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementNotJustACult",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_not_just_a_cult",
			group = "civilizations",
			action = checkNotJustACult
		});
		succession = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSuccession",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_succession",
			group = "experiments"
		});
		multiply_spoken = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMultiplySpoken",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_multiply_spoken",
			group = "civilizations",
			action = checkMultiplySpoken
		});
		child_named_toto = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementChildNamedToto",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_child_named_toto",
			group = "experiments",
			action = checkChildNamedMakoMako
		});
		flick_it = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementFlickIt",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_flick_it",
			group = "experiments"
		});
		segregator = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSegregator",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_segregator",
			group = "creation",
			action = checkSegregator
		});
		eternal_chaos = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementEternalChaos",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_eternal_chaos",
			group = "nature",
			action = checkEternalChaos
		});
		minefield = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMinefield",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_minefield",
			group = "nature",
			action = checkMinefield
		});
		godly_smithing = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementGodlySmithing",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_godly_smithing",
			group = "experiments"
		});
		master_of_combat = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMasterOfCombat",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_master_of_combat",
			group = "creatures",
			action = checkMasterOfCombat
		});
		clannibals = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementClannibals",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_clannibals",
			group = "creatures",
			action = checkClannibals
		});
		social_network = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSocialNetwork",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_social_network",
			group = "miscellaneous"
		});
		watch_your_mouth = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementWatchYourMouth",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_watch_your_mouth",
			group = "creatures",
			action = checkWatchYourMouth
		});
		clone_wars = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementCloneWars",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_clone_wars",
			group = "experiments",
			action = checkCloneWars
		});
		smelly_city = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSmellyCity",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_smelly_city",
			group = "civilizations",
			action = checkSmellyCity
		});
		tldr = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementTLDR",
			locale_key = "achievement_tldr",
			hidden = true,
			icon = "ui/Icons/achievements/achievement_tldr",
			group = "exploration"
		});
		not_on_my_watch = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementNotOnMyWatch",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_not_on_my_watch",
			group = "civilizations",
			action = checkNotOnMyWatch
		});
		may_i_interrupt = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementMayIInterrupt",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_may_i_interrupt",
			group = "civilizations",
			action = checkMayIInterrupt
		});
		ball_to_ball = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementBallToBall",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_ball_to_ball",
			group = "destruction",
			action = checkBallToBall
		});
		sword_with_shotgun = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSwordWithShotgun",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_sword_with_shotgun",
			group = "creatures",
			action = checkSwordWithShotgun
		});
		back_to_beta_testing = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementBackToBetaTesting",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_back_to_beta_testing",
			group = "creatures",
			action = checkBackToBetaTesting
		});
		swarm = add(new Achievement
		{
			play_store_id = "?",
			steam_id = "?",
			id = "achievementSwarm",
			hidden = false,
			icon = "ui/Icons/achievements/achievement_swarm",
			group = "creatures",
			action = checkSwarm
		});
		standaloneAchievements();
	}

	private void standaloneAchievements()
	{
		the_builder = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_7",
			id = "achievementTheBuilder",
			icon = "ui/Icons/achievements/achievements_thebuilder",
			group = "worlds"
		});
		the_dwarf = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_8",
			id = "achievementTheDwarf",
			icon = "ui/Icons/achievements/achievements_thedwarf",
			group = "worlds"
		});
		the_creator = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_9",
			id = "achievementTheCreator",
			icon = "ui/Icons/achievements/achievements_thecreator",
			group = "worlds"
		});
		the_light = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_10",
			id = "achievementTheLight",
			icon = "ui/Icons/achievements/achievements_thelight",
			group = "worlds"
		});
		the_sky = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_11",
			id = "achievementTheSky",
			icon = "ui/Icons/achievements/achievements_thesky",
			group = "worlds"
		});
		the_land = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_12",
			id = "achievementTheLand",
			icon = "ui/Icons/achievements/achievements_theland",
			group = "worlds"
		});
		the_sun = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_13",
			id = "achievementTheSun",
			icon = "ui/Icons/achievements/achievements_thesun",
			group = "worlds"
		});
		the_moon = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_14",
			id = "achievementTheMoon",
			icon = "ui/Icons/achievements/achievements_themoon",
			group = "worlds"
		});
		the_living = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_15",
			id = "achievementTheLiving",
			icon = "ui/Icons/achievements/achievements_theliving",
			group = "worlds"
		});
		the_rest_day = add(new Achievement
		{
			play_store_id = "CgkIia6M98wfEAIQAg",
			steam_id = "1_16",
			id = "achievementTheRestDay",
			icon = "ui/Icons/achievements/achievements_restday",
			group = "worlds"
		});
		WorkshopAchievements.checkAchievements();
	}

	public override void post_init()
	{
		base.post_init();
		foreach (Achievement item in list)
		{
			Achievement achievement = item;
			if (achievement.locale_key == null)
			{
				achievement.locale_key = item.id.Underscore();
			}
			if (item.getSignal() != null)
			{
				item.has_signal = true;
			}
		}
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (Achievement item in list)
		{
			addAsUnlockAssets(item, AssetManager.traits);
			addAsUnlockAssets(item, AssetManager.subspecies_traits);
			addAsUnlockAssets(item, AssetManager.culture_traits);
			addAsUnlockAssets(item, AssetManager.language_traits);
			addAsUnlockAssets(item, AssetManager.clan_traits);
			addAsUnlockAssets(item, AssetManager.religion_traits);
			addAsUnlockAssets(item, AssetManager.kingdoms_traits);
			addAsUnlockAssets(item, AssetManager.gene_library);
			addAsUnlockAssets(item, AssetManager.items);
			addAsUnlockAssets(item, AssetManager.actor_library);
			addAsUnlockAssets(item, AssetManager.plots_library);
		}
	}

	private void addAsUnlockAssets(Achievement pAchievement, ILibraryWithUnlockables pLibrary)
	{
		foreach (BaseUnlockableAsset item in pLibrary.elements_list)
		{
			if (item.unlocked_with_achievement && !(item.achievement_id != pAchievement.id))
			{
				if (pAchievement.unlock_assets == null)
				{
					pAchievement.unlock_assets = new List<BaseUnlockableAsset>();
					pAchievement.unlocks_something = true;
				}
				pAchievement.unlock_assets.Add(item);
			}
		}
	}

	public static void unlock(string pID)
	{
		Achievement achievement = AssetManager.achievements.get(pID);
		if (achievement != null)
		{
			unlock(achievement);
		}
	}

	public static void unlock(Achievement pAchievement)
	{
		if (WorldLawLibrary.world_law_cursed_world.isEnabled())
		{
			return;
		}
		SteamAchievements.TriggerAchievement(pAchievement.id);
		if (!isUnlocked(pAchievement))
		{
			if (GameProgress.unlockAchievement(pAchievement.id))
			{
				AchievementPopup.show(pAchievement);
			}
			Analytics.LogEvent("Achievement", "id", pAchievement.id);
			MapBox.aye();
		}
	}

	public static bool isUnlocked(Achievement pAchievement)
	{
		return GameProgress.isAchievementUnlocked(pAchievement.id);
	}

	public static bool isUnlocked(string pID)
	{
		return GameProgress.isAchievementUnlocked(pID);
	}

	private static bool checkTraitsExplorer(int pAmount)
	{
		int num = 0;
		foreach (ActorTrait item in AssetManager.traits.list)
		{
			if (item.isAvailable())
			{
				num++;
			}
		}
		if (num < pAmount)
		{
			return false;
		}
		return true;
	}

	private static bool checkUnlockAugmentations(int pAmount, ILibraryWithUnlockables pLibrary)
	{
		int num = 0;
		foreach (BaseUnlockableAsset item in pLibrary.elements_list)
		{
			if (item.isAvailable())
			{
				num++;
			}
		}
		if (num < pAmount)
		{
			return false;
		}
		return true;
	}

	private static bool checkAntWorld(object pCheckData = null)
	{
		List<Actor> units = World.world.kingdoms_wild.get("ants").units;
		if (units.Count < 40)
		{
			return false;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		for (int i = 0; i < units.Count; i++)
		{
			switch (units[i].asset.id)
			{
			case "ant_black":
				num++;
				break;
			case "ant_blue":
				num4++;
				break;
			case "ant_red":
				num3++;
				break;
			case "ant_green":
				num2++;
				break;
			}
		}
		if (num4 >= 10 && num2 >= 10 && num3 >= 10 && num >= 10)
		{
			return true;
		}
		return false;
	}

	private static bool checkCursedWorld(object pCheckData = null)
	{
		return WorldLawLibrary.world_law_cursed_world.isEnabledRaw();
	}

	private static bool checkBoatDisposal(object pCheckData = null)
	{
		if (StatsHelper.getStat("statistics_boats_destroyed_by_magnet") < 10)
		{
			return false;
		}
		return true;
	}

	private static bool check10000Creatures(object pCheckData = null)
	{
		if (World.world.game_stats.data.creaturesCreated >= 10000)
		{
			return true;
		}
		return false;
	}

	private static bool checkManyBombs(object pCheckData = null)
	{
		if (World.world.game_stats.data.bombsDropped >= 1000)
		{
			return true;
		}
		return false;
	}

	private static bool checkMegapolis(object pCheckData = null)
	{
		foreach (City city in World.world.cities)
		{
			if (!(city.getSpecies() != "human") && city.getPopulationPeople() >= 200)
			{
				return true;
			}
		}
		return false;
	}

	private static bool check4RaceCities(object pCheckData = null)
	{
		if (World.world.cities.Count < 4)
		{
			return false;
		}
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		using (IEnumerator<City> enumerator = World.world.cities.GetEnumerator())
		{
			while (enumerator.MoveNext())
			{
				switch (enumerator.Current.getSpecies())
				{
				case "human":
					flag = true;
					break;
				case "orc":
					flag2 = true;
					break;
				case "elf":
					flag3 = true;
					break;
				case "dwarf":
					flag4 = true;
					break;
				}
			}
		}
		if (flag && flag2 && flag3 && flag4)
		{
			return true;
		}
		return false;
	}

	private static bool checkPiranhaLand(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		if (actor.asset.id != "piranha")
		{
			return false;
		}
		if (!actor.mustAvoidGround())
		{
			return false;
		}
		if (actor.current_tile.Type.liquid)
		{
			return false;
		}
		return true;
	}

	private static bool checkPrintHeart(object pCheckData = null)
	{
		if (((GodPower)pCheckData).printers_print == "heart")
		{
			return true;
		}
		return false;
	}

	internal static void checkSteamMapUploads()
	{
		long workshopUploads = World.world.game_stats.data.workshopUploads;
		if (workshopUploads >= 1)
		{
			the_builder.check();
		}
		if (workshopUploads >= 3)
		{
			the_dwarf.check();
		}
		if (workshopUploads >= 5)
		{
			the_creator.check();
		}
	}

	internal static void checkSteamMapDownloads(int pDownloads)
	{
		if (pDownloads >= 1)
		{
			the_light.check();
		}
		if (pDownloads >= 2)
		{
			the_sky.check();
		}
		if (pDownloads >= 3)
		{
			the_land.check();
		}
		if (pDownloads >= 4)
		{
			the_sun.check();
		}
		if (pDownloads >= 5)
		{
			the_moon.check();
		}
		if (pDownloads >= 6)
		{
			the_living.check();
		}
		if (pDownloads >= 7)
		{
			the_rest_day.check();
		}
	}

	private static bool checkLifeIsASim(object pCheckData = null)
	{
		if (Mathf.Ceil(Time.realtimeSinceStartup) / 3600f > 24f)
		{
			return true;
		}
		return false;
	}

	private static bool checkTheDemon(object pCheckData = null)
	{
		if (!SelectedUnit.isSet())
		{
			return false;
		}
		if (SelectedUnit.unit.hasDivineScar())
		{
			return false;
		}
		if (SelectedUnit.unit.asset.id != "demon")
		{
			return false;
		}
		if (SelectedUnit.unit.countTraits() < 10)
		{
			return false;
		}
		return true;
	}

	private static bool checkTheKing(object pCheckData = null)
	{
		if (!SelectedUnit.isSet())
		{
			return false;
		}
		if (SelectedUnit.unit.hasDivineScar())
		{
			return false;
		}
		if (!SelectedUnit.unit.isKing())
		{
			return false;
		}
		if (SelectedUnit.unit.countTraits() < 20)
		{
			return false;
		}
		return true;
	}

	private static bool checkTheAccomplished(object pCheckData = null)
	{
		if (!SelectedUnit.isSet())
		{
			return false;
		}
		if (SelectedUnit.unit.hasDivineScar())
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("veteran"))
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("mageslayer"))
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("dragonslayer"))
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("kingslayer"))
		{
			return false;
		}
		return true;
	}

	private static bool checkTheBroken(object pCheckData = null)
	{
		if (!SelectedUnit.isSet())
		{
			return false;
		}
		if (SelectedUnit.unit.hasDivineScar())
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("crippled"))
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("eyepatch"))
		{
			return false;
		}
		if (!SelectedUnit.unit.hasTrait("skin_burns"))
		{
			return false;
		}
		return true;
	}

	private static bool checkMapCreations100(object pCheckData = null)
	{
		if (World.world.game_stats.data.mapsCreated >= 100)
		{
			return true;
		}
		return false;
	}

	private static bool checkMapCreations50(object pCheckData = null)
	{
		if (World.world.game_stats.data.mapsCreated >= 50)
		{
			return true;
		}
		return false;
	}

	private static bool checkMapCreations5(object pCheckData = null)
	{
		if (World.world.game_stats.data.mapsCreated >= 5)
		{
			return true;
		}
		return false;
	}

	private static bool checkTheHell(object pCheckData = null)
	{
		float num = TopTileLibrary.infernal_high.hashset.Count + TopTileLibrary.infernal_low.hashset.Count;
		if (num == 0f)
		{
			return false;
		}
		float num2 = World.world.tiles_list.Length;
		if (num / num2 < 0.666f)
		{
			return false;
		}
		if (World.world.kingdoms_wild.get("demon").units.Count >= 66)
		{
			return true;
		}
		return false;
	}

	private static bool checkLetsNot(object pCheckData = null)
	{
		float num = TopTileLibrary.wasteland_high.hashset.Count + TopTileLibrary.wasteland_low.hashset.Count;
		float num2 = World.world.tiles_list.Length;
		if (num / num2 >= 0.9f)
		{
			return true;
		}
		return false;
	}

	private static bool checkWorldWar(object pCheckData = null)
	{
		int num = 0;
		foreach (Kingdom kingdom in World.world.kingdoms)
		{
			if (kingdom.hasEnemies())
			{
				num++;
				if (num >= 10)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool checkPlanetOfTheApes(object pCheckData = null)
	{
		float num = TopTileLibrary.wasteland_high.hashset.Count + TopTileLibrary.wasteland_low.hashset.Count;
		float num2 = TopTileLibrary.jungle_high.hashset.Count + TopTileLibrary.jungle_low.hashset.Count;
		float num3 = World.world.tiles_list.Length;
		float num4 = num / num3;
		float num5 = num2 / num3;
		float num6 = num4 + num5;
		if (World.world.kingdoms_wild.get("monkey").units.Count >= 100 && num6 > 0.8f)
		{
			return true;
		}
		return false;
	}

	private static bool checkGreatPlague(object pCheckData = null)
	{
		if (World.world.map_stats.current_infected_plague < 1000)
		{
			return false;
		}
		return true;
	}

	private static bool checkRainTornado(object pCheckData = null)
	{
		if (World.world.map_stats.world_age_id != "age_tears")
		{
			return false;
		}
		return World.world.stack_effects.get("fx_tornado").getList().Count >= 100;
	}

	private static bool checkSimpleStupidGenetics(object pCheckData = null)
	{
		Subspecies selected_subspecies = SelectedMetas.selected_subspecies;
		if (selected_subspecies == null)
		{
			return false;
		}
		List<Chromosome> chromosomes = selected_subspecies.nucleus.chromosomes;
		GeneAsset geneAsset = null;
		foreach (Chromosome item in chromosomes)
		{
			foreach (GeneAsset gene in item.genes)
			{
				if (!gene.is_empty)
				{
					if (geneAsset == null)
					{
						geneAsset = gene;
					}
					if (geneAsset != gene)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	private static bool checkFastLiving(object pCheckData = null)
	{
		Subspecies selected_subspecies = SelectedMetas.selected_subspecies;
		if (selected_subspecies == null)
		{
			return false;
		}
		int num = 2;
		float num2 = selected_subspecies.base_stats["lifespan"];
		float num3 = selected_subspecies.base_stats["lifespan"] + num2;
		float num4 = selected_subspecies.base_stats_female["lifespan"] + num2;
		if (num3 <= (float)num && num4 <= (float)num)
		{
			return true;
		}
		return false;
	}

	private static bool checkLongLiving(object pCheckData = null)
	{
		Subspecies selected_subspecies = SelectedMetas.selected_subspecies;
		if (selected_subspecies == null)
		{
			return false;
		}
		int num = 3000;
		float num2 = selected_subspecies.base_stats["lifespan"];
		float num3 = selected_subspecies.base_stats_male["lifespan"] + num2;
		float num4 = selected_subspecies.base_stats_female["lifespan"] + num2;
		if (num3 >= (float)num && num4 >= (float)num)
		{
			return true;
		}
		return false;
	}

	private static bool checkAncientWarOfGeometryAndEvil(object pCheckData = null)
	{
		foreach (War war in World.world.wars)
		{
			if (war.hasEnded())
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			foreach (Kingdom attacker in war.getAttackers())
			{
				if (attacker.getSpecies() == "angle")
				{
					flag = true;
				}
				if (attacker.getSpecies() == "demon")
				{
					flag2 = true;
				}
			}
			foreach (Kingdom defender in war.getDefenders())
			{
				if (defender.getSpecies() == "angle")
				{
					flag = true;
				}
				if (defender.getSpecies() == "demon")
				{
					flag2 = true;
				}
			}
			if (flag && flag2)
			{
				return true;
			}
		}
		return false;
	}

	private static bool checkCantBeTooMuch(object pCheckData = null)
	{
		int num = 10;
		int num2 = 0;
		foreach (Building building in World.world.buildings)
		{
			if (!(building.asset.id != "monolith"))
			{
				num2++;
			}
		}
		if (num2 >= num)
		{
			return true;
		}
		return false;
	}

	private static bool checkZoo(object pCheckData = null)
	{
		using ListPool<string> listPool = new ListPool<string>();
		using (IEnumerator<City> enumerator = World.world.cities.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				City current = enumerator.Current;
				listPool.Clear();
				foreach (Actor unit in current.units)
				{
					string item = unit.asset.id;
					if (!listPool.Contains(item))
					{
						listPool.Add(item);
					}
				}
				if (listPool.Count < 33)
				{
					return false;
				}
				return true;
			}
		}
		return false;
	}

	private static bool checkMindlessHusk(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		UtilityBasedDecisionSystem decision_system = DecisionHelper.decision_system;
		int counter = decision_system.getCounter();
		DecisionAsset[] actions = decision_system.getActions();
		for (int i = 0; i < counter; i++)
		{
			DecisionAsset decisionAsset = actions[i];
			if (actor.isDecisionEnabled(decisionAsset.decision_index))
			{
				return false;
			}
		}
		return true;
	}

	private static bool checkMasterWeaver(object pCheckData = null)
	{
		Subspecies selected_subspecies = SelectedMetas.selected_subspecies;
		if (selected_subspecies == null)
		{
			return false;
		}
		if (selected_subspecies.getActorAsset().id != "butterfly")
		{
			return false;
		}
		foreach (Chromosome chromosome in selected_subspecies.nucleus.chromosomes)
		{
			if (!chromosome.isAllLociSynergy())
			{
				return false;
			}
		}
		return true;
	}

	private static bool checkNotJustACult(object pCheckData = null)
	{
		if (((Religion)pCheckData).countUnits() < 7777)
		{
			return false;
		}
		return true;
	}

	private static bool checkMultiplySpoken(object pCheckData = null)
	{
		if (((Language)pCheckData).countUnits() < 5555)
		{
			return false;
		}
		return true;
	}

	private static bool checkChildNamedMakoMako(object pCheckData = null)
	{
		if ((string)pCheckData != "Mako Mako")
		{
			return false;
		}
		return true;
	}

	private static bool checkSegregator(object pCheckData = null)
	{
		if (World.world.game_stats.data.wallsPlaced < 10000)
		{
			return false;
		}
		return true;
	}

	private static bool checkEternalChaos(object pCheckData = null)
	{
		if (World.world_era.id != "age_chaos")
		{
			return false;
		}
		if ((float)Date.getYearsSince(World.world.map_stats.same_world_age_started_at) < 1000f)
		{
			return false;
		}
		return true;
	}

	private static bool checkMinefield(object pCheckData = null)
	{
		if (!WorldLawLibrary.world_law_exploding_mushrooms.isEnabled())
		{
			return false;
		}
		if ((float)Date.getYearsSince(World.world.map_stats.exploding_mushrooms_enabled_at) < 1000f)
		{
			return false;
		}
		return true;
	}

	private static bool checkWatchYourMouth(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		if (!actor.isBaby())
		{
			return false;
		}
		if (!actor.hasStatus("swearing"))
		{
			return false;
		}
		return true;
	}

	private static bool checkCloneWars(object pCheckData = null)
	{
		var (actor, actor2) = ((Actor, Actor))pCheckData;
		if (!actor.isAlive() || !actor2.isAlive())
		{
			return false;
		}
		if (!actor.isSameClones(actor2) && !actor.isClonedFrom(actor2) && !actor2.isClonedFrom(actor))
		{
			return false;
		}
		return true;
	}

	private static bool checkCreaturesExplorer(object pCheckData = null)
	{
		int num = 0;
		int num2 = 0;
		foreach (ActorAsset item in AssetManager.actor_library.list)
		{
			if (item.needs_to_be_explored && !item.isTemplateAsset())
			{
				num++;
				if (item.isAvailable())
				{
					num2++;
				}
			}
		}
		if (num2 < 52)
		{
			return false;
		}
		return true;
	}

	private static bool checkMasterOfCombat(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		if (actor == null)
		{
			return false;
		}
		if (!actor.isAlive())
		{
			return false;
		}
		if (actor.hasDivineScar())
		{
			return false;
		}
		int num = 0;
		foreach (ActorTrait trait in actor.getTraits())
		{
			if (trait.in_training_dummy_combat_pot)
			{
				num++;
			}
		}
		if (num < 5)
		{
			return false;
		}
		return true;
	}

	private static bool checkClannibals(object pCheckData = null)
	{
		var (actor, clan) = ((Actor, Clan))pCheckData;
		if (!actor.hasClan() || clan == null)
		{
			return false;
		}
		if (actor.clan.id != clan.id)
		{
			return false;
		}
		return true;
	}

	private static bool checkSmellyCity(object pCheckData = null)
	{
		if (((City)pCheckData).getResourcesAmount("fertilizer") < 999)
		{
			return false;
		}
		return true;
	}

	private static bool checkNotOnMyWatch(object pCheckData = null)
	{
		if (!((Actor)pCheckData).hasStatus("being_suspicious"))
		{
			return false;
		}
		return true;
	}

	private static bool checkMayIInterrupt(object pCheckData = null)
	{
		if ((string)pCheckData != "socialize_do_talk")
		{
			return false;
		}
		return true;
	}

	private static bool checkBallToBall(object pCheckData = null)
	{
		if (((Actor)pCheckData).asset.id != "armadillo")
		{
			return false;
		}
		return true;
	}

	private static bool checkSwordWithShotgun(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		if (actor.asset.id != "crystal_sword")
		{
			return false;
		}
		if (!actor.hasWeapon())
		{
			return false;
		}
		Item weapon = actor.getWeapon();
		if (weapon.getAsset().id != "shotgun")
		{
			return false;
		}
		if (weapon.hasMod("divine_rune"))
		{
			return false;
		}
		return true;
	}

	private static bool checkBackToBetaTesting(object pCheckData = null)
	{
		Actor actor = (Actor)pCheckData;
		if (actor.asset.id != "beetle")
		{
			return false;
		}
		if (actor.current_tile.Type.biome_id != "biome_singularity")
		{
			return false;
		}
		return true;
	}

	private static bool checkSwarm(object pCheckData = null)
	{
		Subspecies subspecies = (Subspecies)pCheckData;
		if (subspecies.hasPopulationLimit())
		{
			return false;
		}
		if (!subspecies.hasTrait("high_fecundity"))
		{
			return false;
		}
		if (!subspecies.hasTrait("reproduction_spores"))
		{
			return false;
		}
		if (!subspecies.hasTrait("gestation_short"))
		{
			return false;
		}
		if (!subspecies.hasTrait("rapid_aging"))
		{
			return false;
		}
		return true;
	}

	public static void checkCityAchievements(City pCity)
	{
		zoo.checkBySignal();
		four_race_cities.check(pCity);
		smelly_city.check(pCity);
		megapolis.checkBySignal();
	}

	public static void checkUnitAchievements(Actor pActor)
	{
		creatures_explorer.check();
		the_broken.check();
		the_demon.check();
		the_king.check();
		the_accomplished.check();
		watch_your_mouth.check(pActor);
		master_of_combat.check(pActor);
		sword_with_shotgun.check(pActor);
		ninja_turtle.check(pActor);
	}

	public static void checkSubspeciesAchievements(Subspecies pSubspecies)
	{
		creatures_explorer.check();
		swarm.checkBySignal(pSubspecies);
	}

	public static void login()
	{
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (Achievement item in list)
		{
			checkLocale(item, item.getLocaleID());
			checkLocale(item, item.getDescriptionID());
		}
	}

	public static int countUnlocked()
	{
		int num = 0;
		foreach (Achievement item in AssetManager.achievements.list)
		{
			if (isUnlocked(item.id))
			{
				num++;
			}
		}
		return num;
	}

	public static bool isAllUnlocked()
	{
		int num = countUnlocked();
		int count = AssetManager.achievements.list.Count;
		return num >= count;
	}
}
// --- End of File: AchievementLibrary.cs ---



// --- Start of File: AchievementPopup.cs ---
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.UI;

public class AchievementPopup : MonoBehaviour
{
	private static AchievementPopup _instance;

	[SerializeField]
	private Image _icon_left;

	[SerializeField]
	private Image _icon_right;

	[SerializeField]
	private Text _popup_text;

	[SerializeField]
	private Text _popup_description;

	[SerializeField]
	private AchievementGoodie _goodie_prefab;

	[SerializeField]
	private Transform _goodies_parent;

	private ObjectPoolGenericMono<AchievementGoodie> _goodie_pool;

	private Tweener _tween;

	private void Awake()
	{
		_instance = this;
		hide();
	}

	internal static void show(string pAchievementID)
	{
		_instance.showByID(pAchievementID);
	}

	internal static void show(Achievement pAchievement)
	{
		_instance.showByID(pAchievement.id);
	}

	private void Update()
	{
		World.world.spawnCongratulationFireworks();
	}

	internal void showByID(string pAchievementID)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Expected O, but got Unknown
		if (_tween != null && ((Tween)_tween).active)
		{
			return;
		}
		((Component)this).gameObject.SetActive(true);
		checkPool();
		Achievement achievement = AssetManager.achievements.get(pAchievementID);
		Sprite icon = achievement.getIcon();
		if ((Object)(object)icon != (Object)null)
		{
			_icon_left.sprite = icon;
			_icon_right.sprite = icon;
		}
		((Component)_popup_text).GetComponent<LocalizedText>().setKeyAndUpdate(achievement.getLocaleID());
		((Component)_popup_description).GetComponent<LocalizedText>().setKeyAndUpdate(achievement.getDescriptionID());
		float num = Screen.height;
		Rect safeArea = Screen.safeArea;
		float num2 = (num - ((Rect)(ref safeArea)).height) / CanvasMain.instance.canvas_ui.scaleFactor;
		_tween = (Tweener)(object)TweenSettingsExtensions.OnComplete<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetDelay<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOLocalMoveY(((Component)this).transform, 0f - num2, 1f, false), (Ease)27), 0.2f), new TweenCallback(tweenHide));
		if (!achievement.unlocks_something)
		{
			return;
		}
		foreach (BaseUnlockableAsset unlock_asset in achievement.unlock_assets)
		{
			if (unlock_asset.show_for_unlockables_ui)
			{
				_goodie_pool.getNext().load(unlock_asset, pUnlocked: true);
			}
		}
	}

	public void forceHide()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Expected O, but got Unknown
		if (_tween != null)
		{
			TweenExtensions.Kill((Tween)(object)_tween, false);
		}
		_tween = (Tweener)(object)TweenSettingsExtensions.OnComplete<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOLocalMoveY(((Component)this).transform, 200f, 0.5f, false), (Ease)27), new TweenCallback(hide));
	}

	private void tweenHide()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		_tween = (Tweener)(object)TweenSettingsExtensions.OnComplete<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetDelay<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOLocalMoveY(((Component)this).transform, 200f, 1f, false), 4f), (Ease)27), new TweenCallback(hide));
	}

	private void hide()
	{
		((Component)this).gameObject.SetActive(false);
		_goodie_pool?.clear();
	}

	private void checkPool()
	{
		if (_goodie_pool == null)
		{
			_goodie_pool = new ObjectPoolGenericMono<AchievementGoodie>(_goodie_prefab, _goodies_parent);
		}
	}
}
// --- End of File: AchievementPopup.cs ---



// --- Start of File: AchievementWindow.cs ---
using System.Collections.Generic;
using UnityEngine;

public class AchievementWindow : MonoBehaviour
{
	public AchievementGroup achievementGroupPrefab;

	private List<AchievementGroup> _elements = new List<AchievementGroup>();

	public Transform transformContent;

	public StatBar achievementBar;

	private void OnEnable()
	{
		showList();
	}

	internal void showList()
	{
		if (!Config.game_loaded)
		{
			return;
		}
		for (int i = 0; i < _elements.Count; i++)
		{
			Object.Destroy((Object)(object)((Component)_elements[i]).gameObject);
		}
		_elements.Clear();
		foreach (AchievementGroupAsset item in AssetManager.achievement_groups.list)
		{
			showElement(item);
		}
		updateTotalBar();
	}

	private void updateTotalBar()
	{
		int count = AssetManager.achievements.list.Count;
		int num = AchievementLibrary.countUnlocked();
		achievementBar.setBar(num, count, "/" + count.ToText());
	}

	private void showElement(AchievementGroupAsset pAchievementGroup)
	{
		AchievementGroup achievementGroup = Object.Instantiate<AchievementGroup>(achievementGroupPrefab, transformContent);
		achievementGroup.showGroup(pAchievementGroup);
		_elements.Add(achievementGroup);
	}
}
// --- End of File: AchievementWindow.cs ---



// --- Start of File: ActionExtensions.cs ---
using System;

public static class ActionExtensions
{
	public static bool[] Run(this WorldAction pAction, BaseSimObject pTarget = null, WorldTile pTile = null)
	{
		Delegate[] invocationList = pAction.GetInvocationList();
		bool[] array = new bool[invocationList.Length];
		int num = 0;
		Delegate[] array2 = invocationList;
		for (int i = 0; i < array2.Length; i++)
		{
			WorldAction worldAction = (WorldAction)array2[i];
			array[num++] = worldAction(pTarget, pTile);
		}
		return array;
	}

	public static bool RunAnyTrue(this WorldAction pAction, BaseSimObject pTarget = null, WorldTile pTile = null)
	{
		Delegate[] invocationList = pAction.GetInvocationList();
		bool result = false;
		Delegate[] array = invocationList;
		for (int i = 0; i < array.Length; i++)
		{
			if (((WorldAction)array[i])(pTarget, pTile))
			{
				result = true;
			}
		}
		return result;
	}

	public static bool[] Run(this AttackAction pAction, BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		Delegate[] invocationList = pAction.GetInvocationList();
		bool[] array = new bool[invocationList.Length];
		int num = 0;
		Delegate[] array2 = invocationList;
		for (int i = 0; i < array2.Length; i++)
		{
			AttackAction attackAction = (AttackAction)array2[i];
			array[num++] = attackAction(pSelf, pTarget, pTile);
		}
		return array;
	}

	public static bool RunAnyTrue(this AttackAction pAction, BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		Delegate[] invocationList = pAction.GetInvocationList();
		bool result = false;
		Delegate[] array = invocationList;
		for (int i = 0; i < array.Length; i++)
		{
			if (((AttackAction)array[i])(pSelf, pTarget, pTile))
			{
				result = true;
			}
		}
		return result;
	}
}
// --- End of File: ActionExtensions.cs ---



// --- Start of File: ActionFormatCounterOptionAsset.cs ---
public delegate string ActionFormatCounterOptionAsset(OptionAsset pAsset);
// --- End of File: ActionFormatCounterOptionAsset.cs ---



// --- Start of File: ActionLibrary.cs ---
using System.Collections.Generic;
using UnityEngine;
using ai;

public static class ActionLibrary
{
	public static bool unluckyMeteorite(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!WorldLawLibrary.world_law_disasters_nature.isEnabled())
		{
			return false;
		}
		if (World.world.cities.Count < 5)
		{
			return false;
		}
		if (pTarget.a.getAge() < 30)
		{
			return false;
		}
		if (!Randy.randomChance(5E-05f))
		{
			return false;
		}
		Meteorite.spawnMeteoriteDisaster(pTarget.current_tile, pTarget.a);
		return true;
	}

	public static bool unluckyFall(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (Randy.randomChance(0.8f))
		{
			return false;
		}
		pTarget.a.makeStunned();
		return true;
	}

	public static bool flamingWeapon(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		if (!MapBox.isRenderGameplay())
		{
			return false;
		}
		if (pTarget.isBuilding())
		{
			return false;
		}
		Actor a = pTarget.a;
		if (!a.a.is_visible)
		{
			return false;
		}
		Sprite renderedItemSprite = a.getRenderedItemSprite();
		if ((Object)(object)renderedItemSprite == (Object)null)
		{
			return false;
		}
		AnimationFrameData animationFrameData = a.getAnimationFrameData();
		if (animationFrameData == null)
		{
			return false;
		}
		Vector3 point = default(Vector3);
		point.x = a.cur_transform_position.x + animationFrameData.pos_item.x * a.current_scale.x;
		point.y = a.cur_transform_position.y + animationFrameData.pos_item.y * a.current_scale.y;
		point.z = -0.01f;
		Rect rect = renderedItemSprite.rect;
		float num = ((Rect)(ref rect)).height * a.current_scale.y;
		if (a.is_moving)
		{
			point.y += num;
			point.x += Randy.randomFloat(-0.1f, 0.1f);
			point.y += Randy.randomFloat(-0.1f, 0.2f);
		}
		else
		{
			point.x += Randy.randomFloat(-0.05f, 0.05f);
			float num2 = Randy.randomFloat(0f, num * 1.5f);
			if ((double)num2 < (double)num * 0.5)
			{
				point.x += Randy.randomFloat(-0.15f, 0.15f);
			}
			point.y += num2;
		}
		if (a.current_rotation.y != 0f || a.current_rotation.z != 0f)
		{
			point = Toolbox.RotatePointAroundPivot(ref point, ref a.cur_transform_position, ref a.current_rotation);
		}
		BaseEffect baseEffect = EffectsLibrary.spawn("fx_weapon_particle");
		if ((Object)(object)baseEffect != (Object)null)
		{
			((StatusParticle)baseEffect).spawnParticle(point, Toolbox.colors_fire.GetRandom());
			return true;
		}
		return false;
	}

	public static bool shiny(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!pTile.has_tile_up)
		{
			return false;
		}
		if (!MapBox.isRenderGameplay())
		{
			return false;
		}
		Vector3 posV = pTile.tile_up.posV3;
		posV.x += Randy.randomFloat(-0.3f, 0.3f);
		posV.y += Randy.randomFloat(-0.3f, 0.3f);
		EffectsLibrary.spawnAt("fx_building_sparkle", posV, 0.1f);
		return true;
	}

	public static bool restoreHealthOnHit(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget == null)
		{
			return false;
		}
		if (!pTarget.isActor())
		{
			return false;
		}
		if (!pSelf.isActor())
		{
			return false;
		}
		if (!pSelf.isAlive())
		{
			return false;
		}
		int maxHealthPercent = pTarget.getMaxHealthPercent(0.05f);
		pSelf.a.restoreHealth(maxHealthPercent);
		return true;
	}

	public static void throwTorchAtTile(BaseSimObject pSelf, WorldTile pTile)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Vector2Int pos = pTile.pos;
		Vector3 val = Vector2.op_Implicit(pSelf.current_position);
		float pDist = Vector2.Distance(Vector2.op_Implicit(val), Vector2Int.op_Implicit(pos));
		Vector3 newPoint = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pDist);
		Vector3 newPoint2 = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pSelf.a.stats["size"]);
		newPoint2.y += 0.5f;
		World.world.projectiles.spawn(pSelf, null, "torch", newPoint2, newPoint);
	}

	public static bool canThrowBomb(BaseSimObject pTarget, WorldTile pTile)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		float x = pTarget.a.current_position.x;
		float y = pTarget.a.current_position.y;
		Vector2Int pos = pTile.pos;
		float x2 = ((Vector2Int)(ref pos)).x;
		pos = pTile.pos;
		float num = Toolbox.Dist(x, y, x2, ((Vector2Int)(ref pos)).y);
		if (num > 3f && num < 26f)
		{
			return true;
		}
		return false;
	}

	public static void throwBombAtTile(BaseSimObject pSelf, WorldTile pTile)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Vector2Int pos = pTile.pos;
		Vector3 val = Vector2.op_Implicit(pSelf.current_position);
		float pDist = Vector2.Distance(Vector2.op_Implicit(val), Vector2Int.op_Implicit(pos));
		Vector3 newPoint = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pDist);
		Vector3 newPoint2 = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pSelf.a.stats["size"]);
		newPoint2.y += 0.5f;
		World.world.projectiles.spawn(pSelf, null, "firebomb", newPoint2, newPoint);
	}

	public static bool zombieInfectAttack(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (!pTarget.isActor())
		{
			return false;
		}
		if (Randy.randomChance(0.25f))
		{
			pTarget.a.startShake(0.2f, 0.05f, pHorizontal: true, pVertical: false);
		}
		pTarget.a.spawnParticle(Toolbox.color_infected);
		if (pTarget.a.asset.can_turn_into_zombie && Randy.randomChance(0.5f))
		{
			pTarget.a.addTrait("infected");
		}
		return true;
	}

	public static bool zombieEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		pTarget.a.spawnParticle(Toolbox.color_infected);
		if (Randy.randomChance(0.25f))
		{
			pTarget.a.startShake(0.2f, 0.05f, pHorizontal: true, pVertical: false);
		}
		return true;
	}

	public static bool infectedEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		int num = pTarget.getHealth() / 10;
		if (num < 10)
		{
			num = 10;
		}
		pTarget.a.getHit(num, pFlash: true, AttackType.Infection, null, pSkipIfShake: false);
		pTarget.a.spawnParticle(Toolbox.color_infected);
		pTarget.a.startShake(0.4f, 0.2f, pHorizontal: true, pVertical: false);
		return true;
	}

	public static bool mushSporesEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		int num = 3;
		foreach (Actor item in Finder.getUnitsFromChunk(pTile, 1, 3f, pRandom: true))
		{
			if (item != pTarget.a && !Randy.randomChance(0.7f) && item.addTrait("mush_spores"))
			{
				item.spawnParticle(Toolbox.color_mushSpores);
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
		return true;
	}

	public static bool tumorEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		pTarget.a.startShake(0.4f, 0.2f, pHorizontal: true, pVertical: false);
		if (Randy.randomChance(0.1f))
		{
			pTarget.getHit(pTarget.getMaxHealthPercent(0.1f), pFlash: false, AttackType.Tumor, null, pSkipIfShake: false);
		}
		return true;
	}

	public static bool healingAuraEffect(BaseSimObject pSelf, WorldTile pTile = null)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!Randy.randomChance(0.2f))
		{
			return false;
		}
		foreach (Actor item in Finder.getUnitsFromChunk(pTile, 1, 4f, pRandom: true))
		{
			if (item != pSelf.a && !item.hasMaxHealth() && !pSelf.areFoes(item))
			{
				item.restoreHealth(10);
				item.spawnParticle(Toolbox.color_heal);
				item.removeTrait("plague");
			}
		}
		return true;
	}

	public static bool heliophobiaEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		BiomeAsset biome = a.current_tile.getBiome();
		if (biome != null)
		{
			if (biome.cold_biome)
			{
				return false;
			}
			if (biome.dark_biome)
			{
				return false;
			}
		}
		if (!World.world_era.flag_light_damage)
		{
			return false;
		}
		int num = (int)((float)a.getMaxHealth() * 0.1f) + 1;
		a.getHit(num, pFlash: true, AttackType.Other, null, pSkipIfShake: true, pMetallicWeapon: false, pCheckDamageReduction: true);
		return true;
	}

	public static bool regenerationEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Actor a = pTarget.a;
		if (a.hasTrait("infected"))
		{
			return true;
		}
		if (!a.hasMaxHealth() && !a.isHungry() && Randy.randomChance(0.2f))
		{
			int maxHealthPercent = a.getMaxHealthPercent(0.02f);
			a.restoreHealth(maxHealthPercent);
			a.spawnParticle(Toolbox.color_heal);
		}
		checkRegenerationTraits(a);
		return true;
	}

	private static void checkRegenerationTraits(Actor pActorTarget)
	{
		if (pActorTarget.hasTrait("crippled") && Randy.randomChance(0.05f))
		{
			pActorTarget.removeTrait("crippled");
		}
		if (pActorTarget.hasTrait("skin_burns") && Randy.randomChance(0.05f))
		{
			pActorTarget.removeTrait("skin_burns");
		}
		if (pActorTarget.hasTrait("eyepatch") && Randy.randomChance(0.05f))
		{
			pActorTarget.removeTrait("eyepatch");
		}
	}

	public static bool regenerationEffectClan(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Actor a = pTarget.a;
		if (a.hasTrait("infected"))
		{
			return true;
		}
		if (!a.hasMaxHealth() && !a.isHungry() && Randy.randomChance(0.2f))
		{
			int maxHealthPercent = a.getMaxHealthPercent(0.01f);
			a.restoreHealth(maxHealthPercent);
			a.spawnParticle(Toolbox.color_heal);
		}
		checkRegenerationTraits(a);
		return true;
	}

	public static bool suprisedByArchitector(BaseSimObject _, WorldTile pTile)
	{
		if (World.world.isPaused())
		{
			return false;
		}
		foreach (Actor item in Finder.getUnitsFromChunk(pTile, 1, 8f))
		{
			item.tryToGetSurprised(pTile);
		}
		return true;
	}

	public static bool coldAuraEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		World.world.loopWithBrush(pTarget.current_tile, Brush.get(4), PowerLibrary.drawTemperatureMinus);
		return true;
	}

	public static bool megaHeartbeat(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		World.world.applyForceOnTile(pTile, 3, 0.3f, pForceOut: true, 0, null, pTarget);
		EffectsLibrary.spawnExplosionWave(pTile.posV3, 3f, 0.5f);
		return true;
	}

	public static bool thornsDefense(BaseSimObject pSelf, BaseSimObject pAttackedBy, WorldTile pTile = null)
	{
		if (pSelf.isAlive() && Randy.randomChance(0.5f))
		{
			if (pAttackedBy != null && pAttackedBy.isActor() && pAttackedBy.isAlive())
			{
				Actor a = pAttackedBy.a;
				if (Toolbox.DistTile(pSelf.a.current_tile, a.a.current_tile) < 2f)
				{
					float pDamage = a.stats["damage"] * 0.2f;
					a.getHit(pDamage, pFlash: true, AttackType.Weapon, pSelf);
				}
			}
			return true;
		}
		return false;
	}

	public static bool bubbleDefense(BaseSimObject pSelf, BaseSimObject pAttackedBy, WorldTile pTile = null)
	{
		if (pSelf.hasHealth() && Randy.randomChance(0.1f))
		{
			pSelf.addStatusEffect("shield", 5f);
			return true;
		}
		return false;
	}

	public static bool plagueEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		tickPlagueInfection(pTarget.a);
		pTarget.a.startShake(0.4f, 0.2f, pHorizontal: true, pVertical: false);
		if (Randy.randomChance(0.1f))
		{
			int num = pTarget.getMaxHealthPercent(0.15f) + 1;
			pTarget.a.getHit(num, pFlash: false, AttackType.Plague, null, pSkipIfShake: false);
		}
		return true;
	}

	public static bool energizedLightning(BaseSimObject pTarget, WorldTile pTile = null)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Toolbox.inMapBorder(ref pTarget.current_position))
		{
			EffectsLibrary.spawnAt("fx_lightning_small", pTarget.current_position, 0.25f);
			return true;
		}
		MapBox.spawnLightningSmall(pTarget.current_tile, 0.25f, pTarget.a);
		return true;
	}

	public static bool contagiousEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!WorldLawLibrary.world_law_rat_plague.isEnabled())
		{
			return false;
		}
		if (Randy.randomChance(0.7f) && ActorTool.countContagiousNearby(pTarget.a) > 20 && Randy.randomChance(0.2f))
		{
			tickPlagueInfection(pTarget.a);
		}
		return true;
	}

	public static bool deathMark(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (Randy.randomChance(0.2f))
		{
			pTarget.a.getHitFullHealth(AttackType.Divine);
		}
		return true;
	}

	private static void tickPlagueInfection(Actor pActor)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		pActor.spawnParticle(Toolbox.color_plague);
		if (!Randy.randomChance(0.05f))
		{
			return;
		}
		int num = 3;
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, 0, 6f, pRandom: true))
		{
			if (item != pActor)
			{
				if (item.addTrait("plague"))
				{
					break;
				}
				num--;
				if (num <= 0)
				{
					break;
				}
			}
		}
	}

	public static bool burningFeetEffectTileDraw(WorldTile pTile, string pPowerID)
	{
		if (pTile.isTemporaryFrozen() && Randy.randomBool())
		{
			pTile.unfreeze();
		}
		return true;
	}

	public static bool burningFeetEffect(BaseSimObject pSelf, WorldTile pTile = null)
	{
		WorldTile current_tile = pSelf.current_tile;
		if (!current_tile.Type.can_be_set_on_fire_by_burning_feet)
		{
			return false;
		}
		Actor a = pSelf.a;
		if (a.isInLiquid())
		{
			return false;
		}
		if (!a.has_attack_target && !a.hasTag("moody"))
		{
			return false;
		}
		World.world.loopWithBrush(current_tile, Brush.get(4), burningFeetEffectTileDraw);
		current_tile.startFire(pForce: true);
		for (int i = 0; i < current_tile.neighbours.Length; i++)
		{
			WorldTile obj = current_tile.neighbours[i];
			obj.startFire();
			obj.setBurned();
		}
		return true;
	}

	public static bool flowerPrintsEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!Randy.randomChance(0.3f))
		{
			return false;
		}
		WorldTile current_tile = pTarget.a.current_tile;
		BiomeAsset biome_asset = current_tile.Type.biome_asset;
		if (biome_asset == null)
		{
			return false;
		}
		if (!biome_asset.grow_vegetation_auto)
		{
			return false;
		}
		if (biome_asset.grow_type_selector_plants != null)
		{
			BuildingActions.tryGrowVegetationRandom(current_tile, VegetationType.Plants, pOnStart: false, pCheckLimit: false);
		}
		return true;
	}

	public static bool acidBloodEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		for (int i = 0; i < 5; i++)
		{
			if (Randy.randomBool())
			{
				World.world.drop_manager.spawnParabolicDrop(pTarget.a.current_tile, "acid", 0f, 0.1f, 5f, 0.5f, 4f, 0.15f);
			}
		}
		if (!pTarget.isActor())
		{
			return true;
		}
		if (pTarget.a.asset.actor_size < ActorSize.S17_Dragon)
		{
			return true;
		}
		for (int j = 0; j < 25; j++)
		{
			if (Randy.randomBool())
			{
				World.world.drop_manager.spawnParabolicDrop(pTarget.a.current_tile, "acid", 0f, 0.1f, 10f, 0.5f, 10f, 0.15f);
			}
			for (int k = 0; k < pTarget.a.current_tile.neighboursAll.Length; k++)
			{
				WorldTile pTile2 = pTarget.a.current_tile.neighboursAll[k];
				if (Randy.randomBool())
				{
					World.world.drop_manager.spawnParabolicDrop(pTile2, "acid", 0f, 0.1f, 10f, 0.5f, 7f, 0.15f);
				}
			}
		}
		return true;
	}

	public static bool acidTouchEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!Randy.randomChance(0.3f))
		{
			return false;
		}
		MapAction.checkAcidTerraform(pTarget.a.current_tile);
		return true;
	}

	public static bool sunblessedEffect(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!Randy.randomChance(0.5f))
		{
			return false;
		}
		if (World.world.era_manager.getCurrentAge().flag_night)
		{
			return false;
		}
		float pVal = Randy.randomFloat(0.05f, 0.1f);
		pTarget.a.restoreHealthPercent(pVal);
		return true;
	}

	public static bool castSpawnSkeleton(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		int num = 0;
		foreach (Actor item in Finder.findSpeciesAroundTileChunk(pTile, "skeleton"))
		{
			_ = item;
			if (num++ > 6)
			{
				return false;
			}
		}
		WorldTile worldTile = pTile?.region?.getRandomTile();
		if (worldTile == null)
		{
			return false;
		}
		spawnSkeleton(pSelf, worldTile);
		return true;
	}

	public static bool spawnSkeleton(BaseSimObject pCaster, WorldTile pTile = null)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (pTile == null)
		{
			return false;
		}
		BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_create_skeleton", pTile.posV3, 0.1f);
		Actor tActorCaster = pCaster.a;
		Subspecies tTargetSubspecies = null;
		TileZone current_zone = tActorCaster.current_zone;
		bool tNeedNewSkeletonForm = false;
		Subspecies tSubspeciesTargetForNewSkeleton = null;
		City city = current_zone.city;
		if (city != null && !city.kingdom.isNeutral())
		{
			Subspecies mainSubspecies = city.getMainSubspecies();
			tTargetSubspecies = mainSubspecies?.getSkeletonForm();
			if (tTargetSubspecies == null)
			{
				tNeedNewSkeletonForm = true;
				tSubspeciesTargetForNewSkeleton = mainSubspecies;
			}
		}
		else if (tActorCaster.hasCity())
		{
			city = tActorCaster.city;
			tTargetSubspecies = city.getSubspecies("skeleton");
		}
		baseEffect.setCallback(19, delegate
		{
			Actor actor = World.world.units.createNewUnit("skeleton", pTile, pMiracleSpawn: false, 0f, tTargetSubspecies, null, pSpawnWithItems: true, pAdultAge: true);
			actor.makeWait(1f);
			if (!tActorCaster.isRekt())
			{
				if (actor.subspecies.isJustCreated() && tActorCaster.isKingdomCiv())
				{
					actor.subspecies.addTrait("prefrontal_cortex");
				}
				if (actor.subspecies.isJustCreated() && tNeedNewSkeletonForm && !tSubspeciesTargetForNewSkeleton.isRekt())
				{
					tSubspeciesTargetForNewSkeleton.setSkeletonForm(actor.subspecies);
				}
				if (tActorCaster.isKingdomCiv() && actor.subspecies.hasTrait("prefrontal_cortex"))
				{
					City city2 = tActorCaster.city;
					Kingdom kingdom = tActorCaster.kingdom;
					if (!city2.isRekt() && city2.kingdom == kingdom)
					{
						actor.joinCity(tActorCaster.city);
					}
					else
					{
						actor.joinKingdom(kingdom);
					}
				}
			}
		});
		return true;
	}

	public static bool castFire(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "fire", 15f, -1f, -1L);
		for (int i = 0; i < 3; i++)
		{
			World.world.drop_manager.spawn(pTile.neighboursAll.GetRandom(), "fire", 15f, -1f, -1L);
		}
		return true;
	}

	public static bool castSpellSilence(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "spell_silence", 15f, -1f, -1L);
		return true;
	}

	public static bool castBloodRain(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "blood_rain", 15f, -1f, pSelf.id);
		return true;
	}

	public static bool castSpawnGrassSeeds(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTile == null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		if (WorldLawLibrary.world_law_gaias_covenant.isEnabled())
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "seeds_grass", 15f, -1f, -1L);
		return true;
	}

	public static bool castSpawnFertilizer(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTile == null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "fertilizer_trees", 15f, -1f, -1L);
		return true;
	}

	public static bool castCurses(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			if (pTarget.a.hasStatus("cursed"))
			{
				return false;
			}
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "curse", 15f, -1f, -1L);
		return true;
	}

	public static bool castLightning(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		MapBox.spawnLightningMedium(pTile, 0.15f, pSelf.a);
		return true;
	}

	public static bool castTornado(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget != null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		(EffectsLibrary.spawnAtTile("fx_tornado", pTile, 1f / 12f) as TornadoEffect).resizeTornado(1f / 6f);
		return true;
	}

	public static bool castCure(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTile == null)
		{
			pTile = pTarget.current_tile;
		}
		if (pTile == null)
		{
			return false;
		}
		World.world.drop_manager.spawn(pTile, "cure", 15f, -1f, -1L);
		return true;
	}

	public static bool castShieldOnHimself(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		return addShieldEffectOnTarget(pSelf, pTarget);
	}

	public static bool addShieldEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget.hasStatus("shield"))
		{
			return false;
		}
		pTarget.a.addStatusEffect("shield", 30f);
		return true;
	}

	public static bool addBurningEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isBuilding() && pTarget.b.isBurnable())
		{
			pTarget.addStatusEffect("burning");
			return true;
		}
		if (pTarget.isActor())
		{
			pTarget.addStatusEffect("burning");
			return true;
		}
		return false;
	}

	public static bool addFrozenEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isBuilding())
		{
			return false;
		}
		if (Randy.randomChance(0.2f))
		{
			return addFrozenEffectOnTarget(pSelf, pTarget, pTile);
		}
		return false;
	}

	public static bool addStunnedEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget.isRekt())
		{
			return false;
		}
		if (pTarget.isBuilding())
		{
			return false;
		}
		if (Randy.randomChance(0.2f))
		{
			return addStunnedEffectOnTarget(pSelf, pTarget, pTile);
		}
		return false;
	}

	public static bool addStunnedEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget.isRekt())
		{
			return false;
		}
		if (pTarget.isBuilding())
		{
			return false;
		}
		pTarget.addStatusEffect("stunned");
		return true;
	}

	public static bool addFrozenEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget.isBuilding())
		{
			return false;
		}
		if (pTarget.current_tile.Type.lava)
		{
			return false;
		}
		if (pTarget.current_tile.isOnFire())
		{
			return false;
		}
		pTarget.addStatusEffect("frozen");
		return true;
	}

	public static bool addSlowEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isBuilding())
		{
			return false;
		}
		if (Randy.randomChance(0.2f))
		{
			return addSlowEffectOnTarget(pSelf, pTarget, pTile);
		}
		return false;
	}

	public static bool addSlowEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget.isBuilding())
		{
			return false;
		}
		pTarget.addStatusEffect("slowness");
		return true;
	}

	public static bool addPoisonedEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTarget.isActor())
		{
			return false;
		}
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.a.hasTrait("poison_immune"))
		{
			return false;
		}
		if (!pTarget.a.asset.has_skin)
		{
			return false;
		}
		if (pTarget.a.asset.immune_to_injuries)
		{
			return false;
		}
		if (Randy.randomChance(0.3f))
		{
			pTarget.a.addStatusEffect("poisoned");
		}
		return false;
	}

	public static void increaseDroppedBombsCounter(WorldTile pTile = null, string pDropID = null)
	{
		World.world.game_stats.data.bombsDropped++;
		AchievementLibrary.many_bombs.check();
	}

	public static bool giveCursed(WorldTile pTile, Actor pActor)
	{
		if (pActor.hasSubspecies() && pActor.subspecies.hasTrait("adaptation_corruption"))
		{
			return false;
		}
		bool num = pActor.addStatusEffect("cursed");
		if (num)
		{
			pActor.removeTrait("blessed");
		}
		return num;
	}

	public static bool singularityTeleportation(WorldTile pTile, Actor pActor)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		BiomeAsset biomeAsset = AssetManager.biome_library.get("biome_singularity");
		WorldTile worldTile = null;
		if (biomeAsset.getTileHigh().hashset.Count > 0 && Randy.randomBool())
		{
			worldTile = biomeAsset.getTileHigh().hashset.GetRandom();
		}
		else if (biomeAsset.getTileLow().hashset.Count > 0)
		{
			worldTile = biomeAsset.getTileLow().hashset.GetRandom();
		}
		if (worldTile == null)
		{
			return false;
		}
		EffectsLibrary.spawnAt("fx_teleport_singularity", worldTile.posV3, pActor.stats["scale"] * 1.2f);
		EffectsLibrary.spawnAt("fx_teleport_singularity", pActor.current_position, pActor.stats["scale"] * 1.2f);
		pActor.cancelAllBeh();
		pActor.spawnOn(worldTile);
		pActor.makeStunned();
		return true;
	}

	public static bool timeParadox(WorldTile pTile, Actor pActor)
	{
		if (pActor.isAlive())
		{
			pActor.data.age_overgrowth++;
			return true;
		}
		return false;
	}

	public static bool giveEnchanted(WorldTile pTile, Actor pActor)
	{
		pActor.finishStatusEffect("cursed");
		return pActor.addStatusEffect("enchanted");
	}

	public static bool spawnGhost(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTarget.isActor())
		{
			return false;
		}
		if (!pTarget.a.asset.has_soul)
		{
			return false;
		}
		Actor actor = World.world.units.createNewUnit("ghost", pTile);
		actor.removeTrait("blessed");
		ActorTool.copyUnitToOtherUnit(pTarget.a, actor);
		return true;
	}

	public static bool tryToGrowBiomeGrass(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (!pTile.Type.can_be_biome)
		{
			return false;
		}
		if (pTile.Type.is_biome)
		{
			return false;
		}
		DropsLibrary.useSeedOn(pTile, TopTileLibrary.grass_low, TopTileLibrary.grass_high);
		return true;
	}

	public static bool tryToGrowTree(BaseSimObject pTarget, WorldTile pTile = null)
	{
		BuildingActions.tryGrowVegetationRandom(pTile, VegetationType.Trees, pOnStart: false, pCheckLimit: false);
		return true;
	}

	public static bool tryToCreatePlants(BaseSimObject pTarget, WorldTile pTile = null)
	{
		BiomeAsset biome_asset = pTarget.current_tile.Type.biome_asset;
		if (biome_asset == null)
		{
			return false;
		}
		if (biome_asset.grow_type_selector_plants != null)
		{
			BuildingActions.tryGrowVegetationRandom(pTarget.current_tile, VegetationType.Plants);
		}
		return true;
	}

	public static bool startNuke(BaseSimObject pTarget, WorldTile pTile = null)
	{
		pTarget.a.findCurrentTile();
		EffectsLibrary.spawn("fx_nuke_flash", pTile, "atomic_bomb");
		return true;
	}

	public static bool clearCrabzilla(BaseSimObject pTarget, WorldTile pTile = null)
	{
		MusicBox.inst.stopDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaLazer");
		MusicBox.inst.stopDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaVoice");
		if (Config.joyControls)
		{
			UltimateJoystick.ResetJoysticks();
		}
		return true;
	}

	public static bool startCrabzillaNuke(BaseSimObject pTarget, WorldTile pTile = null)
	{
		pTarget.a.findCurrentTile();
		EffectsLibrary.spawn("fx_nuke_flash", pTile, "crabzilla_bomb");
		return true;
	}

	public static bool deathNuke(BaseSimObject pTarget, WorldTile pTile = null)
	{
		pTarget.a.findCurrentTile();
		DropsLibrary.action_atomic_bomb(pTarget.current_tile);
		return true;
	}

	public static bool deathBomb(BaseSimObject pTarget, WorldTile pTile = null)
	{
		pTarget.a.findCurrentTile();
		DropsLibrary.action_bomb(pTarget.current_tile);
		return true;
	}

	public static bool spawnAliens(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		a.findCurrentTile();
		if (!a.inMapBorder())
		{
			return false;
		}
		int num = 1;
		if (Randy.randomChance(0.5f))
		{
			num++;
		}
		if (Randy.randomChance(0.1f))
		{
			num++;
		}
		for (int i = 0; i < num; i++)
		{
			World.world.units.createNewUnit("alien", pTarget.a.current_tile, pMiracleSpawn: false, pTarget.a.position_height, null, null, pSpawnWithItems: true, pAdultAge: true);
		}
		return true;
	}

	public static bool fireDropsSpawn(BaseSimObject pTarget, WorldTile pTile = null)
	{
		for (int i = 0; i < 5; i++)
		{
			if (Randy.randomBool())
			{
				World.world.drop_manager.spawnParabolicDrop(pTarget.a.current_tile, "fire", 0f, 0.1f, 5f, 0.5f, 4f, 0.15f);
			}
		}
		if (!pTarget.isActor())
		{
			return true;
		}
		if (pTarget.a.asset.actor_size < ActorSize.S17_Dragon)
		{
			return true;
		}
		for (int j = 0; j < 25; j++)
		{
			if (Randy.randomBool())
			{
				World.world.drop_manager.spawnParabolicDrop(pTarget.a.current_tile, "fire", 0f, 0.1f, 10f, 0.5f, 10f, 0.15f);
			}
			for (int k = 0; k < pTarget.a.current_tile.neighboursAll.Length; k++)
			{
				WorldTile pTile2 = pTarget.a.current_tile.neighboursAll[k];
				if (Randy.randomBool())
				{
					World.world.drop_manager.spawnParabolicDrop(pTile2, "fire", 0f, 0.1f, 10f, 0.5f, 7f, 0.15f);
				}
			}
		}
		return true;
	}

	public static bool snowDropsSpawn(BaseSimObject pTarget, WorldTile pTile = null)
	{
		for (int i = 0; i < 20; i++)
		{
			if (Randy.randomBool())
			{
				World.world.drop_manager.spawnParabolicDrop(pTarget.a.current_tile, "snow", 0f, 0.1f, 5f, 0.5f, 4f, 0.15f);
			}
		}
		return true;
	}

	public static bool teleportRandom(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	{
		WorldTile worldTile = World.world.islands_calculator.getRandomIslandGround()?.regions.GetRandom()?.tiles.GetRandom();
		if (worldTile == null)
		{
			return false;
		}
		if (worldTile.Type.block)
		{
			return false;
		}
		if (!worldTile.Type.ground)
		{
			return false;
		}
		teleportEffect(pTarget.a, worldTile);
		pTarget.a.cancelAllBeh();
		pTarget.a.spawnOn(worldTile);
		return true;
	}

	public static void teleportEffect(Actor pActor, WorldTile pTile)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		string text = pActor.asset.effect_teleport;
		if (string.IsNullOrEmpty(text))
		{
			text = "fx_teleport_blue";
		}
		EffectsLibrary.spawnAt(text, pActor.current_position, pActor.stats["scale"]);
		BaseEffect baseEffect = EffectsLibrary.spawnAt(text, pTile.posV3, pActor.stats["scale"]);
		if ((Object)(object)baseEffect != (Object)null)
		{
			baseEffect.sprite_animation.setFrameIndex(9);
		}
	}

	public static bool metamorphInto(Actor pTarget, string pAsset, bool pRemoveAcquiredTraits = false, bool pUseCurrentSubspecies = false)
	{
		if (pTarget == null)
		{
			return false;
		}
		if (!pTarget.inMapBorder())
		{
			return false;
		}
		if (pTarget.isAlreadyTransformed())
		{
			return false;
		}
		pTarget.finishStatusEffect("cursed");
		pTarget.removeTrait("infected");
		pTarget.removeTrait("mush_spores");
		pTarget.removeTrait("tumor_infection");
		if (pRemoveAcquiredTraits)
		{
			IReadOnlyCollection<ActorTrait> traits = pTarget.getTraits();
			using ListPool<ActorTrait> listPool = new ListPool<ActorTrait>(traits.Count);
			foreach (ActorTrait item in traits)
			{
				if (item.group_id == "acquired")
				{
					listPool.Add(item);
				}
			}
			pTarget.removeTraits(listPool);
		}
		Subspecies pSubspecies = null;
		if (pUseCurrentSubspecies)
		{
			pSubspecies = pTarget.subspecies;
		}
		Actor actor = World.world.units.createNewUnit(pAsset, pTarget.current_tile, pMiracleSpawn: false, 0f, pSubspecies, null, pSpawnWithItems: false);
		ActorTool.copyUnitToOtherUnit(pTarget, actor, pCopyAge: false);
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget);
		pTarget.setTransformed();
		actor.addTrait("metamorphed");
		return true;
	}

	public static bool turnIntoMush(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		if (a == null)
		{
			return false;
		}
		if (!a.hasTrait("mush_spores"))
		{
			return false;
		}
		if (!a.inMapBorder())
		{
			return false;
		}
		if (!a.asset.can_turn_into_mush)
		{
			return false;
		}
		if (a.isAlreadyTransformed())
		{
			return false;
		}
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		a.removeTrait("peaceful");
		Actor actor = World.world.units.createNewUnit(a.asset.mush_id, a.current_tile, pMiracleSpawn: false, 0f, null, null, pSpawnWithItems: false);
		ActorTool.copyUnitToOtherUnit(a, actor);
		if (MapBox.isRenderGameplay())
		{
			EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		}
		removeUnit(pTarget.a);
		a.setTransformed();
		return true;
	}

	public static Actor turnIntoMetamorph(BaseSimObject pTarget, string pAssetID)
	{
		Actor a = pTarget.a;
		if (a == null)
		{
			return null;
		}
		if (!a.inMapBorder())
		{
			return null;
		}
		if (a.isAlreadyTransformed())
		{
			return null;
		}
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		a.removeTrait("peaceful");
		Actor actor = World.world.units.createNewUnit(pAssetID, a.current_tile, pMiracleSpawn: false, 0f, null, null, pSpawnWithItems: false);
		ActorTool.copyUnitToOtherUnit(a, actor);
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget.a);
		a.setTransformed();
		return actor;
	}

	public static Actor turnIntoIceOne(BaseSimObject pTarget, WorldTile pTile = null)
	{
		return turnIntoMetamorph(pTarget, "cold_one");
	}

	public static bool turnIntoDemon(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		if (a == null)
		{
			return false;
		}
		if (!a.inMapBorder())
		{
			return false;
		}
		if (a.isAlreadyTransformed())
		{
			return false;
		}
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		a.removeTrait("peaceful");
		Actor actor = World.world.units.createNewUnit("demon", a.current_tile, pMiracleSpawn: false, 0f, null, null, pSpawnWithItems: false);
		actor.addTrait("metamorphed");
		ActorTool.copyUnitToOtherUnit(a, actor);
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget.a);
		a.setTransformed();
		return true;
	}

	public static bool turnIntoTumorMonster(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		if (a == null)
		{
			return false;
		}
		if (!a.hasTrait("tumor_infection"))
		{
			return false;
		}
		if (!a.inMapBorder())
		{
			return false;
		}
		if (!a.asset.can_turn_into_tumor)
		{
			return false;
		}
		if (a.isAlreadyTransformed())
		{
			return false;
		}
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		a.removeTrait("peaceful");
		Actor actor = World.world.units.createNewUnit(a.asset.tumor_id, a.current_tile, pMiracleSpawn: false, 0f, null, null, pSpawnWithItems: false);
		ActorTool.copyUnitToOtherUnit(a, actor);
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget.a);
		a.setTransformed();
		return true;
	}

	public static bool turnIntoZombie(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		if (a == null)
		{
			return false;
		}
		if (!a.hasTrait("infected"))
		{
			return false;
		}
		if (!a.inMapBorder())
		{
			return false;
		}
		if (!a.asset.can_turn_into_zombie)
		{
			return false;
		}
		if (a.isAlreadyTransformed())
		{
			return false;
		}
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		string zombieID = a.asset.getZombieID();
		if (a.asset.id == "dragon")
		{
			a.removeTrait("fire_blood");
			a.removeTrait("fire_proof");
		}
		Actor actor = World.world.units.createNewUnit(zombieID, a.current_tile, pMiracleSpawn: false, 0f, null, a.subspecies, pSpawnWithItems: false);
		ActorTool.copyUnitToOtherUnit(a, actor);
		actor.removeTrait("fast");
		actor.removeTrait("agile");
		actor.removeTrait("genius");
		actor.removeTrait("peaceful");
		if (!a.getName().StartsWith("Un"))
		{
			actor.setName("Un" + Toolbox.LowerCaseFirst(a.getName()));
		}
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget.a);
		a.setTransformed();
		return true;
	}

	public static bool turnIntoSkeleton(BaseSimObject pTarget, WorldTile pTile = null)
	{
		Actor a = pTarget.a;
		if (string.IsNullOrEmpty(a.asset.skeleton_id))
		{
			return false;
		}
		if (a == null)
		{
			return false;
		}
		if (!a.hasStatus("cursed"))
		{
			return false;
		}
		if (!a.inMapBorder())
		{
			return false;
		}
		if (a.isAlreadyTransformed())
		{
			return false;
		}
		string skeleton_id = a.asset.skeleton_id;
		a.finishStatusEffect("cursed");
		a.removeTrait("infected");
		a.removeTrait("mush_spores");
		a.removeTrait("tumor_infection");
		Subspecies subspecies = null;
		if (a.hasSubspecies())
		{
			subspecies = a.subspecies.getSkeletonForm();
		}
		Actor actor = World.world.units.createNewUnit(skeleton_id, a.current_tile, pMiracleSpawn: false, 0f, subspecies, null, pSpawnWithItems: false);
		Subspecies subspecies2 = actor.subspecies;
		if (subspecies2.isJustCreated())
		{
			subspecies?.setSkeletonForm(subspecies2);
		}
		ActorTool.copyUnitToOtherUnit(a, actor);
		if (!a.getName().StartsWith("Un"))
		{
			actor.setName("Un" + Toolbox.LowerCaseFirst(a.getName()));
		}
		EffectsLibrary.spawn("fx_spawn", actor.current_tile);
		removeUnit(pTarget.a);
		a.setTransformed();
		return true;
	}

	public static Actor getActorNearPos(Vector2 pPos)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		Actor result = null;
		float num = float.MaxValue;
		Actor[] array = World.world.units.visible_units.array;
		int count = World.world.units.visible_units.count;
		for (int i = 0; i < count; i++)
		{
			Actor actor = array[i];
			if (actor.isAlive() && actor.asset.can_be_inspected && !actor.isInsideSomething())
			{
				float num2 = Toolbox.DistVec2Float(actor.current_position, pPos);
				if (!(num2 > 3f) && num2 < num)
				{
					result = actor;
					num = num2;
				}
			}
		}
		return result;
	}

	public static Actor getActorFromTile(WorldTile pTile = null)
	{
		if (pTile == null)
		{
			return null;
		}
		Actor result = null;
		float num = float.MaxValue;
		List<Actor> simpleList = World.world.units.getSimpleList();
		for (int i = 0; i < simpleList.Count; i++)
		{
			Actor actor = simpleList[i];
			if (actor.isAlive())
			{
				float num2 = Toolbox.SquaredDistTile(actor.current_tile, pTile);
				if (!(num2 > num) && !(num2 > 9f) && actor.asset.can_be_inspected && !actor.isInsideSomething())
				{
					result = actor;
					num = num2;
				}
			}
		}
		return result;
	}

	public static void openUnitWindow(Actor pActor)
	{
		if (!pActor.isRekt())
		{
			SelectedUnit.clear();
			SelectedUnit.select(pActor);
		}
		else if (!SelectedUnit.isSet())
		{
			return;
		}
		ScrollWindow.showWindow("unit");
	}

	public static bool inspectUnit(WorldTile pTile = null, string pPower = null)
	{
		Actor actor = null;
		actor = ((pTile != null) ? getActorFromTile(pTile) : World.world.getActorNearCursor());
		if (actor == null)
		{
			return false;
		}
		openUnitWindow(actor);
		return true;
	}

	public static bool inspectUnitSelectedMeta(WorldTile pTile = null, string pPower = null)
	{
		Actor actor = null;
		actor = ((pTile != null) ? getActorFromTile(pTile) : World.world.getActorNearCursor());
		if (actor == null)
		{
			return false;
		}
		MetaTypeAsset asset = Zones.getCurrentMapBorderMode().getAsset();
		if (asset == null)
		{
			return false;
		}
		if (asset.check_unit_has_meta(actor))
		{
			asset.set_unit_set_meta_for_meta_for_window(actor);
			ScrollWindow.showWindow(asset.window_name);
			return true;
		}
		openUnitWindow(actor);
		return true;
	}

	public static bool inspectCity(WorldTile pTile = null, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.city);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.City.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectKingdom(WorldTile pTile = null, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.kingdom);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		if (((Kingdom)nanoObjectFromTile).isNeutral())
		{
			return false;
		}
		MetaType.Kingdom.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectAlliance(WorldTile pTile = null, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		City city = pTile.zone.city;
		if (city.isRekt())
		{
			return false;
		}
		Kingdom kingdom = city.kingdom;
		if (kingdom.isRekt())
		{
			return false;
		}
		if (kingdom.isNeutral())
		{
			return false;
		}
		if (kingdom.hasAlliance())
		{
			MetaType.Alliance.getAsset().selectAndInspect(kingdom.getAlliance());
		}
		else
		{
			inspectKingdom(pTile, pPower);
		}
		return true;
	}

	public static bool inspectCulture(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.culture);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Culture.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectReligion(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.religion);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Religion.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectSubspecies(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.subspecies);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Subspecies.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectFamily(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.family);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Family.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectArmy(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.army);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Army.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectLanguage(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.language);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Language.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool inspectClan(WorldTile pTile, string pPower = null)
	{
		if (pTile == null)
		{
			return false;
		}
		NanoObject nanoObjectFromTile = getNanoObjectFromTile(pTile, MetaTypeLibrary.clan);
		if (nanoObjectFromTile == null)
		{
			return false;
		}
		MetaType.Clan.getAsset().selectAndInspect(nanoObjectFromTile);
		return true;
	}

	public static bool burnTile(BaseSimObject pSelf, BaseSimObject pTarget = null, WorldTile pTile = null)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!World.world.flash_effects.contains(pTile) && Randy.randomChance(0.2f))
		{
			World.world.particles_fire.spawn(pTile.posV3);
		}
		pTile.startFire(pForce: true);
		return true;
	}

	public static bool tryToEvolveUnitViaMonolith(Actor pActor)
	{
		pActor.startShake();
		pActor.startColorEffect();
		if (!pActor.hasSubspecies())
		{
			return false;
		}
		if (pActor.hasSubspeciesTrait("pure"))
		{
			return false;
		}
		float pVal = 1f;
		if (pActor.asset.can_evolve_into_new_species)
		{
			pVal = 1f;
		}
		else if (pActor.hasSubspeciesTrait("uplifted") && pActor.subspecies.isSapient())
		{
			pVal = 0.1f;
		}
		if (!Randy.randomChance(pVal))
		{
			return false;
		}
		World.world.units.evolutionEvent(pActor, pWithBiomeEffect: true, pAscension: false);
		return true;
	}

	public static bool tryToEvolveUnitViaAscension(Actor pActor, out Actor pEvolvedActorForm)
	{
		pEvolvedActorForm = null;
		pActor.startShake();
		pActor.startColorEffect();
		if (!pActor.hasSubspecies())
		{
			return false;
		}
		if (pActor.hasSubspeciesTrait("pure"))
		{
			return false;
		}
		Actor actor = World.world.units.evolutionEvent(pActor, pWithBiomeEffect: true, pAscension: true);
		pEvolvedActorForm = actor;
		return true;
	}

	public static void startBurningObjects(BaseSimObject pSelf, BaseSimObject pTarget = null, WorldTile pTile = null)
	{
		List<BaseSimObject> allObjectsInChunks = Finder.getAllObjectsInChunks(pTile);
		for (int i = 0; i < allObjectsInChunks.Count; i++)
		{
			BaseSimObject baseSimObject = allObjectsInChunks[i];
			if (baseSimObject.isAlive() && !baseSimObject.current_tile.Type.ocean)
			{
				addBurningEffectOnTarget(pSelf, baseSimObject);
			}
		}
	}

	public static void action_growTornadoes(WorldTile pTile = null, string pDropID = null)
	{
		TornadoEffect.growTornados(pTile);
	}

	public static void action_shrinkTornadoes(WorldTile pTile = null, string pDropID = null)
	{
		TornadoEffect.shrinkTornados(pTile);
	}

	public static bool dragonSlayer(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget == null)
		{
			return false;
		}
		if (!pTarget.isActor())
		{
			return false;
		}
		BaseSimObject attackedBy = pTarget.a.attackedBy;
		if (attackedBy != null && attackedBy.isActor() && attackedBy.isAlive())
		{
			attackedBy.a.addTrait("dragonslayer");
			return true;
		}
		return false;
	}

	public static bool mageSlayerCheck(BaseSimObject pTarget, WorldTile pTile = null)
	{
		if (pTarget == null)
		{
			return false;
		}
		if (!pTarget.isActor())
		{
			return false;
		}
		if (!pTarget.a.hasSpells())
		{
			return false;
		}
		BaseSimObject attackedBy = pTarget.a.attackedBy;
		if (attackedBy != null && attackedBy.isActor() && attackedBy.isAlive())
		{
			attackedBy.a.addTrait("mageslayer");
			return true;
		}
		return false;
	}

	public static bool checkPiranhaAchievement(BaseSimObject pTarget, WorldTile pTile = null)
	{
		AchievementLibrary.piranha_land.check(pTarget.a);
		return true;
	}

	public static bool clickRelations(WorldTile pTile, string pPowerID)
	{
		City city = pTile.zone.city;
		if (city.isRekt())
		{
			return false;
		}
		Kingdom kingdom = city.kingdom;
		if (kingdom.isRekt())
		{
			return false;
		}
		if (kingdom.isNeutral())
		{
			return false;
		}
		if (SelectedMetas.selected_kingdom != kingdom)
		{
			SelectedMetas.selected_kingdom = kingdom;
		}
		else
		{
			ScrollWindow.showWindow("kingdom");
		}
		return true;
	}

	public static bool clickWhisperOfWar(WorldTile pTile, string pPowerID)
	{
		City city = pTile.zone.city;
		if (city.isRekt())
		{
			return false;
		}
		Kingdom kingdom = city.kingdom;
		if (kingdom.isRekt())
		{
			return false;
		}
		if (kingdom.isNeutral())
		{
			return false;
		}
		if (Config.whisper_A == null)
		{
			Config.whisper_A = kingdom;
			showWhisperTip("whisper_selected_first");
			return false;
		}
		if (Config.whisper_B == null && Config.whisper_A == kingdom)
		{
			showWhisperTip("whisper_cancelled");
			Config.whisper_A = null;
			Config.whisper_B = null;
			return false;
		}
		if (Config.whisper_B == null)
		{
			Config.whisper_B = kingdom;
		}
		if (Config.whisper_B != Config.whisper_A)
		{
			if (Config.whisper_A.isEnemy(Config.whisper_B))
			{
				showWhisperTip("whisper_already_in_war");
				Config.whisper_B = null;
				return false;
			}
			if (Config.whisper_A.isInWarOnSameSide(Config.whisper_B))
			{
				using ListPool<War> listPool = new ListPool<War>(Config.whisper_A.getWars());
				foreach (ref War item in listPool)
				{
					War current = item;
					if (!current.isTotalWar() && current.onTheSameSide(Config.whisper_A, Config.whisper_B))
					{
						current.leaveWar(Config.whisper_B);
					}
				}
			}
			bool flag = World.world.wars.haveCommonEnemy(Config.whisper_A, Config.whisper_B);
			Alliance alliance = Config.whisper_A.getAlliance();
			if (alliance != null && Alliance.isSame(alliance, Config.whisper_B.getAlliance()))
			{
				alliance.leave(Config.whisper_A);
			}
			War randomWarFor = World.world.wars.getRandomWarFor(Config.whisper_B);
			if (randomWarFor != null && !randomWarFor.isTotalWar() && !flag)
			{
				if (randomWarFor.isAttacker(Config.whisper_B))
				{
					randomWarFor.joinDefenders(Config.whisper_A);
				}
				else
				{
					randomWarFor.joinAttackers(Config.whisper_A);
				}
				showWhisperTip("whisper_joined_war");
			}
			else
			{
				World.world.diplomacy.startWar(Config.whisper_A, Config.whisper_B, WarTypeLibrary.whisper_of_war);
				showWhisperTip("whisper_new_war");
			}
			Config.whisper_A.affectKingByPowers();
			Config.whisper_A = null;
			Config.whisper_B = null;
		}
		return true;
	}

	public static bool clickUnity(WorldTile pTile, string pPowerID)
	{
		City city = pTile.zone.city;
		if (city.isRekt())
		{
			return false;
		}
		Kingdom kingdom = city.kingdom;
		if (kingdom.isRekt())
		{
			return false;
		}
		if (kingdom.isNeutral())
		{
			return false;
		}
		if (Config.unity_A == null)
		{
			Config.unity_A = kingdom;
			showWhisperTip("unity_selected_first");
			return false;
		}
		if (Config.whisper_B == null && Config.unity_A == kingdom)
		{
			showWhisperTip("unity_cancelled");
			Config.unity_A = null;
			Config.unity_B = null;
			return false;
		}
		if (Config.unity_A.hasAlliance() && kingdom.hasAlliance() && Config.unity_A.getAlliance() == kingdom.getAlliance())
		{
			showWhisperTip("unity_cancelled");
			Config.unity_A = null;
			Config.unity_B = null;
			return false;
		}
		if (Config.unity_B == null)
		{
			Config.unity_B = kingdom;
		}
		if (Config.unity_B == Config.unity_A)
		{
			return false;
		}
		if (Config.unity_A.isEnemy(Config.unity_B))
		{
			showWhisperTip("unity_in_war");
			Config.unity_B = null;
			return false;
		}
		if (Config.unity_A.hasAlliance())
		{
			if (Config.unity_A.getAlliance() == Config.unity_B.getAlliance())
			{
				showWhisperTip("unity_cancelled");
				Config.unity_B = null;
				return false;
			}
			if (Config.unity_B.hasAlliance())
			{
				Config.unity_A.getAlliance().leave(Config.unity_A);
			}
		}
		if (World.world.alliances.forceAlliance(Config.unity_A, Config.unity_B))
		{
			showWhisperTip("unity_new_alliance");
		}
		else
		{
			showWhisperTip("unity_joined_alliance");
		}
		Config.unity_A.affectKingByPowers();
		Config.unity_A = null;
		Config.unity_B = null;
		World.world.zone_calculator.dirtyAndClear();
		return true;
	}

	private static void showWhisperTip(string pText)
	{
		string text = LocalizedTextManager.getText(pText);
		if (Config.whisper_A != null)
		{
			text = text.Replace("$kingdom_A$", Config.whisper_A.name);
		}
		if (Config.whisper_B != null)
		{
			text = text.Replace("$kingdom_B$", Config.whisper_B.name);
		}
		WorldTip.showNow(text, pTranslate: false, "top", 6f);
	}

	public static bool selectWhisperOfWar(string pPowerID)
	{
		WorldTip.showNow("whisper_selected", pTranslate: true, "top");
		Config.whisper_A = null;
		Config.whisper_B = null;
		return false;
	}

	public static bool selectUnity(string pPowerID)
	{
		WorldTip.showNow("unity_selected", pTranslate: true, "top");
		Config.unity_A = null;
		Config.unity_B = null;
		return false;
	}

	public static bool selectRelations(string pPowerID)
	{
		SelectedMetas.selected_kingdom = World.world.kingdoms.getRandom();
		return false;
	}

	public static bool whirlwind(BaseSimObject pSelf, WorldTile pTile)
	{
		World.world.applyForceOnTile(pTile, 10, 3f, pForceOut: false, 0, null, pSelf);
		return true;
	}

	public static void removeUnit(Actor pActor)
	{
		pActor.removeByMetamorphosis();
	}

	public static bool breakBones(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isActor())
		{
			pTarget.a.addInjuryTrait("crippled");
		}
		return true;
	}

	public static bool restoreMana(WorldTile pTile, Actor pSelf)
	{
		if (pSelf.isManaFull())
		{
			return false;
		}
		int pValue = (int)((float)pSelf.getMaxMana() * 0.01f);
		pSelf.addMana(pValue);
		return true;
	}

	public static bool restoreStamina(WorldTile pTile, Actor pSelf)
	{
		if (pSelf.isStaminaFull())
		{
			return false;
		}
		int pValue = (int)((float)pSelf.getMaxStamina() * 0.01f);
		pSelf.addStamina(pValue);
		return true;
	}

	public static bool restoreFullStats(NanoObject pTarget, BaseAugmentationAsset pTrait)
	{
		if (pTarget.isRekt())
		{
			return false;
		}
		((Actor)pTarget).event_full_stats = true;
		return true;
	}

	public static bool forcedKingdomAdd(NanoObject pTarget, BaseAugmentationAsset pTrait)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		ActorTrait actorTrait = (ActorTrait)pTrait;
		Actor actor = (Actor)pTarget;
		if (actor.asset.is_boat)
		{
			actor.getHitFullHealth(AttackType.Explosion);
			return false;
		}
		actor.applyForcedKingdomTrait();
		actor.setForcedKingdom(actorTrait.getForcedKingdom());
		return true;
	}

	public static bool forcedKingdomEffectRemove(NanoObject pTarget, BaseAugmentationAsset pTrait)
	{
		if (pTarget.isRekt())
		{
			return false;
		}
		((Actor)pTarget).setDefaultKingdom();
		return true;
	}

	public static bool madnessEffectLoad(NanoObject pTarget, BaseAugmentationAsset pTrait)
	{
		if (pTarget.isRekt())
		{
			return false;
		}
		((Actor)pTarget).setForcedKingdom(((ActorTrait)pTrait).getForcedKingdom());
		return true;
	}

	public static bool tryToMakeBuildingAlive(Building pBuilding)
	{
		if (!pBuilding.isAlive())
		{
			return false;
		}
		if (pBuilding.isRuin())
		{
			return false;
		}
		if (pBuilding.isUnderConstruction())
		{
			return false;
		}
		if (!pBuilding.asset.can_be_living_house)
		{
			return false;
		}
		Actor actor = World.world.units.createNewUnit("living_house", pBuilding.current_tile);
		actor.data.set("special_sprite_id", pBuilding.asset.id);
		actor.data.set("special_sprite_index", pBuilding.animData_index);
		actor.data.created_time = pBuilding.data.created_time;
		pBuilding.removeBuildingFinal();
		actor.startColorEffect();
		return true;
	}

	public static bool tryToMakeFloraAlive(Building pBuilding, bool pFullyGrownOnly = true)
	{
		if (!pBuilding.isAlive())
		{
			return false;
		}
		if (pBuilding.isRuin())
		{
			return false;
		}
		if (!pBuilding.asset.can_be_living_plant)
		{
			return false;
		}
		if (pBuilding.chopped)
		{
			return false;
		}
		if (pBuilding.isUnderConstruction())
		{
			return false;
		}
		if (pFullyGrownOnly && !pBuilding.isFullyGrown())
		{
			return false;
		}
		Actor actor = World.world.units.createNewUnit("living_plants", pBuilding.current_tile, pMiracleSpawn: false, 0f, null, null, pSpawnWithItems: false);
		actor.data.set("special_sprite_id", pBuilding.asset.id);
		actor.data.set("special_sprite_index", pBuilding.animData_index);
		actor.data.created_time = pBuilding.data.created_time;
		pBuilding.removeBuildingFinal();
		actor.startColorEffect();
		return true;
	}

	public static void growRandomVegetation(WorldTile pTile, BiomeAsset pBiomeAsset)
	{
		switch (Randy.randomInt(0, 3))
		{
		case 0:
			if (pBiomeAsset.grow_type_selector_trees != null)
			{
				BuildingActions.tryGrowVegetationRandom(pTile, VegetationType.Trees);
			}
			break;
		case 1:
			if (pBiomeAsset.grow_type_selector_plants != null)
			{
				BuildingActions.tryGrowVegetationRandom(pTile, VegetationType.Plants);
			}
			break;
		case 2:
			if (pBiomeAsset.grow_type_selector_bushes != null)
			{
				BuildingActions.tryGrowVegetationRandom(pTile, VegetationType.Bushes);
			}
			break;
		}
	}

	private static NanoObject getNanoObjectFromTile(WorldTile pTile, MetaTypeAsset pMetaTypeAsset)
	{
		if (pTile == null)
		{
			return null;
		}
		NanoObject nanoObject = pMetaTypeAsset.tile_get_metaobject(pTile.zone, pMetaTypeAsset.getZoneOptionState()) as NanoObject;
		if (nanoObject.isRekt())
		{
			return null;
		}
		return nanoObject;
	}
}
// --- End of File: ActionLibrary.cs ---



// --- Start of File: ActionOptionAsset.cs ---
public delegate void ActionOptionAsset(OptionAsset pAsset);
// --- End of File: ActionOptionAsset.cs ---



// --- Start of File: Actor.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Mathematics;
using UnityEngine;
using ai;
using ai.behaviours;

public class Actor : BaseSimObject, ILoadable<ActorData>, ITraitsOwner<ActorTrait>, IEquatable<Actor>, IComparable<Actor>, IFavoriteable
{
	internal ActorIdleLoopSound idle_loop_sound;

	internal bool is_forced_socialize_icon;

	internal double is_forced_socialize_timestamp;

	internal string ate_last_item_id;

	internal double timestamp_session_ate_food;

	internal double timestamp_tween_session_social;

	private double _last_color_effect_timestamp;

	private double _last_stamina_reduce_timestamp;

	internal double timestamp_profession_set;

	internal List<BaseActorComponent> children_special;

	private Dictionary<Type, BaseActorComponent> _dict_special;

	private List<ActorSimpleComponent> children_pre_behaviour;

	private Dictionary<Type, ActorSimpleComponent> dict_pre_behaviour;

	private UnitProfession _profession;

	public GameObject avatar;

	private double _timestamp_augmentation_effects;

	internal bool show_shadow;

	internal Vector2 current_shadow_position = Vector2.op_Implicit(Globals.POINT_IN_VOID);

	private double[] _decision_cooldowns;

	private bool[] _decision_disabled;

	public DecisionAsset[] decisions = new DecisionAsset[64];

	public int decisions_counter;

	private int _current_children;

	private readonly Queue<HappinessHistory> _last_happiness_history = new Queue<HappinessHistory>();

	private HashSet<long> _aggression_targets = new HashSet<long>();

	private HoverState _hover_state;

	private float _hover_timer;

	public BatchActors batch;

	internal WorldTile beh_tile_target;

	internal Building beh_building_target;

	internal BaseSimObject beh_actor_target;

	internal Book beh_book_target;

	internal Building inside_building;

	internal bool is_inside_building;

	internal Boat inside_boat;

	internal bool is_inside_boat;

	internal BaseSimObject attackedBy;

	public Actor lover;

	public readonly HashSet<ActorTrait> traits = new HashSet<ActorTrait>();

	private readonly CombatActionHolder _combat_actions = new CombatActionHolder();

	private readonly SpellHolder _spells = new SpellHolder();

	private readonly Dictionary<string, bool> _traits_cache = new Dictionary<string, bool>();

	internal ActorData data;

	internal ProfessionAsset profession_asset;

	private bool _state_adult;

	private bool _state_baby;

	private bool _state_egg;

	public ActorAsset asset;

	public Vector2 next_step_position;

	public Vector2 next_step_position_possession;

	internal Vector2 shake_offset;

	public static readonly Vector2 sprite_offset = new Vector2(0.5f, 0.5f);

	public Vector2 move_jump_offset;

	private bool _shake_horizontal;

	private bool _shake_vertical;

	private float _shake_timer;

	private bool _shake_active;

	private float _shake_volume;

	private bool _is_moving;

	private bool _possessed_movement;

	private bool _is_in_liquid;

	internal bool is_visible;

	internal bool last_sprite_renderer_enabled;

	internal AnimationFrameData frame_data;

	internal bool dirty_current_tile;

	internal WorldTile tile_target;

	private WorldTile _next_step_tile;

	public SplitPathStatus split_path;

	public int current_path_index;

	public readonly List<WorldTile> current_path = new List<WorldTile>();

	public List<MapRegion> current_path_global;

	public BaseActionActor callbacks_on_death;

	public BaseActionActor callbacks_landed;

	public BaseActionActor callbacks_cancel_path_movement;

	public BaseActionActor callbacks_magnet_update;

	internal float actor_scale;

	internal float target_scale;

	internal BaseSimObject attack_target;

	internal bool has_attack_target;

	internal float timer_action;

	internal float timer_jump_animation;

	internal float hitbox_bonus_height;

	internal Vector3 velocity;

	internal float velocity_speed;

	internal bool under_forces;

	protected WorldTimer targets_to_ignore_timer;

	private bool _flying;

	internal bool is_in_magnet;

	internal float attack_timer;

	internal double last_attack_timestamp;

	internal EquipmentAsset _attack_asset;

	internal PersonalityAsset s_personality;

	private readonly List<BaseAugmentationAsset> _s_special_effect_augmentations = new List<BaseAugmentationAsset>();

	private readonly Dictionary<BaseAugmentationAsset, double> _s_special_effect_augmentations_timers = new Dictionary<BaseAugmentationAsset, double>();

	internal AttackAction s_action_attack_target;

	internal GetHitAction s_get_hit_action;

	protected static readonly List<BaseAugmentationAsset> _tempAugmentationList = new List<BaseAugmentationAsset>();

	private bool _has_emotions;

	private bool _has_tag_unconscious;

	public bool has_tag_immunity_cold;

	private bool _has_status_strange_urge;

	private bool _has_status_possessed;

	private bool _has_status_sleeping;

	private bool _has_status_tantrum;

	private bool _has_status_drowning;

	private bool _has_status_invincible;

	private bool _cache_check_has_status_removed_on_damage;

	private bool _has_trait_weightless;

	private bool _has_trait_peaceful;

	private bool _has_trait_clone;

	internal bool has_tag_generate_light;

	private bool _has_any_sick_trait;

	internal bool is_immovable;

	internal bool is_ai_frozen;

	private bool _has_stop_idle_animation;

	private bool _ignore_fights;

	protected bool should_check_land_cancel;

	internal WorldTile scheduled_tile_target;

	internal bool _action_wait_after_land;

	internal float _action_wait_after_land_timer;

	internal AiSystemActor ai;

	public CitizenJobAsset citizen_job;

	protected Building _home_building;

	private float _death_timer_color_stage_1;

	private float _death_timer_alpha_stage_2;

	private float _jump_time;

	private float lastX;

	private float lastY;

	public float flip_angle;

	internal bool flip;

	private int _precalc_movement_speed_skips;

	private float _current_combined_movement_speed;

	internal float _timeout_targets;

	internal Vector3 target_angle;

	internal float rotation_cooldown;

	private RotationDirection _rotation_direction;

	private Sprite _last_topic_sprite;

	public Color color;

	internal bool dirty_sprite_main;

	private Sprite _cached_sprite_item;

	private IHandRenderer _cached_hand_renderer_asset;

	internal Sprite cached_sprite_head;

	internal bool dirty_sprite_head;

	internal AnimationContainerUnit animation_container;

	private Sprite _last_main_sprite;

	private Sprite _last_colored_sprite;

	private ColorAsset _last_color_asset;

	private bool _dirty_sprite_item;

	private bool _has_animated_item;

	public SpriteAnimation sprite_animation;

	private const float POSSESSION_ATTACK_SECONDS = 0.5f;

	private double _possession_attack_happened_frame;

	private AttackType _last_attack_type;

	public ActorEquipment equipment;

	public Army army;

	public City city;

	public Clan clan;

	public Culture culture;

	public Family family;

	public Language language;

	public Plot plot;

	public Religion religion;

	public Subspecies subspecies;

	private const float FIND_TILE_SQ_DIST = 4f;

	private const float CUR_SQ_DIST = 0.16000001f;

	private const float NEW_SQ_DIST = 0.09f;

	private bool _beh_skip;

	private bool _update_done;

	private string _last_decision_id;

	public Queue<HappinessHistory> happiness_change_history => _last_happiness_history;

	public string coloredName
	{
		get
		{
			if (data != null)
			{
				if (kingdom?.getColor() != null)
				{
					return "<color=" + kingdom.getColor().color_text + ">" + getName() + "</color>";
				}
				return getName();
			}
			return "";
		}
	}

	public bool is_invincible => _has_status_invincible;

	public override string name
	{
		get
		{
			return getName();
		}
		protected set
		{
			data.name = value;
		}
	}

	public Building home_building => _home_building;

	public int age => getAge();

	public bool is_army_captain
	{
		get
		{
			if (hasArmy())
			{
				return army.getCaptain() == this;
			}
			return false;
		}
	}

	public bool is_profession_nothing => _profession == UnitProfession.Nothing;

	public bool is_profession_king => _profession == UnitProfession.King;

	public bool is_profession_leader => _profession == UnitProfession.Leader;

	public bool is_profession_warrior => _profession == UnitProfession.Warrior;

	public bool is_profession_citizen => _profession == UnitProfession.Unit;

	public bool is_looking_left => !flip;

	public ResourceAsset favorite_food_asset => AssetManager.resources.get(data.favorite_food);

	public int current_children_count => _current_children;

	public bool is_unconscious => _has_tag_unconscious;

	public int loot => data.loot;

	public int money => data.money;

	public int renown => data.renown;

	public int level => data.level;

	public int intelligence => (int)stats["intelligence"];

	public int diplomacy => (int)stats["diplomacy"];

	public int warfare => (int)stats["warfare"];

	public int stewardship => (int)stats["stewardship"];

	protected override MetaType meta_type => MetaType.Unit;

	public bool is_moving
	{
		get
		{
			if (!_is_moving)
			{
				return _possessed_movement;
			}
			return true;
		}
	}

	public bool has_rendered_sprite_head => cached_sprite_head != null;

	public WorldTile debug_next_step_tile => _next_step_tile;

	public ActorBag inventory
	{
		get
		{
			return data.inventory;
		}
		set
		{
			data.inventory = value;
		}
	}

	protected sealed override void setDefaultValues()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		base.setDefaultValues();
		_last_decision_id = string.Empty;
		is_inside_building = false;
		inside_building = null;
		_state_adult = false;
		_state_baby = false;
		_state_egg = false;
		next_step_position = Vector2.op_Implicit(Globals.emptyVector);
		shake_offset = new Vector2(0f, 0f);
		move_jump_offset = new Vector2(0f, 0f);
		_shake_horizontal = true;
		_shake_vertical = true;
		_shake_timer = 0f;
		_shake_active = false;
		_shake_volume = 0.1f;
		_is_moving = false;
		is_visible = false;
		last_sprite_renderer_enabled = false;
		dirty_current_tile = true;
		split_path = SplitPathStatus.Normal;
		current_path_index = 0;
		current_path_global = null;
		actor_scale = 0f;
		target_scale = 0f;
		timer_action = 0f;
		timer_jump_animation = 0f;
		hitbox_bonus_height = 0f;
		velocity = default(Vector3);
		velocity_speed = 0f;
		under_forces = false;
		_flying = false;
		is_in_magnet = false;
		attack_timer = 0f;
		_attack_asset = ItemLibrary.base_attack;
		dirty_sprite_main = true;
		cached_sprite_head = null;
		dirty_sprite_head = true;
		_cached_sprite_item = null;
		_cached_hand_renderer_asset = null;
		s_personality = null;
		_action_wait_after_land = false;
		rotation_cooldown = 0f;
		target_angle = default(Vector3);
		_timeout_targets = 0f;
		_precalc_movement_speed_skips = 0;
		flip_angle = 0f;
		lastX = -10f;
		lastY = -10f;
		_jump_time = 0f;
		_death_timer_color_stage_1 = 1f;
		_death_timer_alpha_stage_2 = 1f;
		color = Color.white;
		ate_last_item_id = string.Empty;
		timestamp_session_ate_food = 0.0;
		timestamp_tween_session_social = 0.0;
		timestamp_profession_set = 0.0;
		_timestamp_augmentation_effects = 0.0;
		show_shadow = false;
		_decision_cooldowns = Toolbox.checkArraySize(_decision_cooldowns, AssetManager.decisions_library.list.Count);
		_decision_disabled = Toolbox.checkArraySize(_decision_disabled, AssetManager.decisions_library.list.Count);
		decisions = Toolbox.checkArraySize(decisions, AssetManager.decisions_library.list.Count);
	}

	public void setShowShadow(bool pShadow)
	{
		show_shadow = pShadow;
	}

	private void updateChildrenList(List<BaseActorComponent> pList, float pElapsed)
	{
		if (pList != null)
		{
			for (int i = 0; i < pList.Count; i++)
			{
				pList[i].update(pElapsed);
			}
		}
	}

	private void updateChildrenListSimple(List<ActorSimpleComponent> pList, float pElapsed)
	{
		if (pList != null)
		{
			for (int i = 0; i < pList.Count; i++)
			{
				pList[i].update(pElapsed);
			}
		}
	}

	public void setAsset(ActorAsset pAsset)
	{
		if (asset != null)
		{
			asset.units.Remove(this);
		}
		asset = pAsset;
		asset.units.Add(this);
		setStatsDirty();
		if (canUseItems() && !hasEquipment())
		{
			equipment = new ActorEquipment();
		}
	}

	internal override void create()
	{
		base.create();
		if (ai == null)
		{
			ai = new AiSystemActor(this);
		}
		ai.jobs_library = AssetManager.job_actor;
		ai.task_library = AssetManager.tasks_actor;
		ai.next_job_delegate = getNextJob;
		ai.clear_action_delegate = clearBeh;
		ai.subscribeToTaskSwitch(setItemSpriteRenderDirty);
		if (targets_to_ignore_timer == null)
		{
			targets_to_ignore_timer = new WorldTimer(3f, base.clearIgnoreTargets);
		}
		_flying = asset.flying;
		setActorScale(asset.base_stats["scale"] * 0.6f);
		if (asset.finish_scale_on_creation)
		{
			target_scale = asset.base_stats["scale"];
			finishScale();
		}
		setObjectType(MapObjectType.Actor);
		setShowShadow(asset.shadow);
		if (asset.has_sound_idle_loop)
		{
			idle_loop_sound = new ActorIdleLoopSound(asset, this);
		}
		if (isHovering())
		{
			move_jump_offset.y = asset.hovering_min;
		}
		addChildren();
		if (asset.kingdom_id_wild.Contains("ants"))
		{
			AchievementLibrary.ant_world.check();
		}
		if (asset.kingdom_id_wild.Contains("monkey"))
		{
			AchievementLibrary.planet_of_apes.check();
		}
		if (asset.cancel_beh_on_land)
		{
			callbacks_landed = (BaseActionActor)Delegate.Combine(callbacks_landed, new BaseActionActor(checkLand));
		}
		callbacks_landed = (BaseActionActor)Delegate.Combine(callbacks_landed, new BaseActionActor(checkDeathOutsideMap));
		callbacks_on_death = (BaseActionActor)Delegate.Combine(callbacks_on_death, new BaseActionActor(playDeathSound));
		callbacks_magnet_update = (BaseActionActor)Delegate.Combine(callbacks_magnet_update, new BaseActionActor(actionMagnetAnimation));
	}

	public bool canSeeTileBasedOnDirection(WorldTile pTile)
	{
		bool flag = isTileOnTheLeft(pTile);
		return is_looking_left == flag;
	}

	public void setParent1(Actor pParentActor, bool pIncreaseChildren = true)
	{
		data.parent_id_1 = pParentActor.data.id;
		if (pIncreaseChildren)
		{
			pParentActor.increaseChildren();
		}
	}

	public void setParent2(Actor pActor, bool pIncreaseChildren = true)
	{
		data.parent_id_2 = pActor.data.id;
		if (pIncreaseChildren)
		{
			pActor.increaseChildren();
		}
	}

	internal void setProfession(UnitProfession pType, bool pCancelBeh = true)
	{
		_profession = pType;
		profession_asset = AssetManager.professions.get(pType);
		setStatsDirty();
		if (hasCity())
		{
			city.setCitizensDirty();
		}
		if (pCancelBeh)
		{
			cancelAllBeh();
		}
		timestamp_profession_set = World.world.getCurWorldTime();
		clearGraphicsFully();
	}

	private void addChildren()
	{
		if (asset.avatar_prefab != string.Empty)
		{
			GameObject val = Resources.Load<GameObject>("actors/" + asset.avatar_prefab);
			avatar = Object.Instantiate<GameObject>(val, World.world.transform_units);
			if (avatar.HasComponent<SpriteAnimation>())
			{
				sprite_animation = avatar.GetComponent<SpriteAnimation>();
				batch.c_sprite_animations.Add(this);
			}
			if (avatar.HasComponent<Crabzilla>())
			{
				addChild(avatar.GetComponent<Crabzilla>());
			}
			if (avatar.HasComponent<GodFinger>())
			{
				addChild(avatar.GetComponent<GodFinger>());
			}
			if (avatar.HasComponent<Dragon>())
			{
				addChild(avatar.GetComponent<Dragon>());
			}
			if (avatar.HasComponent<UFO>())
			{
				addChild(avatar.GetComponent<UFO>());
			}
		}
		if (asset.is_boat)
		{
			addChildSimple(new Boat());
		}
		if (children_pre_behaviour != null || children_special != null)
		{
			batch.c_update_children.Add(this);
		}
	}

	private void addChild(BaseActorComponent pObject)
	{
		if (children_special == null)
		{
			children_special = new List<BaseActorComponent>();
			_dict_special = new Dictionary<Type, BaseActorComponent>();
		}
		Type type = ((object)pObject).GetType();
		children_special.Add(pObject);
		_dict_special.Add(type, pObject);
		pObject.create(this);
	}

	private void addChildSimple(ActorSimpleComponent pObject)
	{
		if (children_pre_behaviour == null)
		{
			children_pre_behaviour = new List<ActorSimpleComponent>();
			dict_pre_behaviour = new Dictionary<Type, ActorSimpleComponent>();
		}
		Type type = pObject.GetType();
		children_pre_behaviour.Add(pObject);
		dict_pre_behaviour.Add(type, pObject);
		pObject.create(this);
	}

	public T getActorComponent<T>() where T : BaseActorComponent
	{
		if (_dict_special == null)
		{
			return null;
		}
		if (_dict_special.TryGetValue(typeof(T), out var value))
		{
			return value as T;
		}
		return null;
	}

	public T getSimpleComponent<T>() where T : ActorSimpleComponent
	{
		if (dict_pre_behaviour.TryGetValue(typeof(T), out var value))
		{
			return value as T;
		}
		return null;
	}

	private void playDeathSound(Actor pActor)
	{
		if (asset.has_sound_death)
		{
			MusicBox.playSound(asset.sound_death, current_tile, pGameViewOnly: true, pVisibleOnly: true);
		}
	}

	public void playIdleSound()
	{
		if (asset.has_sound_idle)
		{
			MusicBox.playIdleSoundVisibleOnly(asset.sound_idle, current_tile);
		}
	}

	public void startShake(float pTimer = 0.3f, float pVol = 0.1f, bool pHorizontal = true, bool pVertical = true)
	{
		_shake_horizontal = pHorizontal;
		_shake_vertical = pVertical;
		_shake_timer = Mathf.Min(pTimer, asset.max_shake_timer);
		_shake_volume = pVol;
		_shake_active = true;
		batch.c_shake.Add(this);
	}

	public Vector3 getThrowStartPosition()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = cur_transform_position;
		Vector3 val2 = current_scale;
		Vector3 val3 = current_rotation;
		AnimationFrameData animationFrameData = getAnimationFrameData();
		float num = 0f;
		float num2 = 0f;
		if (animationFrameData != null)
		{
			num = animationFrameData.pos_item.x;
			num2 = animationFrameData.pos_item.y;
		}
		float num3 = val.x + num * val2.x;
		float num4 = val.y + num2 * val2.y;
		Vector3 point = default(Vector3);
		((Vector3)(ref point))._002Ector(num3, num4, -0.01f);
		Vector3 angles = val3;
		if (angles.y != 0f || angles.z != 0f)
		{
			Vector3 pivot = default(Vector3);
			((Vector3)(ref pivot))._002Ector(val.x, val.y, 0f);
			point = Toolbox.RotatePointAroundPivot(ref point, ref pivot, ref angles);
			point.z = -0.01f;
		}
		return point;
	}

	public void checkDefaultProfession()
	{
		setProfession(UnitProfession.Unit, pCancelBeh: false);
	}

	public void addAfterglowStatus()
	{
		float pOverrideTimer = (float)asset.months_breeding_timeout * 5f;
		addStatusEffect("afterglow", pOverrideTimer);
	}

	public void updateHover(float pElapsed)
	{
		if (!isAlive())
		{
			changeMoveJumpOffset((0f - pElapsed) * 10f);
			return;
		}
		if (isOnGround())
		{
			changeMoveJumpOffset((0f - pElapsed) * 3f);
		}
		else if (move_jump_offset.y < asset.hovering_min)
		{
			changeMoveJumpOffset(pElapsed * 3f);
			return;
		}
		if (_hover_timer > 0f)
		{
			_hover_timer -= pElapsed;
			return;
		}
		_hover_timer = 1f + Randy.randomFloat(0f, 4f);
		if (World.world.isPaused())
		{
			return;
		}
		switch (_hover_state)
		{
		case HoverState.Hover:
			if (Randy.randomBool())
			{
				_hover_state = HoverState.Down;
			}
			else
			{
				_hover_state = HoverState.Up;
			}
			break;
		case HoverState.Up:
			_hover_state = HoverState.Hover;
			if (move_jump_offset.y < asset.hovering_max)
			{
				changeMoveJumpOffset(pElapsed * 3f);
			}
			break;
		case HoverState.Down:
			_hover_state = HoverState.Hover;
			if (move_jump_offset.y > asset.hovering_min)
			{
				changeMoveJumpOffset((0f - pElapsed) * 3f);
			}
			break;
		}
	}

	public void updatePollinate(float pElapsed)
	{
		if (!isAlive())
		{
			return;
		}
		if (!is_moving && ai.task?.id == "pollinate")
		{
			setHoverState(HoverState.Down);
			changeMoveJumpOffset((0f - pElapsed) * 3f);
			return;
		}
		setHoverState(HoverState.Up);
		if (move_jump_offset.y < asset.hovering_max)
		{
			changeMoveJumpOffset(pElapsed * 3f);
		}
	}

	private void checkCalibrateTargetPosition()
	{
		if (hasRangeAttack() || beh_actor_target == null)
		{
			return;
		}
		BaseSimObject baseSimObject = beh_actor_target;
		if (hasTask() && ai.action != null && ai.action.calibrate_target_position && baseSimObject != null && baseSimObject.isActor())
		{
			Actor actor = beh_actor_target.a;
			float num = Toolbox.SquaredDist(actor.current_tile.x, actor.current_tile.y, tile_target.x, tile_target.y);
			float num2 = ai.action.check_actor_target_position_distance * ai.action.check_actor_target_position_distance;
			if (num > num2)
			{
				clearPathForCalibration();
				ai.action.startExecute(this);
			}
		}
	}

	internal override bool addStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer = 0f, bool pColorEffect = true)
	{
		if (pStatusAsset.affects_mind && hasTag("strong_mind"))
		{
			return false;
		}
		bool num = base.addStatusEffect(pStatusAsset, pOverrideTimer, pColorEffect);
		if (num && pColorEffect)
		{
			startColorEffect();
		}
		return num;
	}

	public void setTargetAngleZ(float pValue)
	{
		target_angle.z = pValue;
	}

	public void lookTowardsPosition(Vector2 pDirection)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (asset.can_flip)
		{
			if (current_position.x < pDirection.x)
			{
				setFlip(pFlip: true);
			}
			else
			{
				setFlip(pFlip: false);
			}
		}
	}

	public override void setStatsDirty()
	{
		if (isAlive())
		{
			batch.c_stats_dirty.Add(this);
		}
		base.setStatsDirty();
		setItemSpriteRenderDirty();
	}

	private void checkRageDemon()
	{
		if (WorldLawLibrary.world_law_disasters_other.isEnabled() && canTurnIntoDemon() && World.world_era.era_disaster_rage_brings_demons && !hasTrait("blessed") && !isFavorite() && hasStatus("rage") && Randy.randomChance(0.1f))
		{
			ActionLibrary.turnIntoDemon(this);
		}
	}

	internal void updateChangeScale(float pElapsed)
	{
		if (actor_scale == target_scale)
		{
			return;
		}
		if (actor_scale > target_scale)
		{
			setActorScale(actor_scale - 0.2f * pElapsed);
			if (actor_scale < target_scale)
			{
				setActorScale(target_scale);
			}
		}
		else
		{
			setActorScale(actor_scale + 0.2f * pElapsed);
			if (actor_scale > target_scale)
			{
				setActorScale(target_scale);
			}
		}
	}

	internal void newCreature()
	{
		changeHappiness("just_born");
		World.world.game_stats.data.creaturesCreated++;
		World.world.map_stats.creaturesCreated++;
		AchievementLibrary.ten_thousands_creatures.check();
		generatePersonality();
		checkShouldBeEgg();
		event_full_stats = true;
		updateStats();
		event_full_stats = true;
		if (needsFood())
		{
			setNutrition(getMaxNutrition());
		}
	}

	public void clearTraits()
	{
		clearTraitCache();
		traits.Clear();
	}

	public override void Dispose()
	{
		WorldBehaviourUnitTemperatures.removeUnit(this);
		clearTraits();
		idle_loop_sound = null;
		checkSimpleComponentListDispose(children_pre_behaviour);
		checkComponentListDispose(children_special);
		_profession = UnitProfession.Nothing;
		sprite_animation = null;
		lover = null;
		idle_loop_sound = null;
		scheduled_tile_target = null;
		_last_main_sprite = null;
		_last_colored_sprite = null;
		_last_color_asset = null;
		_last_topic_sprite = null;
		children_special = null;
		_dict_special = null;
		children_pre_behaviour = null;
		dict_pre_behaviour = null;
		avatar = null;
		clearDecisions();
		if (hasSubspecies())
		{
			World.world.subspecies.unitDied(subspecies);
			subspecies = null;
		}
		if (hasCulture())
		{
			World.world.cultures.unitDied(culture);
			culture = null;
		}
		ai.reset();
		_last_happiness_history.Clear();
		citizen_job = null;
		if (hasCity())
		{
			World.world.cities.unitDied(city);
			city = null;
		}
		if (hasKingdom())
		{
			if (isKing())
			{
				kingdom.removeKing();
			}
			World.world.kingdoms.unitDied(kingdom);
			kingdom = null;
		}
		callbacks_on_death = null;
		callbacks_landed = null;
		callbacks_cancel_path_movement = null;
		callbacks_magnet_update = null;
		s_personality = null;
		_s_special_effect_augmentations.Clear();
		_s_special_effect_augmentations_timers.Clear();
		s_action_attack_target = null;
		targets_to_ignore_timer = null;
		clearOldPath();
		data = null;
		attackedBy = null;
		attack_target = null;
		has_attack_target = false;
		army = null;
		clan = null;
		culture = null;
		family = null;
		language = null;
		plot = null;
		religion = null;
		subspecies = null;
		beh_tile_target = null;
		beh_building_target = null;
		beh_actor_target = null;
		beh_book_target = null;
		exitBuilding();
		inside_boat = null;
		is_inside_boat = false;
		army = null;
		batch = null;
		equipment = null;
		tile_target = null;
		profession_asset = null;
		_next_step_tile = null;
		asset = null;
		frame_data = null;
		animation_container = null;
		_home_building = null;
		cached_sprite_head = null;
		_cached_sprite_item = null;
		_cached_hand_renderer_asset = null;
		_aggression_targets.Clear();
		_current_children = 0;
		is_forced_socialize_icon = false;
		is_forced_socialize_timestamp = 0.0;
		base.Dispose();
	}

	private void checkComponentListDispose(List<BaseActorComponent> pList)
	{
		if (pList != null)
		{
			for (int i = 0; i < pList.Count; i++)
			{
				pList[i].Dispose();
			}
			pList.Clear();
		}
	}

	private void checkSimpleComponentListDispose(List<ActorSimpleComponent> pList)
	{
		if (pList != null)
		{
			for (int i = 0; i < pList.Count; i++)
			{
				pList[i].Dispose();
			}
			pList.Clear();
		}
	}

	public void showTooltip(object pUiObject)
	{
		string pType = (isKing() ? "actor_king" : ((!isCityLeader()) ? "actor" : "actor_leader"));
		Tooltip.show(pUiObject, pType, new TooltipData
		{
			actor = this
		});
	}

	public override ColorAsset getColor()
	{
		return kingdom.getColor();
	}

	public void setHoverState(HoverState pState)
	{
		_hover_state = pState;
	}

	public override string ToString()
	{
		if (data == null)
		{
			return "[Actor is null]";
		}
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[Actor:{base.id} ");
		if (!isAlive())
		{
			stringBuilderPool.Append("[DEAD] ");
		}
		if (!string.IsNullOrEmpty(data.name))
		{
			stringBuilderPool.Append(data.name + " ");
		}
		if (hasCity())
		{
			stringBuilderPool.Append($"City:{city.getID()} ");
			if (city.kingdom != kingdom)
			{
				stringBuilderPool.Append($"CityKingdom:{city.kingdom?.getID() ?? (-1)} ");
			}
			if (city.hasArmy())
			{
				stringBuilderPool.Append($"CityArmy:{city.army.id} ");
			}
		}
		if (hasKingdom())
		{
			stringBuilderPool.Append($"Kingdom:{kingdom.getID()} ");
		}
		if (isKing())
		{
			stringBuilderPool.Append("isKing ");
		}
		if (isCityLeader())
		{
			stringBuilderPool.Append("isCityLeader ");
		}
		if (hasArmy())
		{
			stringBuilderPool.Append($"Army:{army.id} ");
			if (isArmyGroupLeader())
			{
				stringBuilderPool.Append("isArmyGroupLeader ");
			}
			if (isArmyGroupWarrior())
			{
				stringBuilderPool.Append("isArmyGroupWarrior ");
			}
		}
		return stringBuilderPool.ToString().Trim() + "]";
	}

	private int getMaxPossibleLevel()
	{
		return 9999;
	}

	internal void addExperience(int pValue)
	{
		if (pValue == 0 || !asset.can_level_up || !isAlive())
		{
			return;
		}
		if (hasCulture() && culture.hasTrait("fast_learners"))
		{
			pValue *= CultureTraitLibrary.getValue("fast_learners");
		}
		int maxPossibleLevel = getMaxPossibleLevel();
		if (data.level < maxPossibleLevel)
		{
			data.experience += pValue;
			if (data.experience >= getExpToLevelup())
			{
				levelUp();
			}
			if (data.level >= maxPossibleLevel)
			{
				data.experience = getExpToLevelup();
			}
		}
	}

	public void addRenown(int pValue)
	{
		data.renown += pValue;
	}

	public void addRenown(int pAmount, float pPercent)
	{
		int pValue = (int)((float)pAmount * pPercent);
		addRenown(pValue);
	}

	internal void updateAge()
	{
		checkGrowthEvent();
		float num = getAge();
		if (hasSubspecies())
		{
			subspecies.all_actions_actor_growth?.Invoke(this, current_tile);
			updateAttributes();
		}
		if (hasCity())
		{
			if (isKing())
			{
				addExperience(20);
			}
			if (isCityLeader())
			{
				addExperience(10);
			}
		}
		if (isSapient() && num > 300f && hasTrait("immortal") && Randy.randomBool())
		{
			addTrait("evil");
		}
		if (num > 40f && Randy.randomChance(0.3f))
		{
			addTrait("wise");
		}
	}

	private void updateAttributes()
	{
		if (Randy.randomChance(0.3f))
		{
			string possibleAttribute = subspecies.getPossibleAttribute();
			if (!string.IsNullOrEmpty(possibleAttribute))
			{
				data[possibleAttribute]++;
			}
		}
	}

	public void setMaxHappiness()
	{
		setHappiness(getMaxHappiness());
	}

	public void setHappiness(int pValue, bool pClamp = true)
	{
		if (pClamp)
		{
			pValue = Math.Clamp(pValue, getMinHappiness(), getMaxHappiness());
		}
		data.happiness = pValue;
	}

	public void restoreHealthPercent(float pVal)
	{
		if (pVal > 0f && !hasMaxHealth())
		{
			int maxHealthPercent = getMaxHealthPercent(pVal);
			restoreHealth(maxHealthPercent);
		}
	}

	public void restoreHealth(int pVal)
	{
		if (!hasMaxHealth())
		{
			changeHealth(pVal);
		}
	}

	public bool changeHappiness(string pID, int pValue = 0)
	{
		if (!hasEmotions())
		{
			return false;
		}
		if (isEgg())
		{
			return false;
		}
		HappinessAsset happinessAsset = AssetManager.happiness_library.get(pID);
		if (happinessAsset.ignored_by_psychopaths && hasTrait("psychopath"))
		{
			return false;
		}
		int num = pValue + happinessAsset.value;
		int num2 = getHappiness() + num;
		num2 = Mathf.Clamp(num2, getMinHappiness(), getMaxHappiness());
		setHappiness(num2);
		if (happinessAsset.show_change_happiness_effect)
		{
			if (num > 0)
			{
				EffectsLibrary.showMetaEventEffect("fx_change_happiness_positive", this);
			}
			else if (num < 0)
			{
				EffectsLibrary.showMetaEventEffect("fx_change_happiness_negative", this);
			}
		}
		_last_happiness_history.Enqueue(new HappinessHistory
		{
			index = happinessAsset.index,
			timestamp = World.world.getCurWorldTime(),
			bonus = pValue
		});
		if (_last_happiness_history.Count > 20)
		{
			_last_happiness_history.Dequeue();
		}
		return true;
	}

	public void spendNutritionOnBirth()
	{
		decreaseNutrition(SimGlobals.m.nutrition_cost_new_baby);
	}

	public void addNutritionFromEating(int pVal = 100, bool pSetMaxNutrition = false, bool pSetJustAte = false)
	{
		if (pSetMaxNutrition)
		{
			setNutrition(getMaxNutrition());
		}
		else
		{
			int pVal2 = Math.Min(getMaxNutrition(), data.nutrition + pVal);
			setNutrition(pVal2);
		}
		if (pSetJustAte)
		{
			justAte();
		}
	}

	public void updateNutritionDecay(bool pDoStarvationDamage = true)
	{
		int metabolicRate = subspecies.getMetabolicRate();
		decreaseNutrition(metabolicRate);
		if (isStarving())
		{
			setNutrition(0);
			if (pDoStarvationDamage)
			{
				int maxHealthPercent = getMaxHealthPercent(SimGlobals.m.starvation_damage_multiplier);
				getHit(maxHealthPercent, pFlash: true, AttackType.Starvation);
				if (isAlive())
				{
					addStatusEffect("starving", 0f, pColorEffect: false);
				}
			}
		}
		else
		{
			updateStamina();
			updateMana();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void decreaseNutrition(int pValue = -1)
	{
		setNutrition(getNutrition() - pValue);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void setNutrition(int pVal, bool pClamp = true)
	{
		if (pClamp)
		{
			pVal = Math.Clamp(pVal, 0, getMaxNutrition());
		}
		data.nutrition = pVal;
	}

	public void updateMana()
	{
		if (!isManaFull())
		{
			addMana(SimGlobals.m.mana_change);
		}
	}

	public void addMana(int pValue)
	{
		int maxMana = getMaxMana();
		int num = getMana();
		if (num < maxMana)
		{
			num += pValue;
		}
		num = Math.Clamp(num, 0, maxMana);
		setMana(num);
	}

	public int getMaxManaPercent(float pPercent)
	{
		int num = (int)((float)getMaxMana() * pPercent);
		return Mathf.Max(1, num);
	}

	public void restoreManaPercent(float pVal)
	{
		if (pVal > 0f && !hasMaxMana())
		{
			int maxManaPercent = getMaxManaPercent(pVal);
			restoreMana(maxManaPercent);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void changeMana(int pValue)
	{
		int num = data.mana + pValue;
		data.mana = Mathf.Clamp(num, 0, getMaxMana());
	}

	public void restoreMana(int pVal)
	{
		if (!hasMaxMana())
		{
			changeMana(pVal);
		}
	}

	public void setMana(int pValue, bool pClamp = true)
	{
		if (pClamp)
		{
			pValue = Math.Clamp(pValue, 0, getMaxMana());
		}
		data.mana = pValue;
	}

	public void spendMana(int pValueSpend)
	{
		if (pValueSpend != 0)
		{
			setMana(getMana() - pValueSpend);
		}
	}

	public int getMaxStaminaPercent(float pPercent)
	{
		int num = (int)((float)getMaxStamina() * pPercent);
		return Mathf.Max(1, num);
	}

	public void restoreStaminaPercent(float pVal)
	{
		if (pVal > 0f && !isStaminaFull())
		{
			int maxStaminaPercent = getMaxStaminaPercent(pVal);
			restoreStamina(maxStaminaPercent);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void changeStamina(int pValue)
	{
		int num = data.stamina + pValue;
		data.stamina = Mathf.Clamp(num, 0, getMaxStamina());
	}

	public void restoreStamina(int pVal)
	{
		if (!isStaminaFull())
		{
			changeStamina(pVal);
		}
	}

	public void updateStamina()
	{
		if (!isStaminaFull())
		{
			addStamina(SimGlobals.m.stamina_change);
		}
	}

	public void addStamina(int pValue)
	{
		int maxStamina = getMaxStamina();
		int num = getStamina();
		if (num < maxStamina)
		{
			num += pValue;
		}
		num = Math.Clamp(num, 0, maxStamina);
		setStamina(num);
	}

	public void setStamina(int pValue, bool pClamp = true)
	{
		if (pClamp)
		{
			pValue = Math.Clamp(pValue, 0, getMaxStamina());
		}
		data.stamina = pValue;
	}

	public void spendStamina(int pValueSpend)
	{
		if (pValueSpend != 0)
		{
			setStamina(getStamina() - pValueSpend);
		}
	}

	public void spendStaminaWithCooldown(int pValueSpend)
	{
		if (pValueSpend != 0 && !isUnderStaminaCooldown())
		{
			_last_stamina_reduce_timestamp = World.world.getCurSessionTime();
			setStamina(getStamina() - pValueSpend);
		}
	}

	public bool hasHappinessEntry(string pID, float pTime = 0f)
	{
		if (!hasHappinessHistory())
		{
			return false;
		}
		foreach (HappinessHistory item in happiness_change_history)
		{
			if (!(item.asset.id != pID))
			{
				if (pTime == 0f)
				{
					return true;
				}
				if (item.elapsedSince() < (double)pTime)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void finishScale()
	{
		setActorScale(target_scale);
	}

	public void setActorScale(float pVal)
	{
		actor_scale = pVal;
		((Vector3)(ref current_scale)).Set(actor_scale, actor_scale, 1f);
	}

	public void setData(ActorData pData)
	{
		data = pData;
	}

	public void loadData(ActorData pData)
	{
		setData(pData);
		pData.load();
	}

	public void generateSex()
	{
		if (Randy.randomBool())
		{
			data.sex = ActorSex.Male;
		}
		else
		{
			data.sex = ActorSex.Female;
		}
	}

	protected void generatePersonality()
	{
		if (hasSubspecies())
		{
			foreach (ActorTrait trait in subspecies.getActorBirthTraits().getTraits())
			{
				addTrait(trait);
			}
			if (subspecies.hasPhenotype())
			{
				generatePhenotypeAndShade();
			}
		}
		else
		{
			generateRandomSpawnTraits(asset);
		}
		if (isAdult())
		{
			checkTraitMutationGrowUp();
		}
		checkTraitMutationOnBirth();
		generateSex();
		setStatsDirty();
	}

	public void calcIsEgg()
	{
		if (hasSubspecies() && subspecies.has_egg_form)
		{
			_state_egg = hasStatus("egg");
		}
	}

	public void calcIsBaby()
	{
		if (hasSubspecies() && asset.has_baby_form && !((float)getAge() >= subspecies.age_adult))
		{
			_state_baby = true;
			clearSprites();
		}
	}

	public void setCheckLanding()
	{
		should_check_land_cancel = true;
	}

	public void addForce(float pX, float pY, float pHeight, bool pCheckLandCancelAllActions = false, bool pIgnorePosHeight = false)
	{
		if (asset.can_be_moved_by_powers)
		{
			if (pCheckLandCancelAllActions)
			{
				setCheckLanding();
			}
			if (pIgnorePosHeight || !(position_height > 0f))
			{
				velocity.x = pX;
				velocity.y = pY;
				velocity.z = pHeight;
				velocity_speed = pHeight;
				under_forces = true;
			}
		}
	}

	public void setFlying(bool pVal)
	{
		_flying = pVal;
		if (pVal)
		{
			hitbox_bonus_height = 8f;
		}
		else
		{
			hitbox_bonus_height = 2f;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void checkIsInLiquid()
	{
		bool is_in_liquid = current_tile.is_liquid && move_jump_offset.y == 0f && position_height <= 0f && isAlive();
		_is_in_liquid = is_in_liquid;
	}

	private void addDefaultItemAttackActions(ItemAsset pItemAsset)
	{
		addItemActions(pItemAsset);
		if (pItemAsset.action_attack_target != null)
		{
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, pItemAsset.action_attack_target);
		}
	}

	private void addItemActions(ItemAsset pItemAsset)
	{
		if (pItemAsset.action_special_effect != null)
		{
			_s_special_effect_augmentations.Add(pItemAsset);
		}
	}

	internal void attackTargetActions(BaseSimObject pTarget, WorldTile pTile)
	{
		s_action_attack_target?.Invoke(this, pTarget, pTile);
	}

	protected void calcAgeStates()
	{
		_state_egg = false;
		_state_baby = false;
		_state_adult = false;
		calcIsEgg();
		if (!isEgg())
		{
			calcIsBaby();
			if (!isBaby())
			{
				_state_adult = true;
				clearSprites();
			}
		}
		else
		{
			_state_baby = true;
			clearSprites();
		}
	}

	internal override void updateStats()
	{
		if (!isStatsDirty())
		{
			return;
		}
		base.updateStats();
		checkGrowthEvent();
		decisions_counter = 0;
		batch.c_stats_dirty.Remove(a);
		if (!isAlive())
		{
			return;
		}
		s_action_attack_target = null;
		s_get_hit_action = null;
		_s_special_effect_augmentations.Clear();
		_s_special_effect_augmentations_timers.Clear();
		stats.clear();
		clearCombatActions();
		clearSpells();
		if (hasSubspecies())
		{
			stats.mergeStats(subspecies.base_stats);
			if (isSexMale())
			{
				stats.mergeStats(subspecies.base_stats_male);
			}
			else
			{
				stats.mergeStats(subspecies.base_stats_female);
			}
		}
		else
		{
			stats.mergeStats(asset.base_stats);
		}
		if (hasClan())
		{
			stats.mergeStats(clan.base_stats);
			if (isSexMale())
			{
				stats.mergeStats(clan.base_stats_male);
			}
			else
			{
				stats.mergeStats(clan.base_stats_female);
			}
		}
		if (hasLanguage())
		{
			stats.mergeStats(language.base_stats);
		}
		if (hasCulture())
		{
			stats.mergeStats(culture.base_stats);
		}
		stats["diplomacy"] += data["diplomacy"];
		stats["stewardship"] += data["stewardship"];
		stats["intelligence"] += data["intelligence"];
		stats["warfare"] += data["warfare"];
		_cache_check_has_status_removed_on_damage = false;
		if (hasAnyStatusEffect())
		{
			foreach (Status status in getStatuses())
			{
				stats.mergeStats(status.asset.base_stats);
				if (status.asset.removed_on_damage)
				{
					_cache_check_has_status_removed_on_damage = true;
				}
				if (!string.IsNullOrEmpty(status.asset.decision_id))
				{
					decisions[decisions_counter++] = status.asset.getDecisionAsset();
				}
			}
		}
		if (!hasWeapon())
		{
			EquipmentAsset equipmentAsset = AssetManager.items.get(asset.default_attack);
			if (equipmentAsset != null)
			{
				stats.mergeStats(equipmentAsset.base_stats);
			}
		}
		checkAttackTypes();
		foreach (ActorTrait trait in traits)
		{
			if (!trait.only_active_on_era_flag || ((!trait.era_active_moon || World.world_era.flag_moon) && (!trait.era_active_night || World.world_era.overlay_darkness)))
			{
				if (trait.action_get_hit != null)
				{
					s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, trait.action_get_hit);
				}
				stats.mergeStats(trait.base_stats);
			}
		}
		is_forced_socialize_icon = hasStatus("possessed") && hasTag("strong_mind");
		if (hasStatus("budding"))
		{
			stats["diplomacy"] *= 2f;
			stats["stewardship"] *= 2f;
			stats["intelligence"] *= 2f;
			stats["warfare"] *= 2f;
		}
		if (isSapient())
		{
			s_personality = null;
			if (isKing() || isCityLeader())
			{
				string pID = "balanced";
				float num = stats["diplomacy"];
				if (stats["diplomacy"] > stats["stewardship"])
				{
					pID = "diplomat";
					num = stats["diplomacy"];
				}
				else if (stats["diplomacy"] < stats["stewardship"])
				{
					pID = "administrator";
					num = stats["stewardship"];
				}
				if (stats["warfare"] > num)
				{
					pID = "militarist";
				}
				s_personality = AssetManager.personalities.get(pID);
				stats.mergeStats(s_personality.base_stats);
			}
		}
		float num2 = (float)data.level * SimGlobals.m.level_mod_bonus_health * stats["health"];
		float num3 = (float)data.level * SimGlobals.m.level_mod_bonus_mana * stats["mana"];
		float num4 = (float)data.level * SimGlobals.m.level_mod_bonus_stamina * stats["stamina"];
		stats["health"] += num2;
		stats["mana"] += num3;
		stats["stamina"] += num4;
		stats["skill_combat"] += (float)(int)(stats["warfare"] / 5f) * 0.01f;
		stats["skill_spell"] += (float)(int)(stats["intelligence"] / 5f) * 0.01f;
		if (data.level > 5)
		{
			stats["skill_combat"] += 0.1f;
			stats["skill_spell"] += 0.1f;
		}
		addSpecialEffectAugmentations(traits);
		checkActionsFromAllMetas();
		recalcCombatActions();
		recalcSpells();
		registerDecisions();
		bool has_tag_unconscious = _has_tag_unconscious;
		has_tag_generate_light = hasTag("generate_light");
		_has_tag_unconscious = hasTag("unconscious");
		has_tag_immunity_cold = hasTag("immunity_cold");
		if (_has_tag_unconscious)
		{
			if (!has_tag_unconscious)
			{
				if (((Random)(ref batch.rnd)).NextBool())
				{
					_rotation_direction = RotationDirection.Left;
				}
				else
				{
					_rotation_direction = RotationDirection.Right;
				}
			}
			timer_jump_animation = 0f;
		}
		_has_trait_weightless = hasTrait("weightless");
		_has_status_sleeping = hasStatus("sleeping");
		_has_status_strange_urge = hasStatus("strange_urge");
		_has_status_possessed = hasStatus("possessed");
		_has_status_tantrum = hasStatus("tantrum");
		_has_status_drowning = hasStatus("drowning");
		_has_status_invincible = hasStatus("invincible");
		is_immovable = isImmovable();
		is_ai_frozen = isAiFrozen();
		_has_stop_idle_animation = hasStopIdleAnimation();
		_ignore_fights = isIgnoreFights();
		if (hasSubspecies())
		{
			_has_emotions = subspecies.can_process_emotions;
		}
		else
		{
			_has_emotions = false;
		}
		if (!hasWeapon())
		{
			EquipmentAsset equipmentAsset2 = AssetManager.items.get(asset.default_attack);
			addDefaultItemAttackActions(equipmentAsset2);
			if (equipmentAsset2.item_modifiers != null)
			{
				for (int i = 0; i < equipmentAsset2.item_modifiers.Length; i++)
				{
					ItemModAsset itemModAsset = equipmentAsset2.item_modifiers[i];
					if (itemModAsset != null)
					{
						addDefaultItemAttackActions(itemModAsset);
					}
				}
			}
		}
		if (canUseItems())
		{
			foreach (ActorEquipmentSlot item3 in equipment)
			{
				if (item3.isEmpty())
				{
					continue;
				}
				Item item = item3.getItem();
				addItemActions(item.getAsset());
				if (item.action_attack_target != null)
				{
					s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, item.action_attack_target);
				}
				foreach (ref string modifier in item.data.modifiers)
				{
					string current4 = modifier;
					ItemModAsset pItemAsset = AssetManager.items_modifiers.get(current4);
					addItemActions(pItemAsset);
				}
			}
		}
		if (_s_special_effect_augmentations.Count == 0)
		{
			batch.c_augmentation_effects.Remove(a);
		}
		else
		{
			batch.c_augmentation_effects.Add(a);
		}
		_has_any_sick_trait = calculateIsSick();
		_has_trait_peaceful = hasTrait("peaceful");
		_has_trait_clone = hasTrait("clone");
		if (canUseItems())
		{
			foreach (ActorEquipmentSlot item4 in equipment)
			{
				if (!item4.isEmpty())
				{
					Item item2 = item4.getItem();
					float pMultiplier = 1f;
					if (item2.isBroken())
					{
						pMultiplier = 0.5f;
					}
					ItemTools.mergeStatsWithItem(stats, item2, pCalcGlobalValue: false, pMultiplier);
				}
			}
		}
		if (asset.only_melee_attack)
		{
			stats["range"] = asset.base_stats["range"];
		}
		stats.normalize();
		stats["cities"] += (int)stats["stewardship"] / 6 + 1;
		stats["bonus_towers"] += (int)(stats["warfare"] / 10f);
		stats["mana"] += (int)(stats["intelligence"] * SimGlobals.m.MANA_PER_INTELLIGENCE);
		stats.checkMultipliers();
		if (isSapient())
		{
			calculateOffspringBasedOnAge();
		}
		if (hasRangeAttack())
		{
			stats["range"] += stats["range"] * World.world_era.range_weapons_multiplier;
		}
		stats["damage"] += stats["warfare"] / 5f;
		if (isBaby())
		{
			stats["damage"] = stats["damage"] * 0.5f;
			stats["health"] = stats["health"] * 0.5f;
		}
		stats.normalize();
		if (getHealth() > getMaxHealth())
		{
			setMaxHealth();
		}
		if (getHappiness() > getMaxHappiness())
		{
			setMaxHappiness();
		}
		if (getStamina() > getMaxStamina())
		{
			setMaxStamina();
		}
		if (getMana() > getMaxMana())
		{
			setMaxMana();
		}
		if (event_full_stats)
		{
			event_full_stats = false;
			setMaxHealth();
			setMaxStamina();
			setMaxMana();
		}
		if (isHovering())
		{
			batch.c_hovering.Add(a);
		}
		else
		{
			move_jump_offset.y = 0f;
			batch.c_hovering.Remove(a);
		}
		if (isPollinator())
		{
			batch.c_pollinating.Add(a);
		}
		else
		{
			batch.c_pollinating.Remove(a);
		}
		target_scale = stats["scale"];
		if (attack_timer > getAttackCooldown())
		{
			attack_timer = getAttackCooldown();
		}
	}

	public void resetAttackTimeout()
	{
		attack_timer = 0f;
	}

	public void setActionTimeout(float pTimeout)
	{
		attack_timer = pTimeout;
	}

	private void addSpecialEffectAugmentations(IEnumerable<BaseAugmentationAsset> pAssets)
	{
		foreach (BaseAugmentationAsset pAsset in pAssets)
		{
			if (pAsset.action_special_effect != null)
			{
				_s_special_effect_augmentations.Add(pAsset);
			}
			if (pAsset.action_attack_target != null)
			{
				s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, pAsset.action_attack_target);
			}
		}
	}

	private void addSpecialEffectsFromMetas(List<BaseAugmentationAsset> pAugmentations)
	{
		if (pAugmentations != null && pAugmentations.Count != 0)
		{
			_s_special_effect_augmentations.AddRange(pAugmentations);
		}
	}

	private void calculateOffspringBasedOnAge()
	{
		if (!hasTrait("immortal"))
		{
			int num = (int)stats["offspring"];
			float ageRatio = getAgeRatio();
			float num2 = 1f;
			if (ageRatio > 0.9f)
			{
				num2 = 0.1f;
			}
			else if (ageRatio > 0.7f)
			{
				num2 = 0.2f;
			}
			else if (ageRatio > 0.5f)
			{
				num2 = 0.5f;
			}
			else if (ageRatio > 0.3f)
			{
				num2 = 0.8f;
			}
			stats["offspring"] = (int)Math.Ceiling((float)num * num2);
		}
	}

	internal virtual void updateFall()
	{
		if (position_height < 0f)
		{
			return;
		}
		float elapsed = World.world.elapsed;
		float num = SimGlobals.m.gravity * stats.get("mass");
		position_height -= num * elapsed;
		if (position_height <= 0f)
		{
			position_height = 0f;
			if (!under_forces)
			{
				stopForce();
			}
		}
	}

	private void stopForce()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		position_height = 0f;
		velocity = Vector3.zero;
		under_forces = false;
		batch.c_action_landed.Add(this);
	}

	internal virtual void actionLanded()
	{
		batch.c_action_landed.Remove(this);
		dirty_current_tile = true;
		callbacks_landed?.Invoke(this);
		if (_action_wait_after_land)
		{
			_action_wait_after_land = false;
			makeWait(_action_wait_after_land_timer);
		}
		checkStepActionForTile(current_tile);
	}

	public void updateShake(float pElapsed)
	{
		if (!_shake_active)
		{
			return;
		}
		_shake_timer -= pElapsed;
		if (_shake_timer <= 0f)
		{
			((Vector2)(ref shake_offset)).Set(0f, 0f);
			_shake_active = false;
			batch.c_shake.Remove(this);
			return;
		}
		if (_shake_vertical)
		{
			shake_offset.y = ((Random)(ref batch.rnd)).NextFloat(0f - _shake_volume, _shake_volume);
		}
		if (_shake_horizontal)
		{
			shake_offset.x = ((Random)(ref batch.rnd)).NextFloat(0f - _shake_volume, _shake_volume);
		}
	}

	internal void updateFlipRotation(float pElapsed)
	{
		if (!asset.can_flip)
		{
			return;
		}
		if (flip)
		{
			flip_angle += pElapsed * 600f;
			if (flip_angle > 180f)
			{
				flip_angle = 180f;
			}
		}
		else
		{
			flip_angle -= pElapsed * 600f;
			if (flip_angle < 0f)
			{
				flip_angle = 0f;
			}
		}
		target_angle.y = flip_angle;
	}

	internal bool flipAnimationActive()
	{
		if (!asset.can_flip)
		{
			return false;
		}
		if (flip)
		{
			return flip_angle != 180f;
		}
		return flip_angle != 0f;
	}

	private void updateRotations(float pElapsed)
	{
		if (rotation_cooldown > 0f)
		{
			rotation_cooldown -= pElapsed;
		}
		else if (is_unconscious)
		{
			updateRotationFall(pElapsed);
		}
		else
		{
			updateRotationBack(pElapsed);
		}
	}

	private void updateRotationFall(float pElapsed)
	{
		if (getTextureAsset().prevent_unconscious_rotation)
		{
			return;
		}
		if (current_tile.is_liquid && _is_in_liquid)
		{
			target_angle.z = 0f;
			return;
		}
		if (_rotation_direction == RotationDirection.Left && target_angle.z != -90f)
		{
			target_angle.z -= 230f * pElapsed;
			if (target_angle.z < -90f)
			{
				target_angle.z = -90f;
			}
		}
		if (_rotation_direction == RotationDirection.Right && target_angle.z != 90f)
		{
			target_angle.z += 300f * pElapsed;
			if (target_angle.z > 90f)
			{
				target_angle.z = 90f;
			}
		}
	}

	private void updateRotationBack(float pElapsed)
	{
		if (target_angle.z == 0f)
		{
			return;
		}
		if (target_angle.z < 0f)
		{
			target_angle.z += 300f * pElapsed;
			if (target_angle.z > 0f)
			{
				target_angle.z = 0f;
			}
		}
		if (target_angle.z > 0f)
		{
			target_angle.z -= 300f * pElapsed;
			if (target_angle.z < 0f)
			{
				target_angle.z = 0f;
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vector3 updateRotation()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (current_rotation.y == target_angle.y && current_rotation.z == target_angle.z)
		{
			return current_rotation;
		}
		((Vector3)(ref current_rotation)).Set(target_angle.x, target_angle.y, target_angle.z);
		return current_rotation;
	}

	internal void updateDeadBlackAnimation(float pElapsed)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		if (_death_timer_color_stage_1 > 0f)
		{
			_death_timer_color_stage_1 -= pElapsed;
			if (_death_timer_color_stage_1 <= 0f)
			{
				_death_timer_color_stage_1 = 0f;
			}
		}
		if (_death_timer_color_stage_1 > 0f)
		{
			Color val = default(Color);
			((Color)(ref val))._002Ector(_death_timer_color_stage_1, _death_timer_color_stage_1, _death_timer_color_stage_1, 1f);
			color = val;
		}
		else if (_death_timer_alpha_stage_2 > 0f)
		{
			_death_timer_alpha_stage_2 -= 1f * pElapsed;
			if (_death_timer_alpha_stage_2 <= 0f)
			{
				die(pDestroy: true, AttackType.None, pCountDeath: false);
				return;
			}
			Color val2 = default(Color);
			((Color)(ref val2))._002Ector(_death_timer_color_stage_1, _death_timer_color_stage_1, _death_timer_color_stage_1, _death_timer_alpha_stage_2);
			color = val2;
		}
	}

	internal virtual void spawnOn(WorldTile pTile, float pZHeight = 0f)
	{
		setCurrentTilePosition(pTile);
		position_height = pZHeight;
		hitbox_bonus_height = asset.default_height;
	}

	public string getName()
	{
		if (string.IsNullOrEmpty(data.name))
		{
			generateNewName();
			AchievementLibrary.child_named_toto.checkBySignal(data.name);
		}
		return data.name;
	}

	public string generateName(MetaType pType, long pSeed, ActorSex pSex = ActorSex.None)
	{
		return NameGenerator.generateName(this, pType, pSeed + World.world.map_stats.life_dna, pSex);
	}

	private void generateNewName()
	{
		ActorSex pSex = (isSapient() ? data.sex : ActorSex.None);
		long iD = getID();
		long pSeed = World.world.map_stats.life_dna + iD * 543;
		string pName = NameGenerator.generateName(this, MetaType.Unit, pSeed, pSex);
		setName(pName);
		data.name_culture_id = culture?.id ?? (-1);
	}

	public override void trackName(bool pPostChange = false)
	{
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
		{
			ActorData actorData = data;
			if (actorData.past_names == null)
			{
				actorData.past_names = new List<NameEntry>();
			}
			if (data.past_names.Count == 0)
			{
				NameEntry item = new NameEntry(data.name, pCustom: false, data.created_time);
				data.past_names.Add(item);
			}
			else if (!(data.past_names.Last().name == data.name))
			{
				NameEntry item2 = new NameEntry(data.name, data.custom_name);
				data.past_names.Add(item2);
			}
		}
	}

	public void setHomeBuilding(Building pBuilding)
	{
		if (_home_building != null)
		{
			clearHomeBuilding();
		}
		_home_building = pBuilding;
		_home_building.residents.Add(data.id);
		World.world.buildings.event_houses = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasHomeBuilding()
	{
		return getHomeBuilding() != null;
	}

	public Building getHomeBuilding()
	{
		checkHomeBuilding();
		return _home_building;
	}

	public void checkHomeBuilding()
	{
		if (_home_building != null)
		{
			if (!_home_building.isUsable() || _home_building.isAbandoned())
			{
				clearHomeBuilding();
				changeHappiness("just_lost_house");
			}
			else if (_home_building.asset.city_building && _home_building.city != city)
			{
				clearHomeBuilding();
				changeHappiness("just_lost_house");
			}
		}
	}

	public void cloneTopicSprite(Sprite pSprite)
	{
		_last_topic_sprite = pSprite;
	}

	public void clearLastTopicSprite()
	{
		_last_topic_sprite = null;
	}

	public Sprite getTopicSpriteTrait()
	{
		if (traits.Count == 0)
		{
			return null;
		}
		return traits.GetRandom().getSprite();
	}

	public Sprite getSocializeTopic()
	{
		if ((Object)(object)_last_topic_sprite == (Object)null)
		{
			_last_topic_sprite = AssetManager.communication_topic_library.getTopicSprite(this);
		}
		return _last_topic_sprite;
	}

	public void forceSocializeTopic(string pPath)
	{
		_last_topic_sprite = SpriteTextureLoader.getSprite(pPath);
		is_forced_socialize_timestamp = World.world.getCurWorldTime();
	}

	public void clearHomeBuilding()
	{
		_home_building = null;
		World.world.buildings.event_houses = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override void setAlive(bool pValue)
	{
		_alive = pValue;
		if (!pValue && data.died_time == 0.0)
		{
			data.died_time = World.world.getCurWorldTime();
		}
		if (!pValue)
		{
			World.world.units.somethingChanged();
		}
	}

	internal bool isProfession(UnitProfession pType)
	{
		return _profession == pType;
	}

	public bool isAnimal()
	{
		if (isSapient())
		{
			return false;
		}
		if (asset.unit_other)
		{
			return false;
		}
		return asset.default_animal;
	}

	public bool isNomad()
	{
		return !isKingdomCiv();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isSapient()
	{
		if (hasSubspecies())
		{
			return subspecies.isSapient();
		}
		return false;
	}

	public bool isPrettyOld()
	{
		int num = getAge();
		if (num <= 1)
		{
			return false;
		}
		if ((float)num < subspecies.age_adult)
		{
			return false;
		}
		return getAgeRatio() > 0.7f;
	}

	public bool isBaby()
	{
		return _state_baby;
	}

	public bool isAdult()
	{
		return _state_adult;
	}

	public bool isBreedingAge()
	{
		if (!hasSubspecies())
		{
			return false;
		}
		return (float)getAge() >= subspecies.age_breeding;
	}

	public bool isEgg()
	{
		return _state_egg;
	}

	public int getAge()
	{
		return data.getAge();
	}

	public string getBirthday()
	{
		return Date.getDate(data.created_time);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isKing()
	{
		if (!hasKingdom())
		{
			return false;
		}
		return kingdom.king == this;
	}

	public float getMaturationTimeSeconds()
	{
		return getMaturationTimeMonths() * 5f;
	}

	public float getMaturationTimeMonths()
	{
		float num = 0f;
		if (hasSubspecies())
		{
			num += subspecies.getMaturationTimeMonths();
		}
		return num;
	}

	public bool isFavorite()
	{
		return data.favorite;
	}

	public void switchFavorite()
	{
		data.favorite = !data.favorite;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override City getCity()
	{
		return city;
	}

	public bool canBuildNewCity()
	{
		if (base.current_zone.hasCity())
		{
			return false;
		}
		if (hasCity())
		{
			return false;
		}
		if (!base.current_zone.isGoodForNewCity(this))
		{
			return false;
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isCityLeader()
	{
		if (!hasCity())
		{
			return false;
		}
		return city.leader == this;
	}

	public override bool hasDied()
	{
		return data.died_time > 0.0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isPollinator()
	{
		return subspecies?.has_trait_pollinating ?? false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isAffectedByLiquid()
	{
		if (isInAir())
		{
			return false;
		}
		return _is_in_liquid;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal override bool isInAir()
	{
		if (!_flying && !isHovering())
		{
			return isInMagnet();
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal override bool isFlying()
	{
		return _flying;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool ignoresBlocks()
	{
		if (!asset.ignore_blocks && !isFlying())
		{
			return isInMagnet();
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isInMagnet()
	{
		return is_in_magnet;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isHovering()
	{
		return subspecies?.has_trait_hovering ?? false;
	}

	public ActorAsset getActorAsset()
	{
		return asset;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public IReadOnlyCollection<ActorTrait> getTraits()
	{
		return traits;
	}

	public bool isWaterCreature()
	{
		if (!asset.force_ocean_creature)
		{
			return subspecies?.has_trait_water_creature ?? false;
		}
		return true;
	}

	public bool mustAvoidGround()
	{
		if (isWaterCreature())
		{
			return !asset.force_land_creature;
		}
		return false;
	}

	public bool isInStablePlace()
	{
		if (mustAvoidGround())
		{
			if (current_tile.Type.ground)
			{
				return false;
			}
		}
		else
		{
			if (current_tile.Type.ocean && !isWaterCreature())
			{
				return false;
			}
			if (current_tile.Type.lava && asset.die_in_lava)
			{
				return false;
			}
		}
		return true;
	}

	internal bool hasWeapon()
	{
		if (canUseItems())
		{
			return !equipment.weapon.isEmpty();
		}
		return false;
	}

	internal Item getWeapon()
	{
		if (hasWeapon())
		{
			return equipment.weapon.getItem();
		}
		return null;
	}

	internal EquipmentAsset getWeaponAsset()
	{
		if (hasWeapon())
		{
			return equipment.weapon.getItem().getAsset();
		}
		return AssetManager.items.get(asset.default_attack);
	}

	public bool isWeaponFirearm()
	{
		return getWeapon()?.getAsset().group_id == "firearm";
	}

	public bool isArmyGroupLeader()
	{
		if (hasArmy())
		{
			return army.getCaptain() == this;
		}
		return false;
	}

	public bool isArmyGroupWarrior()
	{
		if (hasArmy())
		{
			return army.getCaptain() != this;
		}
		return false;
	}

	public bool hasTraits()
	{
		return traits.Count > 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isSexMale()
	{
		return data.sex == ActorSex.Male;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isSexFemale()
	{
		return data.sex == ActorSex.Female;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasEquipment()
	{
		return equipment != null;
	}

	public bool hasHouse()
	{
		return getHomeBuilding() != null;
	}

	public bool hasLover()
	{
		return lover != null;
	}

	public bool hasBestFriend()
	{
		return getBestFriend() != null;
	}

	public Actor getBestFriend()
	{
		if (data.best_friend_id.hasValue())
		{
			return World.world.units.get(data.best_friend_id);
		}
		return null;
	}

	public bool isChildOf(Actor pActor)
	{
		return isChildOf(pActor.data.id);
	}

	public bool isChildOf(long pID)
	{
		if (data.parent_id_1 == pID)
		{
			return true;
		}
		if (data.parent_id_2 == pID)
		{
			return true;
		}
		return false;
	}

	public bool isParentOf(long pID, Actor pActor)
	{
		if (pID == pActor.data.parent_id_1)
		{
			return true;
		}
		if (pID == pActor.data.parent_id_2)
		{
			return true;
		}
		return false;
	}

	public bool isParentOf(Actor pActor)
	{
		return isParentOf(data.id, pActor);
	}

	public IEnumerable<Actor> getParents()
	{
		Actor actor = World.world.units.get(data.parent_id_1);
		if (actor != null && actor.isAlive())
		{
			yield return actor;
		}
		Actor actor2 = World.world.units.get(data.parent_id_2);
		if (actor2 != null && actor2.isAlive())
		{
			yield return actor2;
		}
	}

	public IEnumerable<Actor> getChildren(bool pOnlyCurrentFamily = true)
	{
		if (pOnlyCurrentFamily)
		{
			if (!hasFamily())
			{
				yield break;
			}
			Family family = this.family;
			foreach (Actor unit in family.units)
			{
				if (unit != this && unit.isChildOf(this))
				{
					yield return unit;
				}
			}
			yield break;
		}
		int tCurrentLivingChildren = current_children_count;
		if (tCurrentLivingChildren == 0)
		{
			yield break;
		}
		long tParentID = data.id;
		if (!hasSubspecies() || subspecies.isRekt())
		{
			yield break;
		}
		foreach (Actor unit2 in subspecies.units)
		{
			if (!unit2.isRekt() && unit2 != this && unit2.isChildOf(tParentID))
			{
				tCurrentLivingChildren--;
				yield return unit2;
				if (tCurrentLivingChildren == 0)
				{
					break;
				}
			}
		}
	}

	public bool hasSuitableBookTraits()
	{
		foreach (ActorTrait trait in getTraits())
		{
			if (trait.group_id == "mind")
			{
				return true;
			}
		}
		return false;
	}

	public bool canBeSurprised(WorldTile pFromTile = null)
	{
		if (!_has_emotions)
		{
			return false;
		}
		if (!asset.can_be_surprised)
		{
			return false;
		}
		if (isFighting())
		{
			return false;
		}
		if (isInsideSomething())
		{
			return false;
		}
		if (is_unconscious)
		{
			return false;
		}
		if (isEgg())
		{
			return false;
		}
		if (hasTask() && ai.task.ignore_fight_check)
		{
			return false;
		}
		return true;
	}

	public bool isTileOnTheLeft(WorldTile pTile)
	{
		return current_tile.x > pTile.x;
	}

	public bool isFighting()
	{
		if (has_attack_target)
		{
			return true;
		}
		return false;
	}

	public UnitProfession getProfession()
	{
		return _profession;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getNutrition()
	{
		return data.nutrition;
	}

	public bool isHungry()
	{
		if (!needsFood())
		{
			return false;
		}
		return getNutritionRatio() <= SimGlobals.m.nutrition_level_hungry;
	}

	public float getNutritionRatio()
	{
		float num = getNutrition();
		float num2 = getMaxNutrition();
		return num / num2;
	}

	public float getHealthRatio()
	{
		float num = getHealth();
		float num2 = getMaxHealth();
		return num / num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasMaxHealth()
	{
		return getHealth() >= getMaxHealth();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasMaxMana()
	{
		return getMana() >= getMaxMana();
	}

	public bool isStarving()
	{
		return getNutrition() == 0;
	}

	public bool hasFavoriteFood()
	{
		return !string.IsNullOrEmpty(data.favorite_food);
	}

	public bool hasEmotions()
	{
		return _has_emotions;
	}

	public bool canHavePrejudice()
	{
		return hasEmotions();
	}

	public bool hasHappinessHistory()
	{
		return _last_happiness_history.Count > 0;
	}

	public bool isUnhappy()
	{
		if (!hasEmotions())
		{
			return false;
		}
		return getHappinessRatio() < 0.3f;
	}

	public int getHappiness()
	{
		return data.happiness;
	}

	public bool isHappy()
	{
		if (!hasEmotions())
		{
			return true;
		}
		return getHappinessRatio() >= 0.6f;
	}

	public int getMinHappiness()
	{
		return -100;
	}

	public int getMaxHappiness()
	{
		return 100;
	}

	public float getHappinessRatio()
	{
		return ((float)getHappiness() + 100f) / 200f;
	}

	internal bool isSameSpecies(string pID)
	{
		return asset.id == pID;
	}

	internal bool isSameSpecies(Actor pActor)
	{
		return isSameSpecies(pActor.asset.id);
	}

	internal bool isSameSubspecies(Subspecies pSubspecies)
	{
		return subspecies == pSubspecies;
	}

	public bool isAllowedToLookForEnemies()
	{
		if (shouldSkipFightCheck())
		{
			return false;
		}
		if (hasTask() && ai.task.ignore_fight_check)
		{
			return false;
		}
		if (_has_trait_peaceful)
		{
			return false;
		}
		if (isInsideSomething())
		{
			return false;
		}
		if (kingdom.asset.units_always_looking_for_enemies)
		{
			return true;
		}
		if (isBaby())
		{
			return false;
		}
		return true;
	}

	private bool shouldSkipFightCheck()
	{
		if (asset.skip_fight_logic)
		{
			return true;
		}
		if (_ignore_fights)
		{
			return true;
		}
		if (asset.is_boat && getSimpleComponent<Boat>().hasPassengers())
		{
			return true;
		}
		return false;
	}

	public bool isInWaterAndCantAttack()
	{
		if (!isWaterCreature())
		{
			return isAffectedByLiquid();
		}
		return false;
	}

	public bool hasReachedOffspringLimit()
	{
		int maxOffspring = getMaxOffspring();
		if (current_children_count >= maxOffspring)
		{
			return true;
		}
		return false;
	}

	public int getMaxOffspring()
	{
		return (int)Math.Ceiling(stats["offspring"]);
	}

	public bool haveNutritionForNewBaby()
	{
		if (needsFood() && getNutrition() < SimGlobals.m.nutrition_cost_new_baby)
		{
			return false;
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isInsideSomething()
	{
		if (is_inside_building || is_inside_boat)
		{
			return true;
		}
		return false;
	}

	public bool isOnSameIsland(Actor pActor)
	{
		return current_tile.isSameIsland(pActor.current_tile);
	}

	public bool hasSameCity(Actor pActorTarget)
	{
		if (hasCity())
		{
			return city == pActorTarget.city;
		}
		return false;
	}

	public bool canBreed()
	{
		if (!isAlive())
		{
			return false;
		}
		if (!isBreedingAge())
		{
			return false;
		}
		if (!haveNutritionForNewBaby())
		{
			return false;
		}
		if (hasStatus("pregnant"))
		{
			return false;
		}
		if (hasStatus("afterglow"))
		{
			return false;
		}
		return true;
	}

	public bool canProduceBabies()
	{
		if (hasTrait("infertile"))
		{
			return false;
		}
		return true;
	}

	public bool isPlacePrivateForBreeding()
	{
		int num = Toolbox.countUnitsInChunk(current_tile);
		if (hasCity())
		{
			int num2 = city.getPopulationMaximum() * 2 + 10;
			return city.countUnits() < num2;
		}
		return asset.animal_breeding_close_units_limit > num;
	}

	public bool isOnGround()
	{
		if (!is_immovable && !is_unconscious)
		{
			if (hasTask())
			{
				return ai.action?.land_if_hovering ?? false;
			}
			return false;
		}
		return true;
	}

	internal bool isInAttackRange(BaseSimObject pObject)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		float num = getAttackRange() + pObject.stats["size"];
		num *= num;
		return Toolbox.SquaredDistVec2Float(current_position, pObject.current_position) < num;
	}

	internal bool isAttackReady()
	{
		if (attack_timer > 0f)
		{
			return false;
		}
		return true;
	}

	public float getAttackCooldownRatio()
	{
		float attackCooldown = getAttackCooldown();
		if (attackCooldown == 0f)
		{
			return 1f;
		}
		return attack_timer / attackCooldown;
	}

	internal bool isAttackPossible()
	{
		if (!isAttackReady())
		{
			return false;
		}
		if (current_rotation.z != 0f)
		{
			return false;
		}
		return true;
	}

	public bool canUseSpells()
	{
		if (hasStatus("spell_silence"))
		{
			return false;
		}
		if (hasSpellCastCooldownStatus())
		{
			return false;
		}
		return true;
	}

	public bool hasSpells()
	{
		if (_spells.hasAny())
		{
			return true;
		}
		if (hasSubspecies() && subspecies.spells.hasAny())
		{
			return true;
		}
		if (canUseReligionSpells() && religion.spells.hasAny())
		{
			return true;
		}
		return asset.hasDefaultSpells();
	}

	public bool canUseReligionSpells()
	{
		if (!hasReligion())
		{
			return false;
		}
		if (!religion.spells.hasAny())
		{
			return false;
		}
		if (hasTrait("mute"))
		{
			return false;
		}
		if (hasClan())
		{
			if (clan.hasTrait("void_ban"))
			{
				return false;
			}
			return true;
		}
		if (religion.is_magic_only_clan_members)
		{
			return false;
		}
		return true;
	}

	public SpellAsset getRandomSpell()
	{
		using ListPool<SpellAsset> listPool = new ListPool<SpellAsset>();
		if (_spells.hasAny())
		{
			listPool.Add(_spells.getRandomSpell());
		}
		if (hasSubspecies() && subspecies.spells.hasAny())
		{
			listPool.Add(subspecies.spells.getRandomSpell());
		}
		if (canUseReligionSpells())
		{
			listPool.Add(religion.spells.getRandomSpell());
		}
		if (asset.hasDefaultSpells())
		{
			listPool.Add(asset.spells.getRandomSpell());
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	internal override float getHeight()
	{
		return position_height + hitbox_bonus_height;
	}

	public float getScaleMod()
	{
		return actor_scale / 0.1f;
	}

	public bool isCameraFollowingUnit()
	{
		return MoveCamera.isCameraFollowingUnit(this);
	}

	internal bool isTargetOkToAttack(Actor pTarget)
	{
		if (pTarget == this)
		{
			return false;
		}
		if (!canAttackTarget(pTarget))
		{
			return false;
		}
		if (!isSameIslandAs(pTarget))
		{
			return false;
		}
		return true;
	}

	private float getLastColorEffectTime()
	{
		return World.world.getRealTimeElapsedSince(_last_color_effect_timestamp);
	}

	private float getLastStaminaReduceTime()
	{
		return World.world.getRealTimeElapsedSince(_last_stamina_reduce_timestamp);
	}

	public bool isUnderDamageCooldown()
	{
		return getLastColorEffectTime() < 0.3f;
	}

	private bool isUnderStaminaCooldown()
	{
		return getLastStaminaReduceTime() < 0.3f;
	}

	private bool haveMetallicArmor()
	{
		return false;
	}

	private bool haveMetallicWeapon()
	{
		if (!hasEquipment())
		{
			return false;
		}
		if (equipment.getSlot(EquipmentType.Weapon).isEmpty())
		{
			return false;
		}
		return equipment.getSlot(EquipmentType.Weapon).getItem().getAsset()
			.metallic;
	}

	public bool isSameKingdomAndAlmostDead(Actor pActor, float pDamage)
	{
		if (isSameKingdom(pActor) && (float)getHealth() - pDamage <= 0f)
		{
			return true;
		}
		return false;
	}

	public bool isSameKingdom(BaseSimObject pSimObject)
	{
		return kingdom == pSimObject.kingdom;
	}

	public bool isInCityIsland()
	{
		if (city.isRekt())
		{
			return false;
		}
		WorldTile tile = city.getTile();
		if (tile == null)
		{
			return false;
		}
		if (current_tile.isSameIsland(tile))
		{
			return true;
		}
		return false;
	}

	public bool isClone()
	{
		return _has_trait_clone;
	}

	public bool isClonedFrom(Actor pActor)
	{
		if (!isClone())
		{
			return false;
		}
		if (data.parent_id_1 != pActor.data.id)
		{
			return false;
		}
		return true;
	}

	public bool isSameClones(Actor pActor)
	{
		if (!isClone())
		{
			return false;
		}
		if (!pActor.isClone())
		{
			return false;
		}
		if (data.parent_id_1 != pActor.data.parent_id_1)
		{
			return false;
		}
		return true;
	}

	public bool isUnitFitToRule()
	{
		if (!isAlive())
		{
			return false;
		}
		if (!isKingdomCiv())
		{
			return false;
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Actor pObject)
	{
		return GetHashCode() == pObject.GetHashCode();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int CompareTo(Actor pTarget)
	{
		return GetHashCode().CompareTo(pTarget.GetHashCode());
	}

	public bool canTalkWith(Actor pTarget)
	{
		if (this == pTarget)
		{
			return false;
		}
		if (!pTarget.isReadyToTalk())
		{
			return false;
		}
		if (!isSameIslandAs(pTarget))
		{
			return false;
		}
		if (areFoes(pTarget))
		{
			return false;
		}
		if (isInsideSomething())
		{
			return false;
		}
		if (pTarget.asset.special)
		{
			return false;
		}
		return true;
	}

	public bool canFallInLoveWith(Actor pTarget)
	{
		if (hasLover())
		{
			return false;
		}
		if (!isAdult())
		{
			return false;
		}
		if (!isBreedingAge())
		{
			return false;
		}
		if (!subspecies.needs_mate)
		{
			return false;
		}
		if (!pTarget.subspecies.needs_mate)
		{
			return false;
		}
		if (!isSameSpecies(pTarget))
		{
			return false;
		}
		if (!subspecies.isPartnerSuitableForReproduction(this, pTarget))
		{
			return false;
		}
		if (pTarget.hasLover())
		{
			return false;
		}
		if (!pTarget.isAdult())
		{
			return false;
		}
		if (!pTarget.isBreedingAge())
		{
			return false;
		}
		if (isRelatedTo(pTarget))
		{
			return false;
		}
		return true;
	}

	public bool hasHouseCityInBordersAndSameIsland()
	{
		if (hasCity() && hasHouse() && inOwnCityBorders() && inOwnHouseIsland())
		{
			return true;
		}
		return false;
	}

	public bool inOwnHouseIsland()
	{
		Building homeBuilding = getHomeBuilding();
		if (homeBuilding.isRekt())
		{
			return false;
		}
		return current_tile.isSameIsland(homeBuilding.current_tile);
	}

	public bool inOwnCityBorders()
	{
		if (!hasCity())
		{
			return false;
		}
		return base.current_zone.isSameCityHere(city);
	}

	public bool inOwnCityIsland()
	{
		if (!hasCity())
		{
			return false;
		}
		WorldTile tile = city.getTile();
		if (tile == null)
		{
			return false;
		}
		return current_tile.isSameIsland(tile);
	}

	public bool isReadyToTalk()
	{
		if (!isAlive())
		{
			return false;
		}
		if (!canSocialize())
		{
			return false;
		}
		if (hasTask() && !ai.task.cancellable_by_socialize)
		{
			return false;
		}
		return true;
	}

	public bool canSocialize()
	{
		if (asset.unit_zombie)
		{
			return false;
		}
		if (isEgg())
		{
			return false;
		}
		if (isFighting())
		{
			return false;
		}
		if (hasStatus("recovery_social"))
		{
			return false;
		}
		if (!hasSubspecies())
		{
			return false;
		}
		return true;
	}

	public int getConstructionSpeed()
	{
		int num = 2;
		if (hasSubspecies())
		{
			num += (int)subspecies.base_stats_meta["construction_speed"];
		}
		return num;
	}

	private bool combatActionOnTimeout()
	{
		return hasStatus("recovery_combat_action");
	}

	private bool hasSpellCastCooldownStatus()
	{
		return hasStatus("recovery_spell");
	}

	public bool hasEnoughMana(int pCostMana)
	{
		if (pCostMana != 0)
		{
			return getMana() >= pCostMana;
		}
		return true;
	}

	public int getMana()
	{
		return data.mana;
	}

	public int getMaxMana()
	{
		return (int)stats["mana"];
	}

	public void setMaxMana()
	{
		setMana(getMaxMana());
	}

	public bool isManaFull()
	{
		return getMana() == getMaxMana();
	}

	public bool hasEnoughStamina(int pCostStamina)
	{
		if (pCostStamina != 0)
		{
			return getStamina() >= pCostStamina;
		}
		return true;
	}

	public int getStamina()
	{
		return data.stamina;
	}

	public int getMaxStamina()
	{
		return (int)stats["stamina"];
	}

	public void setMaxStamina()
	{
		setStamina(getMaxStamina());
	}

	public bool isStaminaFull()
	{
		return getStamina() == getMaxStamina();
	}

	public bool isWarrior()
	{
		return profession_asset.profession_id == UnitProfession.Warrior;
	}

	public bool isCarnivore()
	{
		if (hasSubspecies() && subspecies.diet_meat)
		{
			return true;
		}
		return false;
	}

	public bool isHerbivore()
	{
		if (hasSubspecies() && subspecies.diet_vegetation)
		{
			return true;
		}
		return false;
	}

	public bool hasStatusStunned()
	{
		return hasStatus("stunned");
	}

	public bool isLying()
	{
		if (!is_unconscious)
		{
			return _has_status_sleeping;
		}
		return true;
	}

	public override bool hasStatusTantrum()
	{
		return _has_status_tantrum;
	}

	public bool hasAnyCash()
	{
		if (money <= 0)
		{
			return loot > 0;
		}
		return true;
	}

	public bool hasEnoughMoney(int pCost)
	{
		return money >= pCost;
	}

	public int getHappinessPercent()
	{
		int maxHappiness = getMaxHappiness();
		int minHappiness = getMinHappiness();
		return Mathf.Clamp(Mathf.Clamp(getHappiness() - minHappiness, 0, maxHappiness - minHappiness) * 100 / (maxHappiness - minHappiness), 0, 100);
	}

	public float distanceToObjectTarget(BaseSimObject pBaseSimObject)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Toolbox.DistVec2Float(current_position, pBaseSimObject.current_position);
	}

	public float distanceToActorTile(Actor pActor)
	{
		return distanceToActorTile(pActor.current_tile);
	}

	public float distanceToActorTile(WorldTile pTile)
	{
		return current_tile.distanceTo(pTile);
	}

	public bool isRelatedTo(Actor pTarget)
	{
		if (hasFamily() && pTarget.hasFamily() && isSapient() && family == pTarget.family)
		{
			return true;
		}
		if (isChildOf(pTarget))
		{
			return true;
		}
		if (isParentOf(pTarget))
		{
			return true;
		}
		return false;
	}

	public bool isImportantTo(Actor pTarget)
	{
		if (hasLover() && lover == pTarget)
		{
			return true;
		}
		if (hasBestFriend() && getBestFriend() == pTarget)
		{
			return true;
		}
		return false;
	}

	public bool canWork()
	{
		if (isAdult())
		{
			return true;
		}
		if (hasCulture())
		{
			Culture culture = this.culture;
			if (culture.hasTrait("tiny_legends"))
			{
				return true;
			}
			if (culture.hasTrait("youth_reverence"))
			{
				return false;
			}
		}
		if (getAge() >= SimGlobals.m.child_work_age)
		{
			return true;
		}
		return false;
	}

	public bool hasCultureTrait(string pTraitID)
	{
		if (hasCulture())
		{
			return culture.hasTrait(pTraitID);
		}
		return false;
	}

	public bool canBePossessed()
	{
		return asset.allow_possession;
	}

	public float getAttackRange()
	{
		return stats["range"];
	}

	public float getAttackRangeSquared()
	{
		return stats["range"] * stats["range"];
	}

	public float getStaminaRatio()
	{
		float num = getMaxStamina();
		if (num == 0f)
		{
			return 0f;
		}
		return (float)getStamina() / num;
	}

	public float getManaRatio()
	{
		float num = getMaxMana();
		if (num == 0f)
		{
			return 0f;
		}
		return (float)getMana() / num;
	}

	public bool canGetFoodFromCity()
	{
		if (isFoodFreeForThisPerson())
		{
			return true;
		}
		if (money <= SimGlobals.m.min_coins_before_city_food)
		{
			return false;
		}
		return true;
	}

	public bool isFoodFreeForThisPerson()
	{
		if (isKing())
		{
			return true;
		}
		if (isCityLeader())
		{
			return true;
		}
		if (isBaby())
		{
			return true;
		}
		if (isStarving())
		{
			return true;
		}
		return false;
	}

	public int getMaxNutrition()
	{
		float num = asset.nutrition_max;
		if (hasSubspecies())
		{
			num += subspecies.base_stats_meta["max_nutrition"];
		}
		return (int)num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getExpToLevelup()
	{
		return 100 + (data.level - 1) * 20;
	}

	private bool calculateIsSick()
	{
		if (hasTrait("infected"))
		{
			return true;
		}
		if (hasTrait("plague"))
		{
			return true;
		}
		if (hasTrait("mush_spores") && asset.can_turn_into_mush)
		{
			return true;
		}
		if (hasTrait("tumor_infection") && asset.can_turn_into_tumor)
		{
			return true;
		}
		return false;
	}

	public bool isSick()
	{
		return _has_any_sick_trait;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool canTakeItems()
	{
		return asset.take_items;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool understandsHowToUseItems()
	{
		if (!canUseItems())
		{
			return false;
		}
		if (isSapient())
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool canUseItems()
	{
		return asset.use_items;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool canEditEquipment()
	{
		return asset.use_items;
	}

	public bool canTurnIntoColdOne()
	{
		if (isAdult())
		{
			return false;
		}
		if (!asset.can_turn_into_ice_one)
		{
			return false;
		}
		if (!asset.has_soul)
		{
			return false;
		}
		return true;
	}

	public bool canTurnIntoDemon()
	{
		if (isBaby())
		{
			return false;
		}
		return asset.can_turn_into_demon_in_age_of_chaos;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override BaseObjectData getData()
	{
		return data;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isCarryingResources()
	{
		return inventory.hasResources();
	}

	public bool needsFood()
	{
		if (hasSubspecies())
		{
			return subspecies.needs_food;
		}
		return false;
	}

	public bool isDamagedByRain()
	{
		if (hasSubspecies())
		{
			return subspecies.is_damaged_by_water;
		}
		return false;
	}

	public bool isDamagedByOcean()
	{
		if (hasSubspecies())
		{
			return subspecies.is_damaged_by_water;
		}
		return asset.damaged_by_ocean;
	}

	public int getWaterDamage()
	{
		int num = (int)((float)getMaxHealth() * SimGlobals.m.water_damage_multiplier);
		if (num < 1)
		{
			num = 1;
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasSubspeciesTrait(string pTraitID)
	{
		if (hasSubspecies())
		{
			return subspecies.hasTrait(pTraitID);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasSubspeciesMetaTag(string pTagID)
	{
		if (hasSubspecies())
		{
			return subspecies.hasMetaTag(pTagID);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasTag(string pTag)
	{
		return stats.hasTag(pTag);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isImmuneToFire()
	{
		return hasTag("immunity_fire");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isImmuneToCold()
	{
		return hasTag("immunity_cold");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isImmovable()
	{
		return hasTag("immovable");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isAiFrozen()
	{
		return hasTag("frozen_ai");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isIgnoreFights()
	{
		return hasTag("ignore_fights");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasStopIdleAnimation()
	{
		if (hasSubspecies() && subspecies.hasMetaTag("always_idle_animation"))
		{
			return false;
		}
		return hasTag("stop_idle_animation");
	}

	public bool hasDivineScar()
	{
		return hasTrait("scar_of_divinity");
	}

	public bool hasTelepathicLink()
	{
		if (!hasSubspecies())
		{
			return false;
		}
		return subspecies.hasTrait("telepathic_link");
	}

	public float getResourceThrowDistance()
	{
		return asset.base_throwing_range + stats["throwing_range"];
	}

	internal bool isFalling()
	{
		if (position_height != 0f)
		{
			return true;
		}
		if (move_jump_offset.y != 0f)
		{
			return true;
		}
		return false;
	}

	public float getAgeRatio()
	{
		float num = stats["lifespan"];
		return (float)getAge() / num;
	}

	public int getMassKG()
	{
		float num = target_scale / 0.1f;
		int num2 = (int)(stats["mass_2"] * num);
		if (isBaby())
		{
			num2 = (int)((float)num2 * SimGlobals.m.baby_mass_multiplier);
		}
		return num2;
	}

	public IEnumerable<ResourceContainer> getResourcesFromActor()
	{
		if (asset.resources_given == null)
		{
			yield break;
		}
		int tMass = getMassKG();
		foreach (ResourceContainer item in asset.resources_given)
		{
			ResourceAsset resourceAsset = item.asset;
			int num = tMass / resourceAsset.drop_per_mass + 1;
			int num2 = item.amount * num;
			num2 = Mathf.Clamp(num2, 1, resourceAsset.drop_max);
			if (num2 > 0)
			{
				yield return new ResourceContainer(item.id, num2);
			}
		}
	}

	public bool hasXenophobic()
	{
		if (hasCulture())
		{
			return culture.hasTrait("xenophobic");
		}
		return false;
	}

	public bool hasXenophiles()
	{
		if (hasCulture())
		{
			return culture.hasTrait("xenophiles");
		}
		return false;
	}

	public bool hasCannibalism()
	{
		if (hasSubspecies())
		{
			return subspecies.hasCannibalism();
		}
		return false;
	}

	public bool isOneCityKingdom()
	{
		if (hasCity() && city.kingdom.countCities() == 1)
		{
			return true;
		}
		return false;
	}

	public bool isImportantPerson()
	{
		if (isKing())
		{
			return true;
		}
		if (isCityLeader())
		{
			return true;
		}
		if (isArmyGroupLeader())
		{
			return true;
		}
		if (isFavorite())
		{
			return true;
		}
		return false;
	}

	public bool canCurrentTaskBeCancelledByReproduction()
	{
		if (!hasTask())
		{
			return true;
		}
		return ai.task.cancellable_by_reproduction;
	}

	public bool isAbleToSkipPriorityLevels()
	{
		if (isWarrior() && hasCity() && city.hasAttackZoneOrder())
		{
			return false;
		}
		return true;
	}

	public void makeSpawnSound(bool pFromUI)
	{
		if (asset.has_sound_spawn)
		{
			if (pFromUI)
			{
				MusicBox.playSoundUI(asset.sound_spawn);
			}
			else
			{
				MusicBox.playSound(asset.sound_spawn, current_tile);
			}
		}
	}

	public void makeSoundAttack()
	{
		if (asset.has_sound_attack)
		{
			MusicBox.playSound(asset.sound_attack, current_tile, pGameViewOnly: true, pVisibleOnly: true);
		}
	}

	public string getTaskText()
	{
		if (!hasTask())
		{
			return "???";
		}
		string localizedText = ai.task.getLocalizedText();
		string taskTime = ai.getTaskTime();
		return localizedText + " " + taskTime.ColorHex(ColorStyleLibrary.m.color_text_grey_dark);
	}

	public void afterEvolutionEvents()
	{
		clearGraphicsFully();
		makeConfused();
		applyRandomForce();
		increaseEvolutions();
	}

	public void generatePhenotypeAndShade()
	{
		data.phenotype_index = subspecies.getRandomPhenotypeIndex();
		data.phenotype_shade = getRandomPhenotypeShade();
	}

	public static int getRandomPhenotypeShade()
	{
		return Randy.randomInt(0, 4);
	}

	public bool isRendered()
	{
		return current_tile.zone.visible;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool checkHasRenderedItem()
	{
		if (!canUseItems() || _is_in_liquid)
		{
			return false;
		}
		if (isEgg())
		{
			return false;
		}
		if (!equipment.weapon.isEmpty())
		{
			return true;
		}
		if (hasTask() && ai.task.force_hand_tool != string.Empty)
		{
			return true;
		}
		if (isCarryingResources())
		{
			return true;
		}
		return false;
	}

	internal Sprite getSpriteToRender()
	{
		return checkSpriteToRender();
	}

	public bool hasColoredSprite()
	{
		return asset.need_colored_sprite;
	}

	public bool isColoredSpriteNeedsCheck(Sprite pMainSprite)
	{
		if ((Object)(object)_last_main_sprite != (Object)(object)pMainSprite || _last_color_asset != kingdom.getColor())
		{
			return true;
		}
		return false;
	}

	public Sprite calculateColoredSprite(Sprite pMainSprite, bool pUpdateFrameData = true)
	{
		if (isColoredSpriteNeedsCheck(pMainSprite))
		{
			if (animation_container != null && pUpdateFrameData)
			{
				animation_container.dict_frame_data.TryGetValue(((Object)pMainSprite).name, out frame_data);
			}
			checkSpriteHead();
			int phenotype_index = data.phenotype_index;
			int phenotype_shade = data.phenotype_shade;
			_last_colored_sprite = DynamicSpriteCreator.getSpriteUnit(frame_data, pMainSprite, this, kingdom.getColor(), phenotype_index, phenotype_shade, asset.texture_atlas);
			_last_main_sprite = pMainSprite;
			_last_color_asset = kingdom.getColor();
		}
		return _last_colored_sprite;
	}

	public Sprite getLastColoredSprite()
	{
		return _last_colored_sprite;
	}

	public bool canParallelSetColoredSprite()
	{
		if (asset.has_avatar_prefab)
		{
			return true;
		}
		if (dirty_sprite_main)
		{
			return false;
		}
		return true;
	}

	public Sprite calculateMainSprite()
	{
		if (asset.has_override_sprite)
		{
			return asset.get_override_sprite(this);
		}
		checkAnimationContainer();
		if (ai.action != null && ai.action.force_animation)
		{
			return animation_container.sprites[ai.action.force_animation_id];
		}
		if (!isAlive() || _has_stop_idle_animation)
		{
			if (animation_container.has_swimming && _has_status_drowning)
			{
				return animation_container.swimming.frames[0];
			}
			return animation_container.idle.frames[0];
		}
		float num = asset.animation_walk_speed;
		bool flag = false;
		ActorAnimation actorAnimation;
		if (is_moving || timer_jump_animation > 0f || move_jump_offset.y > 0f || is_in_magnet)
		{
			if (animation_container.has_swimming && isAffectedByLiquid())
			{
				actorAnimation = animation_container.swimming;
				num = asset.animation_swim_speed;
			}
			else
			{
				actorAnimation = animation_container.walking;
			}
			flag = true;
		}
		else if (position_height > 0f)
		{
			actorAnimation = animation_container.idle;
		}
		else if (animation_container.has_swimming && isAffectedByLiquid())
		{
			actorAnimation = animation_container.swimming;
			num = asset.animation_swim_speed;
			flag = true;
		}
		else
		{
			actorAnimation = animation_container.idle;
			num = asset.animation_idle_speed;
		}
		if (asset.animation_speed_based_on_walk_speed && flag)
		{
			num *= stats["speed"] / 10f;
			num = Mathf.Clamp(num, 4f, num);
		}
		if (actorAnimation.frames.Length > 1)
		{
			return AnimationHelper.getSpriteFromList(GetHashCode(), actorAnimation.frames, num);
		}
		return actorAnimation.frames[0];
	}

	internal Sprite checkSpriteToRender()
	{
		Sprite val = calculateMainSprite();
		if (!asset.need_colored_sprite)
		{
			return val;
		}
		return calculateColoredSprite(val);
	}

	protected void setItemSpriteRenderDirty()
	{
		_dirty_sprite_item = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Sprite getRenderedItemSprite()
	{
		if (_dirty_sprite_item || _has_animated_item)
		{
			_cached_hand_renderer_asset = getHandRendererAsset();
			_cached_sprite_item = ItemRendering.getItemMainSpriteFrame(_cached_hand_renderer_asset);
			_dirty_sprite_item = false;
		}
		return _cached_sprite_item;
	}

	public IHandRenderer getCachedHandRendererAsset()
	{
		return _cached_hand_renderer_asset;
	}

	public IHandRenderer getHandRendererAsset()
	{
		IHandRenderer renderedToolOrItem = getRenderedToolOrItem();
		if (renderedToolOrItem != null)
		{
			return renderedToolOrItem;
		}
		if (hasWeapon())
		{
			return getWeaponTextureId();
		}
		return null;
	}

	private IHandRenderer getRenderedToolOrItem()
	{
		if (!asset.use_tool_items)
		{
			return null;
		}
		_has_animated_item = false;
		if (has_attack_target && hasWeapon())
		{
			return null;
		}
		if (isCarryingResources())
		{
			return AssetManager.resources.get(inventory.getItemIDToRender());
		}
		if (hasTask())
		{
			UnitHandToolAsset cached_hand_tool_asset = ai.task.cached_hand_tool_asset;
			if (cached_hand_tool_asset != null)
			{
				_has_animated_item = cached_hand_tool_asset.animated;
				return cached_hand_tool_asset;
			}
		}
		return null;
	}

	public bool isItemInHandAnimated()
	{
		if (isCarryingResources())
		{
			return false;
		}
		if (hasTask())
		{
			UnitHandToolAsset cached_hand_tool_asset = ai.task.cached_hand_tool_asset;
			if (cached_hand_tool_asset != null)
			{
				return cached_hand_tool_asset.animated;
			}
		}
		if (hasWeapon())
		{
			return getWeapon().getAsset().animated;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void clearSprites()
	{
		dirty_sprite_head = true;
		dirty_sprite_main = true;
	}

	public void clearGraphicsFully()
	{
		clearSprites();
		clearLastColorCache();
		animation_container = null;
		frame_data = null;
		animation_container = null;
		_last_main_sprite = null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public AnimationFrameData getAnimationFrameData()
	{
		return frame_data;
	}

	public Vector3 getHeadOffsetPositionForFunRendering()
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		((Vector3)(ref result))._002Ector(cur_transform_position.x, cur_transform_position.y, 0f);
		AnimationFrameData animationFrameData = getAnimationFrameData();
		if (animationFrameData != null)
		{
			result.x += animationFrameData.pos_head.x * current_scale.x;
			result.y += animationFrameData.pos_head.y * current_scale.y;
		}
		return result;
	}

	public IHandRenderer getWeaponTextureId()
	{
		Item weapon = getWeapon();
		_has_animated_item = weapon.getAsset().animated;
		return weapon.asset;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ActorTextureSubAsset getTextureAsset()
	{
		if (hasSubspecies() && subspecies.has_mutation_reskin)
		{
			return subspecies.mutation_skin_asset.texture_asset;
		}
		return asset.texture_asset;
	}

	public string getUnitTexturePath()
	{
		return getTextureAsset().getUnitTexturePath(this);
	}

	internal void checkAnimationContainer()
	{
		if (dirty_sprite_main)
		{
			dirty_sprite_main = false;
			AnimationContainerUnit animationContainer = ActorAnimationLoader.getAnimationContainer(getUnitTexturePath(), asset, subspecies?.egg_asset, subspecies?.mutation_skin_asset);
			animation_container = animationContainer;
		}
	}

	public SpriteAnimation getSpriteAnimation()
	{
		return sprite_animation;
	}

	public Vector2 getRenderedItemPosition()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return getAnimationFrameData()?.pos_item ?? Vector2.one;
	}

	public void clearLastColorCache()
	{
		_last_colored_sprite = null;
		_last_color_asset = null;
		cached_sprite_head = null;
	}

	public void startColorEffect(ActorColorEffect pColorType = ActorColorEffect.White)
	{
		if (!asset.effect_damage || !is_visible || isUnderDamageCooldown())
		{
			return;
		}
		_last_color_effect_timestamp = World.world.getCurSessionTime();
		if (World.world.stack_effects.actor_effect_hit.Count <= 1000)
		{
			if (pColorType == ActorColorEffect.Red)
			{
				World.world.stack_effects.actor_effect_hit.Add(new ActorDamageEffectData
				{
					actor = this,
					timestamp = _last_color_effect_timestamp
				});
			}
			else
			{
				World.world.stack_effects.actor_effect_highlight.Add(new ActorHighlightEffectData
				{
					actor = this,
					timestamp = _last_color_effect_timestamp
				});
			}
		}
	}

	protected void checkSpriteHead()
	{
		if (!dirty_sprite_head)
		{
			return;
		}
		dirty_sprite_head = false;
		if (frame_data == null || !frame_data.show_head || animation_container.heads.Length == 0 || isEgg() || (isBaby() && !animation_container.render_heads_for_children))
		{
			return;
		}
		ActorTextureSubAsset textureAsset = getTextureAsset();
		if (!textureAsset.has_advanced_textures)
		{
			checkHeadID(animation_container.heads);
			setHeadSprite(animation_container.heads[data.head]);
			return;
		}
		bool flag = false;
		string pPath;
		Sprite[] pListHeads;
		if (isSexMale())
		{
			pPath = textureAsset.texture_heads_male;
			pListHeads = animation_container.heads_male;
		}
		else
		{
			pPath = textureAsset.texture_heads_female;
			pListHeads = animation_container.heads_female;
		}
		if (isSapient())
		{
			if (is_profession_warrior && !equipment.helmet.isEmpty())
			{
				pPath = textureAsset.texture_head_warrior;
				flag = true;
			}
			else if (is_profession_king)
			{
				pPath = textureAsset.texture_head_king;
				flag = true;
			}
			else if (textureAsset.has_old_heads && hasTrait("wise"))
			{
				pPath = ((!isSexMale()) ? textureAsset.texture_heads_old_female : textureAsset.texture_heads_old_male);
				flag = true;
			}
			else if (isSexMale())
			{
				pPath = textureAsset.texture_heads_male;
				pListHeads = animation_container.heads_male;
			}
			else
			{
				pPath = textureAsset.texture_heads_female;
				pListHeads = animation_container.heads_female;
			}
		}
		if (flag)
		{
			setHeadSprite(ActorAnimationLoader.getHeadSpecial(pPath));
			return;
		}
		checkHeadID(pListHeads);
		setHeadSprite(ActorAnimationLoader.getHead(pPath, data.head));
	}

	internal void checkHeadID(Sprite[] pListHeads, bool pCheckSavedHead = true)
	{
		if (pCheckSavedHead && data.head > pListHeads.Length - 1)
		{
			data.head = 0;
		}
		if (data.head == -1)
		{
			int spriteIndex = AnimationHelper.getSpriteIndex(data.id, pListHeads.Length);
			data.head = spriteIndex;
		}
	}

	private void setHeadSprite(Sprite pSprite)
	{
		cached_sprite_head = pSprite;
	}

	protected void updateDeadAnimation(float pElapsed)
	{
		if (asset.special_dead_animation && asset.action_dead_animation(this, current_tile, pElapsed))
		{
			return;
		}
		if (World.world.quality_changer.isFullLowRes())
		{
			die(pDestroy: true, AttackType.None, pCountDeath: false);
			return;
		}
		if (asset.death_animation_angle && !_has_status_drowning && target_angle.z < 90f)
		{
			target_angle.z = Mathf.Lerp(target_angle.z, 90f, pElapsed * 4f);
			if (target_angle.z > 90f)
			{
				target_angle.z = 90f;
			}
			if (is_visible && Mathf.Abs(current_rotation.z) < 45f)
			{
				return;
			}
		}
		changeMoveJumpOffset(-0.05f);
		if (!isFalling())
		{
			updateDeadBlackAnimation(pElapsed);
		}
	}

	public double[] getDecisionsCooldowns()
	{
		return _decision_cooldowns;
	}

	public bool[] getDecisionsDisabled()
	{
		return _decision_disabled;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isDecisionOnCooldown(int pIndex, double pCooldown)
	{
		double num = _decision_cooldowns[pIndex];
		if (num == 0.0)
		{
			return false;
		}
		if ((double)World.world.getWorldTimeElapsedSince(num) > pCooldown)
		{
			_decision_cooldowns[pIndex] = 0.0;
			return false;
		}
		return true;
	}

	public void setupRandomDecisionCooldowns()
	{
		double curWorldTime = World.world.getCurWorldTime();
		for (int i = 0; i < decisions_counter; i++)
		{
			DecisionAsset decisionAsset = decisions[i];
			if (decisionAsset.cooldown != 0)
			{
				double num = curWorldTime - (double)Randy.randomFloat(0f, (float)decisionAsset.cooldown * 0.5f);
				_decision_cooldowns[decisionAsset.decision_index] = num;
			}
		}
		timer_action = Randy.randomFloat(1f, 5f);
	}

	public void setDecisionCooldown(DecisionAsset pAsset)
	{
		if (pAsset.cooldown != 0)
		{
			_decision_cooldowns[pAsset.decision_index] = World.world.getCurWorldTime();
		}
	}

	public bool isDecisionEnabled(int pIndex)
	{
		return !_decision_disabled[pIndex];
	}

	public bool switchDecisionState(int pIndex)
	{
		_decision_disabled[pIndex] = !_decision_disabled[pIndex];
		return _decision_disabled[pIndex];
	}

	public void setDecisionState(int pIndex, bool pState)
	{
		_decision_disabled[pIndex] = !pState;
	}

	public void setTask(string pTaskId, bool pClean = true, bool pCleanJob = false, bool pForceAction = false)
	{
		ai.setTask(pTaskId, pClean, pCleanJob, pForceAction);
	}

	public void cancelAllBeh()
	{
		ai.clearBeh();
		ai.setTaskBehFinished();
		endJob();
		clearTasks();
	}

	public void endJob()
	{
		ai.clearJob();
		citizen_job = null;
	}

	protected virtual void clearTasks()
	{
		exitBuilding();
		clearAttackTarget();
		timer_action = 0f;
		clearTileTarget();
		stopMovement();
	}

	public void setCitizenJob(CitizenJobAsset pJobAsset)
	{
		citizen_job = pJobAsset;
		ai.setJob(pJobAsset.unit_job_default);
	}

	internal void clearBeh()
	{
		clearTasks();
		beh_tile_target = null;
		beh_building_target = null;
		beh_actor_target = null;
		beh_book_target = null;
	}

	public string getNextJob()
	{
		return nextJobActor(a);
	}

	public static string nextJobActor(Actor pActor)
	{
		if (pActor.isEgg())
		{
			return "egg";
		}
		string result = null;
		if (pActor.isSapient())
		{
			if (pActor.isBaby())
			{
				result = pActor.asset.job_baby.GetRandom();
			}
			else if (pActor.hasCity())
			{
				result = ((!pActor.isProfession(UnitProfession.Warrior)) ? pActor.asset.job_citizen.GetRandom() : pActor.asset.job_attacker.GetRandom());
			}
			else if (pActor.isKingdomCiv())
			{
				result = pActor.asset.job_kingdom.GetRandom();
			}
			else if (pActor.asset.job.Length != 0)
			{
				result = pActor.asset.job.GetRandom();
			}
		}
		else if (pActor.asset.job.Length != 0)
		{
			result = pActor.asset.job.GetRandom();
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isTask(string pID)
	{
		return ai.task?.id == pID;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasTask()
	{
		return ai.hasTask();
	}

	public void clearDecisions()
	{
		_decision_cooldowns.Clear();
		_decision_disabled.Clear();
		decisions.Clear();
		decisions_counter = 0;
		_last_decision_id = string.Empty;
	}

	public void scheduleTask(string pTask, WorldTile pTile)
	{
		ai.scheduleTask(pTask);
		scheduled_tile_target = pTile;
	}

	private void registerDecisions()
	{
		foreach (ActorTrait trait in traits)
		{
			DecisionAsset[] decisions_assets = trait.decisions_assets;
			if (decisions_assets != null)
			{
				for (int i = 0; i < decisions_assets.Length; i++)
				{
					decisions[decisions_counter++] = decisions_assets[i];
				}
			}
		}
		Clan obj = clan;
		if (obj != null && obj.decisions_assets.Count > 0)
		{
			List<DecisionAsset> decisions_assets2 = clan.decisions_assets;
			for (int j = 0; j < decisions_assets2.Count; j++)
			{
				decisions[decisions_counter++] = decisions_assets2[j];
			}
		}
		Culture obj2 = culture;
		if (obj2 != null && obj2.decisions_assets.Count > 0)
		{
			List<DecisionAsset> decisions_assets3 = culture.decisions_assets;
			for (int k = 0; k < decisions_assets3.Count; k++)
			{
				decisions[decisions_counter++] = decisions_assets3[k];
			}
		}
		Language obj3 = language;
		if (obj3 != null && obj3.decisions_assets.Count > 0)
		{
			List<DecisionAsset> decisions_assets4 = language.decisions_assets;
			for (int l = 0; l < decisions_assets4.Count; l++)
			{
				decisions[decisions_counter++] = decisions_assets4[l];
			}
		}
		Religion obj4 = religion;
		if (obj4 != null && obj4.decisions_assets.Count > 0 && canUseReligionSpells())
		{
			List<DecisionAsset> decisions_assets5 = religion.decisions_assets;
			for (int m = 0; m < decisions_assets5.Count; m++)
			{
				decisions[decisions_counter++] = decisions_assets5[m];
			}
		}
		Subspecies obj5 = subspecies;
		if (obj5 != null && obj5.decisions_assets.Count > 0)
		{
			List<DecisionAsset> decisions_assets6 = subspecies.decisions_assets;
			for (int n = 0; n < decisions_assets6.Count; n++)
			{
				decisions[decisions_counter++] = decisions_assets6[n];
			}
		}
		if (profession_asset != null && profession_asset.hasDecisions())
		{
			DecisionAsset[] decisions_assets7 = profession_asset.decisions_assets;
			for (int num = 0; num < decisions_assets7.Length; num++)
			{
				decisions[decisions_counter++] = decisions_assets7[num];
			}
		}
		if (_spells.hasAny())
		{
			foreach (SpellAsset spell in _spells.spells)
			{
				if (spell.hasDecisions())
				{
					DecisionAsset[] decisions_assets8 = spell.decisions_assets;
					for (int num2 = 0; num2 < decisions_assets8.Length; num2++)
					{
						decisions[decisions_counter++] = decisions_assets8[num2];
					}
				}
			}
		}
		if (hasWeapon() && getWeapon().getAsset().hasDecisions())
		{
			DecisionAsset[] decisions_assets9 = getWeapon().getAsset().decisions_assets;
			for (int num3 = 0; num3 < decisions_assets9.Length; num3++)
			{
				decisions[decisions_counter++] = decisions_assets9[num3];
			}
		}
		if (hasFamily())
		{
			DecisionAsset[] decisions_assets10 = MetaTypeLibrary.family.decisions_assets;
			for (int num4 = 0; num4 < decisions_assets10.Length; num4++)
			{
				decisions[decisions_counter++] = decisions_assets10[num4];
			}
		}
		if (hasCity() && !asset.is_boat)
		{
			DecisionAsset[] decisions_assets11 = MetaTypeLibrary.city.decisions_assets;
			for (int num5 = 0; num5 < decisions_assets11.Length; num5++)
			{
				decisions[decisions_counter++] = decisions_assets11[num5];
			}
		}
		if (hasPlot())
		{
			DecisionAsset[] decisions_assets12 = MetaTypeLibrary.plot.decisions_assets;
			for (int num6 = 0; num6 < decisions_assets12.Length; num6++)
			{
				decisions[decisions_counter++] = decisions_assets12[num6];
			}
		}
		if (hasClan())
		{
			DecisionAsset[] decisions_assets13 = MetaTypeLibrary.clan.decisions_assets;
			for (int num7 = 0; num7 < decisions_assets13.Length; num7++)
			{
				decisions[decisions_counter++] = decisions_assets13[num7];
			}
		}
	}

	public void debugFav()
	{
	}

	public void clearWait()
	{
		timer_action = 0f;
	}

	public void makeWait(float pValue = 10f)
	{
		stopMovement();
		timer_action = pValue;
	}

	public void stopSleeping()
	{
		finishStatusEffect("sleeping");
	}

	private void checkStepActionForTile(WorldTile pTile)
	{
		if (pTile.Type.step_action != null && Randy.randomChance(pTile.Type.step_action_chance))
		{
			pTile.Type.step_action(pTile, a);
		}
		Building building = pTile.building;
		if (building == null || !building.asset.flora)
		{
			return;
		}
		BuildingAsset buildingAsset = building.asset;
		switch (buildingAsset.flora_type)
		{
		case FloraType.Fungi:
			if (WorldLawLibrary.world_law_exploding_mushrooms.isEnabled())
			{
				MapAction.damageWorld(pTile, 5, AssetManager.terraform.get("grenade"));
				EffectsLibrary.spawnAtTileRandomScale("fx_explosion_small", pTile, 0.1f, 0.15f);
			}
			break;
		case FloraType.Plant:
			if (buildingAsset.type == "type_flower" && WorldLawLibrary.world_law_nectar_nap.isEnabled() && Randy.randomChance(0.1f))
			{
				makeSleep(10f);
				break;
			}
			if (WorldLawLibrary.world_law_plants_tickles.isEnabled() && Randy.randomChance(0.3f))
			{
				tryToGetSurprised(pTile);
			}
			if (WorldLawLibrary.world_law_root_pranks.isEnabled() && Randy.randomChance(0.2f))
			{
				makeStunned();
			}
			break;
		}
	}

	public void setLover(Actor pActor)
	{
		lover = pActor;
	}

	public void setBestFriend(Actor pActor, bool pNew)
	{
		data.best_friend_id = pActor.data.id;
		if (pNew)
		{
			changeHappiness("just_made_friend");
		}
	}

	public void becomeLoversWith(Actor pTarget)
	{
		setLover(pTarget);
		pTarget.setLover(this);
		addStatusEffect("fell_in_love", 0f, pColorEffect: false);
		pTarget.addStatusEffect("fell_in_love", 0f, pColorEffect: false);
	}

	public void resetSocialize()
	{
		data.removeInt("socialize");
		timestamp_tween_session_social = 0.0;
	}

	public void addActionWaitAfterLand(float pTimer)
	{
		_action_wait_after_land = true;
		_action_wait_after_land_timer = pTimer;
	}

	private void actionMagnetAnimation(Actor pActor)
	{
		position_height = 0f;
	}

	private bool isSurprisedJump(WorldTile pTile)
	{
		bool num = canSeeTileBasedOnDirection(pTile);
		bool result = false;
		if (!num && hasSubspecies() && subspecies.can_process_emotions && (subspecies.has_trait_timid || !hasStatus("on_guard")))
		{
			result = true;
		}
		return result;
	}

	private void checkLand(Actor pActor)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!should_check_land_cancel)
		{
			return;
		}
		should_check_land_cancel = false;
		if (has_attack_target && isEnemyTargetAlive() && _has_emotions && !hasStatusTantrum())
		{
			if (getHealthRatio() < 0.15f)
			{
				cancelAllBeh();
				setTask("run_away", pClean: true, pCleanJob: false, pForceAction: true);
				return;
			}
			if (Toolbox.DistVec2Float(current_position, attack_target.current_position) < 10f)
			{
				return;
			}
		}
		cancelAllBeh();
	}

	private void checkDeathOutsideMap(Actor pActor)
	{
		if (!inMapBorder())
		{
			getHitFullHealth(AttackType.Gravity);
		}
	}

	public void tryToGetSurprised(WorldTile pTile, bool pForceJump = false)
	{
		if (canBeSurprised(pTile))
		{
			getSurprised(pTile, pForceJump);
		}
	}

	public void getSurprised(WorldTile pTile, bool pForceJump = false)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (!_has_emotions)
		{
			return;
		}
		float num = 1f + Randy.randomFloat(0f, 2f);
		bool num2 = !hasStatus("surprised");
		bool flag = pForceJump || isSurprisedJump(pTile);
		if (num2)
		{
			addStatusEffect("surprised", num, pColorEffect: false);
			if (hasStatus("just_ate"))
			{
				poop(pApplyForce: false);
				flag = true;
			}
		}
		else
		{
			num = 0.1f;
		}
		if (flag)
		{
			addActionWaitAfterLand(num);
			applyRandomForce();
		}
		addStatusEffect("on_guard", 0f, pColorEffect: false);
		if (flag || !isTask("investigate_curiosity") || !is_moving)
		{
			lookTowardsPosition(Vector2.op_Implicit(pTile.posV3));
			stopMovement();
			cancelAllBeh();
			if (!flag)
			{
				makeWait(num);
			}
			scheduleTask("investigate_curiosity", pTile);
		}
		float num3 = 0.3f;
		if (hasSubspecies() && subspecies.has_trait_timid)
		{
			num3 += 0.3f;
		}
		if (Randy.randomChance(num3))
		{
			cancelAllBeh();
			scheduleTask("run_away", null);
		}
	}

	public bool makeSleep(float pTime)
	{
		bool num = addStatusEffect("sleeping", pTime);
		if (num)
		{
			makeWait(pTime);
		}
		return num;
	}

	public void makeStunned(float pTime = 5f)
	{
		pTime += Randy.randomFloat(0f, pTime * 0.1f);
		cancelAllBeh();
		makeWait(pTime);
		if (addStatusEffect("stunned", pTime))
		{
			finishAngryStatus();
		}
	}

	public void makeStunnedFromUI()
	{
		makeStunned();
		updateStats();
	}

	public void justAte()
	{
		addStatusEffect("just_ate");
	}

	public void poop(bool pApplyForce)
	{
		donePooping();
		float num = 1f;
		string pAssetID;
		if (hasSubspecies())
		{
			pAssetID = subspecies.getRandomBioProduct();
			num = 0.2f;
		}
		else
		{
			pAssetID = "poop";
		}
		if (num >= 1f || Randy.randomChance(num))
		{
			BuildingHelper.tryToBuildNear(current_tile, pAssetID);
		}
		if (pApplyForce)
		{
			applyRandomForce();
		}
	}

	public void donePooping()
	{
		finishStatusEffect("just_ate");
		changeHappiness("just_pooped");
	}

	public void birthEvent(string pAddSpecialTrait = null, string pAddSpecialStatus = null)
	{
		changeHappiness("just_had_child");
		makeStunned(4f);
		spendNutritionOnBirth();
		if (!string.IsNullOrEmpty(pAddSpecialTrait))
		{
			addTrait(pAddSpecialTrait);
		}
		if (!string.IsNullOrEmpty(pAddSpecialStatus))
		{
			addStatusEffect(pAddSpecialStatus);
		}
	}

	public void consumeTopTile(WorldTile pTile)
	{
		if (Randy.randomChance(0.3f))
		{
			World.world.units.addRandomTraitFromBiomeToActor(this, pTile);
		}
		addNutritionFromEating(pTile.Type.nutrition, pSetMaxNutrition: false, pSetJustAte: true);
		countConsumed();
		pTile.topTileEaten();
		pTile.setBurned();
	}

	public void countConsumed()
	{
		data.food_consumed++;
	}

	public void consumeFoodResource(ResourceAsset pAsset)
	{
		ate_last_item_id = pAsset.id;
		timestamp_session_ate_food = World.world.getCurSessionTime();
		if (pAsset.give_experience != 0)
		{
			addExperience(pAsset.give_experience);
		}
		if (pAsset.restore_happiness != 0)
		{
			changeHappiness("just_ate", pAsset.restore_happiness);
		}
		int num = pAsset.restore_nutrition;
		float num2 = pAsset.restore_health;
		if (hasFavoriteFood())
		{
			if (pAsset.id != data.favorite_food)
			{
				ResourceAsset resourceAsset = favorite_food_asset;
				if (pAsset.tastiness > resourceAsset.tastiness && Randy.randomChance(pAsset.favorite_food_chance))
				{
					data.favorite_food = pAsset.id;
				}
			}
		}
		else if (Randy.randomChance(pAsset.favorite_food_chance))
		{
			data.favorite_food = pAsset.id;
		}
		if (pAsset.id == data.favorite_food)
		{
			num *= 2;
			num2 *= 2f;
		}
		addNutritionFromEating(num, pSetMaxNutrition: false, pSetJustAte: true);
		restoreHealthPercent(num2);
		countConsumed();
		if (!Randy.randomChance(pAsset.give_chance))
		{
			return;
		}
		ActorTrait[] give_trait = pAsset.give_trait;
		if (give_trait != null && give_trait.Length != 0 && Randy.randomBool())
		{
			ActorTrait random = pAsset.give_trait.GetRandom();
			if (random != null)
			{
				addTrait(random);
			}
		}
		StatusAsset[] give_status = pAsset.give_status;
		if (give_status != null && give_status.Length != 0 && Randy.randomBool())
		{
			StatusAsset random2 = pAsset.give_status.GetRandom();
			if (random2 != null)
			{
				addStatusEffect(random2);
			}
		}
		if (pAsset.give_action != null && Randy.randomBool())
		{
			pAsset.give_action(pAsset);
		}
	}

	internal void justBorn()
	{
		setActorScale(0.02f);
	}

	public void stopBeingWarrior()
	{
		if (isProfession(UnitProfession.Warrior))
		{
			setProfession(UnitProfession.Unit);
			if (hasCity())
			{
				city.status.warriors_current--;
			}
		}
		removeFromArmy();
	}

	public void pokeFromAvatarUI()
	{
		if (getHealth() > 1)
		{
			getHit(1f, pFlash: true, AttackType.Divine);
		}
		if (Randy.randomChance(0.15f))
		{
			makeStunnedFromUI();
			changeHappiness("got_poked");
		}
		addStatusEffect("motivated");
		applyRandomForce();
		makeSoundAttack();
	}

	public void finishPossessionStatus()
	{
		finishStatusEffect("possessed");
		_has_status_possessed = false;
	}

	public void madePeace(War pWar)
	{
		changeHappiness("just_made_peace");
		if (isKing())
		{
			addRenown(pWar.getRenown(), 0.2f);
		}
		if (isCityLeader())
		{
			addRenown(pWar.getRenown(), 0.05f);
		}
		if (is_army_captain)
		{
			army.addRenown(pWar.getRenown(), 0.05f);
		}
		if (hasTag("love_peace"))
		{
			addStatusEffect("festive_spirit");
		}
	}

	public void warWon(War pWar)
	{
		if (!hasHappinessEntry("was_conquered", 300f))
		{
			if (isKing())
			{
				addRenown(pWar.getRenown());
			}
			if (isCityLeader())
			{
				addRenown(pWar.getRenown(), 0.2f);
			}
			if (isWarrior())
			{
				addRenown(pWar.getRenown(), 0.05f);
			}
			if (is_army_captain)
			{
				army.addRenown(pWar.getRenown(), 0.05f);
			}
			changeHappiness("just_won_war");
		}
		if (hasTag("love_peace"))
		{
			addStatusEffect("festive_spirit");
		}
	}

	public void warLost(War pWar)
	{
		changeHappiness("just_lost_war");
		if (isKing())
		{
			addRenown(pWar.getRenown(), 0.05f);
		}
		if (is_army_captain)
		{
			army.addRenown(pWar.getRenown(), 0.01f);
		}
	}

	public void setTransformed()
	{
		data.set("transformation_done", pData: true);
	}

	public bool isAlreadyTransformed()
	{
		data.get("transformation_done", out var pResult, pDefault: false);
		return pResult;
	}

	public void makeConfused(float pConfusedTimer = -1f, bool pColorEffect = false)
	{
		cancelAllBeh();
		if (pColorEffect)
		{
			startColorEffect();
		}
		addStatusEffect("confused", pConfusedTimer, pColorEffect);
		makeStunned(3f);
	}

	public void checkShouldBeEgg()
	{
		if (hasSubspecies() && subspecies.has_egg_form && (float)age < subspecies.age_adult)
		{
			float maturationTimeSeconds = getMaturationTimeSeconds();
			addStatusEffect("egg", maturationTimeSeconds);
		}
	}

	public void leavePlot()
	{
		setPlot(null);
	}

	private void levelUp()
	{
		int expToLevelup = getExpToLevelup();
		int maxPossibleLevel = getMaxPossibleLevel();
		data.experience = 0;
		data.level++;
		if (hasCulture() && culture.hasTrait("training_potential"))
		{
			data.level++;
		}
		if (data.level == maxPossibleLevel)
		{
			data.experience = expToLevelup;
		}
		setStatsDirty();
		EffectsLibrary.showMetaEventEffect("fx_experience_gain", this);
	}

	private void checkGrowthEvent()
	{
		bool flag = isBaby();
		bool num = isEgg();
		calcAgeStates();
		if (animation_container != null && animation_container.child != isBaby())
		{
			clearSprites();
		}
		if (num && !isEgg())
		{
			batch.c_events_hatched.Add(this);
		}
		else if (flag && !isBaby())
		{
			batch.c_events_become_adult.Add(this);
		}
	}

	internal void eventHatchFromEgg()
	{
		growthStateEvent();
		triggerHatchFromEggAction();
		applyRandomForce();
		changeHappiness("just_got_out_of_egg");
		batch.c_events_hatched.Remove(this);
	}

	internal void eventBecomeAdult()
	{
		growthStateEvent();
		changeHappiness("just_became_adult");
		checkTraitMutationGrowUp();
		batch.c_events_become_adult.Remove(this);
		subspecies.counter_new_adults?.registerEvent();
	}

	private void growthStateEvent()
	{
		setStatsDirty();
		event_full_stats = true;
		if (hasCity())
		{
			city.setCitizensDirty();
			city.setStatusDirty();
		}
	}

	private void triggerHatchFromEggAction()
	{
		SubspeciesTrait egg_asset = subspecies.egg_asset;
		if (egg_asset != null && egg_asset.has_after_hatch_from_egg_action)
		{
			egg_asset.after_hatch_from_egg_action(this);
		}
	}

	public bool checkNaturalDeath()
	{
		if (!WorldLawLibrary.world_law_old_age.isEnabled())
		{
			return false;
		}
		if (hasTrait("immortal"))
		{
			return false;
		}
		float num = getAge();
		float num2 = stats["lifespan"];
		if (num2 == 0f)
		{
			return false;
		}
		if (num <= num2)
		{
			return false;
		}
		float num3 = num - num2;
		float num4 = 5f;
		if (Randy.randomChance(Mathf.Clamp(1f / (1f + Mathf.Exp((0f - num4) * (num3 / num2 - 0.5f))), 0f, 0.9f)))
		{
			getHitFullHealth(AttackType.Age);
			return true;
		}
		return false;
	}

	public void spawnParticle(Color pColor)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (!Randy.randomBool() && MapBox.isRenderGameplay())
		{
			Vector3 pVector = Vector2.op_Implicit(current_position);
			pVector.y += 0.5f * current_scale.y / 2f;
			pVector.x += Randy.randomFloat(-0.2f, 0.2f);
			pVector.y += Randy.randomFloat(-0.2f, 0.2f);
			BaseEffect baseEffect = EffectsLibrary.spawn("fx_status_particle");
			if ((Object)(object)baseEffect != (Object)null)
			{
				((StatusParticle)baseEffect).spawnParticle(pVector, pColor);
			}
		}
	}

	private void checkActionsFromAllMetas()
	{
		if (hasSubspecies())
		{
			addSpecialEffectsFromMetas(subspecies.all_actions_actor_special_effect);
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, subspecies.all_actions_actor_attack_target);
			s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, subspecies.all_actions_actor_get_hit);
		}
		if (hasClan())
		{
			addSpecialEffectsFromMetas(clan.all_actions_actor_special_effect);
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, clan.all_actions_actor_attack_target);
			s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, clan.all_actions_actor_get_hit);
		}
		if (hasLanguage())
		{
			addSpecialEffectsFromMetas(language.all_actions_actor_special_effect);
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, language.all_actions_actor_attack_target);
			s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, language.all_actions_actor_get_hit);
		}
		if (hasCulture())
		{
			addSpecialEffectsFromMetas(culture.all_actions_actor_special_effect);
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, culture.all_actions_actor_attack_target);
			s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, culture.all_actions_actor_get_hit);
		}
		if (hasReligion())
		{
			addSpecialEffectsFromMetas(religion.all_actions_actor_special_effect);
			s_action_attack_target = (AttackAction)Delegate.Combine(s_action_attack_target, religion.all_actions_actor_attack_target);
			s_get_hit_action = (GetHitAction)Delegate.Combine(s_get_hit_action, religion.all_actions_actor_get_hit);
		}
	}

	private void recalcCombatActions()
	{
		foreach (ActorTrait trait in traits)
		{
			if (trait.hasCombatActions())
			{
				_combat_actions.mergeWith(trait.combat_actions);
			}
		}
		checkCombatActions(subspecies?.combat_actions);
		checkCombatActions(clan?.combat_actions);
		checkCombatActions(religion?.combat_actions);
	}

	private void recalcSpells()
	{
		foreach (ActorTrait trait in traits)
		{
			if (trait.hasSpells())
			{
				_spells.mergeWith(trait.spells);
			}
		}
		if (!hasEquipment())
		{
			return;
		}
		foreach (ActorEquipmentSlot item2 in equipment)
		{
			if (!item2.isEmpty())
			{
				Item item = item2.getItem();
				if (item.asset.hasSpells())
				{
					_spells.mergeWith(item.asset.spells);
				}
			}
		}
	}

	private void checkSpells(SpellHolder pSpellsHolder)
	{
		if (pSpellsHolder != null && pSpellsHolder.hasAny())
		{
			_spells.mergeWith(pSpellsHolder);
		}
	}

	private void checkCombatActions(CombatActionHolder pHolder)
	{
		if (pHolder != null && !pHolder.isEmpty())
		{
			_combat_actions.mergeWith(pHolder);
		}
	}

	public List<CombatActionAsset> getCombatActionPool(CombatActionPool pPool)
	{
		if (!_combat_actions.hasAny())
		{
			return null;
		}
		return _combat_actions.getPool(pPool);
	}

	private void clearCombatActions()
	{
		_combat_actions.reset();
	}

	private void clearSpells()
	{
		_spells.reset();
	}

	private bool checkCurrentEnemyTarget()
	{
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		if (shouldSkipFightCheck())
		{
			return false;
		}
		if (!has_attack_target)
		{
			return false;
		}
		if (!isEnemyTargetAlive())
		{
			return false;
		}
		BaseSimObject baseSimObject = attack_target;
		Actor actor = attack_target.a;
		if (isKingdomCiv() && baseSimObject.isKingdomCiv() && !shouldContinueToAttackTarget())
		{
			clearAttackTarget();
			return false;
		}
		if (baseSimObject.isActor() && !hasStatusTantrum() && !baseSimObject.areFoes(this) && baseSimObject.a.is_unconscious)
		{
			clearAttackTarget();
			return false;
		}
		if (canAttackTarget(baseSimObject, pCheckForFactions: true, asset.can_attack_buildings))
		{
			bool flag = isAttackPossible();
			bool flag2 = isInAttackRange(baseSimObject);
			if (!flag2)
			{
				float num = distanceToObjectTarget(baseSimObject);
				if (num > 20f && actor != null && actor.isTask("run_away"))
				{
					clearAttackTarget();
					return false;
				}
				if (num > 50f)
				{
					clearAttackTarget();
					return false;
				}
				if (num > 3f && tryToUseAdvancedCombatAction(getCombatActionPool(CombatActionPool.BEFORE_ATTACK_MELEE), baseSimObject, out var pResultCombatAsset))
				{
					pResultCombatAsset.action_actor_target_position(this, baseSimObject.current_position, baseSimObject.current_tile);
					return false;
				}
			}
			if (attack_timer > 0f || (!flag && flag2))
			{
				stopMovement();
				if (hasRangeAttack() && tryToUseAdvancedCombatAction(getCombatActionPool(CombatActionPool.BEFORE_ATTACK_RANGE), baseSimObject, out var pResultCombatAsset2))
				{
					pResultCombatAsset2.action_actor_target_position(this, baseSimObject.current_position, baseSimObject.current_tile);
				}
				return true;
			}
			if (flag2 && tryToAttack(baseSimObject, pDoChecks: false))
			{
				stopMovement();
				return true;
			}
		}
		return false;
	}

	private bool checkEnemyTargets()
	{
		if (!isAllowedToLookForEnemies())
		{
			return false;
		}
		if (isInWaterAndCantAttack())
		{
			return false;
		}
		if (_has_status_strange_urge)
		{
			return false;
		}
		if (has_attack_target)
		{
			if (!hasTask() || !ai.task.in_combat)
			{
				setTask("fighting", pClean: true, pCleanJob: true);
			}
			return false;
		}
		if (_timeout_targets > 0f)
		{
			return false;
		}
		_timeout_targets = 0.1f + Randy.randomFloat(0f, 1f);
		BaseSimObject baseSimObject = findEnemyObjectTarget(asset.can_attack_buildings);
		if (baseSimObject == null && _aggression_targets.Count > 0)
		{
			using ListPool<Actor> listPool = new ListPool<Actor>(_aggression_targets.Count);
			foreach (long aggression_target in _aggression_targets)
			{
				Actor actor = World.world.units.get(aggression_target);
				if (!actor.isRekt())
				{
					listPool.Add(actor);
				}
			}
			if (listPool.Count > 0)
			{
				baseSimObject = checkObjectList(listPool, asset.can_attack_buildings, pFindClosest: true, pIgnoreStunned: true, 30);
			}
			else
			{
				_aggression_targets.Clear();
			}
		}
		if (baseSimObject == null)
		{
			return false;
		}
		startFightingWith(baseSimObject);
		return true;
	}

	public void startFightingWith(BaseSimObject pSimObject)
	{
		setAttackTarget(pSimObject);
		setTask("fighting", pClean: false, pCleanJob: true);
		beh_actor_target = pSimObject;
	}

	internal void startAttackCooldown()
	{
		attack_timer = getAttackCooldown();
		last_attack_timestamp = World.world.getCurWorldTime();
	}

	internal bool isJustAttacked()
	{
		return World.world.getWorldTimeElapsedSince(last_attack_timestamp) < 0.25f;
	}

	internal bool tryToAttack(BaseSimObject pTarget, bool pDoChecks = true, Action pKillAction = null, Vector3 pAttackPosition = default(Vector3), Kingdom pForceKingdom = null, WorldTile pTileTarget = null, float pBonusAreOfEffect = 0f)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		if (pDoChecks)
		{
			if (hasMeleeAttack() && pTarget != null && pTarget.position_height > 0f)
			{
				return false;
			}
			if (isInWaterAndCantAttack())
			{
				return false;
			}
			if (!isAttackPossible())
			{
				return false;
			}
			if (pTarget != null && !isInAttackRange(pTarget))
			{
				return false;
			}
		}
		float num = 0f;
		float num2 = 0f;
		Vector3 val;
		if (pTarget != null)
		{
			val = Vector2.op_Implicit(pTarget.current_position);
			num = pTarget.getHeight();
			num2 = pTarget.stats["size"];
		}
		else
		{
			val = pAttackPosition;
		}
		bool has_status_possessed = _has_status_possessed;
		startAttackCooldown();
		punchTargetAnimation(val, pFlip: true, hasRangeAttack());
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))._002Ector(val.x, val.y);
		if (pTarget != null && pTarget.isActor() && pTarget.a.is_moving && pTarget.isFlying())
		{
			val2 = Vector3.MoveTowards(val2, Vector2.op_Implicit(pTarget.a.next_step_position), num2 * 3f);
		}
		Vector3 val3 = Vector2.op_Implicit(current_position);
		float num3 = Vector2.Distance(Vector2.op_Implicit(val3), Vector2.op_Implicit(val)) + num;
		Vector3 newPoint = Toolbox.getNewPoint(val3.x, val3.y, val2.x, val2.y, num3 - num2);
		string projectile = getWeaponAsset().projectile;
		bool pProjectile = hasRangeAttack();
		Kingdom kingdom = pForceKingdom ?? base.kingdom;
		WorldTile pHitTile = pTileTarget ?? pTarget?.current_tile;
		Kingdom pKingdom = kingdom;
		Vector3 pInitiatorPosition = val3;
		AttackData pData = new AttackData(this, pHitTile, newPoint, pInitiatorPosition, pTarget, pKingdom, AttackType.Weapon, haveMetallicWeapon(), pSkipShake: true, pProjectile, projectile, pKillAction, pBonusAreOfEffect);
		using ListPool<CombatActionAsset> listPool = new ListPool<CombatActionAsset>();
		CombatActionAsset combatActionAsset = null;
		bool flag = false;
		if (hasSpells() && canUseSpells() && !has_status_possessed)
		{
			addToAttackPool(CombatActionLibrary.combat_cast_spell, listPool);
		}
		if (listPool.Count > 0)
		{
			if (hasMeleeAttack())
			{
				addToAttackPool(CombatActionLibrary.combat_attack_melee, listPool);
			}
			else
			{
				addToAttackPool(CombatActionLibrary.combat_attack_range, listPool);
			}
			combatActionAsset = listPool.GetRandom();
			flag = combatActionAsset.action(pData);
			if (!flag && !combatActionAsset.basic)
			{
				flag = ((!hasMeleeAttack()) ? CombatActionLibrary.combat_attack_range.action(pData) : CombatActionLibrary.combat_attack_melee.action(pData));
			}
		}
		else
		{
			combatActionAsset = ((!hasMeleeAttack()) ? CombatActionLibrary.combat_attack_range : CombatActionLibrary.combat_attack_melee);
			flag = combatActionAsset.action(pData);
		}
		if (flag)
		{
			spendStamina(combatActionAsset.cost_stamina);
			spendMana(combatActionAsset.cost_mana);
		}
		if (combatActionAsset.play_unit_attack_sounds)
		{
			makeSoundAttack();
		}
		if (needsFood() && Randy.randomBool())
		{
			decreaseNutrition();
		}
		float num4 = stats.get("recoil");
		if (num4 > 0f)
		{
			calculateForce(current_position.x, current_position.y, val2.x, val2.y, num4);
		}
		return true;
	}

	internal override void getHitFullHealth(AttackType pAttackType)
	{
		getHit(getHealth(), pFlash: false, pAttackType, null, pSkipIfShake: false, pMetallicWeapon: false, pCheckDamageReduction: false);
	}

	internal override void getHit(float pDamage, bool pFlash, AttackType pAttackType, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
	{
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		_last_attack_type = pAttackType;
		if (_cache_check_has_status_removed_on_damage)
		{
			foreach (Status status in getStatuses())
			{
				if (!status.is_finished && status.asset.removed_on_damage)
				{
					finishStatusEffect(status.asset.id);
				}
			}
		}
		if (DebugConfig.isOn(DebugOption.IgnoreDamage) || (pSkipIfShake && _shake_active))
		{
			return;
		}
		attackedBy = null;
		if (pAttacker.isRekt())
		{
			pAttacker = null;
		}
		if (pAttacker != this)
		{
			attackedBy = pAttacker;
		}
		if (!hasHealth() || is_invincible)
		{
			return;
		}
		Actor actor = pAttacker?.a;
		if (pAttackType == AttackType.Weapon)
		{
			bool flag = false;
			if (pMetallicWeapon && haveMetallicWeapon())
			{
				flag = true;
			}
			if (flag)
			{
				MusicBox.playSound("event:/SFX/HIT/HitSwordSword", current_tile, pGameViewOnly: false, pVisibleOnly: true);
			}
			else if (asset.has_sound_hit)
			{
				MusicBox.playSound(asset.sound_hit, current_tile, pGameViewOnly: false, pVisibleOnly: true);
			}
			if (actor != null && !hasStatus("shield"))
			{
				damageEquipmentOnGetHit(actor);
			}
		}
		if (pCheckDamageReduction)
		{
			if (pAttackType == AttackType.Other || pAttackType == AttackType.Weapon)
			{
				float num = 1f - stats["armor"] / 100f;
				pDamage *= num;
			}
			if (pDamage < 1f)
			{
				pDamage = 1f;
			}
			if (actor != null)
			{
				checkSpecialAttackLogic(actor, pAttackType, pDamage, out var pDamageFinal);
				pDamage = pDamageFinal;
				AchievementLibrary.clone_wars.checkBySignal((this, actor));
			}
		}
		changeHealth((int)(0f - pDamage));
		timer_action = 0.002f;
		s_get_hit_action?.Invoke(this, pAttacker, current_tile);
		if (pFlash)
		{
			startColorEffect(ActorColorEffect.Red);
		}
		if (!hasHealth())
		{
			batch.c_check_deaths.Add(this);
		}
		if (pAttackType == AttackType.Weapon && !asset.immune_to_injuries && !hasStatus("shield"))
		{
			if (Randy.randomChance(0.02f))
			{
				addInjuryTrait("crippled");
			}
			if (Randy.randomChance(0.02f))
			{
				addInjuryTrait("eyepatch");
			}
		}
		startShake();
		if (!has_attack_target)
		{
			if (attackedBy != null && !shouldIgnoreTarget(attackedBy) && canAttackTarget(attackedBy, pCheckForFactions: false))
			{
				setAttackTarget(attackedBy);
			}
		}
		else if (hasMeleeAttack() && attackedBy != null && canAttackTarget(attackedBy, pCheckForFactions: false))
		{
			float num2 = Toolbox.SquaredDistVec2Float(current_position, attack_target.current_position);
			float num3 = Toolbox.SquaredDistVec2Float(current_position, pAttacker.current_position);
			if (num2 > getAttackRangeSquared() && num3 < num2)
			{
				setAttackTarget(pAttacker);
			}
		}
		if (hasAnyStatusEffect())
		{
			foreach (Status status2 in getStatuses())
			{
				status2.asset.action_get_hit?.Invoke(this, pAttacker, current_tile);
			}
		}
		asset.action_get_hit?.Invoke(this, pAttacker, current_tile);
		if (!hasHealth())
		{
			checkCallbacksOnDeath();
		}
	}

	private void pickupResourcesFromKill(Actor pAttacker)
	{
		if (!pAttacker.hasCity())
		{
			return;
		}
		foreach (ResourceContainer item in getResourcesFromActor())
		{
			if (!isSameSpecies(pAttacker) || pAttacker.hasTrait("savage"))
			{
				pAttacker.addToInventory(item);
			}
		}
	}

	private void checkSpecialAttackLogic(Actor pAttacker, AttackType pAttackType, float pInitialDamage, out float pDamageFinal)
	{
		pDamageFinal = pInitialDamage;
		bool flag = isSameKingdom(pAttacker);
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = pAttacker.hasStatus("tantrum") && !flag;
		bool flag5 = pAttacker.hasStatus("possessed");
		bool num = kingdom.isEnemy(pAttacker.kingdom);
		float pVal = 0.1f;
		if (_has_status_possessed || flag5)
		{
			pVal = 0.7f;
		}
		else if (flag)
		{
			pVal = 0.5f;
		}
		if (num)
		{
			pVal = 0f;
		}
		flag3 = Randy.randomChance(pVal);
		if (flag4)
		{
			flag3 = true;
		}
		if (getHealthRatio() < 0.5f && flag3)
		{
			pDamageFinal = 1f;
			makeStunned();
			changeHappiness("lost_fight");
			finishAngryStatus();
			flag2 = true;
			if (flag4)
			{
				pAttacker.finishStatusEffect("tantrum");
			}
			if (Randy.randomChance(0.4f))
			{
				pAttacker.finishAngryStatus();
			}
		}
		bool flag6 = false;
		if (flag && pAttackType != AttackType.Eaten)
		{
			if (Randy.randomChance(0.3f) || flag5 || pAttacker.hasStatus("angry"))
			{
				checkAggroAgainst(pAttacker, flag5);
				flag6 = true;
			}
			if (flag2)
			{
				pDamageFinal = 0f;
				pAttacker.clearAttackTarget();
				pAttacker.makeWait(0.3f);
				if (pAttacker.hasStatus("angry"))
				{
					pAttacker.finishAngryStatus();
				}
			}
		}
		if (!flag6 && flag5)
		{
			checkAggroAgainst(pAttacker);
		}
	}

	private void damageEquipmentOnGetHit(Actor pAttacker)
	{
		if (!pAttacker.hasWeapon() || !hasEquipment())
		{
			return;
		}
		int num = 4;
		float pVal = 0.35f;
		Item weapon = pAttacker.getWeapon();
		EquipmentAsset equipmentAsset = weapon.getAsset();
		int rigidity_rating = equipmentAsset.rigidity_rating;
		int num2 = 0;
		bool flag = false;
		foreach (ActorEquipmentSlot item2 in equipment)
		{
			if (Randy.randomBool())
			{
				continue;
			}
			Item item = item2.getItem();
			if (!item.isBroken())
			{
				EquipmentAsset equipmentAsset2 = item.getAsset();
				int rigidity_rating2 = equipmentAsset2.rigidity_rating;
				if (!equipmentAsset2.is_pool_weapon)
				{
					num2 += rigidity_rating2;
				}
				int pDamage = rigidity_rating / rigidity_rating2 * num;
				item.getDamaged(pDamage);
				if (item.isBroken())
				{
					flag = true;
				}
			}
		}
		if (flag)
		{
			setStatsDirty();
		}
		if (!weapon.isBroken() && !Randy.randomBool())
		{
			if (equipmentAsset.attack_type == WeaponType.Melee)
			{
				int pDamage2 = num2 / 5 / rigidity_rating * num;
				weapon.getDamaged(pDamage2);
			}
			else if (equipmentAsset.attack_type == WeaponType.Range && Randy.randomChance(pVal))
			{
				weapon.getDamaged(1);
			}
			if (weapon.isBroken())
			{
				pAttacker.setStatsDirty();
			}
		}
	}

	public void addInjuryTrait(string pTraitID)
	{
		if (addTrait(pTraitID))
		{
			changeHappiness("just_injured");
		}
	}

	private void checkAggroAgainst(Actor pAttackedBy, bool pCheckAllLists = false)
	{
		addAggro(pAttackedBy);
		if (!pCheckAllLists)
		{
			return;
		}
		if (hasFamily())
		{
			family.allAngryAt(pAttackedBy, 10f);
		}
		if (hasClan())
		{
			clan.allAngryAt(pAttackedBy, 10f);
		}
		if (hasCity() && isBaby())
		{
			city.allAngryAt(pAttackedBy, 10f);
		}
		if (hasLover())
		{
			lover.addAggro(pAttackedBy);
		}
		if (hasBestFriend())
		{
			getBestFriend().addAggro(pAttackedBy);
		}
		if ((!isKing() && !isWarrior() && !isCityLeader() && !isBaby()) || pAttackedBy.isKing())
		{
			return;
		}
		foreach (City city in kingdom.getCities())
		{
			if (city.hasArmy())
			{
				city.army.allAngryAt(pAttackedBy, 10f);
			}
		}
	}

	internal void newKillAction(Actor pDeadUnit, Kingdom pPrevKingdom, AttackType pAttackType)
	{
		increaseKills();
		if (hasWeapon())
		{
			getWeapon().countKill();
		}
		if (isKingdomCiv() && pPrevKingdom.isCiv())
		{
			War war = World.world.wars.getWar(kingdom, pPrevKingdom, pOnlyMain: false);
			if (war != null)
			{
				if (war.isAttacker(kingdom))
				{
					war.increaseDeathsDefenders(pAttackType);
				}
				else
				{
					war.increaseDeathsAttackers(pAttackType);
				}
			}
		}
		if (isAlive())
		{
			if (timer_action <= 0f)
			{
				makeWait(Randy.randomFloat(0.1f, 1f));
			}
			if (hasTrait("bloodlust"))
			{
				changeHappiness("just_killed");
			}
			int pLootValue = pDeadUnit.giveAllLootAndMoney();
			addLoot(pLootValue);
			takeAllResources(pDeadUnit);
			if (data.kills > 10)
			{
				addTrait("veteran");
			}
			if (pDeadUnit.isKing())
			{
				addTrait("kingslayer");
			}
			addExperience(pDeadUnit.asset.experience_given);
			addRenown(pDeadUnit.asset.experience_given);
			if (hasTrait("madness"))
			{
				restoreHealth(getMaxHealthPercent(0.05f));
			}
			if (understandsHowToUseItems() && !pDeadUnit.hasTrait("infected") && canTakeItems())
			{
				takeItems(pDeadUnit);
			}
			checkRageDemon();
		}
	}

	internal void applyRandomForce(float pMinHeight = 1.5f, float pMaxHeight = 2f)
	{
		float pForceAmountDirection = Randy.randomFloat(1.5f, 2f);
		float pForceHeight = Randy.randomFloat(pMinHeight, pMaxHeight);
		WorldTile random = current_tile.neighboursAll.GetRandom();
		calculateForce(current_tile.posV3.x, current_tile.posV3.y, random.posV3.x, random.posV3.y, pForceAmountDirection, pForceHeight, pCheckCancelJobOnLand: true);
	}

	internal void calculateForce(float pStartX, float pStartY, float pTargetX, float pTargetY, float pForceAmountDirection, float pForceHeight = 0f, bool pCheckCancelJobOnLand = false)
	{
		if (pForceHeight == 0f)
		{
			pForceHeight = pForceAmountDirection;
		}
		pForceAmountDirection *= SimGlobals.m.unit_force_multiplier;
		pForceHeight *= SimGlobals.m.unit_force_multiplier;
		if (!(pForceAmountDirection <= 0f))
		{
			float angle = Toolbox.getAngle(pStartX, pStartY, pTargetX, pTargetY);
			float pX = (0f - Mathf.Cos(angle)) * pForceAmountDirection;
			float pY = (0f - Mathf.Sin(angle)) * pForceAmountDirection;
			if (pStartX == pTargetX && pStartY == pTargetY)
			{
				pX = 0f;
				pY = 0f;
			}
			addForce(pX, pY, pForceHeight, pCheckCancelJobOnLand);
		}
	}

	public bool tryToUseAdvancedCombatAction(List<CombatActionAsset> pCombatActionAssetsCategory, BaseSimObject pAttackTarget, out CombatActionAsset pResultCombatAsset)
	{
		pResultCombatAsset = null;
		if (pCombatActionAssetsCategory == null)
		{
			return false;
		}
		if (pCombatActionAssetsCategory.Count == 0)
		{
			return false;
		}
		if (hasTrait("slow"))
		{
			return false;
		}
		if (combatActionOnTimeout())
		{
			return false;
		}
		using ListPool<CombatActionAsset> listPool = new ListPool<CombatActionAsset>(pCombatActionAssetsCategory.Count);
		foreach (CombatActionAsset item in pCombatActionAssetsCategory)
		{
			if (!hasEnoughStamina(item.cost_stamina) || !hasEnoughMana(item.cost_mana))
			{
				continue;
			}
			if (pAttackTarget != null)
			{
				CombatActionCheckStart can_do_action = item.can_do_action;
				if (can_do_action != null && !can_do_action(this, pAttackTarget))
				{
					continue;
				}
			}
			listPool.Add(item);
		}
		if (listPool.Count == 0)
		{
			return false;
		}
		CombatActionAsset random = listPool.GetRandom();
		if (!Randy.randomChance(random.chance + random.chance * stats["skill_combat"]))
		{
			return false;
		}
		spendStamina(random.cost_stamina);
		spendMana(random.cost_mana);
		pResultCombatAsset = random;
		addStatusEffect("recovery_combat_action", pResultCombatAsset.cooldown, pColorEffect: false);
		return true;
	}

	public void addAggro(long pActorID)
	{
		Actor actor = World.world.units.get(pActorID);
		if (!actor.isRekt())
		{
			addAggro(actor);
		}
	}

	public void addAggro(Actor pActor)
	{
		if (!pActor.isRekt() && pActor != this)
		{
			addStatusEffect("angry", 0f, pColorEffect: false);
			_aggression_targets.Add(pActor.getID());
		}
	}

	public void finishAngryStatus()
	{
		_aggression_targets.Clear();
		finishStatusEffect("angry");
	}

	public void spawnSlashPunch(Vector2 pTowardsPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		spawnSlash(pTowardsPosition, "effects/slashes/slash_punch");
	}

	public void spawnSlashSteal(Vector2 pTowardsPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		spawnSlash(pTowardsPosition, "effects/slashes/slash_steal");
	}

	public void spawnSlashYell(Vector2 pTowardsPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		spawnSlash(pTowardsPosition, "effects/slashes/slash_swear");
	}

	public void spawnSlashTalk(Vector2 pTowardsPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		spawnSlash(pTowardsPosition, "effects/slashes/slash_talk");
	}

	public void spawnSlashKick(Vector2 pTowardsPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		spawnSlash(pTowardsPosition, "effects/slashes/slash_kick", 2f, 0f, (0f - actor_scale) * 8f);
	}

	public void spawnSlash(Vector2 pTowardsPosition, string pSlashType = null, float pDistMod = 2f, float pTargetZ = 0f, float pStartZ = 0f, float? pAngle = null)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (is_visible && EffectsLibrary.canShowSlashEffect())
		{
			if (string.IsNullOrEmpty(pSlashType))
			{
				pSlashType = _attack_asset.path_slash_animation;
			}
			Vector2 slashPosition = getSlashPosition(this, pTowardsPosition, pDistMod, pTargetZ, pStartZ);
			float pAngle2 = (pAngle.HasValue ? pAngle.Value : getSlashAngle(slashPosition, pTowardsPosition));
			EffectsLibrary.spawnSlash(slashPosition, pSlashType, pAngle2, actor_scale);
		}
	}

	public float getSlashAngle(Vector2 pSlashVector, Vector2 pAttackPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return Toolbox.getAngleDegrees(pSlashVector.x, pSlashVector.y, pAttackPosition.x, pAttackPosition.y);
	}

	public Vector2 getSlashPosition(Actor pActor, Vector2 pAttackPosition, float pDistMod, float pTargetZ = 0f, float pStartZ = 0f)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		float scaleMod = pActor.getScaleMod();
		float num = pActor.stats["size"];
		Vector2 val = default(Vector2);
		((Vector2)(ref val))._002Ector(pActor.current_position.x, pActor.current_position.y);
		val.y += pActor.getHeight();
		val.y += 0.5f * scaleMod;
		val.y += pStartZ;
		float pDist = num * scaleMod * pDistMod;
		return Toolbox.getNewPointVec2(val.x, val.y, pAttackPosition.x, pAttackPosition.y + pTargetZ, pDist);
	}

	public void doCastAnimation()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (is_visible)
		{
			Vector2 renderedItemPosition = getRenderedItemPosition();
			Vector3 pPos = cur_transform_position;
			EffectsLibrary.spawnAt(asset.effect_cast_ground, pPos, stats["scale"]);
			pPos.y += renderedItemPosition.y * 6f * current_scale.y;
			EffectsLibrary.spawnAt(asset.effect_cast_top, pPos, stats["scale"]);
		}
	}

	internal void punchTargetAnimation(Vector3 pDirection, bool pFlip = true, bool pReverse = false, float pAngle = 40f)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!asset.can_flip)
		{
			return;
		}
		if (pFlip && checkFlip())
		{
			if (current_position.x < pDirection.x)
			{
				setFlip(pFlip: true);
			}
			else
			{
				setFlip(pFlip: false);
			}
		}
		if (pReverse)
		{
			target_angle.z = 0f - pAngle;
		}
		else
		{
			target_angle.z = pAngle;
		}
	}

	private void addToAttackPool(CombatActionAsset pAsset, ListPool<CombatActionAsset> pPool)
	{
		for (int i = 0; i < pAsset.rate; i++)
		{
			pPool.Add(pAsset);
		}
	}

	private void checkHappinessChangeFromDeathEvent()
	{
		foreach (Actor parent in getParents())
		{
			parent.changeHappiness("death_child");
		}
		getBestFriend()?.changeHappiness("death_best_friend");
		if (hasLover())
		{
			lover.changeHappiness("death_lover");
			lover.finishStatusEffect("fell_in_love");
		}
		if (!hasFamily())
		{
			return;
		}
		foreach (Actor unit in family.units)
		{
			if (unit != this && !unit.isParentOf(this))
			{
				unit.changeHappiness("death_family_member");
			}
		}
	}

	private void checkCallbacksOnDeath()
	{
		current_tile.Type.unit_death_action?.Invoke(this, current_tile);
		asset.action_death?.Invoke(this, current_tile);
		using ListPool<ActorTrait> listPool = new ListPool<ActorTrait>(getTraits());
		for (int i = 0; i < listPool.Count; i++)
		{
			listPool[i].action_death?.Invoke(this, current_tile);
		}
		if (hasAnyStatusEffect())
		{
			foreach (Status status in getStatuses())
			{
				if (status.asset.action_death != null)
				{
					status.asset.action_death(this, current_tile);
				}
			}
		}
		if (hasClan())
		{
			clan.all_actions_actor_death?.Invoke(this, current_tile);
		}
		if (hasSubspecies())
		{
			subspecies.all_actions_actor_death?.Invoke(this, current_tile);
		}
		if (hasReligion())
		{
			religion.all_actions_actor_death?.Invoke(this, current_tile);
		}
		callbacks_on_death?.Invoke(this);
	}

	public void checkDeath()
	{
		if (!hasHealth() && isAlive())
		{
			Kingdom pPrevKingdom = kingdom;
			Actor actor = null;
			if (!attackedBy.isRekt() && attackedBy.isActor() && attackedBy != this)
			{
				actor = attackedBy.a;
			}
			if (_last_attack_type == AttackType.Weapon && (isKingdomCiv() || (!actor.isRekt() && actor.isKingdomCiv())))
			{
				BattleKeeperManager.addUnitKilled(this);
			}
			if (actor != null)
			{
				actor.newKillAction(this, pPrevKingdom, _last_attack_type);
				pickupResourcesFromKill(actor);
			}
			die(pDestroy: false, _last_attack_type);
		}
	}

	public void dieSimpleNone()
	{
		die(pDestroy: false, AttackType.None, pCountDeath: false);
	}

	public void dieAndDestroy(AttackType pType)
	{
		die(pDestroy: true, pType, pCountDeath: false);
	}

	public void removeByMetamorphosis()
	{
		die(pDestroy: true, AttackType.Metamorphosis, pCountDeath: false, pLogFavorite: false);
	}

	private void die(bool pDestroy = false, AttackType pType = AttackType.Other, bool pCountDeath = true, bool pLogFavorite = true)
	{
		if (!isAlive() && !pDestroy)
		{
			return;
		}
		switch (pType)
		{
		case AttackType.Plague:
		case AttackType.Infection:
		case AttackType.Tumor:
		case AttackType.Divine:
		case AttackType.AshFever:
		case AttackType.Metamorphosis:
		case AttackType.Starvation:
		case AttackType.Age:
		case AttackType.None:
		case AttackType.Poison:
		case AttackType.Gravity:
		case AttackType.Drowning:
			attackedBy = null;
			break;
		}
		SelectedUnit.removeSelected(this);
		if (ControllableUnit.isControllingUnit(this))
		{
			ControllableUnit.remove(this);
			if (asset.id == "crabzilla")
			{
				pDestroy = true;
			}
		}
		if (isAlive())
		{
			setAlive(pValue: false);
			skipUpdates();
			if (is_inside_boat)
			{
				inside_boat.removePassenger(this);
				exitBoat();
			}
			if (pCountDeath)
			{
				countDeath(pType);
				checkHappinessChangeFromDeathEvent();
			}
			if (isFavorite() && pLogFavorite)
			{
				if (!attackedBy.isRekt() && attackedBy.isActor())
				{
					WorldLog.logFavMurder(this, attackedBy.a);
				}
				else
				{
					WorldLog.logFavDead(this);
				}
			}
			clearTasks();
		}
		exitBuilding();
		clearHomeBuilding();
		using ListPool<Item> listPool = new ListPool<Item>();
		if (hasEquipment())
		{
			listPool.AddRange(equipment.getItems());
			takeAwayItems();
		}
		if (current_tile.zone.hasCity())
		{
			current_tile.zone.city.tryToPutItems(listPool);
			listPool.Clear();
		}
		if (pDestroy)
		{
			World.world.units.scheduleDestroyOnPlay(this);
		}
		if (isKing())
		{
			kingdom.removeKing();
			kingdom.logKingDead(this);
		}
		if (hasCity())
		{
			stopBeingWarrior();
			if (pType == AttackType.Age)
			{
				city.tryToPutItems(listPool);
				listPool.Clear();
			}
			setCity(null);
		}
		if (isKing())
		{
			kingdom.removeKing();
		}
		clearManagers();
		if (hasEquipment())
		{
			equipment.destroyAllEquipment();
		}
		clearAttackTarget();
		clearTileTarget();
	}

	public void checkDieOnGroundBoat()
	{
		if (asset.is_boat && !current_tile.Type.liquid && isAlive() && !isInMagnet())
		{
			getHitFullHealth(AttackType.Gravity);
			skipBehaviour();
			if (hasStatus("magnetized"))
			{
				World.world.game_stats.data.boatsDestroyedByMagnet++;
				AchievementLibrary.boats_disposal.checkBySignal();
			}
		}
	}

	public void copyAggroFrom(Actor pTarget)
	{
		if (!pTarget.hasStatus("angry"))
		{
			return;
		}
		foreach (long aggression_target in pTarget._aggression_targets)
		{
			addAggro(aggression_target);
		}
		if (!pTarget.attackedBy.isRekt() && pTarget.attackedBy.isActor())
		{
			addAggro(pTarget.attackedBy.a);
		}
		if (!pTarget.attack_target.isRekt() && pTarget.attack_target.isActor())
		{
			addAggro(pTarget.attack_target.a);
		}
	}

	public bool isInAggroList(Actor pActor)
	{
		return _aggression_targets.Contains(pActor.getID());
	}

	public bool shouldContinueToAttackTarget()
	{
		BaseSimObject baseSimObject = attack_target;
		if (areFoes(baseSimObject))
		{
			return true;
		}
		if (!baseSimObject.isActor())
		{
			return false;
		}
		if (baseSimObject.a.hasStatusTantrum())
		{
			return true;
		}
		if (isInAggroList(baseSimObject.a))
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void clearAttackTarget()
	{
		if (has_attack_target)
		{
			attack_target = null;
			has_attack_target = false;
			batch.c_check_attack_target.Remove(a);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isEnemyTargetAlive()
	{
		if (has_attack_target)
		{
			if (attack_target.isRekt())
			{
				clearAttackTarget();
				return false;
			}
			if (attack_target.isBuilding() && !attack_target.b.isUsable())
			{
				clearAttackTarget();
				return false;
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void setAttackTarget(BaseSimObject pAttackTarget)
	{
		attack_target = pAttackTarget;
		if (!has_attack_target)
		{
			has_attack_target = true;
			batch.c_check_attack_target.Add(a);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasRangeAttack()
	{
		return _attack_asset.attack_type == WeaponType.Range;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasMeleeAttack()
	{
		return _attack_asset.attack_type == WeaponType.Melee;
	}

	private void checkAttackTypes()
	{
		EquipmentAsset weaponAsset = getWeaponAsset();
		_attack_asset = weaponAsset;
	}

	private bool isEquipmentMeleeAttack()
	{
		EquipmentAsset weaponAsset = getWeaponAsset();
		if (asset.only_melee_attack)
		{
			return true;
		}
		return weaponAsset.attack_type == WeaponType.Melee;
	}

	public float getAttackCooldown()
	{
		return 1f / stats["attack_speed"];
	}

	private void takeAwayItems()
	{
		if (!hasEquipment())
		{
			return;
		}
		foreach (ActorEquipmentSlot item in equipment)
		{
			if (!item.isEmpty())
			{
				item.takeAwayItem();
			}
		}
	}

	public bool isInDangerZone()
	{
		if (hasCity())
		{
			return city.danger_zones.Contains(base.current_zone);
		}
		return false;
	}

	public void setPossessionAttackHappened()
	{
		_possession_attack_happened_frame = World.world.getCurWorldTime();
	}

	public bool isPossessionAttackJustHappened()
	{
		return World.world.getCurWorldTime() - _possession_attack_happened_frame <= 0.5;
	}

	public void addLoot(int pLootValue)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (pLootValue != 0)
		{
			data.loot += pLootValue;
			data.loot = Mathf.Clamp(data.loot, 0, 99999);
			EffectsLibrary.showMoneyEffect("fx_money_got_loot", current_position, base.current_zone, actor_scale);
		}
	}

	public void addMoney(int pValue)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (pValue != 0)
		{
			data.money += pValue;
			data.money = Mathf.Clamp(data.money, 0, 99999);
			EffectsLibrary.showMoneyEffect("fx_money_got_money", current_position, base.current_zone, actor_scale);
		}
	}

	public int giveAllLoot()
	{
		int result = data.loot;
		lootEmpty();
		return result;
	}

	public int giveAllMoney()
	{
		int result = data.money;
		data.money = 0;
		return result;
	}

	public void spendMoney(int pCost)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (pCost != 0)
		{
			data.money -= pCost;
			EffectsLibrary.showMoneyEffect("fx_money_spend_money", current_position, base.current_zone, actor_scale);
		}
	}

	public int getMoneyForGift()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (money < 10)
		{
			return 0;
		}
		float num = Randy.randomFloat(0.05f, 0.1f);
		int num2 = Mathf.RoundToInt((float)money * num);
		if (num2 == 0)
		{
			return 0;
		}
		EffectsLibrary.showMoneyEffect("fx_money_spend_money", current_position, base.current_zone, actor_scale);
		return num2;
	}

	public void takeAllOwnLoot()
	{
		addMoney(giveAllLoot());
	}

	public int giveAllLootAndMoney()
	{
		return giveAllLoot() + giveAllMoney();
	}

	public void paidTax(float pTaxRate, string pEffect)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		lootEmpty();
		EffectsLibrary.showMoneyEffect(pEffect, current_position, base.current_zone, actor_scale);
		int pValue = -5;
		if ((double)pTaxRate > 0.7)
		{
			pValue = -10;
		}
		changeHappiness("paid_tax", pValue);
	}

	public void lootEmpty()
	{
		data.loot = 0;
	}

	public void giveInventoryResourcesToCity()
	{
		if (isCarryingResources() && hasCity() && city.isAlive())
		{
			foreach (ResourceContainer value in inventory.getResources().Values)
			{
				city.addResourcesToRandomStockpile(value.id, value.amount);
			}
		}
		inventory.empty();
		setItemSpriteRenderDirty();
	}

	public void generateDefaultSpawnWeapons(bool pUseOwnerless)
	{
		if (pUseOwnerless && canUseItems())
		{
			foreach (Item item in World.world.items)
			{
				if (!item.isDestroyable() && !item.hasCity() && !item.hasActor())
				{
					equipment.setItem(item, this);
					return;
				}
			}
		}
		string[] default_weapons = asset.default_weapons;
		if (default_weapons != null && default_weapons.Length != 0)
		{
			string random = asset.default_weapons.GetRandom();
			createNewWeapon(random);
		}
	}

	public bool createNewWeapon(string pItemId)
	{
		EquipmentAsset pItemAsset = AssetManager.items.get(pItemId);
		Item pItem = World.world.items.generateItem(pItemAsset, null, null, 1, a, 10);
		equipment.weapon.setItem(pItem, a);
		return true;
	}

	internal void reloadInventory()
	{
		setStatsDirty();
	}

	public void stealActionFrom(Actor pTarget, float pTargetStunnedTimer = 5f, float pWaitTimerForThief = 1f, bool pAddAggro = true, bool pPossessedSteal = false)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		int num = pTarget.giveAllLootAndMoney();
		if (num > 0)
		{
			flag = true;
		}
		addLoot(num);
		pTarget.cancelAllBeh();
		pTarget.makeStunned(pTargetStunnedTimer);
		makeWait(pWaitTimerForThief);
		addStatusEffect("being_suspicious");
		if (pAddAggro)
		{
			pTarget.addAggro(this);
		}
		punchTargetAnimation(Vector2.op_Implicit(current_position), pFlip: false, pReverse: false, -40f);
		if ((hasSubspeciesMetaTag("steal_items") || hasTag("steal_items") || pPossessedSteal) && tryToStealItems(pTarget, pPossessedSteal))
		{
			flag = true;
		}
		if (flag)
		{
			pTarget.changeHappiness("got_robbed");
		}
	}

	public bool tryToStealItems(Actor pActorTarget, bool pPossessedSteal = false)
	{
		if (!understandsHowToUseItems())
		{
			return false;
		}
		if (!hasMeleeAttack())
		{
			return false;
		}
		float pChance = 0.5f;
		if (pPossessedSteal)
		{
			pChance = 1f;
		}
		if (takeItems(pActorTarget, pChance, 1))
		{
			pActorTarget.makeStunned(1f);
			checkAttackTypes();
			pActorTarget.checkAttackTypes();
			return true;
		}
		return false;
	}

	public bool tryToAcceptGift(Actor pActorTarget)
	{
		if (!understandsHowToUseItems())
		{
			return false;
		}
		if (takeItems(pActorTarget, 0.5f, 1))
		{
			checkAttackTypes();
			pActorTarget.checkAttackTypes();
			return true;
		}
		return false;
	}

	public void takeAllResources(Actor pActorTarget)
	{
		if (!pActorTarget.isCarryingResources())
		{
			return;
		}
		foreach (KeyValuePair<string, ResourceContainer> resource in pActorTarget.inventory.getResources())
		{
			inventory.add(resource.Value);
		}
		pActorTarget.inventory.empty();
	}

	public bool takeItems(Actor pActorTarget, float pChance = 1f, int pMaxItems = 0)
	{
		if (!understandsHowToUseItems())
		{
			return false;
		}
		if (!pActorTarget.hasEquipment())
		{
			return false;
		}
		using ListPool<ActorEquipmentSlot> listPool = new ListPool<ActorEquipmentSlot>(pActorTarget.equipment);
		bool result = false;
		if (pMaxItems == 0)
		{
			pMaxItems = listPool.Count;
		}
		foreach (ActorEquipmentSlot item3 in listPool.LoopRandom(pMaxItems))
		{
			if (!item3.isEmpty())
			{
				ActorEquipmentSlot slot = equipment.getSlot(item3.type);
				Item item = slot.getItem();
				Item item2 = item3.getItem();
				if (!item2.isCursed() && (slot.isEmpty() || (!item.isCursed() && item2.getValue() > item.getValue())))
				{
					result = true;
					item3.takeAwayItem();
					slot.setItem(item2, this);
					setStatsDirty();
					pActorTarget.setStatsDirty();
				}
			}
		}
		return result;
	}

	public void addToInventory(string pResourceID, int pAmount)
	{
		inventory = inventory.add(pResourceID, pAmount);
		setItemSpriteRenderDirty();
	}

	public void addToInventory(ResourceContainer pResourceContainer)
	{
		inventory = inventory.add(pResourceContainer);
		setItemSpriteRenderDirty();
	}

	public void takeFromInventory(string pID, int pAmount)
	{
		inventory = inventory.remove(pID, pAmount);
		setItemSpriteRenderDirty();
	}

	public void setSubspecies(Subspecies pObject)
	{
		World.world.subspecies.setDirtyUnits(subspecies);
		subspecies = pObject;
		World.world.subspecies.unitAdded(pObject);
		setStatsDirty();
	}

	public void joinLanguage(Language pLanguage)
	{
		if (language != pLanguage)
		{
			bool flag = false;
			if (hasLanguage())
			{
				language.increaseSpeakersLost();
				flag = true;
			}
			if (pLanguage != null)
			{
				if (!flag)
				{
					pLanguage.countNewSpeaker();
				}
				else
				{
					pLanguage.countConversion();
				}
			}
		}
		setLanguage(pLanguage);
	}

	public void setLanguage(Language pObject)
	{
		World.world.languages.setDirtyUnits(language);
		language = pObject;
		World.world.languages.unitAdded(pObject);
		setStatsDirty();
	}

	public void setPlot(Plot pObject)
	{
		World.world.plots.setDirtyUnits(plot);
		plot = pObject;
		World.world.plots.unitAdded(pObject);
		setStatsDirty();
	}

	public void setReligion(Religion pObject)
	{
		World.world.religions.setDirtyUnits(religion);
		religion = pObject;
		World.world.religions.unitAdded(pObject);
		setStatsDirty();
	}

	public void setFamily(Family pObject)
	{
		World.world.families.setDirtyUnits(family);
		family = pObject;
		World.world.families.unitAdded(pObject);
		setStatsDirty();
	}

	public void setClan(Clan pObject)
	{
		World.world.clans.setDirtyUnits(clan);
		clan = pObject;
		World.world.clans.unitAdded(pObject);
		setStatsDirty();
	}

	public void setCulture(Culture pCulture)
	{
		World.world.cultures.setDirtyUnits(culture);
		culture = pCulture;
		World.world.cultures.unitAdded(pCulture);
		setStatsDirty();
	}

	internal void removeFromArmy()
	{
		if (hasArmy())
		{
			Army obj = army;
			setArmy(null);
			obj.checkCaptainRemoval(this);
		}
	}

	public void setArmy(Army pObject)
	{
		World.world.armies.setDirtyUnits(army);
		army = pObject;
		World.world.armies.unitAdded(pObject);
		setStatsDirty();
	}

	internal void setCity(City pCity)
	{
		if (city != pCity)
		{
			if (city != null)
			{
				city.eventUnitRemoved(a);
			}
			World.world.cities.setDirtyUnits(city);
			city = pCity;
			if (city != null)
			{
				city.eventUnitAdded(a);
				setKingdom(city.kingdom);
			}
			World.world.cities.unitAdded(city);
			setStatsDirty();
		}
	}

	public void setMetasFromCity(City pCity)
	{
		if (pCity.hasCulture() && !hasCulture())
		{
			setCulture(pCity.culture);
		}
		if (pCity.hasLanguage() && !hasLanguage())
		{
			joinLanguage(pCity.language);
		}
		if (pCity.hasReligion() && !hasReligion())
		{
			setReligion(pCity.religion);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasClan()
	{
		return clan != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasSubspecies()
	{
		return subspecies != null;
	}

	public bool hasArmy()
	{
		return army != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasFamily()
	{
		return family != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasLanguage()
	{
		return language != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasPlot()
	{
		return plot != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasReligion()
	{
		return religion != null;
	}

	public bool tryToConvertToReligion(Religion pReligion)
	{
		if (!hasSubspecies() || !subspecies.has_advanced_memory)
		{
			return false;
		}
		if (hasReligion() && religion == pReligion)
		{
			return false;
		}
		if (hasCulture() && !culture.isPossibleToConvertToOtherMeta())
		{
			return false;
		}
		setReligion(pReligion);
		pReligion.countConversion();
		EffectsLibrary.showMetaEventEffectConversion("fx_conversion_religion", this);
		return true;
	}

	public bool tryToConvertToCulture(Culture pCulture)
	{
		if (!hasSubspecies() || !subspecies.has_advanced_memory)
		{
			return false;
		}
		if (hasCulture() && culture == pCulture)
		{
			return false;
		}
		if (hasCulture() && !culture.isPossibleToConvertToOtherMeta())
		{
			return false;
		}
		bool num = hasCulture();
		_ = culture;
		setCulture(pCulture);
		if (num)
		{
			pCulture.countConversion();
		}
		EffectsLibrary.showMetaEventEffectConversion("fx_conversion_culture", this);
		return true;
	}

	public bool tryToConvertToLanguage(Language pLanguage)
	{
		if (!hasSubspecies() || !subspecies.has_advanced_communication)
		{
			return false;
		}
		if (hasLanguage() && language == pLanguage)
		{
			return false;
		}
		if (hasCulture() && !culture.isPossibleToConvertToOtherMeta())
		{
			return false;
		}
		joinLanguage(pLanguage);
		EffectsLibrary.showMetaEventEffectConversion("fx_conversion_language", this);
		return true;
	}

	public void saveOriginFamily(long pID)
	{
		data.ancestor_family = pID;
	}

	private void clearManagers()
	{
		if (hasClan())
		{
			World.world.clans.unitDied(clan);
			clan = null;
		}
		if (hasArmy())
		{
			World.world.armies.unitDied(army);
			army = null;
		}
		if (hasCulture())
		{
			World.world.cultures.unitDied(culture);
			culture = null;
		}
		if (hasFamily())
		{
			World.world.families.unitDied(family);
			family = null;
		}
		if (hasLanguage())
		{
			World.world.languages.unitDied(language);
			language = null;
		}
		if (hasPlot())
		{
			World.world.plots.unitDied(plot);
			plot = null;
		}
		if (hasReligion())
		{
			World.world.religions.unitDied(religion);
			religion = null;
		}
	}

	internal bool isCitizenJob(string pJob)
	{
		if (citizen_job == null)
		{
			return false;
		}
		return citizen_job.id == pJob;
	}

	public void forgetCulture()
	{
		makeConfused();
		if (hasCulture())
		{
			setCulture(null);
		}
	}

	public void forgetReligion()
	{
		makeConfused();
		if (hasReligion())
		{
			setReligion(null);
		}
	}

	public void forgetLanguage()
	{
		makeConfused(10f);
		if (hasLanguage())
		{
			joinLanguage(null);
		}
	}

	public void forgetClan()
	{
		makeConfused();
		if (hasClan())
		{
			clan.tryForgetChief(this);
			setClan(null);
		}
	}

	public void forgetKingdomAndCity()
	{
		makeConfused();
		removeFromPreviousFaction();
		if (isKingdomCiv())
		{
			setDefaultKingdom();
		}
	}

	public void tryToConvertActorToMetaFromActor(Actor pActor, bool pStunOnSuccess = true)
	{
		int num = 0;
		if (pActor.hasCulture() && Randy.randomBool() && tryToConvertToCulture(pActor.culture))
		{
			num++;
		}
		if (pActor.hasLanguage() && Randy.randomBool() && tryToConvertToLanguage(pActor.language))
		{
			num++;
		}
		if (pActor.hasReligion() && Randy.randomBool() && tryToConvertToReligion(pActor.religion))
		{
			num++;
		}
		if (pStunOnSuccess)
		{
			if (num > 0)
			{
				makeStunned();
				applyRandomForce();
				addStatusEffect("voices_in_my_head");
			}
			else if (Randy.randomChance(0.1f))
			{
				makeConfused(Randy.randomFloat(0.8f, 5f));
			}
		}
	}

	public void joinCity(City pCity)
	{
		bool flag = !asset.is_boat;
		if (city != pCity)
		{
			bool flag2 = hasCity();
			if (flag2 && flag)
			{
				city.increaseLeft();
			}
			if (pCity != null)
			{
				if (pCity.kingdom != kingdom)
				{
					joinKingdom(pCity.kingdom);
				}
				if (flag)
				{
					if (flag2)
					{
						pCity.increaseMoved();
					}
					else
					{
						pCity.increaseJoined();
					}
				}
			}
		}
		setCity(pCity);
	}

	public void joinKingdom(Kingdom pKingdom)
	{
		if (!asset.is_boat && kingdom != pKingdom)
		{
			bool flag = hasKingdom();
			if (flag && kingdom.isCiv())
			{
				kingdom.increaseLeft();
			}
			if (pKingdom != null && pKingdom.isCiv())
			{
				if (flag)
				{
					pKingdom.increaseMoved();
				}
				else
				{
					pKingdom.increaseJoined();
				}
			}
		}
		setKingdom(pKingdom);
	}

	internal void setKingdom(Kingdom pKingdomToSet)
	{
		if (kingdom != pKingdomToSet)
		{
			checkKingdom();
			kingdom = pKingdomToSet;
			checkKingdom();
			setStatsDirty();
		}
	}

	private void checkKingdom()
	{
		if (hasKingdom())
		{
			if (kingdom.wild)
			{
				World.world.kingdoms_wild.setDirtyUnits(kingdom);
			}
			else
			{
				World.world.kingdoms.setDirtyUnits(kingdom);
			}
		}
	}

	public void setForcedKingdom(Kingdom pForcedKingdom)
	{
		if (!(kingdom.asset.id == pForcedKingdom.asset.id))
		{
			joinKingdom(pForcedKingdom);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasCulture()
	{
		return culture != null;
	}

	public bool buildCityAndStartCivilization()
	{
		if (!World.world.cities.canStartNewCityCivilizationHere(this))
		{
			return false;
		}
		Kingdom obj = World.world.kingdoms.makeNewCivKingdom(this);
		City city = World.world.cities.buildFirstCivilizationCity(this);
		createDefaultCultureAndLanguageAndClan(city.name);
		obj.setUnitMetas(this);
		city.setUnitMetas(this);
		return true;
	}

	public void createDefaultCultureAndLanguageAndClan(string pCultureName = null)
	{
		if (!hasClan())
		{
			World.world.clans.newClan(this, pAddDefaultTraits: true);
		}
		if (!hasLanguage() && subspecies.has_advanced_communication)
		{
			Language language = World.world.languages.newLanguage(this, pAddDefaultTraits: true);
			joinLanguage(language);
			language.convertSameSpeciesAroundUnit(this);
		}
		if (!hasCulture() && subspecies.has_advanced_memory)
		{
			Culture culture = World.world.cultures.newCulture(this, pAddDefaultTraits: true);
			if (pCultureName != null)
			{
				culture.setName(pCultureName, pTrack: false);
			}
			setCulture(culture);
			culture.convertSameSpeciesAroundUnit(this);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void checkDefaultKingdom()
	{
		if (!hasKingdom())
		{
			setDefaultKingdom();
		}
	}

	public void setDefaultKingdom()
	{
		setKingdom(World.world.kingdoms_wild.get(asset.kingdom_id_wild));
	}

	public void removeFromPreviousFaction()
	{
		stopBeingWarrior();
		if (isKing())
		{
			kingdom.kingLeftEvent();
		}
		joinCity(null);
	}

	public bool wantsToSplitMeta()
	{
		if (hasKingdom() && isKingdomCiv() && hasSubspecies() && kingdom.getMainSubspecies() == subspecies)
		{
			return false;
		}
		if (hasTrait("ambitious"))
		{
			return true;
		}
		if (hasStatus("inspired"))
		{
			return true;
		}
		return false;
	}

	public NanoObject getMetaObjectOfType(MetaType pType)
	{
		return pType switch
		{
			MetaType.Alliance => kingdom.getAlliance(), 
			MetaType.Kingdom => kingdom, 
			MetaType.City => city, 
			MetaType.Clan => clan, 
			MetaType.Culture => culture, 
			MetaType.Family => family, 
			MetaType.Army => army, 
			MetaType.Language => language, 
			MetaType.Religion => religion, 
			MetaType.Subspecies => subspecies, 
			_ => null, 
		};
	}

	internal void setFlip(bool pFlip)
	{
		flip = pFlip;
	}

	public void precalcMovementSpeed(bool pForce = false)
	{
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		if (!pForce)
		{
			if (!is_moving)
			{
				return;
			}
			if (_precalc_movement_speed_skips > 0)
			{
				_precalc_movement_speed_skips--;
				return;
			}
			_precalc_movement_speed_skips = 5;
		}
		bool flag = isInAir();
		bool flag2 = isWaterCreature();
		float num = 1f;
		if (asset.ignore_tile_speed_multiplier || flag || flag2)
		{
			num = 1f;
		}
		else if (current_tile.is_liquid)
		{
			if (getStamina() <= 0 && !hasTag("fast_swimming"))
			{
				num *= 0.4f;
			}
		}
		else if (!string.IsNullOrEmpty(current_tile.Type.ignore_walk_multiplier_if_tag) && !stats.hasTag(current_tile.Type.ignore_walk_multiplier_if_tag))
		{
			num = current_tile.Type.walk_multiplier;
		}
		if (!asset.ignore_tile_speed_multiplier && _is_in_liquid && hasTag("fast_swimming"))
		{
			num *= 5f;
		}
		if (hasTask() && ai.task.speed_multiplier != 1f)
		{
			num *= ai.task.speed_multiplier;
		}
		float num2 = stats["speed"] * num;
		if (!flag && WorldLawLibrary.world_law_entanglewood.isEnabled())
		{
			Building building = current_tile.building;
			if (building != null && building.asset.flora_type == FloraType.Tree)
			{
				num2 *= 0.8f;
			}
		}
		if (num2 < 1f)
		{
			num2 = 1f;
		}
		if (DebugConfig.isOn(DebugOption.UnitsAlwaysFast))
		{
			num2 *= 20f;
		}
		num2 *= 0.4f;
		_current_combined_movement_speed = num2 * SimGlobals.m.unit_speed_multiplier;
		if (tile_target != null)
		{
			float num3 = Toolbox.DistVec2Float(current_position, Vector2.op_Implicit(tile_target.posV3));
			if (num3 < 1f && _current_combined_movement_speed > 3f)
			{
				float num4 = Mathf.Lerp(1f, 0.3f, 1f - num3);
				_current_combined_movement_speed *= num4;
			}
		}
	}

	internal bool checkFlip()
	{
		return asset.check_flip(this);
	}

	protected void updateMovement(float pElapsed, float pWalkedDistance = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float num = Toolbox.DistVec2Float(current_position, next_step_position);
		if (asset.can_flip && checkFlip())
		{
			if (current_position.x < next_step_position.x)
			{
				setFlip(pFlip: true);
			}
			else
			{
				setFlip(pFlip: false);
			}
		}
		float movementDelta = getMovementDelta(pElapsed, pWalkedDistance);
		if (num < movementDelta)
		{
			movementDelta = num;
			current_position = next_step_position;
			if (isUsingPath())
			{
				updatePathMovement();
			}
			else
			{
				stopMovement();
			}
			if (is_moving)
			{
				updateMovement(pElapsed, pWalkedDistance + movementDelta);
			}
		}
		else
		{
			current_position = Vector2.MoveTowards(current_position, next_step_position, movementDelta);
		}
	}

	private float getMovementDelta(float pElapsed, float pWalkedDistance = 0f)
	{
		float current_combined_movement_speed = _current_combined_movement_speed;
		current_combined_movement_speed *= pElapsed;
		current_combined_movement_speed -= pWalkedDistance;
		if (current_combined_movement_speed < 0f)
		{
			current_combined_movement_speed = 0f;
		}
		return current_combined_movement_speed;
	}

	internal void updateMovementPossessedFlip()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (InputHelpers.mouseSupported)
		{
			checkFlipAgainstTargetPosition(World.world.getMousePos());
		}
		else if (ControllableUnit.isMovementActionActive() && !isPossessionAttackJustHappened())
		{
			Vector2 pPosition = ControllableUnit.getMovementVector() + current_position;
			checkFlipAgainstTargetPosition(pPosition);
		}
	}

	public void checkFlipAgainstTargetPosition(Vector2 pPosition)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (asset.can_flip)
		{
			if (current_position.x < pPosition.x)
			{
				setFlip(pFlip: true);
			}
			else
			{
				setFlip(pFlip: false);
			}
		}
	}

	internal float updatePossessedMovementTowards(float pElapsed, Vector2 pMovementPoint)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		precalcMovementSpeed(pForce: true);
		if (asset.can_flip && checkFlip())
		{
			float mismatchFactorForSideMovement = getMismatchFactorForSideMovement(pMovementPoint);
			if (mismatchFactorForSideMovement > 0.2f)
			{
				pElapsed *= Mathf.Lerp(1f, 0.8f, mismatchFactorForSideMovement);
			}
		}
		float movementDelta = getMovementDelta(pElapsed);
		Vector2 pNewPos = Vector2.MoveTowards(current_position, pMovementPoint, movementDelta);
		pNewPos = checkVelocityAgainstBlock(pNewPos);
		if (!Toolbox.inMapBorder(ref pNewPos))
		{
			return 0f;
		}
		current_position = pNewPos;
		return movementDelta;
	}

	public Vector2 getPossessionControlTargetPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return ControllableUnit.getClickVector();
	}

	public Vector2 getPossessionControlTargetPositionMovementVector()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (InputHelpers.mouseSupported)
		{
			return ControllableUnit.getClickVector();
		}
		return ControllableUnit.getMovementVector() + current_position;
	}

	private float getMismatchFactorForSideMovement(Vector2 pMovementPoint)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mousePos = World.world.getMousePos();
		bool flag = current_position.x < mousePos.x;
		bool flag2 = current_position.x < pMovementPoint.x;
		bool num = current_position.y < mousePos.y;
		bool flag3 = current_position.y < pMovementPoint.y;
		float num2 = Mathf.Abs(pMovementPoint.x - current_position.x);
		float num3 = Mathf.Abs(pMovementPoint.y - current_position.y);
		float num4 = 0f;
		if (flag != flag2)
		{
			num4 += num2;
		}
		if (num != flag3)
		{
			num4 += num3;
		}
		return Mathf.Clamp01(num4 / (num2 + num3 + 0.001f));
	}

	internal void findCurrentTile(bool pCheckNeighbours = true)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector2.op_Implicit(current_position);
		if (!dirty_current_tile && val.x == lastX && val.y == lastY)
		{
			return;
		}
		dirty_current_tile = false;
		lastX = current_position.x;
		lastY = current_position.y;
		if (current_tile != null && Toolbox.SquaredDist(current_tile.posV3.x, current_tile.posV3.y, val.x, val.y) < 0.16000001f)
		{
			return;
		}
		WorldTile tileAt = Toolbox.getTileAt(val.x, val.y);
		setCurrentTile(tileAt);
		if (Toolbox.SquaredDist(tileAt.posV3.x, tileAt.posV3.y, val.x, val.y) < 0.09f || !pCheckNeighbours || isFlying())
		{
			return;
		}
		bool flag = mustAvoidGround();
		if (tileAt.Type.lava && asset.die_in_lava)
		{
			WorldTile[] neighboursAll = tileAt.neighboursAll;
			foreach (WorldTile worldTile in neighboursAll)
			{
				if (worldTile.Type.ground)
				{
					setCurrentTile(worldTile);
					break;
				}
			}
		}
		if (tileAt.Type.ocean && isDamagedByOcean())
		{
			WorldTile[] neighboursAll2 = tileAt.neighboursAll;
			foreach (WorldTile worldTile2 in neighboursAll2)
			{
				if (!worldTile2.is_liquid)
				{
					setCurrentTile(worldTile2);
					break;
				}
			}
		}
		if (tileAt.Type.block && !isFlying() && !flag)
		{
			WorldTile[] neighboursAll3 = tileAt.neighboursAll;
			foreach (WorldTile worldTile3 in neighboursAll3)
			{
				if (worldTile3.Type.ground)
				{
					setCurrentTile(worldTile3);
					break;
				}
			}
		}
		if (!tileAt.is_liquid && flag)
		{
			WorldTile[] neighboursAll4 = tileAt.neighboursAll;
			foreach (WorldTile worldTile4 in neighboursAll4)
			{
				if (worldTile4.is_liquid)
				{
					setCurrentTile(worldTile4);
					break;
				}
			}
		}
		if (!tileAt.isOnFire() || isImmuneToFire())
		{
			return;
		}
		WorldTile[] neighboursAll5 = tileAt.neighboursAll;
		foreach (WorldTile worldTile5 in neighboursAll5)
		{
			if (!worldTile5.isOnFire())
			{
				setCurrentTile(worldTile5);
				break;
			}
		}
	}

	internal void checkFindCurrentTile()
	{
		if (dirty_current_tile || (_next_step_tile != null && (float)Toolbox.SquaredDistTile(current_tile, _next_step_tile) > 4f))
		{
			findCurrentTile();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void setTileTarget(WorldTile pTile)
	{
		clearTileTarget();
		tile_target = pTile;
		tile_target.setTargetedBy(a);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void clearTileTarget()
	{
		if (tile_target != null)
		{
			if (tile_target.isTargetedBy(this))
			{
				tile_target.cleanTargetedBy();
			}
			tile_target = null;
			scheduled_tile_target = null;
		}
	}

	internal void clearOldPath()
	{
		current_path.Clear();
		current_path_global = null;
		current_path_index = 0;
	}

	public virtual void updatePathMovement()
	{
		if (!isFollowingLocalPath())
		{
			setNotMoving();
			if (split_path != SplitPathStatus.Split)
			{
				split_path = SplitPathStatus.Split;
				timer_action = Randy.randomFloat(0f, asset.path_movement_timeout);
				return;
			}
			split_path = SplitPathStatus.Normal;
			if (tile_target != null)
			{
				goTo(tile_target);
			}
			return;
		}
		WorldTile worldTile = current_path[current_path_index];
		TileTypeBase type = worldTile.Type;
		current_path_index++;
		if (type.damaged_when_walked)
		{
			current_tile.tryToBreak();
		}
		bool flag = true;
		if (_has_status_strange_urge)
		{
			flag = false;
		}
		if (flag)
		{
			if (asset.is_boat && !worldTile.isGoodForBoat())
			{
				callbacks_cancel_path_movement?.Invoke(this);
				cancelAllBeh();
				return;
			}
			if (type.block && !ignoresBlocks())
			{
				if (!hasTask() || !ai.task.move_from_block)
				{
					cancelAllBeh();
					return;
				}
			}
			else
			{
				if (asset.die_in_lava && type.lava)
				{
					cancelAllBeh();
					return;
				}
				if (isDamagedByOcean() && type.ocean && !_is_in_liquid)
				{
					cancelAllBeh();
					return;
				}
			}
		}
		if (worldTile.isOnFire() && !isImmuneToFire() && !hasStatus("burning") && !current_tile.isOnFire())
		{
			if (hasTask() && ai.task.is_fireman)
			{
				stopMovement();
				return;
			}
			cancelAllBeh();
			makeWait(0.3f);
		}
		else
		{
			moveTo(worldTile);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isFollowingLocalPath()
	{
		if (current_path.Count > 0 && current_path_index < current_path.Count)
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isUsingPath()
	{
		if (isFollowingLocalPath() || current_path_global != null)
		{
			return true;
		}
		return false;
	}

	public ExecuteEvent goTo(WorldTile pTile, bool pPathOnWater = false, bool pWalkOnBlocks = false, bool pWalkOnLava = false, int pLimitPathfindingRegions = 0)
	{
		setTileTarget(pTile);
		return ActorMove.goTo(this, pTile, pPathOnWater, pWalkOnBlocks, pWalkOnLava, pLimitPathfindingRegions);
	}

	public void clearPathForCalibration()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		clearOldPath();
		next_step_position = current_position;
	}

	private void finishStrangeUrgeMovement()
	{
		_has_status_strange_urge = false;
		finishStatusEffect("strange_urge");
		setTask("strange_urge_finish");
	}

	public void stopMovement()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		split_path = SplitPathStatus.Normal;
		_next_step_tile = null;
		clearOldPath();
		clearTileTarget();
		setNotMoving();
		next_step_position = Vector2.op_Implicit(Globals.emptyVector);
		dirty_current_tile = true;
		if (_has_status_strange_urge)
		{
			finishStrangeUrgeMovement();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void setIsMoving()
	{
		if (!is_moving)
		{
			_is_moving = true;
			batch.c_update_movement.Add(a);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void setNotMoving()
	{
		if (is_moving)
		{
			_is_moving = false;
			batch.c_update_movement.Remove(a);
		}
	}

	public void setPossessedMovement(bool pValue)
	{
		_possessed_movement = pValue;
	}

	public void moveTo(WorldTile pTileTarget)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		setIsMoving();
		if (!has_attack_target && current_tile != null && pTileTarget.isOnFire() && !current_tile.isOnFire() && !isImmuneToFire())
		{
			cancelAllBeh();
			return;
		}
		_next_step_tile = pTileTarget;
		if ((float)Toolbox.SquaredDistTile(current_tile, pTileTarget) > 4f)
		{
			dirty_current_tile = true;
		}
		else
		{
			setCurrentTile(_next_step_tile);
		}
		checkStepActionForTile(current_tile);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))._002Ector(pTileTarget.posV3.x, pTileTarget.posV3.y);
		next_step_position = Vector2.op_Implicit(val);
	}

	public Vector3 updatePos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector2.op_Implicit(current_position);
		Vector2 val2 = shake_offset;
		Vector2 val3 = move_jump_offset;
		float num = val.x + val3.x + val2.x;
		float num2 = val.y + val3.y + val2.y;
		num2 += position_height;
		((Vector2)(ref current_shadow_position)).Set(val.x + val2.x, val.y + val2.y);
		float num3 = position_height;
		((Vector3)(ref cur_transform_position)).Set(num, num2, num3);
		return cur_transform_position;
	}

	public void stayInBuilding(Building pBuilding)
	{
		is_inside_building = true;
		inside_building = pBuilding;
	}

	internal void exitBuilding()
	{
		if (is_inside_building)
		{
			timer_action = 0f;
			is_inside_building = false;
			inside_building = null;
		}
	}

	internal void embarkInto(Boat pBoat)
	{
		stopMovement();
		data.transportID = pBoat.actor.data.id;
		is_inside_boat = true;
		inside_boat = pBoat;
		inside_boat.addPassenger(this);
		setTask("sit_inside_boat");
		ai.update();
	}

	internal void disembarkTo(Boat pBoat, WorldTile pTile)
	{
		spawnOn(pTile);
		data.transportID = -1L;
		exitBoat();
		setTask("short_move");
	}

	internal void exitBoat()
	{
		inside_boat = null;
		is_inside_boat = false;
		dirty_current_tile = true;
	}

	internal void changeMoveJumpOffset(float pValue)
	{
		move_jump_offset.y += pValue;
		if (move_jump_offset.y < 0f)
		{
			move_jump_offset.y = 0f;
		}
	}

	internal void setCurrentTile(WorldTile pTile)
	{
		current_tile = pTile;
	}

	internal void setCurrentTilePosition(WorldTile pTile)
	{
		setCurrentTile(pTile);
		((Vector2)(ref current_position)).Set(pTile.posV3.x, pTile.posV3.y);
	}

	protected void updateWalkJump(float pElapsed)
	{
		if ((!is_visible && move_jump_offset.y == 0f) || position_height > 0f || asset.disable_jump_animation)
		{
			return;
		}
		if (!is_moving)
		{
			if (move_jump_offset.y == 0f && (_jump_time == 0f || isAffectedByLiquid()))
			{
				return;
			}
		}
		else if ((!is_moving && _jump_time == 0f) || isAffectedByLiquid())
		{
			return;
		}
		_jump_time += World.world.elapsed * 6f;
		if (_jump_time >= 1f)
		{
			changeMoveJumpOffset(-3f * pElapsed);
		}
		else
		{
			changeMoveJumpOffset(3f * pElapsed);
		}
		if (_jump_time >= 2f)
		{
			_jump_time = 0f;
			changeMoveJumpOffset(0f);
		}
		if (asset.rotating_animation)
		{
			target_angle.z += (0f - move_jump_offset.y) * 200f * World.world.elapsed;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool inMapBorder()
	{
		return Toolbox.inMapBorder(ref current_position);
	}

	protected virtual void updateVelocity()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (under_forces)
		{
			dirty_current_tile = true;
			float fixed_delta_time = World.world.fixed_delta_time;
			float num = fixed_delta_time * velocity_speed;
			float num2 = stats["mass"] * SimGlobals.m.gravity;
			num2 = Mathf.Min(num2, 20f);
			float num3 = velocity.z * fixed_delta_time * num2;
			position_height += num3;
			velocity.z -= fixed_delta_time * num2 * 0.3f;
			Vector3 val = Vector2.op_Implicit(current_position);
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))._002Ector(val.x + velocity.x * num, val.y + velocity.y * num);
			val2 = checkVelocityAgainstBlock(val2);
			((Vector2)(ref current_position)).Set(val2.x, val2.y);
			if (position_height < 0f)
			{
				position_height = 0f;
				velocity.z = 0f;
			}
			if (position_height <= 0f)
			{
				stopForce();
			}
		}
	}

	private Vector2 checkVelocityAgainstBlock(Vector2 pNewPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		WorldTile tileAt = Toolbox.getTileAt(pNewPos.x, pNewPos.y);
		if (current_tile.Type.block && (!current_tile.Type.mountains || tileAt.Type.mountains))
		{
			return pNewPos;
		}
		if (tileAt == current_tile)
		{
			return pNewPos;
		}
		if (asset.is_boat)
		{
			if (tileAt.Type.liquid)
			{
				return pNewPos;
			}
		}
		else
		{
			if (!tileAt.Type.block)
			{
				return pNewPos;
			}
			if (getHeight() > tileAt.Type.block_height)
			{
				return pNewPos;
			}
		}
		Vector2 wallNormal = getWallNormal(pNewPos, Vector2.op_Implicit(tileAt.posV3));
		float num = 0.8f;
		float num2 = velocity.x * wallNormal.x + velocity.y * wallNormal.y;
		float num3 = velocity.x - 2f * num2 * wallNormal.x;
		float num4 = velocity.y - 2f * num2 * wallNormal.y;
		velocity.x = num3 * num;
		velocity.y = num4 * num;
		pNewPos.x = current_position.x;
		pNewPos.y = current_position.y;
		return pNewPos;
	}

	private Vector2 getWallNormal(Vector2 pPosition, Vector2 pBlockPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = pPosition - pBlockPosition;
		Vector2 normalized = ((Vector2)(ref val)).normalized;
		if (Mathf.Abs(normalized.x) > Mathf.Abs(normalized.y))
		{
			return new Vector2(Mathf.Sign(normalized.x), 0f);
		}
		return new Vector2(0f, Mathf.Sign(normalized.y));
	}

	public void prepareForSave()
	{
		saveCoordinates();
		saveAssetID();
		saveProfession();
		saveHomeBuilding();
		saveEquipment();
		saveLover();
		saveCity();
		saveKingdomCiv();
		saveCulture();
		saveClan();
		saveSubspecies();
		saveFamily();
		saveArmy();
		saveLanguage();
		savePlot();
		saveReligion();
		saveTraits();
		finishSaving();
	}

	private void saveCoordinates()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ActorData actorData = data;
		Vector2Int pos = current_tile.pos;
		actorData.x = ((Vector2Int)(ref pos)).x;
		ActorData actorData2 = data;
		pos = current_tile.pos;
		actorData2.y = ((Vector2Int)(ref pos)).y;
	}

	private void saveAssetID()
	{
		data.asset_id = asset.id;
	}

	private void saveProfession()
	{
		data.profession = _profession;
	}

	private void saveHomeBuilding()
	{
		if (_home_building != null && _home_building.isUsable() && !_home_building.isAbandoned())
		{
			data.homeBuildingID = _home_building.data.id;
		}
		else
		{
			data.homeBuildingID = -1L;
		}
	}

	private void saveEquipment()
	{
		if (hasEquipment())
		{
			List<long> dataForSave = equipment.getDataForSave();
			data.saved_items = dataForSave;
		}
	}

	private void saveLover()
	{
		if (hasLover())
		{
			data.lover = lover.data.id;
		}
		else
		{
			data.lover = -1L;
		}
	}

	private void saveCity()
	{
		if (hasCity() && city.isAlive())
		{
			data.cityID = city.id;
		}
		else
		{
			data.cityID = -1L;
		}
	}

	private void saveKingdomCiv()
	{
		if (isKingdomCiv())
		{
			data.civ_kingdom_id = kingdom.id;
		}
		else
		{
			data.civ_kingdom_id = -1L;
		}
	}

	private void saveCulture()
	{
		if (hasCulture())
		{
			data.culture = culture.id;
		}
		else
		{
			data.culture = -1L;
		}
	}

	private void saveClan()
	{
		if (hasClan())
		{
			data.clan = clan.id;
		}
		else
		{
			data.clan = -1L;
		}
	}

	private void saveSubspecies()
	{
		if (hasSubspecies())
		{
			data.subspecies = subspecies.id;
		}
		else
		{
			data.subspecies = -1L;
		}
	}

	private void saveFamily()
	{
		if (hasFamily())
		{
			data.family = family.id;
		}
		else
		{
			data.family = -1L;
		}
	}

	private void saveArmy()
	{
		if (hasArmy())
		{
			data.army = army.id;
		}
		else
		{
			data.army = -1L;
		}
	}

	private void saveLanguage()
	{
		if (hasLanguage())
		{
			data.language = language.id;
		}
		else
		{
			data.language = -1L;
		}
	}

	private void savePlot()
	{
		if (hasPlot())
		{
			data.plot = plot.id;
		}
		else
		{
			data.plot = -1L;
		}
	}

	private void saveReligion()
	{
		if (hasReligion())
		{
			data.religion = religion.id;
		}
		else
		{
			data.religion = -1L;
		}
	}

	private void saveTraits()
	{
		data.saved_traits = Toolbox.getListForSave(getTraits());
	}

	private void finishSaving()
	{
		data.save();
	}

	public void loadFromSave()
	{
		setStatsDirty();
		TraitTools.loadTraits(this, data.saved_traits);
		foreach (ActorTrait trait in traits)
		{
			trait.action_on_augmentation_load?.Invoke(this, trait);
		}
		if (isSapient() && is_profession_nothing)
		{
			data.profession = UnitProfession.Unit;
		}
		setProfession(data.profession, pCancelBeh: false);
		City city = World.world.cities.get(data.cityID);
		Kingdom kingdom = World.world.kingdoms.get(data.civ_kingdom_id);
		if (city != null && !city.isNeutral())
		{
			setCity(city);
		}
		if (kingdom != null)
		{
			setKingdom(kingdom);
		}
		if (hasEquipment())
		{
			foreach (ActorEquipmentSlot item2 in equipment)
			{
				if (item2.isEmpty())
				{
					continue;
				}
				Item item = item2.getItem();
				int num = 0;
				while (num < item.data.modifiers.Count)
				{
					if (AssetManager.items_modifiers.get(item.data.modifiers[num]) == null)
					{
						item.data.modifiers.RemoveAt(num);
					}
					else
					{
						num++;
					}
				}
			}
		}
		if (data.inventory.isEmpty())
		{
			data.inventory.empty();
		}
		foreach (Actor parent in getParents())
		{
			parent.increaseChildren();
		}
		asset.action_on_load?.Invoke(this);
	}

	private void countDeath(AttackType pType)
	{
		World.world.game_stats.data.creaturesDied++;
		World.world.map_stats.deaths++;
		switch (pType)
		{
		case AttackType.Plague:
			World.world.map_stats.deaths_plague++;
			break;
		case AttackType.Starvation:
			World.world.map_stats.deaths_hunger++;
			break;
		case AttackType.Eaten:
			World.world.map_stats.deaths_eaten++;
			break;
		case AttackType.Age:
			World.world.map_stats.deaths_age++;
			break;
		case AttackType.Poison:
			World.world.map_stats.deaths_poison++;
			break;
		case AttackType.Infection:
			World.world.map_stats.deaths_infection++;
			break;
		case AttackType.Tumor:
			World.world.map_stats.deaths_tumor++;
			break;
		case AttackType.Acid:
			World.world.map_stats.deaths_acid++;
			break;
		case AttackType.Fire:
			World.world.map_stats.deaths_fire++;
			break;
		case AttackType.Divine:
			World.world.map_stats.deaths_divine++;
			break;
		case AttackType.Metamorphosis:
			World.world.map_stats.metamorphosis++;
			break;
		case AttackType.Weapon:
			World.world.map_stats.deaths_weapon++;
			break;
		case AttackType.Gravity:
			World.world.map_stats.deaths_gravity++;
			break;
		case AttackType.Drowning:
			World.world.map_stats.deaths_drowning++;
			break;
		case AttackType.Water:
			World.world.map_stats.deaths_water++;
			break;
		case AttackType.Explosion:
			World.world.map_stats.deaths_explosion++;
			break;
		case AttackType.Smile:
			World.world.map_stats.deaths_smile++;
			break;
		default:
			throw new ArgumentOutOfRangeException($"Unknown attack type: {pType}");
		case AttackType.Other:
		case AttackType.AshFever:
		case AttackType.None:
			break;
		}
		if (hasArmy())
		{
			army.increaseDeaths(pType);
		}
		if (hasCity())
		{
			city.increaseDeaths(pType);
		}
		if (hasClan())
		{
			clan.increaseDeaths(pType);
		}
		if (hasCulture())
		{
			culture.increaseDeaths(pType);
		}
		if (hasFamily())
		{
			family.increaseDeaths(pType);
		}
		if (hasLanguage())
		{
			language.increaseDeaths(pType);
		}
		if (hasReligion())
		{
			religion.increaseDeaths(pType);
		}
		if (hasSubspecies())
		{
			subspecies.increaseDeaths(pType);
		}
		if (isKingdomCiv())
		{
			kingdom.increaseDeaths(pType);
		}
		foreach (Actor parent in getParents())
		{
			parent.decreaseChildren();
		}
	}

	public void increaseEvolutions()
	{
		World.world.map_stats.evolutions++;
		if (hasCity())
		{
			city.increaseEvolutions();
		}
		if (hasClan())
		{
			clan.increaseEvolutions();
		}
		if (hasReligion())
		{
			religion.increaseEvolutions();
		}
		if (hasSubspecies())
		{
			subspecies.increaseEvolutions();
		}
		if (isKingdomCiv())
		{
			kingdom.increaseEvolutions();
		}
	}

	private void increaseKills()
	{
		data.kills++;
		if (hasArmy())
		{
			army.increaseKills();
		}
		if (hasCity())
		{
			city.increaseKills();
		}
		if (hasClan())
		{
			clan.increaseKills();
		}
		if (hasCulture())
		{
			culture.increaseKills();
		}
		if (hasFamily())
		{
			family.increaseKills();
		}
		if (hasLanguage())
		{
			language.increaseKills();
		}
		if (hasReligion())
		{
			religion.increaseKills();
		}
		if (hasSubspecies())
		{
			subspecies.increaseKills();
		}
		if (isKingdomCiv())
		{
			kingdom.increaseKills();
		}
	}

	public void increaseChildren()
	{
		_current_children++;
	}

	public void decreaseChildren()
	{
		_current_children--;
	}

	public void increaseBirths()
	{
		data.births++;
	}

	public void applyForcedKingdomTrait()
	{
		removeFromPreviousFaction();
		removeTrait("peaceful");
		startShake(0.3f, 0.2f);
		startColorEffect();
		cancelAllBeh();
	}

	public string getTraitsAsLocalizedString()
	{
		string text = "";
		foreach (ActorTrait trait in traits)
		{
			text = text + trait.getTranslatedName() + ", ";
		}
		return text;
	}

	public void sortTraits(IReadOnlyCollection<ActorTrait> pTraits)
	{
		if (!traits.SetEquals(pTraits))
		{
			return;
		}
		traits.Clear();
		foreach (ActorTrait pTrait in pTraits)
		{
			traits.Add(pTrait);
		}
	}

	public void traitModifiedEvent()
	{
	}

	public void removeTrait(string pTraitID)
	{
		ActorTrait pTrait = AssetManager.traits.get(pTraitID);
		removeTrait(pTrait);
	}

	public bool removeTrait(ActorTrait pTrait)
	{
		bool num = traits.Remove(pTrait);
		if (num)
		{
			pTrait.action_on_augmentation_remove?.Invoke(this, pTrait);
			setStatsDirty();
			clearTraitCache();
		}
		return num;
	}

	public void removeTraits(ICollection<ActorTrait> pTraits)
	{
		bool flag = false;
		foreach (ActorTrait pTrait in pTraits)
		{
			if (traits.Remove(pTrait))
			{
				pTrait.action_on_augmentation_remove?.Invoke(this, pTrait);
				flag = true;
			}
		}
		if (flag)
		{
			setStatsDirty();
			clearTraitCache();
		}
	}

	public void clearTraitCache()
	{
		_traits_cache.Clear();
	}

	private void removeOppositeTraits(ActorTrait pTrait)
	{
		if (pTrait.hasOppositeTraits())
		{
			removeTraits(pTrait.opposite_traits);
		}
	}

	public bool addTrait(string pTraitID, bool pRemoveOpposites = false)
	{
		ActorTrait actorTrait = AssetManager.traits.get(pTraitID);
		if (actorTrait == null)
		{
			return false;
		}
		return addTrait(actorTrait, pRemoveOpposites);
	}

	public bool addTrait(ActorTrait pTrait, bool pRemoveOpposites = false)
	{
		if (hasTrait(pTrait))
		{
			return false;
		}
		if (pTrait.affects_mind && hasTag("strong_mind"))
		{
			return false;
		}
		if (pTrait.traits_to_remove != null)
		{
			removeTraits(pTrait.traits_to_remove);
		}
		if (pRemoveOpposites)
		{
			removeOppositeTraits(pTrait);
		}
		else if (hasOppositeTrait(pTrait))
		{
			return false;
		}
		traits.Add(pTrait);
		pTrait.action_on_augmentation_add?.Invoke(this, pTrait);
		setStatsDirty();
		clearTraitCache();
		return true;
	}

	internal bool hasOppositeTrait(string pTraitID)
	{
		return TraitTools.hasOppositeTrait(pTraitID, traits);
	}

	internal bool hasOppositeTrait(ActorTrait pTrait)
	{
		return pTrait.hasOppositeTrait(traits);
	}

	public void generateRandomSpawnTraits(ActorAsset pAsset)
	{
		if (pAsset.traits != null)
		{
			for (int i = 0; i < pAsset.traits.Count; i++)
			{
				string pTraitID = pAsset.traits[i];
				addTrait(pTraitID);
			}
		}
	}

	public void checkTraitMutationOnBirth()
	{
		if (!hasSubspecies())
		{
			return;
		}
		int amountOfRandomMutationsActorTraits = subspecies.getAmountOfRandomMutationsActorTraits();
		if (amountOfRandomMutationsActorTraits == 0)
		{
			return;
		}
		for (int i = 0; i < amountOfRandomMutationsActorTraits; i++)
		{
			ActorTrait random = AssetManager.traits.pot_traits_birth.GetRandom();
			if (asset.traits_ignore == null || !asset.traits_ignore.Contains(random.id))
			{
				addTrait(random);
			}
		}
	}

	public void checkTraitMutationGrowUp()
	{
		if (!hasSubspecies())
		{
			return;
		}
		int num = Randy.randomInt(0, 3);
		for (int i = 0; i < num; i++)
		{
			ActorTrait random = AssetManager.traits.pot_traits_growup.GetRandom();
			if ((asset.traits_ignore == null || !asset.traits_ignore.Contains(random.id)) && (!random.acquire_grow_up_sapient_only || isSapient()))
			{
				addTrait(random);
			}
		}
	}

	public int countTraits()
	{
		return traits.Count;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasTrait(string pTraitID)
	{
		if (!_traits_cache.TryGetValue(pTraitID, out var value))
		{
			ActorTrait pTrait = AssetManager.traits.get(pTraitID);
			value = hasTrait(pTrait);
			_traits_cache[pTraitID] = value;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasTrait(ActorTrait pTrait)
	{
		return traits.Contains(pTrait);
	}

	public void updateParallelChecks(float pElapsed)
	{
		_update_done = false;
		_beh_skip = false;
		if (timer_jump_animation > 0f)
		{
			timer_jump_animation -= pElapsed;
		}
		checkFindCurrentTile();
		checkIsInLiquid();
		if (asset.update_z && position_height != 0f)
		{
			updateFall();
		}
		if (attackedBy != null && !attackedBy.isAlive())
		{
			attackedBy = null;
		}
		if (is_inside_boat)
		{
			return;
		}
		updateFlipRotation(pElapsed);
		if (under_forces)
		{
			for (int i = 0; (float)i < Config.time_scale_asset.multiplier; i++)
			{
				updateVelocity();
			}
		}
		if (!World.world.isPaused() && isAlive())
		{
			updateRotations(pElapsed);
			if (attack_timer >= 0f)
			{
				attack_timer -= pElapsed;
			}
			updateWalkJump(World.world.delta_time);
			if (_timeout_targets >= 0f)
			{
				_timeout_targets -= World.world.delta_time;
			}
			if (timer_action >= 0f)
			{
				timer_action -= pElapsed;
			}
			if (isAllowedToLookForEnemies())
			{
				targets_to_ignore_timer.update(pElapsed);
			}
			updateChangeScale(pElapsed);
			if (!is_immovable)
			{
				precalcMovementSpeed();
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void skipUpdates()
	{
		_update_done = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void skipBehaviour()
	{
		_beh_skip = true;
	}

	public void u1_checkInside(float pElapsed)
	{
		if (isInsideSomething() && is_inside_boat)
		{
			setCurrentTilePosition(inside_boat.actor.current_tile);
			skipUpdates();
		}
	}

	public void u2_updateChildren(float pElapsed)
	{
		if (!_update_done)
		{
			updateChildrenList(children_special, pElapsed);
			updateChildrenListSimple(children_pre_behaviour, pElapsed);
		}
	}

	public void u3_spriteAnimation(float pElapsed)
	{
		if (!_update_done && is_visible)
		{
			sprite_animation.update(pElapsed);
		}
	}

	public void u4_deadCheck(float pElapsed)
	{
		if (!_update_done)
		{
			if (!isAlive())
			{
				updateDeadAnimation(pElapsed);
				skipUpdates();
			}
			else if (isInMagnet() || under_forces)
			{
				skipUpdates();
			}
		}
	}

	public void u5_curTileAction()
	{
		if (_update_done || position_height > 0f)
		{
			return;
		}
		WorldTile worldTile = current_tile;
		TileTypeBase type = worldTile.Type;
		if (isFlying())
		{
			return;
		}
		if (type.block && !ignoresBlocks())
		{
			if (asset.move_from_block && !is_moving && (!hasTask() || !ai.task.move_from_block))
			{
				setTask("move_from_block", pClean: true, pCleanJob: true);
			}
			if (asset.die_on_blocks && !isUnderDamageCooldown() && !_shake_active && getHealth() > 1)
			{
				getHit(1f, pFlash: true, AttackType.Gravity);
			}
			if (!isInAir() || isHovering())
			{
				applyRandomForce(1.5f, 3f);
				if (Randy.randomChance(0.02f))
				{
					makeStunned();
				}
			}
			if (type.mountains || type.wall)
			{
				checkDieOnGroundBoat();
			}
			return;
		}
		if (type.ground)
		{
			if (worldTile.isOnFire() && !isImmuneToFire())
			{
				ActionLibrary.addBurningEffectOnTarget(null, this);
				if (!isAlive())
				{
					if (!_update_done)
					{
						Debug.LogError((object)"If you ever see me, remove this line");
					}
					skipUpdates();
					return;
				}
			}
			if (isWaterCreature() && !asset.force_land_creature)
			{
				spendStaminaWithCooldown(Randy.randomInt(1, 6));
				if (!isUnderDamageCooldown() && !_shake_active)
				{
					getHit(1f, pFlash: true, AttackType.Other, null, pSkipIfShake: true, pMetallicWeapon: false, pCheckDamageReduction: true);
				}
			}
			checkDieOnGroundBoat();
		}
		else if (type.liquid)
		{
			if (type.damaged_when_walked)
			{
				worldTile.tryToBreak();
			}
			if (!type.lava)
			{
				finishStatusEffect("burning");
			}
			if (isDamagedByOcean() && worldTile.Type.ocean && !isUnderDamageCooldown() && !_shake_active)
			{
				getHit(getWaterDamage(), pFlash: true, AttackType.Water);
			}
			if (!hasTag("fast_swimming") && !isWaterCreature() && !isInAir())
			{
				spendStaminaWithCooldown(Randy.randomInt(1, 6));
				if (getStamina() <= 0 && !isUnderDamageCooldown())
				{
					addStatusEffect("drowning", 0f, pColorEffect: false);
				}
			}
		}
		if (type.damage_units && !isUnderDamageCooldown() && (!type.lava || (asset.die_in_lava && !isImmuneToFire())))
		{
			getHit(type.damage, pFlash: true, AttackType.Fire);
			if (!hasHealth())
			{
				if (type.lava)
				{
					CursedSacrifice.checkGoodForSacrifice(this);
				}
				skipUpdates();
			}
		}
		if (worldTile.hasBuilding() && worldTile.building.asset.has_step_action)
		{
			worldTile.building.asset.step_action(this, worldTile.building);
			if (!hasHealth())
			{
				skipUpdates();
			}
		}
	}

	public void u6_checkFrozen(float pElapsed)
	{
		if (!_update_done && (is_ai_frozen || is_unconscious))
		{
			skipUpdates();
		}
	}

	public void u8_checkUpdateTimers(float pElapsed)
	{
		if (_update_done)
		{
			return;
		}
		if (timer_action >= 0f)
		{
			skipUpdates();
		}
		else if (!isAlive())
		{
			if (!_update_done)
			{
				Debug.LogError((object)"If you ever see me, remove this line");
			}
			skipUpdates();
		}
	}

	public void u7_checkAugmentationEffects()
	{
		if (_update_done || World.world.getWorldTimeElapsedSince(_timestamp_augmentation_effects) < 1f)
		{
			return;
		}
		List<BaseAugmentationAsset> tempAugmentationList = _tempAugmentationList;
		Dictionary<BaseAugmentationAsset, double> s_special_effect_augmentations_timers = _s_special_effect_augmentations_timers;
		double value = (_timestamp_augmentation_effects = World.world.getCurWorldTime());
		int i = 0;
		for (int count = _s_special_effect_augmentations.Count; i < count; i++)
		{
			BaseAugmentationAsset baseAugmentationAsset = _s_special_effect_augmentations[i];
			if (s_special_effect_augmentations_timers.TryGetValue(baseAugmentationAsset, out var value2))
			{
				if (World.world.getWorldTimeElapsedSince(value2) < baseAugmentationAsset.special_effect_interval)
				{
					continue;
				}
				tempAugmentationList.Add(baseAugmentationAsset);
			}
			s_special_effect_augmentations_timers[baseAugmentationAsset] = value;
		}
		if (tempAugmentationList.Count == 0)
		{
			return;
		}
		int j = 0;
		for (int count2 = tempAugmentationList.Count; j < count2; j++)
		{
			BaseAugmentationAsset baseAugmentationAsset2 = tempAugmentationList[j];
			WorldAction action_special_effect = baseAugmentationAsset2.action_special_effect;
			if (Bench.bench_enabled)
			{
				double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
				action_special_effect(this, current_tile);
				double pValue = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
				Bench.benchSaveSplit(baseAugmentationAsset2.id, pValue, 1, "effects_traits");
			}
			else
			{
				action_special_effect(this, current_tile);
			}
		}
		_tempAugmentationList.Clear();
	}

	public void b1_checkUnderForce(float pElapsed)
	{
		if (!_update_done)
		{
			if (under_forces)
			{
				skipBehaviour();
			}
			else if (asset.update_z && position_height != 0f)
			{
				skipBehaviour();
			}
		}
	}

	public void b2_checkCurrentEnemyTarget(float pElapsed)
	{
		if (!_update_done && !_beh_skip && checkCurrentEnemyTarget())
		{
			skipBehaviour();
		}
	}

	public void b3_findEnemyTarget(float pElapsed)
	{
		if (!_update_done && !_beh_skip && checkEnemyTargets())
		{
			stopMovement();
			skipBehaviour();
		}
	}

	public void b4_checkTaskVerifier(float pElapsed)
	{
		if (!_update_done && !_beh_skip)
		{
			if (hasTask() && ai.task.has_verifier && ai.task.task_verifier.execute(this) == BehResult.Stop)
			{
				cancelAllBeh();
				skipBehaviour();
			}
			else if (is_moving)
			{
				skipBehaviour();
			}
		}
	}

	public void b5_checkPathMovement(float pElapsed)
	{
		if (!_update_done && !_beh_skip && isUsingPath())
		{
			updatePathMovement();
			skipBehaviour();
		}
	}

	public void b6_0_updateDecision(float pElapsed)
	{
		if (!_update_done && !_beh_skip && !is_unconscious && !_has_status_possessed && asset.has_ai_system)
		{
			DecisionHelper.makeDecisionFor(this, out _last_decision_id);
		}
	}

	public string getLastDecisionForMindOverview()
	{
		return _last_decision_id;
	}

	public void b6_updateAI(float pElapsed)
	{
		if (!_update_done && !_beh_skip && !is_unconscious && !_has_status_possessed && asset.has_ai_system)
		{
			ai.update();
		}
	}

	public void b55_updateNaturalDeaths(float pElapsed)
	{
		if (!_update_done && !_beh_skip && !is_unconscious && !_has_status_possessed && asset.has_ai_system && ai.action_index == 0 && checkNaturalDeath())
		{
			skipBehaviour();
			skipUpdates();
		}
	}

	public void u10_checkSmoothMovement(float pElapsed)
	{
		if (!_update_done && !is_immovable)
		{
			if (!Config.time_scale_asset.sonic)
			{
				checkCalibrateTargetPosition();
			}
			updateMovement(pElapsed);
		}
	}
}
// --- End of File: Actor.cs ---



// --- Start of File: ActorAnimation.cs ---
using UnityEngine;

public class ActorAnimation
{
	public int id;

	internal Sprite[] frames;
}
// --- End of File: ActorAnimation.cs ---



// --- Start of File: ActorAnimationLoader.cs ---
using System.Collections.Generic;
using UnityEngine;

public static class ActorAnimationLoader
{
	public static readonly Dictionary<Sprite, int> int_ids_heads = new Dictionary<Sprite, int>();

	private static readonly Dictionary<string, AnimationContainerUnit> _dict_units = new Dictionary<string, AnimationContainerUnit>();

	private static readonly Dictionary<string, AnimationDataBoat> _dict_boats = new Dictionary<string, AnimationDataBoat>();

	private static readonly Dictionary<string, Sprite> _dict_civ_heads = new Dictionary<string, Sprite>();

	public static int count_units => _dict_units.Count;

	public static int count_boats => _dict_boats.Count;

	public static int count_heads => _dict_civ_heads.Count;

	public static Sprite getHeadSpecial(string pPath)
	{
		if (!_dict_civ_heads.TryGetValue(pPath, out var value))
		{
			Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pPath);
			foreach (Sprite value2 in spriteList)
			{
				_dict_civ_heads.TryAdd(pPath, value2);
			}
			return _dict_civ_heads[pPath];
		}
		return value;
	}

	public static Sprite getHead(string pPath, int pHeadIndex)
	{
		string key = $"{pPath}_head_{pHeadIndex}";
		if (!_dict_civ_heads.TryGetValue(key, out var value))
		{
			Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pPath);
			foreach (Sprite val in spriteList)
			{
				string key2 = pPath + "_" + ((Object)val).name;
				_dict_civ_heads.TryAdd(key2, val);
			}
			return _dict_civ_heads[key];
		}
		return value;
	}

	public static AnimationDataBoat loadAnimationBoat(string pTexturePath)
	{
		if (!_dict_boats.TryGetValue(pTexturePath, out var value))
		{
			Dictionary<string, Sprite> dictionary = new Dictionary<string, Sprite>();
			Sprite[] spriteList = SpriteTextureLoader.getSpriteList("actors/boats/" + pTexturePath);
			Sprite[] array = spriteList;
			foreach (Sprite val in array)
			{
				dictionary.Add(((Object)val).name, val);
			}
			value = new AnimationDataBoat();
			value.broken = new ActorAnimation();
			value.broken.frames = (Sprite[])(object)new Sprite[1] { dictionary["broken"] };
			value.normal = new ActorAnimation();
			value.normal.frames = (Sprite[])(object)new Sprite[1] { dictionary["normal"] };
			array = spriteList;
			foreach (Sprite val2 in array)
			{
				if (!((Object)val2).name.Contains("@1") && ((Object)val2).name.Contains("@"))
				{
					createBoatAnimationArray(value, dictionary, ((Object)val2).name);
				}
			}
			_dict_boats[pTexturePath] = value;
		}
		return value;
	}

	private static void createBoatAnimationArray(AnimationDataBoat pAnimationData, Dictionary<string, Sprite> pDict, string pID, float pTimeBetween = 0.2f)
	{
		int key = int.Parse(pID.Split('@')[0]);
		ActorAnimation actorAnimation = new ActorAnimation();
		actorAnimation.frames = (Sprite[])(object)new Sprite[2];
		actorAnimation.frames[0] = pDict[key + "@" + 0];
		actorAnimation.frames[1] = pDict[key + "@" + 1];
		pAnimationData.dict.Add(key, actorAnimation);
	}

	public static AnimationContainerUnit getAnimationContainer(string pTexturePath, ActorAsset pAsset, SubspeciesTrait pEggAsset = null, SubspeciesTrait pMutationSkinAsset = null)
	{
		if (!_dict_units.TryGetValue(pTexturePath, out var value))
		{
			return createAnimationContainer(pTexturePath, pAsset, pEggAsset, pMutationSkinAsset);
		}
		return value;
	}

	private static AnimationContainerUnit createAnimationContainer(string pTexturePath, ActorAsset pAsset, SubspeciesTrait pEggAsset, SubspeciesTrait pMutationSkinAsset = null)
	{
		AnimationContainerUnit animationContainerUnit = new AnimationContainerUnit(pTexturePath);
		_dict_units.Add(pTexturePath, animationContainerUnit);
		string[] animation_walk;
		string[] animation_swim;
		string[] animation_idle;
		if (pTexturePath.Contains("eggs/"))
		{
			animation_walk = pEggAsset.animation_walk;
			animation_swim = pEggAsset.animation_swim;
			animation_idle = pEggAsset.animation_idle;
		}
		else if (pTexturePath.Contains("species/mutations"))
		{
			animation_walk = pMutationSkinAsset.animation_walk;
			animation_swim = pMutationSkinAsset.animation_swim;
			animation_idle = pMutationSkinAsset.animation_idle;
		}
		else
		{
			animation_walk = pAsset.animation_walk;
			animation_swim = pAsset.animation_swim;
			animation_idle = pAsset.animation_idle;
		}
		generateFrameData(pTexturePath, animationContainerUnit, animationContainerUnit.sprites, animation_swim);
		generateFrameData(pTexturePath, animationContainerUnit, animationContainerUnit.sprites, animation_walk);
		generateFrameData(pTexturePath, animationContainerUnit, animationContainerUnit.sprites, animation_idle);
		if (animation_swim != null && animation_swim.Length != 0)
		{
			animationContainerUnit.swimming = createAnim(0, animationContainerUnit.sprites, animation_swim);
			if (animationContainerUnit.swimming != null)
			{
				animationContainerUnit.has_swimming = true;
			}
		}
		if (animation_walk != null && animation_walk.Length != 0)
		{
			animationContainerUnit.walking = createAnim(1, animationContainerUnit.sprites, animation_walk);
			if (animationContainerUnit.walking != null)
			{
				animationContainerUnit.has_walking = true;
			}
		}
		if (animation_idle != null && animation_idle.Length != 0)
		{
			animationContainerUnit.idle = createAnim(2, animationContainerUnit.sprites, animation_idle);
			if (animationContainerUnit.idle != null)
			{
				animationContainerUnit.has_idle = true;
			}
		}
		if (pTexturePath.Contains("/child"))
		{
			animationContainerUnit.child = true;
		}
		ActorTextureSubAsset actorTextureSubAsset = ((pMutationSkinAsset == null || !pMutationSkinAsset.is_mutation_skin) ? pAsset.texture_asset : pMutationSkinAsset.texture_asset);
		if (actorTextureSubAsset.texture_heads != string.Empty)
		{
			animationContainerUnit.heads = SpriteTextureLoader.getSpriteList(actorTextureSubAsset.texture_heads);
		}
		if (actorTextureSubAsset.texture_heads_male != string.Empty)
		{
			animationContainerUnit.heads_male = SpriteTextureLoader.getSpriteList(actorTextureSubAsset.texture_heads_male);
		}
		if (actorTextureSubAsset.texture_heads_female != string.Empty)
		{
			animationContainerUnit.heads_female = SpriteTextureLoader.getSpriteList(actorTextureSubAsset.texture_heads_female);
		}
		if (animationContainerUnit.heads == null || animationContainerUnit.heads.Length == 0)
		{
			animationContainerUnit.heads = animationContainerUnit.heads_male;
		}
		if (actorTextureSubAsset.render_heads_for_children)
		{
			animationContainerUnit.render_heads_for_children = true;
		}
		return animationContainerUnit;
	}

	private static void generateFrameData(string pFrameString, AnimationContainerUnit pAnimContainer, Dictionary<string, Sprite> pFrames, string[] pStringIDs)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(pFrameString) || pStringIDs == null)
		{
			return;
		}
		foreach (string text in pStringIDs)
		{
			if (!pAnimContainer.dict_frame_data.ContainsKey(text) && pFrames.ContainsKey(text))
			{
				AnimationFrameData animationFrameData = new AnimationFrameData();
				animationFrameData.id = text;
				animationFrameData.sheet_path = pFrameString;
				Sprite val = pFrames[text];
				Rect rect = val.rect;
				animationFrameData.size_unit = ((Rect)(ref rect)).size;
				string key = text + "_head";
				if (pFrames.TryGetValue(key, out var value))
				{
					rect = value.rect;
					float x = ((Rect)(ref rect)).x;
					rect = val.rect;
					float num = x - ((Rect)(ref rect)).x;
					num = num - val.pivot.x + value.pivot.x;
					rect = value.rect;
					float y = ((Rect)(ref rect)).y;
					rect = val.rect;
					float num2 = y - ((Rect)(ref rect)).y;
					num2 = num2 - val.pivot.y + value.pivot.y;
					animationFrameData.pos_head = new Vector2(num, num2);
					rect = value.rect;
					float x2 = ((Rect)(ref rect)).x;
					rect = val.rect;
					float num3 = x2 - ((Rect)(ref rect)).x;
					rect = value.rect;
					float y2 = ((Rect)(ref rect)).y;
					rect = val.rect;
					float num4 = y2 - ((Rect)(ref rect)).y;
					animationFrameData.pos_head_new = new Vector2(num3, num4);
					animationFrameData.show_head = true;
				}
				string key2 = text + "_item";
				if (pFrames.TryGetValue(key2, out var value2))
				{
					rect = value2.rect;
					float x3 = ((Rect)(ref rect)).x;
					rect = val.rect;
					float num5 = x3 - ((Rect)(ref rect)).x;
					num5 = num5 - val.pivot.x + value2.pivot.x;
					rect = value2.rect;
					float y3 = ((Rect)(ref rect)).y;
					rect = val.rect;
					float num6 = y3 - ((Rect)(ref rect)).y;
					num6 = num6 - val.pivot.y + value2.pivot.y;
					animationFrameData.pos_item = new Vector2(num5, num6);
					animationFrameData.show_item = true;
				}
				pAnimContainer.dict_frame_data.Add(text, animationFrameData);
			}
		}
	}

	private static ActorAnimation createAnim(int pID, Dictionary<string, Sprite> pDict, string[] pStringIDs)
	{
		Sprite[] array = createArray(pDict, pStringIDs);
		if (array.Length == 0)
		{
			return null;
		}
		return new ActorAnimation
		{
			id = pID,
			frames = array
		};
	}

	private static Sprite[] createArray(Dictionary<string, Sprite> pDict, string[] pStringIDs)
	{
		using ListPool<Sprite> listPool = new ListPool<Sprite>(pStringIDs.Length);
		foreach (string key in pStringIDs)
		{
			if (!pDict.TryGetValue(key, out var value))
			{
				break;
			}
			listPool.Add(value);
		}
		return listPool.ToArray();
	}
}
// --- End of File: ActorAnimationLoader.cs ---



// --- Start of File: ActorAnimationSequences.cs ---
public static class ActorAnimationSequences
{
	public static readonly string[] walk_0 = Toolbox.a<string>("walk_0");

	public static readonly string[] walk_0_1 = Toolbox.a<string>("walk_0", "walk_1");

	public static readonly string[] walk_0_2 = Toolbox.a<string>("walk_0", "walk_1", "walk_2");

	public static readonly string[] walk_0_3 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3");

	public static readonly string[] walk_0_4 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3", "walk_4");

	public static readonly string[] walk_0_5 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3", "walk_4", "walk_5");

	public static readonly string[] swim_0 = Toolbox.a<string>("swim_0");

	public static readonly string[] swim_0_1 = Toolbox.a<string>("swim_0", "swim_1");

	public static readonly string[] swim_0_2 = Toolbox.a<string>("swim_0", "swim_1", "swim_2");

	public static readonly string[] swim_0_3 = Toolbox.a<string>("swim_0", "swim_1", "swim_2", "swim_3");

	public static readonly string[] swim_0_5 = Toolbox.a<string>("swim_0", "swim_1", "swim_2", "swim_3", "swim_4", "swim_5");

	public static readonly string[] idle_0_3 = Toolbox.a<string>("idle_0", "idle_1", "idle_2", "idle_3");
}
// --- End of File: ActorAnimationSequences.cs ---



// --- Start of File: ActorAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public class ActorAsset : BaseUnlockableAsset, IDescriptionAsset, ILocalizedAsset, IAnimationFrames
{
	[DefaultValue(true)]
	public bool split_ai_update = true;

	[DefaultValue(true)]
	public bool has_ai_system = true;

	[DefaultValue(1)]
	public int item_making_skill = 1;

	public bool affected_by_dust;

	public string sound_idle;

	public string sound_idle_loop;

	public string sound_spawn;

	public string sound_death;

	public string sound_attack;

	[DefaultValue("event:/SFX/HIT/HitGeneric")]
	public string sound_hit = "event:/SFX/HIT/HitGeneric";

	public bool show_controllable_tip = true;

	public bool show_task_icon = true;

	public string music_theme;

	public string music_theme_civ;

	[DefaultValue(UnitTextureAtlasID.Units)]
	public UnitTextureAtlasID texture_atlas;

	public bool ignored_by_infinity_coin;

	[DefaultValue("")]
	public string name_taxonomic_kingdom = "";

	[DefaultValue("")]
	public string name_taxonomic_phylum = "";

	[DefaultValue("")]
	public string name_taxonomic_class = "";

	[DefaultValue("")]
	public string name_taxonomic_order = "";

	[DefaultValue("")]
	public string name_taxonomic_family = "";

	[DefaultValue("")]
	public string name_taxonomic_genus = "";

	[DefaultValue("")]
	public string name_taxonomic_species = "";

	[DefaultValue(true)]
	public bool name_subspecies_add_biome_suffix = true;

	public bool auto_civ;

	[DefaultValue("")]
	public string name_locale = "";

	[DefaultValue(StatusTier.Advanced)]
	public StatusTier allowed_status_tiers = StatusTier.Advanced;

	[DefaultValue(true)]
	public bool render_status_effects = true;

	[DefaultValue(ActorSize.S13_Human)]
	public ActorSize actor_size = ActorSize.S13_Human;

	public string[] animation_walk;

	[DefaultValue(10f)]
	public float animation_walk_speed = 10f;

	public string[] animation_swim;

	[DefaultValue(8f)]
	public float animation_swim_speed = 8f;

	public string[] animation_idle = ActorAnimationSequences.walk_0;

	[DefaultValue(10f)]
	public float animation_idle_speed = 10f;

	[DefaultValue(10f)]
	public float max_shake_timer = 10f;

	[DefaultValue(true)]
	public bool animation_speed_based_on_walk_speed = true;

	[DefaultValue("base_attack")]
	public string default_attack = "base_attack";

	public bool immune_to_tumor;

	public bool immune_to_slowness;

	public int aggression;

	[DefaultValue(true)]
	public bool shadow = true;

	[DefaultValue("unitShadow_5")]
	public string shadow_texture = "unitShadow_5";

	[DefaultValue("unitShadow_2")]
	public string shadow_texture_egg = "unitShadow_2";

	[DefaultValue("unitShadow_4")]
	public string shadow_texture_baby = "unitShadow_4";

	[DefaultValue(true)]
	public bool hit_fx_alternative_offset = true;

	[DefaultValue(true)]
	public bool can_level_up = true;

	[DefaultValue(true)]
	public bool can_talk_with = true;

	public float base_throwing_range;

	[DefaultValue(true)]
	public bool use_tool_items = true;

	public bool use_items;

	public bool take_items;

	public bool control_can_jump = true;

	public bool control_can_talk = true;

	public bool control_can_dash = true;

	public bool control_can_backstep = true;

	public bool control_can_steal = true;

	public bool control_can_swear = true;

	public bool control_can_kick = true;

	public bool use_phenotypes;

	[JsonIgnore]
	public Dictionary<string, List<string>> phenotypes_dict;

	public List<string> phenotypes_list;

	public List<string> generated_subspecies_names_prefixes;

	public bool can_be_killed_by_stuff;

	public bool can_be_killed_by_life_eraser;

	public bool can_be_killed_by_divine_light;

	[DefaultValue(true)]
	public bool show_on_meta_layer = true;

	public bool ignore_tile_speed_multiplier;

	public bool skip_fight_logic;

	public bool can_attack_buildings;

	public bool can_attack_brains;

	[DefaultValue(true)]
	public bool count_as_unit = true;

	public bool only_melee_attack;

	public bool flag_ufo;

	public bool flag_finger;

	public bool flag_turtle;

	public bool default_animal;

	public bool civ;

	public bool unit_other;

	[DefaultValue("")]
	public string kingdom_id_wild = "";

	[DefaultValue("")]
	public string kingdom_id_civilization = "";

	public bool special;

	[DefaultValue(true)]
	public bool show_in_taxonomy_tooltip = true;

	[DefaultValue(true)]
	public bool render_budding = true;

	public string family_banner_frame_generation_exclusion = "families/frame_11";

	public string family_banner_frame_generation_inclusion;

	public bool family_banner_frame_only_inclusion;

	[DefaultValue("")]
	public string texture_id = "";

	[DefaultValue("")]
	public string architecture_id = "";

	public string texture_path_zombie_for_auto_loader_main;

	public string texture_path_zombie_for_auto_loader_heads;

	public ActorTextureSubAsset texture_asset;

	public bool prevent_unconscious_rotation;

	public bool render_heads_for_babies;

	private string _debug_phenotype_color = "";

	public bool body_separate_part_hands;

	public bool has_baby_form;

	public bool has_advanced_textures;

	public List<string> decision_ids;

	private DecisionAsset[] _cached_assets_decisions;

	private int _cached_assets_decisions_counter;

	private HashSet<SubspeciesTrait> _cached_assets_subspecies_traits;

	private Sprite _cached_sprite;

	private BaseStats _cached_overview_stats;

	[DefaultValue(0.5f)]
	public float hovering_min = 0.5f;

	[DefaultValue(1.2f)]
	public float hovering_max = 1.2f;

	public bool hovering;

	public bool flying;

	public bool very_high_flyer;

	public bool disable_jump_animation;

	public bool rotating_animation;

	[DefaultValue(true)]
	public bool die_on_blocks = true;

	public bool ignore_blocks;

	[DefaultValue(true)]
	public bool move_from_block = true;

	[DefaultValue(true)]
	public bool run_to_water_when_on_fire = true;

	public bool damaged_by_ocean;

	[DefaultValue(true)]
	public bool cancel_beh_on_land = true;

	public bool force_ocean_creature;

	public bool force_land_creature;

	public bool is_humanoid;

	public bool is_boat;

	public bool is_boat_transport;

	public bool draw_boat_mark;

	public bool draw_boat_mark_big;

	[DefaultValue("")]
	public string boat_type = "";

	[DefaultValue(6)]
	public int animal_breeding_close_units_limit = 6;

	[DefaultValue("")]
	public string avatar_prefab = "";

	[NonSerialized]
	public bool has_avatar_prefab;

	public bool ignore_generic_render;

	public bool need_colored_sprite;

	public bool die_from_dispel;

	[DefaultValue(true)]
	public bool die_in_lava = true;

	public bool can_be_moved_by_powers;

	public bool can_be_hurt_by_powers;

	public bool can_turn_into_ice_one;

	public bool can_turn_into_mush;

	public bool can_turn_into_tumor;

	public bool can_evolve_into_new_species;

	public bool has_soul;

	[DefaultValue(true)]
	public bool can_receive_traits = true;

	public string base_asset_id;

	public string power_id;

	public bool zombie_auto_asset;

	public bool can_turn_into_zombie;

	[DefaultValue("")]
	public string zombie_id_internal = "";

	public string zombie_color_hex = "#3B8130";

	public bool unit_zombie;

	public bool dynamic_sprite_zombie;

	[DefaultValue("")]
	public string skeleton_id = "";

	[DefaultValue("")]
	public string mush_id = "";

	[DefaultValue("")]
	public string tumor_id = "";

	[DefaultValue("")]
	public string evolution_id = "";

	public bool can_turn_into_demon_in_age_of_chaos;

	public bool show_icon_inspect_window;

	[DefaultValue("")]
	public string show_icon_inspect_window_id = "";

	public bool hide_favorite_icon;

	[DefaultValue(true)]
	public bool can_be_favorited = true;

	public bool can_be_inspected;

	[DefaultValue(2.5f)]
	public float inspect_avatar_scale = 2.5f;

	public float inspect_avatar_offset_x;

	public float inspect_avatar_offset_y;

	[DefaultValue(100)]
	public int nutrition_max = 100;

	[DefaultValue(3)]
	public int months_breeding_timeout = 3;

	[DefaultValue(18)]
	public int age_spawn = 18;

	[DefaultValue(true)]
	public bool can_edit_traits = true;

	[DefaultValue(false)]
	public bool can_edit_equipment;

	[DefaultValue(true)]
	public bool finish_scale_on_creation = true;

	[DefaultValue(2f)]
	public float path_movement_timeout = 2f;

	public bool source_meat;

	public bool source_meat_insect;

	[DefaultValue(0.3f)]
	public float default_height = 0.3f;

	public bool update_z;

	public bool visible_on_minimap;

	public bool follow_herd;

	[DefaultValue(true)]
	public bool inspect_stats = true;

	[DefaultValue(true)]
	public bool inspect_children = true;

	[DefaultValue(true)]
	public bool inspect_generation = true;

	[DefaultValue(true)]
	public bool inspect_sex = true;

	[DefaultValue(true)]
	public bool inspect_kills = true;

	[DefaultValue(true)]
	public bool inspect_experience = true;

	[DefaultValue(true)]
	public bool inspect_show_species = true;

	[DefaultValue(true)]
	public bool inspect_mind = true;

	[DefaultValue(true)]
	public bool inspect_genealogy = true;

	[DefaultValue(true)]
	public bool allow_possession = true;

	[DefaultValue(true)]
	public bool allow_strange_urge_movement = true;

	public bool inspect_home;

	public bool immune_to_injuries;

	[DefaultValue(true)]
	public bool can_be_cloned = true;

	[DefaultValue(10)]
	public int experience_given = 10;

	public string[] job;

	public string[] job_citizen;

	public string[] job_kingdom;

	public string[] job_baby;

	public string[] job_attacker;

	public string effect_cast_top = "fx_cast_top_blue";

	public string effect_cast_ground = "fx_cast_ground_blue";

	public string effect_teleport = "fx_teleport_blue";

	public List<string> spell_ids;

	public bool effect_damage;

	public bool can_flip;

	public bool special_dead_animation;

	public bool death_animation_angle;

	[DefaultValue(StatusTier.Advanced)]
	public StatusTier status_tiers = StatusTier.Advanced;

	[DefaultValue(true)]
	public bool has_sprite_renderer = true;

	public bool die_by_lightning;

	[DefaultValue(true)]
	public bool has_skin = true;

	[DefaultValue("")]
	public string grow_into_id = "";

	[DefaultValue("iconQuestionMark")]
	public string icon = "iconQuestionMark";

	public bool skip_save;

	public string color_hex;

	[NonSerialized]
	public Color32? color;

	public ConstructionCost cost;

	[DefaultValue(40)]
	public int species_spawn_radius = 40;

	public bool can_have_subspecies;

	public int genome_size;

	[DefaultValue(30)]
	public int family_spawn_radius = 30;

	[DefaultValue(20)]
	public int family_limit = 20;

	public bool create_family_at_spawn;

	[DefaultValue(FamilyParentsMode.Normal)]
	public FamilyParentsMode family_show_parents;

	[DefaultValue("COLLECTIVE_NAME")]
	public string collective_term = "COLLECTIVE_NAME";

	[DefaultValue(50)]
	public int language_spawn_radius = 50;

	public List<string> traits;

	public HashSet<string> traits_ignore;

	public List<string> preferred_attribute;

	[DefaultValue(null)]
	public HashSet<string> preferred_colors;

	public string[] production;

	[DefaultValue(null)]
	public string[] name_template_sets;

	[DefaultValue("default_name")]
	public string name_template_unit = "default_name";

	[DefaultValue("")]
	public string banner_id = "";

	[DefaultValue("")]
	public string build_order_template_id = "";

	[DefaultValue(4)]
	public int civ_base_cities = 4;

	[DefaultValue(0.35f)]
	public float civ_base_army_multiplier = 0.35f;

	public List<string> default_subspecies_traits;

	public List<string> default_clan_traits;

	public List<string> default_culture_traits;

	public List<string> default_language_traits;

	public List<string> default_kingdom_traits;

	public List<string> default_religion_traits;

	public List<string> trait_filter_subspecies;

	public List<string> trait_group_filter_subspecies;

	public List<ResourceContainer> resources_given;

	public string[] skin_citizen_male;

	public string[] skin_citizen_female;

	public string[] skin_warrior;

	public string[] default_weapons;

	public ActorGetSprite get_override_sprite;

	[NonSerialized]
	public bool has_override_sprite;

	public ActorGetSprites get_override_avatar_frames;

	[NonSerialized]
	public bool has_override_avatar_frames;

	public List<string> chromosomes_first;

	public HashSet<GenomePart> genome_parts = new HashSet<GenomePart>();

	[DefaultValue(3)]
	public int max_random_amount = 3;

	[DefaultValue(true)]
	public bool can_be_surprised = true;

	[NonSerialized]
	public HashSet<Actor> units = new HashSet<Actor>();

	[NonSerialized]
	public ArchitectureAsset architecture_asset;

	[NonSerialized]
	public SpellHolder spells;

	public BaseActionActor action_on_load;

	public WorldAction action_click;

	public WorldAction action_death;

	public DeadAnimation action_dead_animation;

	public GetHitAction action_get_hit;

	public WorldAction check_flip;

	public bool force_hide_stamina;

	public bool force_hide_mana;

	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_actors;

	[JsonIgnore]
	public bool has_sound_idle => sound_idle != null;

	[JsonIgnore]
	public bool has_sound_idle_loop => sound_idle_loop != null;

	[JsonIgnore]
	public bool has_sound_spawn => sound_spawn != null;

	[JsonIgnore]
	public bool has_sound_death => sound_death != null;

	[JsonIgnore]
	public bool has_sound_attack => sound_attack != null;

	[JsonIgnore]
	public bool has_sound_hit => sound_hit != null;

	[JsonIgnore]
	public bool has_music_theme => music_theme != null;

	[JsonIgnore]
	public bool has_music_theme_civ => music_theme_civ != null;

	[JsonIgnore]
	public string debug_phenotype_colors
	{
		get
		{
			if (string.IsNullOrEmpty(_debug_phenotype_color))
			{
				_debug_phenotype_color = phenotypes_list?.GetRandom();
			}
			return _debug_phenotype_color;
		}
		set
		{
			_debug_phenotype_color = value;
		}
	}

	[DefaultValue("male_1")]
	public string skin_civ_default_male => "male_1";

	[DefaultValue("female_1")]
	public string skin_civ_default_female => "female_1";

	public int decisions_counter => _cached_assets_decisions_counter;

	[JsonIgnore]
	public string boat_texture_id => id;

	public void addSubspeciesNamePrefix(string pName)
	{
		if (generated_subspecies_names_prefixes == null)
		{
			generated_subspecies_names_prefixes = new List<string>();
		}
		generated_subspecies_names_prefixes.Add(pName);
	}

	public bool hasDefaultEggForm()
	{
		return default_subspecies_traits?.Contains("reproduction_strategy_oviparity") ?? false;
	}

	public string getDefaultEggID()
	{
		string result = "egg_shell_plain";
		foreach (string default_subspecies_trait in default_subspecies_traits)
		{
			SubspeciesTrait subspeciesTrait = AssetManager.subspecies_traits.get(default_subspecies_trait);
			if (subspeciesTrait.phenotype_egg)
			{
				result = subspeciesTrait.id_egg;
				break;
			}
		}
		return result;
	}

	public void setZombie(bool pAnimal = true)
	{
		if (id != "zombie")
		{
			base_asset_id = "zombie";
		}
		needs_to_be_explored = false;
		use_phenotypes = false;
		name_locale = "Zombie";
		can_attack_brains = true;
		kingdom_id_wild = "undead";
		collective_term = "group_swarm";
		kingdom_id_civilization = string.Empty;
		architecture_id = string.Empty;
		build_order_template_id = string.Empty;
		take_items = false;
		follow_herd = false;
		can_be_killed_by_divine_light = true;
		unit_zombie = true;
		has_baby_form = false;
		has_advanced_textures = false;
		unlocked_with_achievement = false;
		achievement_id = null;
		addTrait("zombie");
		addTrait("stupid");
		can_turn_into_zombie = false;
		can_turn_into_mush = false;
		base_stats["lifespan"] = 0f;
		zombie_id_internal = string.Empty;
		job = Toolbox.a<string>("decision");
		can_evolve_into_new_species = false;
		addDecision("attack_golden_brain");
		if (traits != null)
		{
			traits = traits.FindAll((string pTrait) => !AssetManager.traits.get(pTrait).remove_for_zombie_actor_asset);
		}
		if (default_subspecies_traits != null)
		{
			default_subspecies_traits = default_subspecies_traits.FindAll((string pTrait) => !AssetManager.subspecies_traits.get(pTrait).remove_for_zombies);
		}
		default_kingdom_traits = null;
		default_culture_traits = null;
		default_clan_traits = null;
		default_language_traits = null;
		default_religion_traits = null;
		addTraitGroupFilter("advanced_brain");
		addTraitGroupFilter("reproduction_strategy");
		addTraitGroupFilter("reproductive_methods");
		addTraitGroupFilter("eggs");
		addTraitGroupFilter("harmony");
		if (pAnimal)
		{
			generateFmodPaths("zombie_animal");
		}
		else
		{
			generateFmodPaths("zombie");
		}
		music_theme = "Units_Zombie";
		sound_hit = "event:/SFX/HIT/HitFlesh";
	}

	public void setCanTurnIntoZombieAsset(string pZombieID, bool pAutoZombieAsset)
	{
		can_turn_into_zombie = true;
		zombie_auto_asset = pAutoZombieAsset;
		zombie_id_internal = pZombieID;
	}

	public string getZombieID()
	{
		if (zombie_auto_asset)
		{
			return zombie_id_internal + "_" + id;
		}
		return zombie_id_internal;
	}

	public void cloneTaxonomyFromForSapiens(string pFrom)
	{
		ActorAsset actorAsset = AssetManager.actor_library.get(pFrom);
		name_taxonomic_kingdom = actorAsset.name_taxonomic_kingdom;
		name_taxonomic_phylum = actorAsset.name_taxonomic_phylum;
		name_taxonomic_class = actorAsset.name_taxonomic_class;
		name_taxonomic_order = actorAsset.name_taxonomic_order;
		name_taxonomic_family = actorAsset.name_taxonomic_family;
		name_taxonomic_genus = actorAsset.name_taxonomic_genus;
		name_taxonomic_species = "sapiens";
	}

	public string getTaxonomyRank(string pType)
	{
		return pType switch
		{
			"taxonomy_kingdom" => name_taxonomic_kingdom, 
			"taxonomy_phylum" => name_taxonomic_phylum, 
			"taxonomy_class" => name_taxonomic_class, 
			"taxonomy_order" => name_taxonomic_order, 
			"taxonomy_family" => name_taxonomic_family, 
			"taxonomy_genus" => name_taxonomic_genus, 
			"taxonomy_species" => name_taxonomic_species, 
			_ => string.Empty, 
		};
	}

	public bool isTaxonomyRank(string pType, string pID)
	{
		return getTaxonomyRank(pType) == pID;
	}

	public void setSocialStructure(string pTerm, int pLimit, bool pCreateOnSpawn = true, bool pFollowHerd = true, FamilyParentsMode pShowParents = FamilyParentsMode.Alpha)
	{
		collective_term = pTerm;
		family_limit = pLimit;
		create_family_at_spawn = pCreateOnSpawn;
		family_show_parents = pShowParents;
		follow_herd = pFollowHerd;
	}

	public void generateFmodPaths(string pID)
	{
		string text = "event:/SFX/UNITS/" + pID;
		if (!has_sound_attack)
		{
			sound_attack = text + "/attack";
		}
		if (!has_sound_death)
		{
			sound_death = text + "/death";
		}
		if (!has_sound_idle)
		{
			sound_idle = text + "/idle";
		}
		if (!has_sound_spawn)
		{
			sound_spawn = text + "/spawn";
		}
	}

	public void clonePhenotype(string pFrom)
	{
		ActorAsset actorAsset = AssetManager.actor_library.get(pFrom);
		if (actorAsset.phenotypes_dict != null)
		{
			phenotypes_dict = new Dictionary<string, List<string>>(actorAsset.phenotypes_dict);
			phenotypes_list = new List<string>(actorAsset.phenotypes_list);
		}
	}

	public PhenotypeAsset getDefaultPhenotypeAsset()
	{
		string pID = phenotypes_list[0];
		return AssetManager.phenotype_library.get(pID);
	}

	public void clearTraits()
	{
		if (traits != null)
		{
			traits.Clear();
		}
	}

	public string getCollectiveTermID()
	{
		return collective_term;
	}

	public override string getLocaleID()
	{
		return name_locale.Underscore();
	}

	public string getDescriptionID()
	{
		return getGodPower()?.getDescriptionID();
	}

	public string getLocalizedName()
	{
		if (!isAvailable())
		{
			return LocalizedTextManager.getText("achievement_tip_hidden");
		}
		return LocalizedTextManager.getText(getLocaleID());
	}

	public string getLocalizedDescription()
	{
		if (!isAvailable())
		{
			if (unlocked_with_achievement)
			{
				string text = LocalizedTextManager.getText("actor_locked_tooltip_text_achievement");
				string newValue = "<color=#00ffffff>" + getAchievementLocaleID().Localize() + "</color>";
				return text.Replace("$achievement_id$", newValue);
			}
			return LocalizedTextManager.getText("actor_locked_tooltip_text_exploration");
		}
		return LocalizedTextManager.getText(getDescriptionID());
	}

	public void addPreferredColors(params string[] pColors)
	{
		preferred_colors = new HashSet<string>(pColors);
	}

	public string getTranslatedName()
	{
		return getLocaleID().Localize();
	}

	public void addGenome(params (string, float)[] pListGenomePartsIDs)
	{
		for (int i = 0; i < pListGenomePartsIDs.Length; i++)
		{
			(string, float) tuple = pListGenomePartsIDs[i];
			string item = tuple.Item1;
			float item2 = tuple.Item2;
			GenomePart genomePart = new GenomePart(item, item2);
			if (!genome_parts.Add(genomePart))
			{
				genome_parts.TryGetValue(genomePart, out var actualValue);
				GenomePart item3 = new GenomePart(item, actualValue.value + item2);
				genome_parts.Remove(actualValue);
				genome_parts.Add(item3);
			}
		}
	}

	public string getIconPath()
	{
		return "ui/Icons/" + icon;
	}

	public Sprite getSpriteIcon()
	{
		if (_cached_sprite == null)
		{
			_cached_sprite = SpriteTextureLoader.getSprite(getIconPath());
		}
		return _cached_sprite;
	}

	public override Sprite getSprite()
	{
		return getSpriteIcon();
	}

	public bool hasBiomePhenotype(string pBiomeID)
	{
		if (phenotypes_dict == null || phenotypes_dict.Count == 0)
		{
			return false;
		}
		return phenotypes_dict.ContainsKey(pBiomeID);
	}

	public BaseStats getStatsForOverview()
	{
		if (_cached_overview_stats == null)
		{
			_cached_overview_stats = new BaseStats();
			_cached_overview_stats["health"] = base_stats["health"];
			_cached_overview_stats["lifespan"] = base_stats["lifespan"];
			_cached_overview_stats["damage"] = base_stats["damage"];
			_cached_overview_stats["speed"] = base_stats["speed"];
			foreach (GenomePart genome_part in genome_parts)
			{
				switch (genome_part.id)
				{
				case "health":
				case "lifespan":
				case "damage":
				case "speed":
					_cached_overview_stats[genome_part.id] += genome_part.value;
					break;
				}
			}
		}
		return _cached_overview_stats;
	}

	public bool hasDecisions()
	{
		List<string> list = decision_ids;
		if (list == null)
		{
			return false;
		}
		return list.Count > 0;
	}

	public DecisionAsset[] getDecisions()
	{
		if (hasDecisions() && _cached_assets_decisions == null)
		{
			_cached_assets_decisions = new DecisionAsset[64];
			foreach (string decision_id in decision_ids)
			{
				DecisionAsset decisionAsset = AssetManager.decisions_library.get(decision_id);
				if (decisionAsset != null)
				{
					_cached_assets_decisions[_cached_assets_decisions_counter++] = decisionAsset;
				}
			}
		}
		return _cached_assets_decisions;
	}

	public string getDefaultKingdom()
	{
		return kingdom_id_wild;
	}

	public HashSet<SubspeciesTrait> getDefaultSubspeciesTraits()
	{
		if (default_subspecies_traits == null)
		{
			return null;
		}
		if (_cached_assets_subspecies_traits == null)
		{
			_cached_assets_subspecies_traits = new HashSet<SubspeciesTrait>();
			default_subspecies_traits.Sort((string pS1, string pS2) => string.Compare(pS1, pS2, StringComparison.Ordinal));
			foreach (string default_subspecies_trait in default_subspecies_traits)
			{
				SubspeciesTrait subspeciesTrait = AssetManager.subspecies_traits.get(default_subspecies_trait);
				if (subspeciesTrait != null)
				{
					_cached_assets_subspecies_traits.Add(subspeciesTrait);
				}
			}
		}
		return _cached_assets_subspecies_traits;
	}

	public int countPopulation()
	{
		return units.Count;
	}

	public int countSubspecies()
	{
		int num = 0;
		foreach (Subspecies subspecy in World.world.subspecies)
		{
			if (subspecy.getActorAsset() == this)
			{
				num++;
			}
		}
		return num;
	}

	public int countFamilies()
	{
		int num = 0;
		foreach (Family family in World.world.families)
		{
			if (family.getActorAsset() == this)
			{
				num++;
			}
		}
		return num;
	}

	public void addSpell(string pID)
	{
		if (spell_ids == null)
		{
			spell_ids = new List<string>();
		}
		spell_ids.Add(pID);
	}

	public void addTraitGroupFilter(string pTrait)
	{
		if (trait_group_filter_subspecies == null)
		{
			trait_group_filter_subspecies = new List<string>();
		}
		if (!trait_group_filter_subspecies.Contains(pTrait))
		{
			trait_group_filter_subspecies.Add(pTrait);
		}
	}

	public void addTrait(string pTraitID)
	{
		if (traits == null)
		{
			traits = new List<string>();
		}
		if (!traits.Contains(pTraitID))
		{
			traits.Add(pTraitID);
		}
	}

	public void addTraitIgnore(string pTraitID)
	{
		if (traits_ignore == null)
		{
			traits_ignore = new HashSet<string>();
		}
		traits_ignore.Add(pTraitID);
	}

	public void removeTrait(string pTrait)
	{
		traits?.Remove(pTrait);
		List<string> list = traits;
		if (list != null && list.Count == 0)
		{
			traits = null;
		}
	}

	public void addSubspeciesTrait(string pTrait)
	{
		if (default_subspecies_traits == null)
		{
			default_subspecies_traits = new List<string>();
		}
		if (!default_subspecies_traits.Contains(pTrait))
		{
			default_subspecies_traits.Add(pTrait);
		}
	}

	public void addCultureTrait(string pTrait)
	{
		if (default_culture_traits == null)
		{
			default_culture_traits = new List<string>();
		}
		if (!default_culture_traits.Contains(pTrait))
		{
			default_culture_traits.Add(pTrait);
		}
	}

	public void addLanguageTrait(string pTrait)
	{
		if (default_language_traits == null)
		{
			default_language_traits = new List<string>();
		}
		if (!default_language_traits.Contains(pTrait))
		{
			default_language_traits.Add(pTrait);
		}
	}

	public void addKingdomTrait(string pTrait)
	{
		if (default_kingdom_traits == null)
		{
			default_kingdom_traits = new List<string>();
		}
		if (!default_kingdom_traits.Contains(pTrait))
		{
			default_kingdom_traits.Add(pTrait);
		}
	}

	public void addClanTrait(string pTrait)
	{
		if (default_clan_traits == null)
		{
			default_clan_traits = new List<string>();
		}
		if (!default_clan_traits.Contains(pTrait))
		{
			default_clan_traits.Add(pTrait);
		}
	}

	public void addReligionTrait(string pTrait)
	{
		if (default_religion_traits == null)
		{
			default_religion_traits = new List<string>();
		}
		if (!default_religion_traits.Contains(pTrait))
		{
			default_religion_traits.Add(pTrait);
		}
	}

	public void addDecision(string pDecision)
	{
		if (decision_ids == null)
		{
			decision_ids = new List<string>();
		}
		if (!decision_ids.Contains(pDecision))
		{
			decision_ids.Add(pDecision);
		}
	}

	public override bool unlock(bool pSaveData = true)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (!base.unlock(pSaveData))
		{
			return false;
		}
		string text = (string.IsNullOrEmpty(base_asset_id) ? id : base_asset_id);
		ActorAsset actorAsset;
		if (text != id)
		{
			actorAsset = AssetManager.actor_library.get(text);
			if (!actorAsset.unlock())
			{
				return false;
			}
		}
		else
		{
			actorAsset = this;
		}
		if (PowerButton.actor_spawn_buttons.TryGetValue(actorAsset, out var value))
		{
			((Graphic)value.icon).color = Toolbox.color_white;
		}
		return true;
	}

	protected override bool isDebugUnlockedAll()
	{
		return DebugConfig.isOn(DebugOption.UnlockAllActors);
	}

	public bool canEditItem(EquipmentAsset pItem)
	{
		if (!pItem.is_pool_weapon && can_edit_equipment)
		{
			return true;
		}
		if (pItem.is_pool_weapon && can_edit_equipment)
		{
			return true;
		}
		return false;
	}

	public void addResource(string pID, int pAmount, bool pNewList = false)
	{
		if (resources_given == null || pNewList)
		{
			resources_given = new List<ResourceContainer>();
		}
		if (resources_given.Count > 0)
		{
			for (int i = 0; i < resources_given.Count; i++)
			{
				ResourceContainer value = resources_given[i];
				if (value.id == pID)
				{
					value.amount += pAmount;
					resources_given[i] = value;
					return;
				}
			}
		}
		resources_given.Add(new ResourceContainer(pID, pAmount));
	}

	public BuildingAsset getBuildingDockAsset()
	{
		string pID = "docks_" + architecture_id;
		return AssetManager.buildings.get(pID);
	}

	public void setSimpleCivSettings()
	{
		skin_citizen_male = Toolbox.a<string>("male_1");
		skin_citizen_female = Toolbox.a<string>("female_1");
		skin_warrior = Toolbox.a<string>("warrior_1");
		production = new string[1] { "bread" };
		build_order_template_id = "build_order_basic";
		name_template_sets = Toolbox.a<string>("default_name");
		job = Toolbox.a<string>("decision");
		job_citizen = Toolbox.a<string>("unit_citizen");
		job_kingdom = Toolbox.a<string>("decision");
		job_baby = Toolbox.a<string>("decision");
		job_attacker = Toolbox.a<string>("attacker");
		kingdom_id_wild = "neutral_animals";
	}

	public bool canBecomeSapient()
	{
		return !string.IsNullOrEmpty(kingdom_id_civilization);
	}

	public bool hasDefaultSpells()
	{
		if (spells != null)
		{
			return spells.hasAny();
		}
		return false;
	}

	public TooltipData getTooltip()
	{
		GodPower godPower = getGodPower();
		return new TooltipData
		{
			tip_name = getLocaleID(),
			tip_description = getDescriptionID(),
			power = godPower
		};
	}

	public GodPower getGodPower()
	{
		string pID = power_id ?? base_asset_id ?? id;
		if (!AssetManager.powers.has(pID))
		{
			return null;
		}
		return AssetManager.powers.get(pID);
	}

	public string getNameTemplate(MetaType pType)
	{
		string text = name_template_sets?.GetRandom();
		if (!string.IsNullOrEmpty(text))
		{
			return AssetManager.name_sets.get(text).get(pType);
		}
		if (pType == MetaType.Unit)
		{
			string.IsNullOrEmpty(name_template_unit);
			return name_template_unit;
		}
		return name_template_unit;
	}

	public string[] getWalk()
	{
		return animation_walk;
	}

	public string[] getIdle()
	{
		return animation_idle;
	}

	public string[] getSwim()
	{
		return animation_swim;
	}
}
// --- End of File: ActorAsset.cs ---



// --- Start of File: ActorAssetElementPlace.cs ---
public class ActorAssetElementPlace : BaseAssetElementPlace<ActorAsset, ActorDebugAssetElement>
{
}
// --- End of File: ActorAssetElementPlace.cs ---



// --- Start of File: ActorAssetFilter.cs ---
public delegate bool ActorAssetFilter(ActorAsset pAsset);
// --- End of File: ActorAssetFilter.cs ---



// --- Start of File: ActorAssetLibrary.cs ---
using System;
using System.Collections.Generic;
using System.Reflection;
using Beebyte.Obfuscator;
using UnityEngine;
using strings;

[Serializable]
[ObfuscateLiterals]
public class ActorAssetLibrary : BaseLibraryWithUnlockables<ActorAsset>
{
	[NonSerialized]
	public List<ActorAsset> list_only_boat_assets;

	private int _humanoids_amount;

	private const string TEMPLATE_BASIC_UNIT = "$basic_unit$";

	private const string TEMPLATE_BASIC_UNIT_COLORED = "$basic_unit_colored$";

	private const string TEMPLATE_ANIMAL_BASE = "$animal_base$";

	private const string TEMPLATE_ANIMAL = "$animal$";

	private const string TEMPLATE_ANIMAL_FUR = "$animal_fur$";

	private const string TEMPLATE_ANIMAL_SKIN = "$animal_skin$";

	private const string TEMPLATE_PEACEFUL_ANIMAL = "$peaceful_animal$";

	private const string TEMPLATE_CARNIVORE = "$carnivore$";

	private const string TEMPLATE_HERBIVORE = "$herbivore$";

	private const string TEMPLATE_OMNIVORE = "$omnivore$";

	private const string TEMPLATE_CIV_UNIT = "$civ_unit$";

	private const string TEMPLATE_CIV_ADVANCED_UNIT = "$civ_advanced_unit$";

	private const string TEMPLATE_BOAT = "$boat$";

	private const string TEMPLATE_BOAT_TRADING = "$boat_trading$";

	private const string TEMPLATE_BOAT_TRANSPORT = "$boat_transport$";

	private const string TEMPLATE_MOB_NO_GENES = "$mob_no_genes$";

	private const string TEMPLATE_MOB = "$mob$";

	private const string TEMPLATE_CREEP_MOB = "$creep_mob$";

	private const string TEMPLATE_ANIMAL_CIV = "$animal_civ$";

	private const string TEMPLATE_INSECT = "$insect$";

	private const string TEMPLATE_FLYING_INSECT = "$flying_insect$";

	public int getHumanoidsAmount()
	{
		return _humanoids_amount;
	}

	public override void init()
	{
		Debug.Log((object)"INIT ActorStats");
		base.init();
		initTemplates();
		initCivsClassic();
		initAnimalsNormal();
		initAnimalsWeird();
		initInsects();
		initMobsOther();
		initCivsNew();
		initSpecial();
		initAnts();
		initCreepMobs();
		initBoats();
		Debug.Log((object)("GENERATE ACTOR STATS " + list.Count));
	}

	private void initSpecial()
	{
		clone("greg", "$mob$");
		t.setUnlockedWithAchievement("achievementCreaturesExplorer");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("greg_set");
		t.kingdom_id_wild = "greg";
		t.kingdom_id_civilization = "miniciv_greg";
		t.name_taxonomic_kingdom = "gregalia";
		t.name_taxonomic_phylum = "gregata";
		t.name_taxonomic_class = "gregia";
		t.name_taxonomic_order = "greges";
		t.name_taxonomic_family = "gregae";
		t.name_taxonomic_genus = "greg";
		t.name_taxonomic_species = "greg";
		t.collective_term = "group_grex";
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTrait("enhanced_strength");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("big_stomach");
		t.addSubspeciesTrait("diet_geophagy");
		t.addSubspeciesTrait("diet_xylophagy");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("exoskeleton");
		t.addSubspeciesTrait("fenix_born");
		t.addSubspeciesTrait("parental_care");
		t.addSubspeciesTrait("reproduction_parthenogenesis");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("gestation_extremely_long");
		t.addSubspeciesTrait("voracious");
		t.addSubspeciesTrait("egg_face");
		t.addReligionTrait("echo_of_the_void");
		t.addTrait("giant");
		t.addTrait("strong");
		t.addTrait("regeneration");
		addPhenotype("bright_yellow");
		t.special = true;
		t.unit_other = true;
		t.name_locale = "Greg";
		t.actor_size = ActorSize.S15_Bear;
		t.shadow_texture = "unitShadow_6";
		t.animation_walk = ActorAnimationSequences.walk_0;
		t.animation_swim = ActorAnimationSequences.walk_0;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.architecture_id = "civ_greg";
		t.banner_id = "human";
		t.addGenome(("health", 500f), ("stamina", 200f), ("mutation", 2f), ("damage", 100f), ("armor", 10f), ("speed", 40f));
		t.icon = "iconGreg";
		t.color_hex = "#24803E";
		t.rotating_animation = true;
		t.has_soul = true;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.addResource("worms", 2, pNewList: true);
		t.addResource("evil_beets", 1);
		clone("living_plants", "$mob_no_genes$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("living_plant_set");
		t.use_phenotypes = false;
		t.special = true;
		t.has_baby_form = false;
		t.name_locale = "living_plant";
		t.actor_size = ActorSize.S15_Bear;
		t.shadow_texture = "unitShadow_6";
		t.kingdom_id_wild = "living_plants";
		t.base_stats["health"] = 300f;
		t.base_stats["speed"] = 10f;
		t.base_stats["armor"] = 0f;
		t.base_stats["attack_speed"] = 70f;
		t.base_stats["damage"] = 30f;
		t.base_stats["knockback"] = 1.2f;
		t.base_stats["mass"] = 50f;
		t.base_stats["mass_2"] = 500f;
		t.base_stats["targets"] = 3f;
		t.damaged_by_ocean = true;
		t.icon = "iconLivingPlants";
		t.show_icon_inspect_window = true;
		t.show_icon_inspect_window_id = "iconLivingPlants";
		t.color_hex = "#115D11";
		t.rotating_animation = true;
		t.disable_jump_animation = false;
		t.inspect_avatar_scale = 1f;
		t.base_stats["scale"] = 0.25f;
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.action_on_load = delegate(Actor pActor)
		{
			pActor.data.get("special_sprite_id", out var pResult3, null);
			if (!string.IsNullOrEmpty(pResult3))
			{
				AssetManager.buildings.get(pResult3).checkSpritesAreLoaded();
			}
		};
		t.get_override_sprite = delegate(Actor pActor)
		{
			pActor.data.get("special_sprite_id", out var pResult, null);
			pActor.data.get("special_sprite_index", out var pResult2, 0);
			if (string.IsNullOrEmpty(pResult))
			{
				pResult = "ui/Icons/iconLivingPlants";
				return SpriteTextureLoader.getSprite(pResult);
			}
			return AssetManager.buildings.get(pResult).building_sprites.animation_data[pResult2].main[0];
		};
		addTrait("regeneration");
		t.music_theme = "Units_LivingPlants";
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.show_in_knowledge_window = false;
		t.use_items = false;
		t.take_items = false;
		t.can_edit_equipment = false;
		t.use_tool_items = false;
		t.addResource("herbs", 1, pNewList: true);
		clone("living_house", "$mob_no_genes$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("living_house_set");
		t.use_phenotypes = false;
		t.has_baby_form = false;
		t.special = true;
		t.name_locale = "living_house";
		t.actor_size = ActorSize.S15_Bear;
		t.shadow_texture = "unitShadow_6";
		t.kingdom_id_wild = "living_houses";
		t.base_stats["health"] = 500f;
		t.base_stats["armor"] = 1f;
		t.base_stats["speed"] = 10f;
		t.base_stats["attack_speed"] = 60f;
		t.base_stats["damage"] = 50f;
		t.base_stats["knockback"] = 1.4f;
		t.base_stats["mass"] = 50f;
		t.base_stats["mass_2"] = 10000f;
		t.base_stats["targets"] = 3f;
		t.damaged_by_ocean = true;
		t.icon = "iconLivingHouse";
		t.show_icon_inspect_window = true;
		t.show_icon_inspect_window_id = "iconLivingHouse";
		t.color_hex = "#24803E";
		t.rotating_animation = true;
		t.disable_jump_animation = false;
		t.inspect_avatar_scale = 1f;
		t.base_stats["scale"] = 0.25f;
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.get_override_sprite = get("living_plants").get_override_sprite;
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.show_in_knowledge_window = false;
		t.use_items = false;
		t.take_items = false;
		t.can_edit_equipment = false;
		t.use_tool_items = false;
		t.addResource("wood", 1, pNewList: true);
		add(t = new ActorAsset
		{
			id = "dragon",
			kingdom_id_wild = "dragons",
			special = true,
			can_be_killed_by_stuff = true,
			can_be_killed_by_life_eraser = true,
			ignore_tile_speed_multiplier = true,
			skip_fight_logic = true,
			job = AssetLibrary<ActorAsset>.a<string>("dragon_job"),
			can_be_moved_by_powers = true,
			can_be_hurt_by_powers = true,
			update_z = true,
			default_height = 0f,
			effect_damage = true,
			can_flip = true,
			can_turn_into_zombie = true,
			actor_size = ActorSize.S17_Dragon,
			shadow_texture = "unitShadow_7",
			can_be_inspected = true,
			hide_favorite_icon = true,
			icon = "iconDragon",
			inspect_avatar_scale = 1.1f,
			inspect_avatar_offset_y = -22f,
			avatar_prefab = "p_dragon",
			visible_on_minimap = true,
			die_on_blocks = false,
			ignore_blocks = true,
			move_from_block = false,
			run_to_water_when_on_fire = false,
			split_ai_update = false,
			experience_given = 100,
			can_be_surprised = false,
			allow_possession = false,
			show_task_icon = false,
			can_talk_with = false,
			control_can_backstep = false,
			control_can_dash = false,
			control_can_jump = false,
			control_can_kick = false,
			control_can_talk = false,
			control_can_swear = false,
			control_can_steal = false,
			inspect_mind = false
		});
		t.setCanTurnIntoZombieAsset("zombie_dragon", pAutoZombieAsset: false);
		t.get_override_sprite = (Actor pActor) => pActor.getSpriteAnimation().currentSpriteGraphic;
		t.get_override_avatar_frames = (Actor pActor) => PrefabLibrary.instance.dragonAsset.getAsset(DragonState.Fly).frames;
		t.allowed_status_tiers = StatusTier.Basic;
		t.render_status_effects = false;
		t.name_locale = "Dragon";
		t.die_in_lava = false;
		t.cancel_beh_on_land = false;
		t.base_stats["health"] = 1000f;
		t.base_stats["damage"] = 100f;
		t.base_stats["speed"] = 40f;
		t.base_stats["scale"] = 0.3f;
		t.base_stats["size"] = 2f;
		t.base_stats["mass"] = 4f;
		t.base_stats["mass_2"] = 2500f;
		t.base_stats["targets"] = 20f;
		t.base_stats["lifespan"] = 10000f;
		addTrait("regeneration");
		addTrait("strong_minded");
		addTrait("fire_proof");
		addTrait("fire_blood");
		t.addResource("dragon_scales", 10, pNewList: true);
		t.addResource("meat", 10);
		t.addResource("bones", 10);
		t.music_theme = "Units_Dragon";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		ActorAsset actorAsset = t;
		actorAsset.action_click = (WorldAction)Delegate.Combine(actorAsset.action_click, new WorldAction(Dragon.clickToWakeup));
		t.action_dead_animation = Dragon.dragonFall;
		ActorAsset actorAsset2 = t;
		actorAsset2.action_death = (WorldAction)Delegate.Combine(actorAsset2.action_death, new WorldAction(ActionLibrary.dragonSlayer));
		ActorAsset actorAsset3 = t;
		actorAsset3.action_get_hit = (GetHitAction)Delegate.Combine(actorAsset3.action_get_hit, new GetHitAction(Dragon.getHit));
		t.check_flip = Dragon.canFlip;
		t.animation_speed_based_on_walk_speed = false;
		t.needs_to_be_explored = false;
		t.use_tool_items = false;
		clone("zombie_dragon", "dragon");
		t.special = true;
		t.name_locale = "Zombie";
		t.avatar_prefab = "p_zombie_dragon";
		t.visible_on_minimap = true;
		t.die_in_lava = true;
		t.show_in_knowledge_window = false;
		t.setZombie(pAnimal: false);
		t.job = AssetLibrary<ActorAsset>.a<string>("dragon_job");
		removeTrait("fire_proof");
		removeTrait("fire_blood");
		addTrait("acid_blood");
		addTrait("acid_proof");
		add(t = new ActorAsset
		{
			id = "UFO",
			kingdom_id_wild = "aliens",
			special = true,
			can_be_killed_by_stuff = true,
			can_be_killed_by_life_eraser = true,
			ignore_tile_speed_multiplier = true,
			skip_fight_logic = true,
			job = AssetLibrary<ActorAsset>.a<string>("ufo_job"),
			flying = true,
			very_high_flyer = true,
			can_be_moved_by_powers = true,
			can_be_hurt_by_powers = true,
			effect_damage = true,
			special_dead_animation = true,
			actor_size = ActorSize.S17_Dragon,
			shadow_texture = "unitShadow_7",
			can_be_inspected = true,
			icon = "iconUfo",
			hide_favorite_icon = true,
			die_by_lightning = true,
			avatar_prefab = "p_ufo",
			visible_on_minimap = true,
			die_on_blocks = false,
			ignore_blocks = true,
			move_from_block = false,
			run_to_water_when_on_fire = false,
			has_skin = false,
			flag_ufo = true,
			split_ai_update = false,
			allow_possession = false,
			show_task_icon = false,
			can_talk_with = false,
			control_can_backstep = false,
			control_can_dash = false,
			control_can_jump = false,
			control_can_kick = false,
			control_can_talk = false,
			control_can_swear = false,
			control_can_steal = false
		});
		t.get_override_sprite = (Actor pActor) => pActor.getSpriteAnimation().currentSpriteGraphic;
		t.allowed_status_tiers = StatusTier.Basic;
		t.render_status_effects = false;
		t.inspect_avatar_scale = 1.45f;
		t.inspect_avatar_offset_y = 8f;
		t.name_locale = "UFO";
		t.name_template_unit = "ufo_name";
		t.base_stats["health"] = 1000f;
		t.base_stats["armor"] = 5f;
		t.base_stats["scale"] = 0.3f;
		t.base_stats["speed"] = 20f;
		t.base_stats["damage"] = 80f;
		t.base_stats["lifespan"] = 0f;
		t.base_stats["size"] = 2f;
		ActorAsset actorAsset4 = t;
		actorAsset4.action_death = (WorldAction)Delegate.Combine(actorAsset4.action_death, new WorldAction(ActionLibrary.spawnAliens));
		t.base_stats["mass"] = 5f;
		t.base_stats["mass_2"] = 2500f;
		t.action_dead_animation = UFO.ufoFall;
		ActorAsset actorAsset5 = t;
		actorAsset5.action_click = (WorldAction)Delegate.Combine(actorAsset5.action_click, new WorldAction(UFO.click));
		ActorAsset actorAsset6 = t;
		actorAsset6.action_get_hit = (GetHitAction)Delegate.Combine(actorAsset6.action_get_hit, new GetHitAction(UFO.getHit));
		t.prevent_unconscious_rotation = true;
		addTrait("strong_minded");
		addTrait("fire_proof");
		addTrait("light_lamp");
		t.music_theme = "Units_UFO";
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.needs_to_be_explored = false;
		t.can_be_surprised = false;
		t.use_tool_items = false;
		t.default_height = 8f;
		add(t = new ActorAsset
		{
			id = "crabzilla",
			kingdom_id_wild = "crabzilla",
			special = true,
			can_be_killed_by_stuff = true,
			ignore_tile_speed_multiplier = true,
			skip_fight_logic = true,
			flying = false,
			can_be_moved_by_powers = false,
			can_be_hurt_by_powers = true,
			update_z = true,
			can_flip = false,
			skip_save = true,
			avatar_prefab = "p_crabzilla",
			visible_on_minimap = true,
			ignore_generic_render = true,
			die_on_blocks = false,
			ignore_blocks = true,
			move_from_block = false,
			run_to_water_when_on_fire = false,
			ignored_by_infinity_coin = true,
			split_ai_update = false,
			has_ai_system = false,
			show_in_knowledge_window = false,
			show_task_icon = false,
			can_talk_with = false,
			control_can_backstep = false,
			control_can_dash = false,
			control_can_jump = false,
			control_can_kick = false,
			control_can_talk = false,
			control_can_swear = false,
			control_can_steal = false,
			show_controllable_tip = false
		});
		t.allowed_status_tiers = StatusTier.None;
		t.has_sprite_renderer = false;
		t.name_locale = "Crabzilla";
		t.icon = "iconCrabzilla";
		t.base_stats["scale"] = 0.25f;
		t.actor_size = ActorSize.S17_Dragon;
		t.base_stats["health"] = 10000f;
		t.base_stats["speed"] = 50f;
		t.base_stats["damage"] = 10f;
		t.base_stats["size"] = 8f;
		t.base_stats["mass_2"] = 99999f;
		t.can_level_up = false;
		t.shadow = false;
		t.hit_fx_alternative_offset = false;
		ActorAsset actorAsset7 = t;
		actorAsset7.action_death = (WorldAction)Delegate.Combine(actorAsset7.action_death, new WorldAction(ActionLibrary.clearCrabzilla));
		ActorAsset actorAsset8 = t;
		actorAsset8.action_death = (WorldAction)Delegate.Combine(actorAsset8.action_death, new WorldAction(ActionLibrary.startCrabzillaNuke));
		t.action_dead_animation = delegate(BaseSimObject pTarget, WorldTile _, float _)
		{
			pTarget.a.dieAndDestroy(AttackType.None);
			return true;
		};
		ActorAsset actorAsset9 = t;
		actorAsset9.action_get_hit = (GetHitAction)Delegate.Combine(actorAsset9.action_get_hit, new GetHitAction(Crabzilla.getHit));
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		addTrait("strong_minded");
		t.needs_to_be_explored = false;
		t.can_be_surprised = false;
		t.use_tool_items = false;
		add(t = new ActorAsset
		{
			id = "god_finger",
			special = true,
			actor_size = ActorSize.S17_Dragon,
			shadow_texture = "unitShadow_7",
			kingdom_id_wild = "godfinger",
			can_be_killed_by_stuff = true,
			ignore_tile_speed_multiplier = true,
			can_be_killed_by_life_eraser = true,
			skip_fight_logic = true,
			can_be_moved_by_powers = true,
			can_be_hurt_by_powers = true,
			update_z = false,
			effect_damage = true,
			skip_save = true,
			avatar_prefab = "p_god_finger",
			visible_on_minimap = true,
			die_on_blocks = false,
			ignore_blocks = true,
			move_from_block = false,
			run_to_water_when_on_fire = false,
			split_ai_update = false,
			has_ai_system = true,
			job = AssetLibrary<ActorAsset>.a<string>("godfinger_job"),
			flying = true,
			very_high_flyer = true,
			die_by_lightning = true,
			show_in_knowledge_window = false,
			allow_possession = false,
			show_task_icon = false,
			can_talk_with = false,
			control_can_backstep = false,
			control_can_dash = false,
			control_can_jump = false,
			control_can_kick = false,
			control_can_talk = false,
			control_can_swear = false,
			control_can_steal = false,
			show_in_taxonomy_tooltip = false
		});
		t.get_override_sprite = (Actor pActor) => pActor.getSpriteAnimation().currentSpriteGraphic;
		t.allowed_status_tiers = StatusTier.Basic;
		t.render_status_effects = false;
		t.flag_finger = true;
		t.name_locale = "God Finger";
		t.base_stats["scale"] = 0.3f;
		t.base_stats["mass"] = 5f;
		t.base_stats["mass_2"] = 99999f;
		t.base_stats["speed"] = 50f;
		t.base_stats["damage"] = 80f;
		t.base_stats["lifespan"] = 10000f;
		t.base_stats["size"] = 2f;
		t.base_stats["health"] = 100f;
		t.base_stats["armor"] = 5f;
		t.die_in_lava = false;
		addTrait("light_lamp");
		addTrait("strong_minded");
		addTrait("fire_proof");
		t.music_theme = "Units_GodFinger";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.needs_to_be_explored = false;
		ActorAsset actorAsset10 = t;
		actorAsset10.action_dead_animation = (DeadAnimation)Delegate.Combine(actorAsset10.action_dead_animation, new DeadAnimation(GodFinger.deathFlip));
		t.can_be_surprised = false;
		t.use_tool_items = false;
	}

	private void initAnts()
	{
		clone("ant_black", "$basic_unit$");
		t.allow_possession = false;
		t.can_be_cloned = false;
		t.show_task_icon = false;
		t.kingdom_id_wild = "ants";
		t.can_be_killed_by_stuff = true;
		t.can_be_killed_by_life_eraser = true;
		t.ignore_tile_speed_multiplier = true;
		t.skip_fight_logic = true;
		t.can_be_moved_by_powers = true;
		t.can_be_hurt_by_powers = true;
		t.update_z = true;
		t.effect_damage = true;
		t.can_flip = true;
		t.actor_size = ActorSize.S13_Human;
		t.color_hex = "#000000";
		t.die_on_blocks = false;
		t.ignore_blocks = true;
		t.move_from_block = false;
		t.run_to_water_when_on_fire = false;
		t.force_land_creature = true;
		t.force_ocean_creature = true;
		t.split_ai_update = false;
		t.can_be_inspected = true;
		t.name_locale = "Black Ant";
		t.name_template_unit = "ant_name";
		t.unit_other = true;
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_black");
		t.animation_walk = ActorAnimationSequences.walk_0;
		t.base_stats["speed"] = 20f;
		t.base_stats["mass_2"] = 0.01f;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.icon = "iconAntBlack";
		addTrait("strong_minded");
		t.generateFmodPaths("ant_black");
		t.can_be_surprised = false;
		t.use_tool_items = false;
		t.inspect_mind = false;
		t.inspect_genealogy = false;
		t.can_talk_with = false;
		clone("ant_green", "ant_black");
		t.name_locale = "Green Ant";
		t.icon = "iconAntGreen";
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_green");
		t.color_hex = "#007F0E";
		clone("ant_blue", "ant_black");
		t.name_locale = "Blue Ant";
		t.icon = "iconAntBlue";
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_blue");
		t.color_hex = "#0094FF";
		clone("ant_red", "ant_black");
		t.name_locale = "Red Ant";
		t.icon = "iconAntRed";
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_red");
		t.color_hex = "#FF2511";
		clone("sand_spider", "ant_black");
		t.name_locale = "Sand Spider";
		t.icon = "iconSandSpider";
		t.job = AssetLibrary<ActorAsset>.a<string>("sandspider_job");
		t.color_hex = "#2D2D2D";
		t.base_stats["speed"] = 100f;
		clone("worm", "ant_black");
		t.unit_other = true;
		t.can_be_inspected = false;
		t.name_template_unit = "bug_name";
		t.name_locale = "Worm";
		t.job = AssetLibrary<ActorAsset>.a<string>("worm_job");
		t.animation_walk = ActorAnimationSequences.walk_0;
		t.can_be_moved_by_powers = false;
		t.can_be_hurt_by_powers = true;
		t.can_be_killed_by_stuff = false;
		t.kingdom_id_wild = "nature";
		t.base_stats["speed"] = 100f;
		t.base_stats["mass_2"] = 0.05f;
		t.color_hex = null;
		t.shadow = false;
		addTrait("fire_proof");
		t.music_theme = "Units_Worm";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		clone("printer", "ant_black");
		t.kingdom_id_wild = "nature";
		t.job = AssetLibrary<ActorAsset>.a<string>("printer_job");
		t.can_be_moved_by_powers = false;
		t.can_be_hurt_by_powers = true;
		t.update_z = true;
		t.effect_damage = true;
		t.can_flip = true;
		t.skip_save = true;
		t.die_on_blocks = false;
		t.ignore_blocks = true;
		t.move_from_block = false;
		t.run_to_water_when_on_fire = false;
		t.ignored_by_infinity_coin = true;
		t.split_ai_update = false;
		t.unit_other = true;
		t.name_locale = "Printer";
		t.base_stats["health"] = 1f;
		t.base_stats["speed"] = 10000f;
		t.base_stats["mass"] = 10f;
		t.animation_walk = ActorAnimationSequences.walk_0_2;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
	}

	private void initCreepMobs()
	{
		clone("$creep_mob$", "$mob$");
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("default_set");
		t.base_stats["speed"] = 10f;
		t.has_advanced_textures = false;
		t.can_turn_into_ice_one = false;
		t.has_baby_form = false;
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		clone("mush_unit", "$creep_mob$");
		t.can_edit_equipment = true;
		t.take_items = true;
		t.use_items = true;
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "ascomycota";
		t.name_taxonomic_class = "sordariomycetes";
		t.name_taxonomic_order = "hypocreales";
		t.name_taxonomic_family = "cordycipitaceae";
		t.name_taxonomic_genus = "cordyceps";
		t.name_taxonomic_species = "puppetus";
		t.collective_term = "group_mycelium";
		addPhenotype("dark_green");
		t.base_stats["mass_2"] = 60f;
		t.addGenome(("health", 300f), ("stamina", 50f), ("lifespan", 100f), ("mutation", 5f), ("damage", 25f), ("attack_speed", 30f), ("speed", 30f));
		t.unit_other = true;
		t.name_taxonomic_kingdom = "fungi";
		t.collective_term = "group_mycelium";
		t.name_locale = "Mush";
		t.body_separate_part_hands = true;
		t.kingdom_id_wild = "mush";
		t.can_be_killed_by_divine_light = true;
		t.icon = "actor_traits/iconMushSpores";
		t.color_hex = "#FF49CB";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.can_turn_into_zombie = false;
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		addTrait("weightless");
		addTrait("mush_spores");
		addTrait("regeneration");
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		clone("mush_animal", "mush_unit");
		t.name_taxonomic_species = "pippitus";
		t.show_in_taxonomy_tooltip = false;
		t.icon = "actor_traits/iconMushSpores";
		t.unit_other = true;
		t.base_stats["health"] = 200f;
		t.base_stats["mass_2"] = 45f;
		t.body_separate_part_hands = false;
		t.use_items = false;
		t.take_items = false;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		clone("tumor_monster_unit", "$mob$");
		t.needs_to_be_explored = true;
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("default_set");
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "neoplasia";
		t.name_taxonomic_class = "malignomorpha";
		t.name_taxonomic_order = "oncovorales";
		t.name_taxonomic_family = "tumoridae";
		t.name_taxonomic_genus = "neoplasmus";
		t.name_taxonomic_species = "carcinomus";
		t.collective_term = "group_cancer";
		addPhenotype("dark_salmon");
		t.base_stats["mass_2"] = 75f;
		t.addGenome(("health", 100f), ("stamina", 50f), ("lifespan", 100f), ("mutation", 5f), ("damage", 15f), ("speed", 6f));
		t.icon = "iconTumor";
		t.unit_other = true;
		t.name_locale = "Tumor Monster";
		t.immune_to_tumor = true;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.body_separate_part_hands = true;
		t.kingdom_id_wild = "tumor";
		t.icon = "iconTumorMonster";
		t.color_hex = "#FF49CB";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		addTrait("weightless");
		addTrait("ugly");
		addTraitIgnore("bomberman");
		addTraitIgnore("pyromaniac");
		t.music_theme = "Buildings_Tumor";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		clone("tumor_monster_animal", "tumor_monster_unit");
		t.show_in_taxonomy_tooltip = false;
		t.show_in_knowledge_window = false;
		t.base_asset_id = "tumor_monster_unit";
		t.icon = "iconTumorMonster";
		t.unit_other = true;
		t.body_separate_part_hands = false;
		t.use_items = false;
		t.take_items = false;
		t.mush_id = "mush_animal";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.base_stats["mass_2"] = 55f;
		clone("lil_pumpkin", "tumor_monster_animal");
		t.show_in_knowledge_window = true;
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("pumpkin_set");
		t.show_in_taxonomy_tooltip = true;
		t.name_taxonomic_kingdom = "plantae";
		t.name_taxonomic_phylum = "angiospermae";
		t.name_taxonomic_class = "dicotyledonae";
		t.name_taxonomic_order = "cucurbitales";
		t.name_taxonomic_family = "cucurbitaceae";
		t.name_taxonomic_genus = "worldboxus";
		t.name_taxonomic_species = "maximus";
		t.collective_term = "group_squash";
		t.addSubspeciesTrait("egg_pumpkin");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		clearPhenotypes();
		addPhenotype("dark_orange");
		t.base_stats["mass_2"] = 9f;
		t.addGenome(("health", 1000f), ("stamina", 150f), ("lifespan", 100f), ("mutation", 5f), ("damage", 15f), ("speed", 6f));
		t.icon = "iconLilPumpkin";
		t.unit_other = true;
		t.name_locale = "Lil Pumpkin";
		t.kingdom_id_wild = "super_pumpkin";
		t.immune_to_slowness = true;
		t.mush_id = "mush_animal";
		t.clearTraits();
		addTrait("attractive");
		addTrait("fat");
		addTrait("bloodlust");
		addTrait("thorns");
		addTraitIgnore("bomberman");
		addTraitIgnore("pyromaniac");
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.base_asset_id = null;
		t.addResource("herbs", 1, pNewList: true);
		t.addResource("tea", 1);
		clone("assimilator", "tumor_monster_animal");
		t.show_in_knowledge_window = true;
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("assimilator_set");
		t.show_in_taxonomy_tooltip = true;
		clearPhenotypes();
		addPhenotype("black_blue");
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTrait("egg_metal_box");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.name_taxonomic_kingdom = "machina";
		t.name_taxonomic_phylum = "cybernetica";
		t.name_taxonomic_class = "slowupdata";
		t.name_taxonomic_order = "noupdates";
		t.name_taxonomic_family = "assimiladae";
		t.name_taxonomic_genus = "assimilatus";
		t.name_taxonomic_species = "perfectus";
		t.collective_term = "group_network";
		t.addGenome(("health", 1000f), ("stamina", 300f), ("lifespan", 100f), ("mutation", 5f), ("damage", 15f), ("armor", 20f), ("speed", 6f));
		t.icon = "iconAssimilator";
		t.unit_other = true;
		t.name_locale = "Assimilator";
		t.inspect_avatar_scale = 2.1f;
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.kingdom_id_wild = "assimilators";
		t.base_stats["mass_2"] = 15f;
		t.base_stats["damage"] = 0f;
		t.body_separate_part_hands = true;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("shotgun");
		addTrait("fire_proof");
		addTrait("bubble_defense");
		removeTrait("ugly");
		removeTrait("weightless");
		addTraitIgnore("bomberman");
		addTraitIgnore("pyromaniac");
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.use_items = true;
		t.base_asset_id = null;
		t.addResource("adamantine", 1, pNewList: true);
		t.addResource("common_metals", 1);
		clone("bioblob", "tumor_monster_animal");
		t.show_in_knowledge_window = true;
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bioblob_set");
		t.show_in_taxonomy_tooltip = true;
		t.name_taxonomic_kingdom = "protista";
		t.name_taxonomic_phylum = "amoebozoa";
		t.name_taxonomic_class = "myxogastria";
		t.name_taxonomic_order = "physarales";
		t.name_taxonomic_family = "blobidae";
		t.name_taxonomic_genus = "blobus";
		t.name_taxonomic_species = "opticus";
		t.collective_term = "group_blob";
		t.addSubspeciesTrait("egg_eyeball");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		addTrait("strong_minded");
		addTrait("ugly");
		addTrait("fragile_health");
		clearPhenotypes();
		addPhenotype("toxic_green");
		t.base_stats["mass_2"] = 15f;
		t.addGenome(("health", 200f), ("stamina", 20f), ("lifespan", 100f), ("mutation", 5f), ("damage", 15f), ("armor", 20f), ("speed", 6f));
		t.icon = "iconBioblob";
		t.unit_other = true;
		t.name_locale = "Bioblob";
		t.kingdom_id_wild = "biomass";
		t.immune_to_slowness = true;
		t.mush_id = "mush_animal";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.prevent_unconscious_rotation = true;
		t.base_asset_id = null;
	}

	public void clearPhenotypes()
	{
		t.phenotypes_dict = null;
		t.phenotypes_list = null;
	}

	public void addPhenotype(string pID, string pType = "default_color")
	{
		if (t.phenotypes_dict == null)
		{
			t.phenotypes_dict = new Dictionary<string, List<string>>();
			t.phenotypes_list = new List<string>();
		}
		if (!t.phenotypes_dict.ContainsKey(pType))
		{
			t.phenotypes_dict[pType] = new List<string>();
		}
		if (!t.phenotypes_dict[pType].Contains(pID))
		{
			t.phenotypes_dict[pType].Add(pID);
			t.phenotypes_list.Add(pID);
		}
	}

	public void clear()
	{
		for (int i = 0; i < list.Count; i++)
		{
			list[i].units.Clear();
		}
	}

	internal void addTrait(string pTrait)
	{
		t.addTrait(pTrait);
	}

	internal void addTraitIgnore(string pTrait)
	{
		t.addTraitIgnore(pTrait);
	}

	internal void removeTrait(string pTrait)
	{
		t.removeTrait(pTrait);
	}

	public override void post_init()
	{
		loadAutoTextures(list);
		generateZombieAssets();
		loadShadows();
		base.post_init();
		generateFmodPaths();
		foreach (ActorAsset item in list)
		{
			if (item.action_dead_animation != null)
			{
				item.special_dead_animation = true;
			}
			if (!string.IsNullOrEmpty(item.base_asset_id))
			{
				ActorAsset actorAsset = get(item.base_asset_id);
				item.units = actorAsset.units;
			}
			if (item.is_humanoid && !item.unit_zombie)
			{
				_humanoids_amount++;
			}
		}
	}

	private void linkSpells()
	{
		foreach (ActorAsset item in list)
		{
			if (item.spell_ids != null && item.spell_ids.Count != 0)
			{
				item.spells = new SpellHolder();
				item.spells.mergeWith(item.spell_ids);
			}
		}
	}

	public override void linkAssets()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.linkAssets();
		setupBoolsAvatarPrefabs();
		setupBoolSpriteOverrides();
		linkArchitectures();
		linkSpells();
		fillOnlyBoatsList();
		foreach (ActorAsset item in list)
		{
			if (item.color_hex != null)
			{
				item.color = Color32.op_Implicit(Toolbox.makeColor(item.color_hex));
			}
			if (item.check_flip == null)
			{
				item.check_flip = (BaseSimObject _, WorldTile _) => true;
			}
		}
	}

	private void linkArchitectures()
	{
		foreach (ActorAsset item in list)
		{
			if (!string.IsNullOrEmpty(item.architecture_id))
			{
				item.architecture_asset = AssetManager.architecture_library.get(item.architecture_id);
			}
		}
	}

	public override ActorAsset add(ActorAsset pAsset)
	{
		ActorAsset actorAsset = base.add(pAsset);
		if (actorAsset.base_stats == null)
		{
			actorAsset.base_stats = new BaseStats();
		}
		return actorAsset;
	}

	private void fillOnlyBoatsList()
	{
		list_only_boat_assets = list.FindAll((ActorAsset pAsset) => pAsset.is_boat);
	}

	private void setupBoolSpriteOverrides()
	{
		foreach (ActorAsset item in list)
		{
			if (item.get_override_sprite != null)
			{
				item.has_override_sprite = true;
			}
			if (item.get_override_avatar_frames != null)
			{
				item.has_override_avatar_frames = true;
			}
		}
	}

	private void setupBoolsAvatarPrefabs()
	{
		foreach (ActorAsset item in list)
		{
			if (item.avatar_prefab != string.Empty)
			{
				item.has_avatar_prefab = true;
			}
		}
	}

	private void loadAutoTextures(IEnumerable<ActorAsset> pAssetsList)
	{
		foreach (ActorAsset pAssets in pAssetsList)
		{
			loadTexturesAndSprites(pAssets);
		}
	}

	private void generateFmodPaths()
	{
		foreach (ActorAsset item in list)
		{
			if (!item.is_boat)
			{
				item.generateFmodPaths(item.id);
			}
		}
	}

	private void loadTexturesAndSprites(ActorAsset pAsset)
	{
		string text = "actors/species/";
		string texture_id = pAsset.id;
		if (pAsset.texture_id != string.Empty)
		{
			texture_id = pAsset.texture_id;
		}
		if (pAsset.default_animal)
		{
			text = text + "animals/" + texture_id + "/";
		}
		else if (pAsset.civ)
		{
			text = text + "civs/" + texture_id + "/";
		}
		else if (pAsset.unit_other)
		{
			text = text + "other/" + texture_id + "/";
		}
		ActorTextureSubAsset actorTextureSubAsset = pAsset.texture_asset;
		if (actorTextureSubAsset == null)
		{
			actorTextureSubAsset = (pAsset.texture_asset = new ActorTextureSubAsset(text, pAsset.has_advanced_textures));
			actorTextureSubAsset.prevent_unconscious_rotation = pAsset.prevent_unconscious_rotation;
			actorTextureSubAsset.render_heads_for_children = pAsset.render_heads_for_babies;
			if (pAsset.shadow)
			{
				actorTextureSubAsset.shadow = true;
				actorTextureSubAsset.shadow_texture = pAsset.shadow_texture;
				actorTextureSubAsset.shadow_texture_egg = pAsset.shadow_texture_egg;
				actorTextureSubAsset.shadow_texture_baby = pAsset.shadow_texture_baby;
			}
		}
		if (pAsset.can_turn_into_zombie)
		{
			pAsset.texture_path_zombie_for_auto_loader_main = text + "zombie";
			pAsset.texture_path_zombie_for_auto_loader_heads = text + "heads_zombie";
		}
		if (pAsset.has_baby_form)
		{
			bool flag = hasSpriteInResources(actorTextureSubAsset.texture_path_baby);
			if (!flag)
			{
				Sprite[] spriteList = SpriteTextureLoader.getSpriteList(actorTextureSubAsset.texture_path_baby);
				for (int i = 0; i < spriteList.Length; i++)
				{
					if (!(((Object)spriteList[i]).name != "walk_0_head"))
					{
						flag = true;
						break;
					}
				}
			}
			if (pAsset.render_heads_for_babies && !flag)
			{
				Debug.LogError((object)("ActorAssetLibrary: Actor Asset " + pAsset.id + " does not have head sprite for baby, but supposed to render them!"));
			}
		}
		else
		{
			actorTextureSubAsset.texture_path_baby = null;
		}
	}

	private void generateZombieAssets()
	{
		using ListPool<ActorAsset> listPool = new ListPool<ActorAsset>(list);
		using ListPool<ActorAsset> listPool2 = new ListPool<ActorAsset>(128);
		createDefaultZombieAsset();
		foreach (ref ActorAsset item2 in listPool)
		{
			ActorAsset current = item2;
			if (!current.isTemplateAsset() && current.zombie_auto_asset && current.can_turn_into_zombie)
			{
				string zombieID = current.getZombieID();
				ActorAsset item = clone(zombieID, current.id);
				listPool2.Add(item);
				setDefaultZombieFields(t, current, current.default_animal);
				ActorTextureSubAsset actorTextureSubAsset = new ActorTextureSubAsset(current.texture_path_zombie_for_auto_loader_main, t.has_advanced_textures);
				t.texture_asset = actorTextureSubAsset;
				ActorTextureSubAsset texture_asset = current.texture_asset;
				actorTextureSubAsset.shadow = texture_asset.shadow;
				actorTextureSubAsset.shadow_texture = texture_asset.shadow_texture;
				actorTextureSubAsset.shadow_texture_egg = texture_asset.shadow_texture_egg;
				actorTextureSubAsset.shadow_texture_baby = texture_asset.shadow_texture_baby;
				if (hasSpriteInResources(current.texture_path_zombie_for_auto_loader_main))
				{
					actorTextureSubAsset.texture_path_main = current.texture_path_zombie_for_auto_loader_main;
					actorTextureSubAsset.texture_heads = current.texture_path_zombie_for_auto_loader_heads;
				}
				else
				{
					actorTextureSubAsset.texture_path_main = current.texture_asset.texture_path_main;
					actorTextureSubAsset.texture_heads = current.texture_asset.texture_heads;
					t.dynamic_sprite_zombie = true;
				}
				if (current.animation_swim == null)
				{
					t.animation_swim = null;
				}
			}
		}
		loadAutoTextures(listPool2);
	}

	private void loadShadows()
	{
		foreach (ActorAsset item in list)
		{
			if (item.shadow)
			{
				item.texture_asset.loadShadow();
			}
		}
	}

	private void createDefaultZombieAsset()
	{
		ActorAsset actorAsset = clone("zombie", "human");
		actorAsset.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
		setDefaultZombieFields(actorAsset, get("human"));
		loadTexturesAndSprites(actorAsset);
	}

	private void setDefaultZombieFields(ActorAsset pAsset, ActorAsset pDefaultCreatureAsset, bool pAnimal = false)
	{
		pAsset.has_advanced_textures = false;
		pAsset.show_in_knowledge_window = false;
		pAsset.civ = false;
		pAsset.can_have_subspecies = true;
		pAsset.name_locale = "Zombie";
		pAsset.body_separate_part_hands = true;
		pAsset.icon = "iconZombie";
		pAsset.use_items = true;
		pAsset.can_edit_equipment = true;
		pAsset.banner_id = string.Empty;
		pAsset.color_hex = "#24803E";
		pAsset.job = AssetLibrary<ActorAsset>.a<string>("decision");
		pAsset.can_attack_buildings = false;
		pAsset.can_attack_brains = true;
		pAsset.disable_jump_animation = true;
		pAsset.animation_walk = pDefaultCreatureAsset.animation_walk;
		pAsset.animation_swim = pDefaultCreatureAsset.animation_swim;
		pAsset.only_melee_attack = true;
		pAsset.setZombie(pAnimal);
		pAsset.name_taxonomic_species = "zombus";
		pAsset.can_be_surprised = false;
	}

	public override void editorDiagnostic()
	{
		editorErrorChecks();
		editorNameSetChecks();
		phenotypeChecks();
		base.editorDiagnostic();
	}

	private void phenotypeChecks()
	{
		using ListPool<string> listPool = new ListPool<string>();
		HashSet<string> hashSet = new HashSet<string>();
		foreach (ActorAsset item in list)
		{
			if (item.use_phenotypes && (item.phenotypes_list == null || item.phenotypes_list.Count == 0))
			{
				BaseAssetLibrary.logAssetError("<b>ActorAssetLibrary</b>: Unit is set to use phenotypes, but no phenotypes are used", item.id);
			}
			if (item.phenotypes_list != null)
			{
				List<string> trait_group_filter_subspecies = item.trait_group_filter_subspecies;
				if (trait_group_filter_subspecies != null && trait_group_filter_subspecies.Contains("phenotypes"))
				{
					hashSet.UnionWith(item.phenotypes_list);
				}
				else
				{
					listPool.AddRange(item.phenotypes_list);
				}
			}
		}
		hashSet.RemoveAll(listPool);
		foreach (ref string item2 in listPool)
		{
			string current2 = item2;
			if (!AssetManager.phenotype_library.has(current2))
			{
				BaseAssetLibrary.logAssetError("<b>ActorAssetLibrary</b>: Phenotype <e>" + current2 + "</e> not found", current2);
			}
		}
		foreach (PhenotypeAsset item3 in AssetManager.phenotype_library.list)
		{
			if (!listPool.Contains(item3.id) && !hashSet.Contains(item3.id))
			{
				BaseAssetLibrary.logAssetError($"<b>ActorAssetLibrary</b>: Phenotype <e>{item3}</e> not findable, because not used by any units", item3.id);
			}
		}
		foreach (string item4 in hashSet)
		{
			using ListPool<string> listPool2 = new ListPool<string>();
			foreach (ActorAsset item5 in list)
			{
				if (item5.phenotypes_list != null && item5.phenotypes_list.Contains(item4))
				{
					listPool2.Add(item5.id);
				}
			}
			BaseAssetLibrary.logAssetError("<b>ActorAssetLibrary</b>: Phenotype <e>" + item4 + "</e> not reachable, because used by units with hidden phenotypes : <e>" + string.Join(",", listPool2) + "</e>", item4);
		}
	}

	private void editorNameSetChecks()
	{
		foreach (ActorAsset item in list)
		{
			if (item.canBecomeSapient() && !item.unit_zombie && item.name_template_sets == null)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Name Templates Not Set!!", item.id);
			}
		}
	}

	private void editorErrorChecks()
	{
		foreach (ActorAsset item in list)
		{
			if (item.can_evolve_into_new_species && string.IsNullOrEmpty(item.evolution_id))
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset missing evolution_id", item.id);
			}
			if (item.kingdom_id_wild != string.Empty && !AssetManager.kingdoms.has(item.kingdom_id_wild))
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset has <e>invalid kingdom_id_wild</e> " + item.kingdom_id_wild, item.id);
			}
			if (item.kingdom_id_civilization != string.Empty)
			{
				if (!AssetManager.kingdoms.has(item.kingdom_id_civilization))
				{
					BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset has <e>invalid kingdom_id_civilization</e> " + item.kingdom_id_civilization, item.id);
				}
				else if (!AssetManager.kingdoms.get(item.kingdom_id_civilization).civ)
				{
					BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset has <e>invalid kingdom_id_civilization</e> that is not a .civ " + item.kingdom_id_civilization, item.id);
				}
			}
			if (item.architecture_id != string.Empty && !AssetManager.architecture_library.has(item.architecture_id))
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset has <e>invalid architecture id</e> " + item.architecture_id, item.id);
			}
			if (!item.zombie_auto_asset && !item.unit_zombie && typeof(SA).GetField(item.id, BindingFlags.Static | BindingFlags.Public) == null)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset does not have <e>SA property</e>", item.id);
			}
			if (item.use_phenotypes && (item.phenotypes_dict == null || item.phenotypes_dict.Count == 0))
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset does not have <e>colors set</e>", item.id);
			}
			if (item.can_have_subspecies && (item.phenotypes_dict == null || item.phenotypes_dict.Count == 0) && item.use_phenotypes)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset can have subspecies, but no default color sets", item.id);
			}
			if (item.can_have_subspecies && item.genome_parts.Count == 0)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset does not have <e>genes set</e>", item.id);
			}
			if (string.IsNullOrEmpty(item.icon))
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset does not have <e>icon set</e>", item.id);
			}
			else if ((Object)(object)item.getSpriteIcon() == (Object)null)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: Actor Asset <e>sprite is missing</e> on path <e>" + item.icon + "</e>", item.id);
			}
			if (!string.IsNullOrEmpty(item.banner_id) && SpriteTextureLoader.getSpriteList(KingdomBannerLibrary.getFullPathBackground(item.banner_id)).Length == 0)
			{
				BaseAssetLibrary.logAssetError("ActorAssetLibrary: there's <e>no folder for banners</e> for", item.id + " with banner id " + item.banner_id);
			}
		}
	}

	public void preloadMainUnitSprites()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		if (!Config.preload_units)
		{
			return;
		}
		foreach (ActorAsset item in list)
		{
			if (item.has_override_sprite || !item.has_sprite_renderer)
			{
				continue;
			}
			item.texture_asset.preloadSprites(item.civ, item.has_baby_form, item);
			if (item.shadow)
			{
				ActorTextureSubAsset texture_asset = item.texture_asset;
				if (texture_asset.shadow_size.x < 1f || texture_asset.shadow_size.y < 1f)
				{
					BaseAssetLibrary.logAssetError($"ActorAssetLibrary: Shadow size is too small : <e>{texture_asset.shadow_size}</e>", item.id);
				}
				if (texture_asset.shadow_size_egg.x < 1f || texture_asset.shadow_size_egg.y < 1f)
				{
					BaseAssetLibrary.logAssetError($"ActorAssetLibrary: Egg shadow size is too small : <e>{texture_asset.shadow_size_egg}</e>", item.id);
				}
				if (texture_asset.shadow_size_baby.x < 1f || texture_asset.shadow_size_baby.y < 1f)
				{
					BaseAssetLibrary.logAssetError($"ActorAssetLibrary: Baby shadow size is too small : <e>{texture_asset.shadow_size_baby}</e>", item.id);
				}
			}
		}
	}

	public override void editorDiagnosticLocales()
	{
		foreach (ActorAsset item in list)
		{
			checkLocale(item, item.getLocaleID());
			if (item.can_have_subspecies)
			{
				checkLocale(item, item.getCollectiveTermID());
			}
		}
	}

	private void initAnimalsNormal()
	{
		clone("fox", "$carnivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fox_set");
		t.kingdom_id_wild = "fox";
		t.kingdom_id_civilization = "miniciv_fox";
		t.base_stats["mass_2"] = 7f;
		t.addGenome(("health", 80f), ("stamina", 80f), ("mutation", 1f), ("lifespan", 90f), ("damage", 18f), ("speed", 7f), ("armor", 5f), ("offspring", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.name_locale = "Fox";
		t.setSocialStructure("group_skulk", 12);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "canidae";
		t.name_taxonomic_genus = "vulpes";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S8_Fox;
		t.shadow_texture = "unitShadow_4";
		t.icon = "iconFox";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("bright_orange");
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_fox";
		t.architecture_id = "civ_fox";
		t.banner_id = "civ_fox";
		t.clearTraits();
		addTrait("genius");
		addTrait("fast");
		t.addResource("leather", 1);
		clone("buffalo", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("buffalo_set");
		t.kingdom_id_wild = "buffalo";
		t.kingdom_id_civilization = "miniciv_buffalo";
		t.base_stats["mass_2"] = 650f;
		t.addGenome(("health", 180f), ("stamina", 200f), ("mutation", 1f), ("speed", 11f), ("lifespan", 80f), ("damage", 20f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_graminivore");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("dense_dwellings");
		t.name_locale = "Buffalo";
		t.setSocialStructure("group_herd", 200);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "artiodactyla";
		t.name_taxonomic_family = "bovidae";
		t.name_taxonomic_genus = "syncerus";
		t.name_taxonomic_species = "caffer";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S16_Buffalo;
		t.shadow_texture = "unitShadow_7";
		t.icon = "iconBuffalo";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("soil");
		t.color_hex = "#C2974E";
		t.max_random_amount = 3;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_buffalo";
		t.architecture_id = "civ_buffalo";
		t.banner_id = "civ_buffalo";
		t.clearTraits();
		addTrait("strong");
		addTrait("tough");
		t.addResource("leather", 2);
		clone("hyena", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("hyena_set");
		t.kingdom_id_wild = "hyena";
		t.kingdom_id_civilization = "miniciv_hyena";
		t.base_stats["mass_2"] = 63f;
		t.addGenome(("health", 130f), ("stamina", 150f), ("mutation", 1f), ("speed", 12f), ("lifespan", 80f), ("damage", 18f), ("armor", 5f), ("offspring", 6f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("super_positivity");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("conscription_female_only");
		t.addCultureTrait("city_layout_tile_wobbly_pattern");
		t.name_locale = "Hyena";
		t.setSocialStructure("group_cackle", 30);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "hyaenidae";
		t.name_taxonomic_genus = "crocuta";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S10_Dog;
		t.shadow_texture = "unitShadow_5";
		t.icon = "iconHyena";
		t.color_hex = "#C2974E";
		t.max_random_amount = 2;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_hyena";
		t.architecture_id = "civ_hyena";
		t.banner_id = "civ_hyena";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("savanna");
		t.addResource("leather", 1);
		clone("crocodile", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crocodile_set");
		t.kingdom_id_wild = "crocodile";
		t.kingdom_id_civilization = "miniciv_crocodile";
		t.base_stats["mass_2"] = 450f;
		t.addGenome(("health", 180f), ("stamina", 40f), ("mutation", 1f), ("speed", 5f), ("lifespan", 70f), ("damage", 30f), ("armor", 15f), ("offspring", 10f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("aquatic");
		t.name_locale = "Crocodile";
		t.setSocialStructure("group_bask", 20);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "reptilia";
		t.name_taxonomic_order = "crocodilia";
		t.name_taxonomic_family = "crocodylidae";
		t.name_taxonomic_genus = "crocodylus";
		t.inspect_avatar_scale = 1.3f;
		t.base_stats["mass"] = 20f;
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S15_Bear;
		t.shadow_texture = "unitShadow_21";
		t.icon = "iconCrocodile";
		t.color_hex = "#C2974E";
		t.prevent_unconscious_rotation = true;
		t.immune_to_slowness = true;
		t.max_random_amount = 2;
		t.force_land_creature = true;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_crocodile";
		t.architecture_id = "civ_crocodile";
		t.banner_id = "civ_crocodile";
		addTrait("tough");
		t.clonePhenotype("$animal_skin$");
		addPhenotype("dark_green");
		t.addResource("leather", 2);
		clone("monkey", "$herbivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("monkey_set");
		t.kingdom_id_wild = "monkey";
		t.kingdom_id_civilization = "miniciv_monkey";
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 80f), ("stamina", 150f), ("mutation", 1f), ("speed", 14f), ("lifespan", 80f), ("damage", 12f), ("armor", 5f), ("offspring", 8f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("nimble");
		t.addSubspeciesTrait("shiny_love");
		t.name_locale = "Monkey";
		t.setSocialStructure("group_troop", 50);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "primates";
		t.name_taxonomic_family = "cercopithecidae";
		t.name_taxonomic_genus = "macaca";
		t.name_taxonomic_species = "mulatta";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S9_Monkey;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconMonkey";
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_monkey";
		t.architecture_id = "civ_monkey";
		t.banner_id = "civ_monkey";
		t.clearTraits();
		addTrait("genius");
		addTrait("agile");
		t.clonePhenotype("$animal_fur$");
		addPhenotype("dark_orange");
		t.default_attack = "rocks";
		t.addResource("leather", 1);
		clone("rhino", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rhino_set");
		t.kingdom_id_wild = "rhino";
		t.kingdom_id_civilization = "miniciv_rhino";
		t.base_stats["mass_2"] = 700f;
		t.addGenome(("health", 80f), ("stamina", 120f), ("mutation", 1f), ("speed", 12f), ("lifespan", 80f), ("damage", 20f), ("armor", 15f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("aggressive");
		t.name_locale = "Rhino";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "perissodactyla";
		t.name_taxonomic_family = "rhinocerotidae";
		t.name_taxonomic_genus = "rhinoceros";
		t.collective_term = "group_crash";
		t.base_stats["mass"] = 20f;
		t.base_stats["targets"] = 3f;
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S16_Buffalo;
		t.shadow_texture = "unitShadow_11";
		t.icon = "iconRhino";
		t.color_hex = "#C2974E";
		t.max_random_amount = 1;
		t.animal_breeding_close_units_limit = 4;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_rhino";
		t.architecture_id = "civ_rhino";
		t.banner_id = "civ_rhino";
		t.clearTraits();
		t.addTrait("strong");
		t.addTrait("fat");
		t.addTrait("dash");
		t.addTrait("hard_skin");
		addPhenotype("mid_gray");
		addPhenotype("skin_medium");
		t.addResource("meat", 2);
		t.addResource("leather", 4);
		clone("frog", "$peaceful_animal$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("frog_set");
		t.kingdom_id_wild = "frog";
		t.kingdom_id_civilization = "miniciv_frog";
		t.base_stats["mass_2"] = 1.5f;
		t.addGenome(("health", 40f), ("stamina", 20f), ("mutation", 2f), ("speed", 7f), ("lifespan", 90f), ("damage", 12f), ("birth_rate", 3f), ("offspring", 30f));
		t.name_locale = "Frog";
		t.setSocialStructure("group_army", 100);
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_bubble");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_insectivore");
		t.addSubspeciesTrait("adaptation_swamp");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "amphibia";
		t.name_taxonomic_order = "anura";
		t.name_taxonomic_family = "ranidae";
		t.name_taxonomic_genus = "rana";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S2_Crab;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconFrog";
		t.color_hex = "#C2974E";
		t.immune_to_slowness = true;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_frog";
		t.architecture_id = "civ_frog";
		t.banner_id = "civ_frog";
		t.clearTraits();
		addTrait("poisonous");
		addTrait("weightless");
		addPhenotype("bright_green");
		addPhenotype("infernal", "biome_jungle");
		addPhenotype("skin_medium", "biome_savanna");
		addPhenotype("pink_yellow_mushroom", "biome_mushroom");
		addPhenotype("aqua", "biome_corrupted");
		addPhenotype("aqua", "biome_swamp");
		addPhenotype("desert", "biome_desert");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("lemon", "biome_lemon");
		t.addResource("leather", 1);
		clone("snake", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snake_set");
		t.kingdom_id_wild = "snake";
		t.kingdom_id_civilization = "miniciv_snake";
		t.base_stats["mass_2"] = 15f;
		t.addGenome(("health", 40f), ("stamina", 10f), ("mutation", 2f), ("speed", 7f), ("lifespan", 150f), ("damage", 20f), ("birth_rate", 3f), ("offspring", 20f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("circadian_drift");
		addTrait("poison_immune");
		addTrait("venomous");
		addTrait("weightless");
		t.name_locale = "Snake";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "reptilia";
		t.name_taxonomic_order = "squamata";
		t.name_taxonomic_family = "elapidae";
		t.name_taxonomic_genus = "naja";
		t.collective_term = "group_den";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S5_Snake;
		t.shadow_texture = "unitShadow_4";
		t.icon = "iconSnake";
		t.color_hex = "#C2974E";
		t.immune_to_slowness = true;
		t.can_attack_buildings = false;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_snake";
		t.architecture_id = "civ_snake";
		t.banner_id = "civ_snake";
		addPhenotype("dark_green");
		addPhenotype("dark_orange");
		addPhenotype("bright_green", "biome_jungle");
		addPhenotype("savanna", "biome_savanna");
		addPhenotype("aqua", "biome_swamp");
		addPhenotype("corrupted", "biome_corrupted");
		addPhenotype("desert", "biome_desert");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("lemon", "biome_lemon");
		t.default_attack = "bite";
		t.addResource("leather", 1);
		clone("dog", "$peaceful_animal$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.base_stats["mass_2"] = 45f;
		t.kingdom_id_wild = "dog";
		t.kingdom_id_civilization = "miniciv_dog";
		t.addGenome(("health", 80f), ("stamina", 120f), ("mutation", 1f), ("lifespan", 20f), ("damage", 18f), ("speed", 15f), ("armor", 5f), ("offspring", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("super_positivity");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_omnivore");
		t.name_locale = "Dog";
		t.setSocialStructure("group_pack", 20);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "canidae";
		t.name_taxonomic_genus = "canis";
		t.name_taxonomic_species = "lupus";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S10_Dog;
		t.shadow_texture = "unitShadow_5";
		t.icon = "iconDog";
		t.color_hex = "#393939";
		t.default_attack = "jaws";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_dog";
		t.architecture_id = "civ_dog";
		t.banner_id = "civ_dog";
		addPhenotype("white_gray");
		addPhenotype("gray_black");
		addPhenotype("wood");
		addPhenotype("polar", "biome_permafrost");
		addPhenotype("skin_black", "biome_corrupted");
		addPhenotype("desert", "biome_desert");
		t.clearTraits();
		addTrait("fast");
		addTrait("dash");
		t.addResource("leather", 1);
		clone("wolf", "$carnivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.base_stats["mass_2"] = 55f;
		t.kingdom_id_wild = "wolf";
		t.kingdom_id_civilization = "miniciv_wolf";
		t.addGenome(("health", 120f), ("stamina", 150f), ("mutation", 1f), ("lifespan", 20f), ("damage", 22f), ("speed", 15f), ("armor", 3f), ("offspring", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_carnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addClanTrait("combat_instincts");
		t.name_locale = "Wolfs";
		t.setSocialStructure("group_pack", 20);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "canidae";
		t.name_taxonomic_genus = "canis";
		t.name_taxonomic_species = "lupus";
		t.can_attack_buildings = false;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_7";
		t.icon = "iconWolf";
		t.color_hex = "#393939";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_wolf";
		t.architecture_id = "civ_wolf";
		t.banner_id = "civ_wolf";
		addTrait("nightchild");
		t.clonePhenotype("$animal_fur$");
		addPhenotype("wood");
		addPhenotype("white_gray");
		addPhenotype("gray_black");
		addPhenotype("dark_red", "biome_infernal");
		t.music_theme = "Units_Wolf";
		t.addResource("leather", 1);
		clone("bear", "$carnivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bear_set");
		t.base_stats["mass_2"] = 175f;
		t.kingdom_id_wild = "bear";
		t.kingdom_id_civilization = "miniciv_bear";
		t.addGenome(("health", 200f), ("stamina", 200f), ("mutation", 1f), ("lifespan", 35f), ("damage", 30f), ("speed", 15f), ("armor", 8f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("big_stomach");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_carnivore");
		t.addSubspeciesTrait("diet_frugivore");
		t.addSubspeciesTrait("winter_slumberers");
		t.addSubspeciesTrait("energy_preserver");
		t.addSubspeciesTrait("aggressive");
		t.name_locale = "Bear";
		t.setSocialStructure("group_sleuth", 4);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "ursidae";
		t.name_taxonomic_genus = "ursus";
		t.base_stats["mass"] = 2f;
		t.base_stats["targets"] = 2f;
		t.can_attack_buildings = false;
		t.actor_size = ActorSize.S15_Bear;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconBear";
		t.color_hex = "#6C522D";
		addTrait("strong");
		t.default_attack = "claws";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_bear";
		t.architecture_id = "civ_bear";
		t.banner_id = "civ_bear";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("wood");
		addPhenotype("skin_dark");
		t.music_theme = "Units_Bear";
		t.addResource("leather", 3);
		clone("piranha", "$animal$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("piranha_set");
		t.kingdom_id_wild = "piranha";
		t.kingdom_id_civilization = "miniciv_piranha";
		t.base_stats["mass_2"] = 10f;
		t.addGenome(("health", 40f), ("stamina", 50f), ("mutation", 1f), ("lifespan", 10f), ("damage", 25f), ("speed", 13f), ("armor", 2f), ("offspring", 20f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_roe");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("aggressive");
		t.addSubspeciesTrait("diet_carnivore");
		t.addSubspeciesTrait("diet_piscivore");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addSubspeciesTrait("aquatic");
		t.addSubspeciesTrait("fins");
		t.name_locale = "Piranha";
		t.setSocialStructure("group_shoal", 30);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "actinopterygii";
		t.name_taxonomic_order = "characiformes";
		t.name_taxonomic_family = "serrasalmidae";
		t.name_taxonomic_genus = "pygocentrus";
		t.name_taxonomic_species = "nattereri";
		t.can_attack_buildings = false;
		t.actor_size = ActorSize.S4_Piranha;
		t.icon = "iconPiranha";
		t.color_hex = "#3483B6";
		t.immune_to_slowness = true;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_piranha";
		t.architecture_id = "civ_piranha";
		t.banner_id = "civ_piranha";
		ActorAsset actorAsset = t;
		actorAsset.action_death = (WorldAction)Delegate.Combine(actorAsset.action_death, new WorldAction(ActionLibrary.checkPiranhaAchievement));
		t.clonePhenotype("$animal_fur$");
		addPhenotype("aqua");
		addPhenotype("bright_salmon");
		t.music_theme = "Units_Piranha";
		t.force_land_creature = false;
		t.addResource("sushi", 1, pNewList: true);
		clone("rabbit", "$herbivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rabbit_set");
		t.kingdom_id_wild = "rabbit";
		t.kingdom_id_civilization = "miniciv_rabbit";
		t.base_stats["mass_2"] = 4.5f;
		t.addGenome(("health", 50f), ("stamina", 140f), ("mutation", 1f), ("lifespan", 15f), ("damage", 5f), ("armor", 1f), ("speed", 15f), ("offspring", 12f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_short");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("cautious_instincts");
		t.addClanTrait("we_are_legion");
		t.name_locale = "Rabbit";
		t.setSocialStructure("group_colony", 30);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "lagomorpha";
		t.name_taxonomic_family = "leporidae";
		t.name_taxonomic_genus = "oryctolagus";
		t.source_meat = true;
		t.actor_size = ActorSize.S6_Chicken;
		t.shadow_texture = "unitShadow_2";
		t.icon = "iconRabbit";
		t.color_hex = "#D3D6D1";
		addTrait("weightless");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_rabbit";
		t.architecture_id = "civ_rabbit";
		t.banner_id = "civ_rabbit";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("white_gray");
		addPhenotype("wood");
		addTrait("fast");
		t.music_theme = "Units_Rabbit";
		t.addResource("leather", 1);
		clone("cat", "$carnivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cat_set");
		t.kingdom_id_wild = "cat";
		t.kingdom_id_civilization = "miniciv_cat";
		t.base_stats["mass_2"] = 5f;
		t.addGenome(("health", 85f), ("stamina", 150f), ("mutation", 1f), ("lifespan", 45f), ("damage", 20f), ("speed", 15f), ("armor", 3f), ("offspring", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.name_locale = "Cat";
		t.setSocialStructure("group_clowder", 15);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "felidae";
		t.name_taxonomic_genus = "felis";
		t.name_taxonomic_species = "catus";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S7_Cat;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconCat";
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_cat";
		t.architecture_id = "civ_cat";
		t.banner_id = "civ_cat";
		addTrait("weightless");
		t.default_attack = "claws";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("white_gray");
		addPhenotype("wood");
		addPhenotype("bright_orange");
		t.music_theme = "Units_Cat";
		t.addResource("leather", 1);
		clone("raccoon", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("raccoon_set");
		t.kingdom_id_wild = "raccoon";
		t.kingdom_id_civilization = "miniciv_raccoon";
		t.base_stats["mass_2"] = 9f;
		t.addGenome(("health", 85f), ("stamina", 80f), ("mutation", 1f), ("lifespan", 45f), ("damage", 20f), ("speed", 15f), ("armor", 3f), ("offspring", 4f));
		t.addSubspeciesTrait("nimble");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("shiny_love");
		t.addSubspeciesTrait("circadian_drift");
		t.addReligionTrait("rite_of_dissent");
		t.addClanTrait("silver_tongues");
		t.name_locale = "Raccoon";
		t.setSocialStructure("group_gaze", 15);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "procyonidae";
		t.name_taxonomic_genus = "procyon";
		t.name_taxonomic_species = "lotor";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S7_Cat;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconRaccoon";
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "bandit";
		t.architecture_id = "civ_bandit";
		t.banner_id = "civ_bandit";
		t.default_attack = "claws";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("gray_black");
		addPhenotype("black_blue");
		t.music_theme = "Units_Cat";
		t.disable_jump_animation = true;
		t.addResource("leather", 1);
		clone("seal", "$carnivore$");
		t.needs_to_be_explored = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("seal_set");
		t.kingdom_id_wild = "seal";
		t.kingdom_id_civilization = "miniciv_seal";
		t.base_stats["mass_2"] = 90f;
		t.addGenome(("health", 200f), ("stamina", 30f), ("mutation", 1f), ("lifespan", 30f), ("damage", 20f), ("speed", 4f), ("armor", 10f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("diet_piscivore");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("fins");
		t.addReligionTrait("cast_blood_rain");
		t.addCultureTrait("dense_dwellings");
		t.addClanTrait("blood_of_sea");
		t.addTrait("agile");
		t.name_locale = "Seal";
		t.setSocialStructure("group_colony", 50);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "carnivora";
		t.name_taxonomic_family = "phocidae";
		t.name_taxonomic_genus = "phoca";
		t.name_taxonomic_species = "vitulina";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S13_Human;
		t.shadow_texture = "unitShadow_5";
		t.icon = "iconSeal";
		t.color_hex = "#C2974E";
		t.evolution_id = "civ_seal";
		t.can_evolve_into_new_species = true;
		t.architecture_id = "civ_piranha";
		t.banner_id = "civ_seal";
		t.default_attack = "bite";
		t.clonePhenotype("$animal_skin$");
		addPhenotype("black_blue");
		addPhenotype("polar", "biome_permafrost");
		t.addResource("meat", 1);
		t.addResource("leather", 2);
		clone("ostrich", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("ostrich_set");
		t.kingdom_id_wild = "ostrich";
		t.kingdom_id_civilization = "miniciv_ostrich";
		t.base_stats["mass_2"] = 117f;
		t.addGenome(("health", 100f), ("stamina", 150f), ("mutation", 1f), ("lifespan", 40f), ("damage", 20f), ("speed", 15f), ("armor", 0f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addTrait("dash");
		t.addTrait("fast");
		t.name_locale = "Ostrich";
		t.setSocialStructure("group_flock", 10);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "aves";
		t.name_taxonomic_order = "struthioniformes";
		t.name_taxonomic_family = "struthionidae";
		t.name_taxonomic_genus = "struthio";
		t.name_taxonomic_species = "camelus";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S13_Human;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconOstrich";
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = false;
		t.architecture_id = "civ_piranha";
		t.banner_id = "civ_druid";
		t.default_attack = "bite";
		t.clonePhenotype("$animal_skin$");
		addPhenotype("black_blue");
		addPhenotype("wood");
		t.addResource("leather", 1);
		clone("unicorn", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("unicorn_set");
		t.kingdom_id_wild = "unicorn";
		t.kingdom_id_civilization = "miniciv_unicorn";
		t.base_stats["mass_2"] = 500f;
		t.addGenome(("health", 500f), ("stamina", 120f), ("mutation", 1f), ("lifespan", 500f), ("damage", 20f), ("speed", 15f), ("armor", 0f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_rainbow");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addCultureTrait("city_layout_royal_checkers");
		t.addCultureTrait("fames_crown");
		t.addClanTrait("magic_blood");
		t.addClanTrait("witchs_vein");
		t.addClanTrait("warlocks_vein");
		t.addTrait("heart_of_wizard");
		t.addTrait("healing_aura");
		t.name_locale = "Unicorn";
		t.setSocialStructure("group_herd", 15);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "perissodactyla";
		t.name_taxonomic_family = "equidae";
		t.name_taxonomic_genus = "unicornis";
		t.name_taxonomic_species = "fabulosus";
		t.skip_fight_logic = false;
		t.source_meat = true;
		t.actor_size = ActorSize.S14_Cow;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconUnicorn";
		t.color_hex = "#C2974E";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_unicorn";
		t.architecture_id = "civ_unicorn";
		t.banner_id = "civ_unicorn";
		t.default_attack = "bite";
		t.clonePhenotype("$animal_skin$");
		addPhenotype("skin_pale");
		addPhenotype("polar");
		addPhenotype("candy");
		t.addTrait("blessed");
		t.addResource("gems", 1);
		t.addResource("leather", 2);
		clone("rat", "$omnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rat_set");
		t.kingdom_id_wild = "rat";
		t.kingdom_id_civilization = "miniciv_rat";
		t.base_stats["mass_2"] = 0.5f;
		t.addGenome(("health", 30f), ("stamina", 30f), ("mutation", 1f), ("lifespan", 30f), ("damage", 8f), ("armor", 1f), ("speed", 15f), ("offspring", 15f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_short");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("nimble");
		t.addSubspeciesTrait("shiny_love");
		t.addClanTrait("we_are_legion");
		t.name_locale = "Rat";
		t.setSocialStructure("group_colony", 100);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "rodentia";
		t.name_taxonomic_family = "muridae";
		t.name_taxonomic_genus = "rattus";
		t.actor_size = ActorSize.S3_Rat;
		t.shadow_texture = "unitShadow_2";
		t.kingdom_id_wild = "rat";
		t.shadow = true;
		t.source_meat = true;
		t.max_random_amount = 5;
		t.can_attack_buildings = false;
		t.color_hex = "#2D2D2D";
		t.icon = "iconRat";
		addTrait("contagious");
		t.clonePhenotype("$animal_fur$");
		addPhenotype("gray_black");
		addPhenotype("white_gray");
		addPhenotype("wood");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_rat";
		t.architecture_id = "civ_rat";
		t.banner_id = "civ_rat";
		t.music_theme = "Units_Rat";
		t.disable_jump_animation = true;
		clone("chicken", "$herbivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("chicken_set");
		t.kingdom_id_wild = "chicken";
		t.kingdom_id_civilization = "miniciv_chicken";
		t.base_stats["mass_2"] = 4f;
		t.addGenome(("health", 35f), ("stamina", 30f), ("mutation", 1f), ("speed", 7f), ("lifespan", 30f), ("damage", 5f), ("armor", 1f), ("birth_rate", 3f), ("offspring", 12f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("cautious_instincts");
		t.addCultureTrait("dense_dwellings");
		addTrait("peaceful");
		addTrait("weightless");
		addTrait("content");
		t.name_locale = "Chicken";
		t.setSocialStructure("group_flock", 20);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "aves";
		t.name_taxonomic_order = "galliformes";
		t.name_taxonomic_family = "phasianidae";
		t.name_taxonomic_genus = "gallus";
		t.source_meat = true;
		t.actor_size = ActorSize.S6_Chicken;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconChicken";
		t.color_hex = "#DEDAC4";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_chicken";
		t.architecture_id = "civ_chicken";
		t.banner_id = "civ_chicken";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("wood");
		addPhenotype("white_gray");
		addPhenotype("dark_orange");
		t.music_theme = "Units_Chicken";
		clone("sheep", "$herbivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("sheep_set");
		t.kingdom_id_wild = "sheep";
		t.kingdom_id_civilization = "miniciv_sheep";
		t.base_stats["mass_2"] = 65f;
		t.addGenome(("health", 90f), ("stamina", 10f), ("mutation", 1f), ("lifespan", 100f), ("damage", 10f), ("speed", 6f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_graminivore");
		t.addSubspeciesTrait("cautious_instincts");
		t.name_locale = "Sheep";
		t.setSocialStructure("group_flock", 100);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "artiodactyla";
		t.name_taxonomic_family = "bovidae";
		t.name_taxonomic_genus = "ovis";
		t.name_taxonomic_species = "aries";
		t.source_meat = true;
		t.actor_size = ActorSize.S11_Sheep;
		t.icon = "iconSheep";
		t.color_hex = "#D7D7D7";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_sheep";
		t.architecture_id = "civ_sheep";
		t.banner_id = "civ_sheep";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("white_gray");
		addPhenotype("skin_mixed");
		addPhenotype("polar");
		t.music_theme = "Units_Sheep";
		t.addResource("leather", 2);
		clone("cow", "$herbivore$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cow_set");
		t.kingdom_id_wild = "cow";
		t.kingdom_id_civilization = "miniciv_cow";
		t.base_stats["mass_2"] = 550f;
		t.addGenome(("health", 120f), ("stamina", 20f), ("mutation", 1f), ("lifespan", 100f), ("damage", 10f), ("speed", 6f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_graminivore");
		t.name_locale = "Cow";
		t.setSocialStructure("group_herd", 50);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "artiodactyla";
		t.name_taxonomic_family = "bovidae";
		t.name_taxonomic_genus = "bos";
		t.name_taxonomic_species = "taurus";
		t.source_meat = true;
		t.actor_size = ActorSize.S14_Cow;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconCow";
		t.color_hex = "#D7D7D7";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_cow";
		t.architecture_id = "civ_cow";
		t.banner_id = "civ_cow";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("white_gray");
		t.addResource("leather", 3);
		clone("penguin", "$animal$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("penguin_set");
		t.kingdom_id_wild = "penguin";
		t.kingdom_id_civilization = "miniciv_penguin";
		t.base_stats["mass_2"] = 35f;
		t.addGenome(("health", 70f), ("stamina", 100f), ("mutation", 1f), ("speed", 5f), ("lifespan", 20f), ("damage", 7f), ("armor", 2f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_spotted");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_piscivore");
		t.addSubspeciesTrait("adaptation_permafrost");
		t.addCultureTrait("matriarchy");
		t.name_locale = "Penguin";
		t.setSocialStructure("group_colony", 200);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "aves";
		t.name_taxonomic_order = "sphenisciformes";
		t.name_taxonomic_family = "spheniscidae";
		t.name_taxonomic_genus = "aptenodytes";
		t.source_meat = true;
		t.actor_size = ActorSize.S10_Dog;
		t.shadow_texture = "unitShadow_3";
		t.icon = "iconPenguin";
		t.color_hex = "#D7D7D7";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_penguin";
		t.architecture_id = "civ_penguin";
		t.banner_id = "civ_penguin";
		addTrait("weightless");
		addPhenotype("black_blue");
		clone("armadillo", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("armadillo_set");
		t.kingdom_id_wild = "armadillo";
		t.kingdom_id_civilization = "miniciv_armadillo";
		t.base_stats["mass_2"] = 5f;
		t.addGenome(("health", 200f), ("stamina", 50f), ("mutation", 1f), ("lifespan", 100f), ("damage", 20f), ("armor", 20f), ("speed", 8f), ("offspring", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addTrait("hard_skin");
		t.addTrait("block");
		t.name_locale = "Armadillo";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "cingulata";
		t.name_taxonomic_family = "dasypodidae";
		t.name_taxonomic_genus = "dasypus";
		t.collective_term = "group_roll";
		t.source_meat = true;
		t.actor_size = ActorSize.S6_Chicken;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconArmadillo";
		t.color_hex = "#D7D7D7";
		t.can_evolve_into_new_species = true;
		t.clonePhenotype("$animal_fur$");
		addPhenotype("dark_orange");
		addPhenotype("wood");
		t.evolution_id = "civ_armadillo";
		t.architecture_id = "civ_armadillo";
		t.banner_id = "civ_armadillo";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		clone("alpaca", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alpaca_set");
		t.kingdom_id_wild = "alpaca";
		t.kingdom_id_civilization = "miniciv_alpaca";
		t.base_stats["mass_2"] = 67f;
		t.addGenome(("health", 100f), ("stamina", 30f), ("mutation", 1f), ("lifespan", 20f), ("damage", 9f), ("speed", 8f), ("armor", 2f), ("offspring", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addTrait("soft_skin");
		t.addReligionTrait("path_of_unity");
		t.name_locale = "Alpaca";
		t.setSocialStructure("group_herd", 50);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "artiodactyla";
		t.name_taxonomic_family = "camelidae";
		t.name_taxonomic_genus = "lama";
		t.name_taxonomic_species = "pacos";
		t.source_meat = true;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconAlpaca";
		t.color_hex = "#D7D7D7";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("skin_dark");
		addPhenotype("white_gray");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_alpaca";
		t.architecture_id = "civ_alpaca";
		t.banner_id = "civ_alpaca";
		t.addResource("leather", 2);
		clone("capybara", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("capybara_set");
		t.kingdom_id_wild = "capybara";
		t.kingdom_id_civilization = "miniciv_capybara";
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 80f), ("stamina", 10f), ("mutation", 1f), ("lifespan", 10f), ("damage", 9f), ("speed", 5f), ("armor", 2f), ("offspring", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addTrait("peaceful");
		t.addTrait("content");
		t.name_locale = "Capybara";
		t.setSocialStructure("group_herd", 20);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "rodentia";
		t.name_taxonomic_family = "caviidae";
		t.name_taxonomic_genus = "hydrochoerus";
		t.source_meat = true;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconCapybara";
		t.color_hex = "#D7D7D7";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("wood");
		addPhenotype("dark_orange");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_capybara";
		t.architecture_id = "civ_capybara";
		t.banner_id = "civ_capybara";
		t.addResource("leather", 1);
		clone("goat", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("goat_set");
		t.kingdom_id_wild = "goat";
		t.kingdom_id_civilization = "miniciv_goat";
		t.base_stats["mass_2"] = 30f;
		t.addGenome(("health", 90f), ("stamina", 100f), ("mutation", 1f), ("lifespan", 20f), ("damage", 11f), ("armor", 2f), ("speed", 12f), ("offspring", 3f));
		t.addTrait("dash");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.name_locale = "Goat";
		t.setSocialStructure("group_flock", 100);
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "artiodactyla";
		t.name_taxonomic_family = "bovidae";
		t.name_taxonomic_genus = "capra";
		t.name_taxonomic_species = "hircus";
		t.source_meat = true;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconGoat";
		t.color_hex = "#D7D7D7";
		t.clonePhenotype("$animal_fur$");
		addPhenotype("gray_black");
		addPhenotype("white_gray");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_goat";
		t.architecture_id = "civ_goat";
		t.banner_id = "civ_goat";
		t.addResource("leather", 1);
		clone("scorpion", "$carnivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("scorpion_set");
		t.kingdom_id_wild = "scorpion";
		t.kingdom_id_civilization = "miniciv_scorpion";
		t.base_stats["mass_2"] = 0.25f;
		t.addGenome(("health", 40f), ("stamina", 10f), ("mutation", 1f), ("lifespan", 10f), ("damage", 30f), ("armor", 5f), ("speed", 5f), ("offspring", 25f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("adaptation_desert");
		t.addSubspeciesTrait("diet_insectivore");
		t.addCultureTrait("conscription_female_only");
		t.name_locale = "Scorpion";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "arachnida";
		t.name_taxonomic_order = "scorpiones";
		t.name_taxonomic_family = "scorpionidae";
		t.name_taxonomic_genus = "pandinus";
		t.collective_term = "group_bed";
		t.source_meat = true;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconScorpion";
		t.color_hex = "#D7D7D7";
		t.disable_jump_animation = true;
		addPhenotype("dark_red");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("bright_yellow", "biome_desert");
		addPhenotype("bright_purple", "biome_corrupted");
		addPhenotype("soil", "biome_savanna");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_scorpion";
		t.architecture_id = "civ_scorpion";
		t.banner_id = "civ_scorpion";
		clone("turtle", "$animal$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("turtle_set");
		t.kingdom_id_wild = "turtle";
		t.kingdom_id_civilization = "miniciv_turtle";
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 150f), ("stamina", 10f), ("mutation", 1f), ("lifespan", 400f), ("damage", 15f), ("speed", 5f), ("armor", 25f), ("birth_rate", 3f), ("offspring", 20f));
		t.name_locale = "Turtle";
		t.setSocialStructure("group_bale", 10);
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_colored");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_algivore");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("cautious_instincts");
		t.addCultureTrait("matriarchy");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "reptilia";
		t.name_taxonomic_order = "testudines";
		t.name_taxonomic_family = "emydidae";
		t.name_taxonomic_genus = "trachemys";
		t.source_meat = true;
		t.actor_size = ActorSize.S7_Cat;
		t.shadow_texture = "unitShadow_7";
		t.icon = "iconTurtle";
		t.color_hex = "#D7D7D7";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_2;
		t.immune_to_slowness = true;
		t.flag_turtle = true;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_turtle";
		t.architecture_id = "civ_turtle";
		t.banner_id = "civ_turtle";
		t.prevent_unconscious_rotation = true;
		addPhenotype("dark_green");
		addPhenotype("swamp");
		addPhenotype("corrupted");
		addPhenotype("desert");
		addPhenotype("aqua");
		addTrait("slow");
		addTrait("weightless");
		addTrait("genius");
		t.addResource("bones", 2);
		clone("crab", "$animal$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crab_set");
		t.kingdom_id_wild = "crab";
		t.kingdom_id_civilization = "miniciv_crab";
		t.base_stats["mass_2"] = 2f;
		t.addGenome(("health", 60f), ("stamina", 10f), ("mutation", 1f), ("lifespan", 10f), ("damage", 20f), ("armor", 15f), ("speed", 5f), ("birth_rate", 3f), ("offspring", 30f));
		t.name_locale = "Crab";
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("exoskeleton");
		t.addSubspeciesTrait("egg_roe");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_algivore");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("population_minimal");
		t.addTrait("weightless");
		t.addTrait("hard_skin");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "malacostraca";
		t.name_taxonomic_order = "decapoda";
		t.name_taxonomic_family = "portunidae";
		t.name_taxonomic_genus = "carcinus";
		t.collective_term = "group_cast";
		t.disable_jump_animation = true;
		t.source_meat = true;
		t.actor_size = ActorSize.S2_Crab;
		t.shadow_texture = "unitShadow_2";
		t.icon = "iconCrab";
		t.color_hex = "#D7D7D7";
		addPhenotype("bright_salmon");
		addPhenotype("swamp", "biome_swamp");
		addPhenotype("corrupted", "biome_corrupted");
		addPhenotype("desert", "biome_desert");
		addPhenotype("infernal", "biome_infernal");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_crab";
		t.architecture_id = "civ_crab";
		t.banner_id = "civ_crab";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
	}

	private void initAnimalsWeird()
	{
		clone("crystal_sword", "$animal$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crystal_sword_set");
		t.kingdom_id_wild = "crystal_sword";
		t.kingdom_id_civilization = "miniciv_crystal_sword";
		t.base_stats["mass_2"] = 10f;
		t.addGenome(("health", 100f), ("stamina", 50f), ("mutation", 1f), ("lifespan", 1000f), ("damage", 50f), ("armor", 20f), ("speed", 10f), ("offspring", 2f));
		t.setSocialStructure("group_guild", 30);
		t.addClanTrait("blood_of_eons");
		t.addClanTrait("combat_instincts");
		t.addCultureTrait("sword_lovers");
		t.addCultureTrait("city_layout_diamond");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_crystal");
		t.addSubspeciesTrait("reproduction_budding");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("death_grow_mythril");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_lithotroph");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addReligionTrait("rite_of_infinite_edges");
		t.addTrait("deflect_projectile");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "cnidaria";
		t.name_taxonomic_class = "anthozoa";
		t.name_taxonomic_order = "crystalliformes";
		t.name_taxonomic_family = "crystallidae";
		t.name_taxonomic_genus = "gladii";
		t.name_taxonomic_species = "volans";
		t.name_locale = "Crystal Sword";
		t.body_separate_part_hands = false;
		t.has_skin = false;
		t.mush_id = "mush_animal";
		t.icon = "iconCrystalSword";
		t.color_hex = "#75D0F4";
		t.disable_jump_animation = true;
		t.animation_idle = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.walk_0_3;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.sound_hit = "event:/SFX/HIT/HitStone";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_crystal_golem";
		t.architecture_id = "civ_crystal_golem";
		t.banner_id = "civ_crystal_golem";
		t.prevent_unconscious_rotation = true;
		addPhenotype("crystal");
		addPhenotype("bright_purple");
		addPhenotype("bright_pink");
		addPhenotype("bright_teal");
		addPhenotype("bright_yellow");
		addPhenotype("bright_red");
		addPhenotype("dark_violet", "biome_corrupted");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("bright_green", "biome_swamp");
		addTrait("shiny");
		addTrait("fire_proof");
		addTrait("freeze_proof");
		addTrait("light_lamp");
		t.addResource("gems", 1, pNewList: true);
		t.addResource("crystal_salt", 1);
		clone("smore", "$animal$");
		t.needs_to_be_explored = true;
		t.render_heads_for_babies = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("smore_set");
		t.kingdom_id_wild = "smore";
		t.kingdom_id_civilization = "miniciv_smore";
		t.base_stats["mass_2"] = 4f;
		t.addGenome(("health", 300f), ("stamina", 10f), ("mutation", 3f), ("lifespan", 400f), ("speed", 12f), ("damage", 30f), ("armor", 5f), ("offspring", 3f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_candy");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("diet_xylophagy");
		t.addSubspeciesTrait("diet_hematophagy");
		t.setSocialStructure("group_diabetes", 10);
		t.name_taxonomic_kingdom = "plantae";
		t.name_taxonomic_phylum = "tracheophyta";
		t.name_taxonomic_class = "magnoliopsida";
		t.name_taxonomic_order = "poales";
		t.name_taxonomic_family = "poaceae";
		t.name_taxonomic_genus = "saccharum";
		t.name_taxonomic_species = "smorex";
		t.name_locale = "Smore";
		t.body_separate_part_hands = false;
		t.has_skin = false;
		t.icon = "iconSmore";
		t.color_hex = "#F74AA6";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_candy_man";
		t.architecture_id = "civ_candy_man";
		t.banner_id = "civ_candy_man";
		addPhenotype("skin_medium");
		addPhenotype("skin_dark");
		addPhenotype("skin_mixed");
		addPhenotype("swamp", "biome_swamp");
		addTrait("flesh_eater");
		addTrait("evil");
		addTrait("gluttonous");
		t.max_random_amount = 3;
		t.addResource("candy", 1, pNewList: true);
		t.addResource("evil_beets", 1);
		clone("acid_blob", "$animal$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("acid_blob_set");
		t.kingdom_id_wild = "acid_blob";
		t.kingdom_id_civilization = "miniciv_acid_blob";
		t.base_stats["mass_2"] = 66f;
		t.addGenome(("health", 120f), ("stamina", 50f), ("mutation", 5f), ("speed", 4f), ("lifespan", 50f), ("damage", 35f), ("offspring", 10f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_blob");
		t.addSubspeciesTrait("reproduction_fission");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("unstable_genome");
		t.addSubspeciesTrait("adaptation_wasteland");
		t.addReligionTrait("cosmic_radiation");
		t.addCultureTrait("happiness_from_war");
		t.name_locale = "Acid Blob";
		t.setSocialStructure("group_legion", 100);
		t.name_taxonomic_kingdom = "protista";
		t.name_taxonomic_phylum = "amoebozoa";
		t.name_taxonomic_class = "myxogastria";
		t.name_taxonomic_order = "liceales";
		t.name_taxonomic_family = "reticulariaceae";
		t.name_taxonomic_genus = "blobicus";
		t.name_taxonomic_species = "slimus";
		t.body_separate_part_hands = false;
		t.has_skin = false;
		t.mush_id = "mush_animal";
		t.icon = "iconAcidBlob";
		t.color_hex = "#008800";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.max_random_amount = 10;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_acid_gentleman";
		t.architecture_id = "civ_acid_gentleman";
		t.banner_id = "civ_acid_gentleman";
		t.prevent_unconscious_rotation = true;
		addTrait("acid_blood");
		addTrait("acid_proof");
		addTrait("acid_touch");
		addTrait("lustful");
		addTrait("fat");
		addPhenotype("toxic_green");
		addPhenotype("bright_pink", "biome_corrupted");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("swamp", "biome_swamp");
		t.addResource("jam", 1, pNewList: true);
		clone("flower_bud", "$peaceful_animal$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("flower_set");
		t.kingdom_id_wild = "flower_bud";
		t.kingdom_id_civilization = "miniciv_flower_bud";
		t.base_stats["mass_2"] = 5f;
		t.addGenome(("health", 50f), ("stamina", 50f), ("mutation", 3f), ("lifespan", 50f), ("damage", 3f), ("speed", 7f), ("armor", 5f), ("offspring", 5f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("death_grow_plant");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("genetic_mirror");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("conscription_female_only");
		t.addTrait("sunblessed");
		t.name_locale = "Flower Bud";
		t.setSocialStructure("group_platoon", 30);
		t.name_taxonomic_kingdom = "plantae";
		t.name_taxonomic_phylum = "tracheophyta";
		t.name_taxonomic_class = "liliopsida";
		t.name_taxonomic_order = "liliales";
		t.name_taxonomic_family = "liliaceae";
		t.name_taxonomic_genus = "ambulilium";
		t.name_taxonomic_species = "mobilens";
		t.source_meat = true;
		t.actor_size = ActorSize.S12_Wolf;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconFlowerBud";
		t.color_hex = "#D7D7D7";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_liliar";
		t.architecture_id = "civ_liliar";
		t.banner_id = "civ_liliar";
		t.clonePhenotype("$animal_skin$");
		addPhenotype("bright_purple");
		addPhenotype("bright_pink");
		addPhenotype("bright_blue");
		addPhenotype("bright_yellow");
		addPhenotype("bright_red");
		addPhenotype("jungle", "biome_jungle");
		addPhenotype("swamp", "biome_swamp");
		addPhenotype("desert", "biome_desert");
		addPhenotype("polar", "biome_permafrost");
		addPhenotype("bright_orange", "biome_maple");
		t.addResource("herbs", 1, pNewList: true);
		clone("lemon_snail", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("lemon_man_set");
		t.kingdom_id_wild = "lemon_snail";
		t.kingdom_id_civilization = "miniciv_lemon_snail";
		t.base_stats["mass_2"] = 5f;
		t.addGenome(("health", 50f), ("stamina", 10f), ("mutation", 3f), ("lifespan", 55f), ("damage", 12f), ("speed", 4f), ("armor", 10f), ("offspring", 15f));
		t.addSubspeciesTrait("reproduction_hermaphroditic");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_colored");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("slow_builders");
		t.addReligionTrait("cast_cure");
		t.addCultureTrait("city_layout_raindrops");
		t.addTrait("slow");
		t.addTrait("regeneration");
		t.name_locale = "Bitba";
		t.setSocialStructure("group_caravan", 10);
		t.name_taxonomic_kingdom = "plantae";
		t.name_taxonomic_phylum = "tracheophyta";
		t.name_taxonomic_class = "magnoliopsida";
		t.name_taxonomic_order = "sapindales";
		t.name_taxonomic_family = "rutaceae";
		t.name_taxonomic_genus = "citruslimax";
		t.name_taxonomic_species = "nicedrinkus";
		t.source_meat = true;
		t.actor_size = ActorSize.S6_Chicken;
		t.shadow_texture = "unitShadow_6";
		t.disable_jump_animation = true;
		t.icon = "iconLemonSnail";
		t.color_hex = "#D7D7D7";
		addPhenotype("lemon");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_lemon_man";
		t.architecture_id = "civ_lemon_man";
		t.banner_id = "civ_lemon_man";
		t.addResource("lemons", 1, pNewList: true);
		clone("garl", "$herbivore$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("garlic_man_set");
		t.kingdom_id_wild = "garl";
		t.kingdom_id_civilization = "miniciv_garl";
		t.base_stats["mass_2"] = 25f;
		t.addGenome(("health", 80f), ("stamina", 110f), ("mutation", 2f), ("lifespan", 5f), ("damage", 18f), ("armor", 3f), ("speed", 8f), ("offspring", 4f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("genetic_mirror");
		t.addTrait("poison_immune");
		t.addTrait("regeneration");
		t.name_locale = "Garl";
		t.setSocialStructure("group_pack", 20);
		t.name_taxonomic_kingdom = "plantae";
		t.name_taxonomic_phylum = "tracheophyta";
		t.name_taxonomic_class = "liliopsida";
		t.name_taxonomic_order = "asparagales";
		t.name_taxonomic_family = "amaryllidaceae";
		t.name_taxonomic_genus = "allium";
		t.name_taxonomic_species = "walkus";
		t.source_meat = true;
		t.actor_size = ActorSize.S6_Chicken;
		t.shadow_texture = "unitShadow_6";
		t.icon = "iconGarl";
		t.color_hex = "#D7D7D7";
		addPhenotype("mid_gray");
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_garlic_man";
		t.architecture_id = "civ_garlic_man";
		t.banner_id = "civ_garlic_man";
		t.addResource("herbs", 1, pNewList: true);
	}

	private void initInsects()
	{
		clone("bee", "$flying_insect$");
		t.animation_idle = ActorAnimationSequences.walk_0_3;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.has_advanced_textures = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.architecture_id = "civ_bee";
		t.banner_id = "civ_bee";
		addPhenotype("bright_yellow");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("city_layout_honeycomb");
		t.addCultureTrait("hive_society");
		t.addGenome(("health", 1f), ("mutation", 1f), ("damage", 10f), ("speed", 5f), ("offspring", 20f));
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "hymenoptera";
		t.name_taxonomic_family = "apidae";
		t.name_taxonomic_genus = "apis";
		t.name_taxonomic_species = "mellifera";
		t.collective_term = "group_colony";
		t.name_locale = "Bee";
		t.hovering_max = 1f;
		t.icon = "iconBee";
		t.color_hex = "#23F3FF";
		t.addDecision("bee_find_hive");
		t.addDecision("bee_create_hive");
		t.music_theme = "Units_BeeHive";
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("diet_nectarivore");
		t.addSubspeciesTrait("pollinating");
		t.addSubspeciesTrait("reproduction_parthenogenesis");
		clone("fly", "$flying_insect$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.kingdom_id_wild = "fly";
		t.architecture_id = "civ_druid";
		t.banner_id = "civ_druid";
		addPhenotype("black_blue");
		t.addGenome(("health", 1f), ("mutation", 1f), ("damage", 1f), ("speed", 5f), ("offspring", 15f));
		t.icon = "iconFly";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "diptera";
		t.name_taxonomic_family = "muscidae";
		t.name_taxonomic_genus = "musca";
		t.name_taxonomic_species = "domestica";
		t.collective_term = "group_business";
		t.name_locale = "Fly";
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("diet_nectarivore");
		t.addSubspeciesTrait("egg_bubble");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("reproduction_sexual");
		clone("butterfly", "$flying_insect$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.architecture_id = "civ_druid";
		t.banner_id = "civ_druid";
		addPhenotype("bright_yellow");
		addPhenotype("bright_red");
		addPhenotype("bright_violet");
		addPhenotype("bright_pink");
		addPhenotype("bright_teal");
		t.addGenome(("lifespan", 3f), ("health", 1f), ("mutation", 1f), ("damage", 1f), ("speed", 5f), ("offspring", 10f));
		t.icon = "iconButterfly";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "lepidoptera";
		t.name_taxonomic_family = "nymphalidae";
		t.name_taxonomic_genus = "danaus";
		t.name_taxonomic_species = "plexippus";
		t.collective_term = "group_kaleidoscope";
		t.name_locale = "Butterfly";
		t.icon = "iconButterfly";
		t.max_random_amount = 6;
		t.color_hex = "#23F3FF";
		ActorAsset actorAsset = t;
		actorAsset.action_death = (WorldAction)Delegate.Combine(actorAsset.action_death, new WorldAction(ActionLibrary.tryToCreatePlants));
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("diet_nectarivore");
		t.addSubspeciesTrait("pollinating");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("egg_cocoon");
		clone("grasshopper", "$insect$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.architecture_id = "civ_druid";
		t.banner_id = "civ_druid";
		addPhenotype("bright_green");
		t.addGenome(("health", 1f), ("mutation", 1f), ("damage", 1f), ("speed", 5f), ("offspring", 10f));
		t.icon = "iconGrasshopper";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "orthoptera";
		t.name_taxonomic_family = "acrididae";
		t.name_taxonomic_genus = "omocestus";
		t.name_taxonomic_species = "viridulus";
		t.collective_term = "group_cloud";
		t.name_locale = "Grasshopper";
		t.shadow = false;
		clone("beetle", "$insect$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.architecture_id = "civ_beetle";
		t.banner_id = "civ_beetle";
		t.kingdom_id_wild = "insect";
		t.kingdom_id_civilization = "miniciv_insect";
		t.can_evolve_into_new_species = true;
		t.evolution_id = "civ_beetle";
		t.addSubspeciesTrait("diet_xylophagy");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("exoskeleton");
		t.addSubspeciesTrait("population_minimal");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_cocoon");
		addPhenotype("aqua");
		addPhenotype("black_blue");
		addPhenotype("swamp");
		addPhenotype("soil");
		t.addTrait("hard_skin");
		t.addTrait("slow");
		t.addGenome(("health", 1f), ("mutation", 1f), ("damage", 1f), ("speed", 5f), ("offspring", 10f));
		t.icon = "iconBeetle";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "coleoptera";
		t.name_taxonomic_family = "scarabaeidae";
		t.name_taxonomic_genus = "sisyphus";
		t.name_taxonomic_species = "schaefferi";
		t.collective_term = "group_swarm";
		t.name_locale = "Beetle";
		t.disable_jump_animation = true;
		t.shadow = true;
	}

	private void initBoats()
	{
		ActorAsset obj = new ActorAsset
		{
			id = "$boat$",
			can_be_killed_by_stuff = true,
			can_be_killed_by_life_eraser = true,
			can_attack_buildings = true,
			can_be_moved_by_powers = true,
			can_be_hurt_by_powers = true,
			update_z = true,
			effect_damage = true,
			force_ocean_creature = true,
			shadow = false,
			is_boat = true,
			kingdom_id_wild = "neutral_animals",
			can_be_inspected = true,
			inspect_children = false,
			inspect_sex = false,
			inspect_show_species = false,
			inspect_generation = false,
			inspect_home = true,
			immune_to_injuries = true,
			path_movement_timeout = 0.1f,
			split_ai_update = false,
			show_on_meta_layer = true,
			show_in_knowledge_window = false,
			show_in_taxonomy_tooltip = false,
			force_hide_stamina = true,
			force_hide_mana = true,
			can_talk_with = false,
			control_can_backstep = false,
			control_can_jump = false,
			control_can_kick = false,
			control_can_dash = false,
			control_can_talk = false,
			control_can_swear = false,
			control_can_steal = false,
			needs_to_be_explored = false,
			show_controllable_tip = false
		};
		ActorAsset pAsset = obj;
		t = obj;
		add(pAsset);
		t.inspect_genealogy = false;
		t.need_colored_sprite = true;
		t.allowed_status_tiers = StatusTier.Basic;
		t.render_status_effects = false;
		t.texture_atlas = UnitTextureAtlasID.Boats;
		t.name_locale = "Boats";
		t.inspect_avatar_scale = 1f;
		t.color_hex = "#000000";
		t.base_stats["scale"] = 0.25f;
		t.base_stats["mass"] = 1000f;
		t.base_stats["size"] = 1f;
		t.can_edit_traits = false;
		addTrait("boat");
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.can_be_surprised = false;
		t.icon = "iconBoat";
		t.job = AssetLibrary<ActorAsset>.a<string>("decision");
		t.sound_attack = null;
		t.sound_spawn = null;
		t.sound_idle = null;
		t.sound_death = null;
		t.addDecision("boat_check_existence");
		t.addDecision("boat_danger_check");
		t.addDecision("boat_idle");
		t.addDecision("boat_check_limits");
		t.prevent_unconscious_rotation = true;
		t.animation_speed_based_on_walk_speed = false;
		t.get_override_sprite = delegate(Actor pActor)
		{
			Boat simpleComponent = pActor.getSimpleComponent<Boat>();
			AnimationDataBoat animationDataBoat = simpleComponent.getAnimationDataBoat();
			ActorAnimation value = animationDataBoat.normal;
			if (!pActor.isAlive())
			{
				value = animationDataBoat.broken;
			}
			else if (pActor.position_height != 0f || pActor.isInMagnet())
			{
				value = animationDataBoat.normal;
			}
			else if (!animationDataBoat.dict.TryGetValue(simpleComponent.last_movement_angle, out value))
			{
				int closestAngle = Toolbox.getClosestAngle(simpleComponent.last_movement_angle, animationDataBoat);
				animationDataBoat.dict.TryGetValue(closestAngle, out value);
			}
			if (value == null)
			{
				value = animationDataBoat.normal;
			}
			Sprite result = value.frames[0];
			if (value.frames.Length != 0)
			{
				result = AnimationHelper.getSpriteFromList(0, value.frames, pActor.asset.animation_swim_speed);
			}
			return result;
		};
		t.use_tool_items = false;
		clone("$boat_trading$", "$boat$");
		t.default_attack = "boat_cannonball";
		t.boat_type = "boat_type_trading";
		t.base_stats["health"] = 200f;
		t.base_stats["speed"] = 30f;
		t.base_stats["mass_2"] = 3000f;
		t.base_stats["attack_speed"] = 0.1f;
		t.draw_boat_mark = true;
		t.cost = new ConstructionCost(10, 0, 0, 10);
		t.actor_size = ActorSize.S16_Buffalo;
		addTrait("light_lamp");
		t.addDecision("boat_trading");
		clone("$boat_transport$", "$boat$");
		t.default_attack = "boat_cannonball";
		t.boat_type = "boat_type_transport";
		t.base_stats["health"] = 1000f;
		t.base_stats["speed"] = 25f;
		t.base_stats["mass_2"] = 2000f;
		t.base_stats["attack_speed"] = 0.5f;
		t.draw_boat_mark = true;
		t.draw_boat_mark_big = true;
		t.is_boat_transport = true;
		t.cost = new ConstructionCost(5, 0, 2, 20);
		t.actor_size = ActorSize.S17_Dragon;
		addTrait("light_lamp");
		t.addDecision("boat_transport_check");
		clone("boat_fishing", "$boat$");
		t.skip_fight_logic = true;
		t.boat_type = "boat_type_fishing";
		t.base_stats["speed"] = 10f;
		t.base_stats["health"] = 100f;
		t.base_stats["mass_2"] = 100f;
		t.cost = new ConstructionCost(5, 0, 0, 5);
		t.actor_size = ActorSize.S15_Bear;
		t.addDecision("boat_fishing");
		clone("boat_transport_human", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_orc", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_elf", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_dwarf", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_acid_gentleman", "$boat_transport$");
		t.default_attack = "boat_acid_ball";
		clone("boat_transport_alpaca", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_angle", "$boat_transport$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_transport_armadillo", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_bear", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_buffalo", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_candy_man", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_capybara", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_cat", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_chicken", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_cow", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_crab", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_crocodile", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_crystal_golem", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_dog", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_fox", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_frog", "$boat_transport$");
		t.default_attack = "boat_acid_ball";
		clone("boat_transport_garlic_man", "$boat_transport$");
		t.default_attack = "boat_acid_ball";
		clone("boat_transport_goat", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_hyena", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_lemon_man", "$boat_transport$");
		t.default_attack = "boat_acid_ball";
		clone("boat_transport_liliar", "$boat_transport$");
		t.default_attack = "boat_acid_ball";
		clone("boat_transport_monkey", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_penguin", "$boat_transport$");
		t.default_attack = "boat_snowball";
		clone("boat_transport_piranha", "$boat_transport$");
		t.default_attack = "boat_necro_ball";
		clone("boat_transport_rabbit", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_rat", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_rhino", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_scorpion", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_sheep", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_snake", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_turtle", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_wolf", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_white_mage", "$boat_transport$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_transport_snowman", "$boat_transport$");
		t.default_attack = "boat_snowball";
		clone("boat_transport_necromancer", "$boat_transport$");
		t.default_attack = "boat_necro_ball";
		clone("boat_transport_evil_mage", "$boat_transport$");
		t.default_attack = "boat_fireball";
		clone("boat_transport_druid", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_bee", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_beetle", "$boat_transport$");
		t.default_attack = "rocks";
		clone("boat_transport_seal", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_unicorn", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_ghost", "$boat_transport$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_transport_fairy", "$boat_transport$");
		t.default_attack = "boat_arrow";
		clone("boat_transport_demon", "$boat_transport$");
		t.default_attack = "boat_fireball";
		clone("boat_transport_cold_one", "$boat_transport$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_transport_bandit", "$boat_transport$");
		t.default_attack = "boat_cannonball";
		clone("boat_transport_alien", "$boat_transport$");
		t.default_attack = "boat_plasma_ball";
		clone("boat_transport_greg", "$boat_transport$");
		t.default_attack = "boat_plasma_ball";
		clone("boat_trading_human", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_orc", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_elf", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_dwarf", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_acid_gentleman", "$boat_trading$");
		t.default_attack = "boat_acid_ball";
		clone("boat_trading_alpaca", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_angle", "$boat_trading$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_trading_armadillo", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_bear", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_buffalo", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_candy_man", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_capybara", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_cat", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_chicken", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_cow", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_crab", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_crocodile", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_crystal_golem", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_dog", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_fox", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_frog", "$boat_trading$");
		t.default_attack = "boat_acid_ball";
		clone("boat_trading_garlic_man", "$boat_trading$");
		t.default_attack = "boat_acid_ball";
		clone("boat_trading_goat", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_hyena", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_lemon_man", "$boat_trading$");
		t.default_attack = "boat_acid_ball";
		clone("boat_trading_liliar", "$boat_trading$");
		t.default_attack = "boat_acid_ball";
		clone("boat_trading_monkey", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_penguin", "$boat_trading$");
		t.default_attack = "boat_snowball";
		clone("boat_trading_piranha", "$boat_trading$");
		t.default_attack = "boat_necro_ball";
		clone("boat_trading_rabbit", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_rat", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_rhino", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_scorpion", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_sheep", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_snake", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_turtle", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_wolf", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_white_mage", "$boat_trading$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_trading_snowman", "$boat_trading$");
		t.default_attack = "boat_snowball";
		clone("boat_trading_necromancer", "$boat_trading$");
		t.default_attack = "boat_necro_ball";
		clone("boat_trading_evil_mage", "$boat_trading$");
		t.default_attack = "boat_fireball";
		clone("boat_trading_druid", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_bee", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_beetle", "$boat_trading$");
		t.default_attack = "rocks";
		clone("boat_trading_seal", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_unicorn", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_ghost", "$boat_trading$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_trading_fairy", "$boat_trading$");
		t.default_attack = "boat_arrow";
		clone("boat_trading_demon", "$boat_trading$");
		t.default_attack = "boat_fireball";
		clone("boat_trading_cold_one", "$boat_trading$");
		t.default_attack = "boat_freeze_ball";
		clone("boat_trading_bandit", "$boat_trading$");
		t.default_attack = "boat_cannonball";
		clone("boat_trading_alien", "$boat_trading$");
		t.default_attack = "boat_plasma_ball";
		clone("boat_trading_greg", "$boat_trading$");
		t.default_attack = "boat_plasma_ball";
	}

	private void initCivsClassic()
	{
		clone("human", "$civ_advanced_unit$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("human_default_set", "human_slavic_set", "human_germanic_set", "human_rus_set", "human_posh_set", "human_folk_set", "human_pomeranian_set", "human_frankish_set", "human_rome_set", "human_iberian_set", "human_monolux_set");
		t.addPreferredColors("blue", "navy", "teal", "cyan");
		t.build_order_template_id = "build_order_advanced";
		t.music_theme = "Humans_Neutral";
		t.kingdom_id_wild = "nomads_human";
		t.kingdom_id_civilization = "human";
		t.banner_id = "human";
		t.architecture_id = "human";
		t.name_locale = "Human";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "primates";
		t.name_taxonomic_family = "hominidae";
		t.name_taxonomic_genus = "homo";
		t.name_taxonomic_species = "sapiens";
		t.icon = "iconHumans";
		t.color_hex = "#005E72";
		t.zombie_color_hex = "#00AD2C";
		t.disable_jump_animation = true;
		t.base_stats["mass_2"] = 65f;
		t.addGenome(("health", 100f), ("stamina", 100f), ("mutation", 1f), ("bonus_sex_random", 2f), ("bad", 2f), ("lifespan", 70f), ("damage", 15f), ("speed", 15f), ("offspring", 5f), ("diplomacy", 3f), ("warfare", 3f), ("stewardship", 3f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addSubspeciesTrait("nocturnal_dormancy");
		t.addClanTrait("divine_dozen");
		t.addCultureTrait("city_layout_the_grand_arrangement");
		t.addCultureTrait("city_layout_stone_garden");
		t.addCultureTrait("roads");
		t.addCultureTrait("statue_lovers");
		t.addCultureTrait("pep_talks");
		t.addCultureTrait("youth_reverence");
		t.addCultureTrait("expansionists");
		t.addLanguageTrait("nicely_structured_grammar");
		t.addReligionTrait("bloodline_bond");
		t.addReligionTrait("rite_of_roaring_skies");
		t.addReligionTrait("cast_shield");
		t.production = new string[2] { "bread", "pie" };
		addPhenotype("skin_light");
		addPhenotype("skin_dark");
		addPhenotype("skin_mixed");
		clone("elf", "$civ_advanced_unit$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("elf_default_set");
		t.addPreferredColors("green", "lime", "lavender");
		t.kingdom_id_wild = "nomads_elf";
		t.kingdom_id_civilization = "elf";
		t.banner_id = "elf";
		t.architecture_id = "elf";
		t.build_order_template_id = "build_order_advanced";
		t.music_theme = "Elves_Neutral";
		t.name_locale = "Elf";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "primates";
		t.name_taxonomic_family = "hominidae";
		t.name_taxonomic_genus = "elvus";
		t.name_taxonomic_species = "elegance";
		t.collective_term = "group_quiver";
		t.icon = "iconElves";
		t.color_hex = "#005D00";
		t.zombie_color_hex = "#2C8D98";
		t.civ_base_cities = 3;
		t.family_limit = 20;
		t.base_stats["mass_2"] = 25f;
		t.addGenome(("health", 70f), ("bonus_sex_random", 1f), ("stamina", 200f), ("lifespan", 500f), ("mutation", 2f), ("damage", 10f), ("speed", 20f), ("offspring", 2f), ("diplomacy", 5f), ("warfare", 2f), ("stewardship", 2f), ("intelligence", 6f));
		t.addCultureTrait("bow_lovers");
		t.addCultureTrait("spear_lovers");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("youth_reverence");
		t.addCultureTrait("reading_lovers");
		t.addCultureTrait("attentive_readers");
		t.addCultureTrait("animal_whisperers");
		t.addCultureTrait("true_roots");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("unbroken_chain");
		t.addCultureTrait("city_layout_pillars");
		t.addClanTrait("blood_pact");
		t.addClanTrait("divine_dozen");
		t.addClanTrait("witchs_vein");
		t.addLanguageTrait("melodic");
		t.addLanguageTrait("magic_words");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("death_grow_tree");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_frugivore");
		t.addSubspeciesTrait("diet_granivore");
		t.addSubspeciesTrait("diet_florivore");
		t.addSubspeciesTrait("diet_folivore");
		t.addSubspeciesTrait("pure");
		t.addKingdomTrait("tax_rate_local_low");
		t.addKingdomTrait("tax_rate_tribute_low");
		t.addReligionTrait("rite_of_living_harvest");
		t.addReligionTrait("rite_of_entanglement");
		t.addReligionTrait("cast_grass_seeds");
		addTrait("weightless");
		addTrait("moonchild");
		addTrait("soft_skin");
		t.disable_jump_animation = true;
		t.production = new string[4] { "bread", "jam", "sushi", "cider" };
		addPhenotype("skin_light");
		addPhenotype("skin_mixed");
		addPhenotype("mid_gray", "biome_corrupted");
		addPhenotype("skin_purple", "biome_celestial");
		t.addResource("meat", 1, pNewList: true);
		t.addResource("bones", 1);
		clone("orc", "$civ_advanced_unit$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("orc_default_set");
		t.addPreferredColors("red", "orange", "brown", "maroon", "black");
		t.kingdom_id_wild = "nomads_orc";
		t.kingdom_id_civilization = "orc";
		t.banner_id = "orc";
		t.architecture_id = "orc";
		t.build_order_template_id = "build_order_advanced";
		t.music_theme = "Orcs_Neutral";
		t.family_limit = 50;
		t.name_locale = "Orc";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "primates";
		t.name_taxonomic_family = "hominidae";
		t.name_taxonomic_genus = "orcus";
		t.name_taxonomic_species = "bellicus";
		t.collective_term = "group_horde";
		t.base_stats["mass_2"] = 85f;
		t.icon = "iconOrcs";
		t.color_hex = "#2F5225";
		t.zombie_color_hex = "#7C5280";
		t.civ_base_cities = 4;
		t.addGenome(("health", 150f), ("bonus_sex_random", 1f), ("stamina", 130f), ("lifespan", 50f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 10f), ("diplomacy", 2f), ("warfare", 5f), ("birth_rate", 5f), ("stewardship", 3f), ("intelligence", 2f));
		addTrait("regeneration");
		addTrait("savage");
		addTrait("nightchild");
		addTrait("bloodlust");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("slow_builders");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addSubspeciesTrait("prolonged_rest");
		t.addSubspeciesTrait("aggressive");
		t.addClanTrait("warlocks_vein");
		t.addClanTrait("combat_instincts");
		t.addCultureTrait("buildings_spread");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("fast_learners");
		t.addCultureTrait("happiness_from_war");
		t.addCultureTrait("dense_dwellings");
		t.addCultureTrait("tiny_legends");
		t.addCultureTrait("warriors_ascension");
		t.addCultureTrait("shattered_crown");
		t.addLanguageTrait("scribble");
		t.addLanguageTrait("raging_paragraphs");
		t.addLanguageTrait("confusing_semantics");
		t.addLanguageTrait("foolish_glyphs");
		t.addReligionTrait("rite_of_falling_stars");
		t.addReligionTrait("zeal_of_conquest");
		t.addReligionTrait("cast_fire");
		t.production = new string[3] { "bread", "burger", "tea" };
		t.disable_jump_animation = true;
		addPhenotype("skin_green");
		addPhenotype("skin_pale", "biome_permafrost");
		addPhenotype("mid_gray", "biome_corrupted");
		addPhenotype("skin_red", "biome_infernal");
		t.addResource("meat", 1, pNewList: true);
		t.addResource("bones", 2);
		clone("dwarf", "$civ_advanced_unit$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("dwarf_default_set", "dwarf_nordic_set");
		t.addPreferredColors("yellow", "orange", "brown");
		t.kingdom_id_wild = "nomads_dwarf";
		t.kingdom_id_civilization = "dwarf";
		t.banner_id = "dwarf";
		t.architecture_id = "dwarf";
		t.build_order_template_id = "build_order_advanced";
		t.music_theme = "Dwarves_Neutral";
		t.name_locale = "Dwarf";
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "chordata";
		t.name_taxonomic_class = "mammalia";
		t.name_taxonomic_order = "primates";
		t.name_taxonomic_family = "hominidae";
		t.name_taxonomic_genus = "dworfus";
		t.name_taxonomic_species = "fortis";
		t.collective_term = "group_beard";
		t.base_stats["mass_2"] = 75f;
		t.family_limit = 30;
		t.item_making_skill = 3;
		t.icon = "iconDwarf";
		t.color_hex = "#828282";
		t.zombie_color_hex = "#7C5280";
		t.civ_base_cities = 3;
		t.addGenome(("health", 150f), ("bonus_sex_random", 1f), ("stamina", 40f), ("lifespan", 220f), ("mutation", 2f), ("damage", 18f), ("speed", 12f), ("offspring", 3f), ("diplomacy", 2f), ("warfare", 3f), ("stewardship", 5f), ("intelligence", 2f));
		addTrait("miner");
		addTrait("deflect_projectile");
		addTrait("block");
		addTrait("fat");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("fast_builders");
		t.addSubspeciesTrait("monophasic_sleep");
		t.addCultureTrait("roads");
		t.addCultureTrait("city_layout_the_grand_arrangement");
		t.addCultureTrait("hammer_lovers");
		t.addCultureTrait("tower_lovers");
		t.addCultureTrait("conscription_male_only");
		t.addCultureTrait("elder_reverence");
		t.addCultureTrait("gossip_lovers");
		t.addCultureTrait("weaponsmith_mastery");
		t.addCultureTrait("armorsmith_mastery");
		t.addLanguageTrait("powerful_words");
		t.addLanguageTrait("ancient_runes");
		t.addClanTrait("divine_dozen");
		t.addClanTrait("iron_will");
		t.addReligionTrait("rite_of_unbroken_shield");
		t.addReligionTrait("rite_of_shattered_earth");
		t.production = new string[2] { "bread", "ale" };
		t.disable_jump_animation = true;
		addPhenotype("skin_light");
		addPhenotype("skin_medium");
		addPhenotype("mid_gray");
		t.addResource("meat", 2, pNewList: true);
		t.addResource("bones", 1);
		t.addResource("stone", 1);
	}

	private void initCivsNew()
	{
		clone("civ_cat", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cat_set");
		t.base_stats["mass_2"] = 35f;
		t.addGenome(("health", 80f), ("stamina", 150f), ("lifespan", 100f), ("mutation", 2f), ("damage", 20f), ("speed", 17f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addSubspeciesTrait("inquisitive_nature");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("true_roots");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("sword_lovers");
		t.addClanTrait("silver_tongues");
		t.addClanTrait("best_five");
		t.addClanTrait("endurance_of_titans");
		t.addClanTrait("deathbound");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("cast_silence");
		t.addReligionTrait("rite_of_eternal_brew");
		t.addReligionTrait("summon_lightning");
		t.addReligionTrait("rite_of_dissent");
		t.addLanguageTrait("melodic");
		addTrait("dodge");
		addTrait("battle_reflexes");
		t.kingdom_id_civilization = "civ_cat";
		t.architecture_id = "civ_cat";
		t.banner_id = "civ_cat";
		t.cloneTaxonomyFromForSapiens("cat");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("cat");
		t.color_hex = "#005E72";
		clone("civ_dog", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.base_stats["mass_2"] = 70f;
		t.addGenome(("health", 120f), ("stamina", 130f), ("lifespan", 80f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("super_positivity");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("dense_dwellings");
		t.addCultureTrait("expansionists");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("patriarchy");
		t.addClanTrait("we_are_legion");
		t.addClanTrait("stonefists");
		t.addClanTrait("blood_of_giants");
		t.addClanTrait("gaia_shield");
		t.addClanTrait("blood_pact");
		t.addCultureTrait("join_or_die");
		t.addReligionTrait("cast_shield");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("hand_of_order");
		t.addReligionTrait("rite_of_roaring_skies");
		t.addLanguageTrait("melodic");
		t.addLanguageTrait("scribble");
		t.addTrait("dash");
		t.kingdom_id_civilization = "civ_dog";
		t.architecture_id = "civ_dog";
		t.banner_id = "civ_dog";
		t.cloneTaxonomyFromForSapiens("dog");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("dog");
		t.color_hex = "#005E72";
		clone("civ_chicken", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("chicken_set");
		t.base_stats["mass_2"] = 35f;
		t.addGenome(("health", 60f), ("stamina", 30f), ("lifespan", 80f), ("mutation", 3f), ("damage", 10f), ("speed", 7f), ("offspring", 12f), ("diplomacy", 4f), ("warfare", 2f), ("stewardship", 4f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("metamorphosis_chicken");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addSubspeciesTrait("monophasic_sleep");
		t.addSubspeciesTrait("cautious_instincts");
		t.addLanguageTrait("strict_spelling");
		t.addReligionTrait("rite_of_living_harvest");
		t.addReligionTrait("cast_silence");
		t.addReligionTrait("summon_lightning");
		t.addReligionTrait("rite_of_change");
		t.addReligionTrait("path_of_unity");
		t.kingdom_id_civilization = "civ_chicken";
		t.render_heads_for_babies = false;
		t.architecture_id = "civ_chicken";
		t.banner_id = "civ_chicken";
		t.cloneTaxonomyFromForSapiens("chicken");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("chicken");
		t.color_hex = "#005E72";
		t.addResource("meat", 1);
		t.addResource("bones", 1);
		clone("civ_rabbit", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rabbit_set");
		t.base_stats["mass_2"] = 30f;
		t.addGenome(("health", 60f), ("stamina", 150f), ("lifespan", 90f), ("mutation", 3f), ("damage", 10f), ("speed", 12f), ("offspring", 12f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_short");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addSubspeciesTrait("cautious_instincts");
		t.addClanTrait("we_are_legion");
		t.addCultureTrait("dense_dwellings");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addReligionTrait("cast_grass_seeds");
		t.addReligionTrait("rite_of_eternal_brew");
		t.addReligionTrait("summon_tornado");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("spawn_vegetation");
		t.kingdom_id_civilization = "civ_rabbit";
		t.architecture_id = "civ_rabbit";
		t.banner_id = "civ_rabbit";
		t.cloneTaxonomyFromForSapiens("rabbit");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("rabbit");
		t.color_hex = "#005E72";
		clone("civ_monkey", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("monkey_set");
		t.base_stats["mass_2"] = 65f;
		t.addGenome(("health", 90f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 8f), ("diplomacy", 4f), ("warfare", 3f), ("stewardship", 2f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("good_throwers");
		t.addSubspeciesTrait("super_positivity");
		t.addSubspeciesTrait("polyphasic_sleep");
		t.addSubspeciesTrait("shiny_love");
		t.addCultureTrait("patriarchy");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("fast_learners");
		t.addCultureTrait("buildings_spread");
		t.addCultureTrait("expertise_exchange");
		t.addCultureTrait("fames_crown");
		t.addClanTrait("we_are_legion");
		t.addClanTrait("silver_tongues");
		t.addClanTrait("bonebreakers");
		t.addClanTrait("combat_instincts");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("rite_of_dissent");
		t.addReligionTrait("summon_tornado");
		t.addReligionTrait("minds_awakening");
		t.addReligionTrait("cast_curse");
		t.addLanguageTrait("scribble");
		t.kingdom_id_civilization = "civ_monkey";
		t.architecture_id = "civ_monkey";
		t.banner_id = "civ_monkey";
		t.cloneTaxonomyFromForSapiens("monkey");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("monkey");
		t.color_hex = "#005E72";
		clone("civ_fox", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fox_set");
		t.base_stats["mass_2"] = 60f;
		t.addGenome(("health", 80f), ("stamina", 120f), ("lifespan", 120f), ("mutation", 2f), ("damage", 20f), ("speed", 12f), ("offspring", 4f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("monophasic_sleep");
		t.addSubspeciesTrait("nimble");
		t.addLanguageTrait("elegant_words");
		t.addLanguageTrait("stylish_writing");
		t.addReligionTrait("cast_curse");
		t.addReligionTrait("rite_of_dissent");
		t.addReligionTrait("summon_lightning");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("path_of_unity");
		t.addCultureTrait("reading_lovers");
		t.addCultureTrait("fames_crown");
		t.kingdom_id_civilization = "civ_fox";
		t.architecture_id = "civ_fox";
		t.banner_id = "civ_fox";
		t.cloneTaxonomyFromForSapiens("fox");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("fox");
		t.color_hex = "#005E72";
		clone("civ_sheep", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("sheep_set");
		t.base_stats["mass_2"] = 80f;
		t.addGenome(("health", 90f), ("stamina", 30f), ("lifespan", 100f), ("mutation", 2f), ("damage", 10f), ("speed", 12f), ("offspring", 2f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("monophasic_sleep");
		t.addSubspeciesTrait("cautious_instincts");
		t.addLanguageTrait("nicely_structured_grammar");
		t.addLanguageTrait("melodic");
		t.addKingdomTrait("tax_rate_tribute_high");
		t.addKingdomTrait("tax_rate_local_high");
		t.addCultureTrait("golden_rule");
		t.addCultureTrait("city_layout_diamond");
		t.addReligionTrait("cast_grass_seeds");
		t.kingdom_id_civilization = "civ_sheep";
		t.architecture_id = "civ_sheep";
		t.banner_id = "civ_sheep";
		t.cloneTaxonomyFromForSapiens("sheep");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("sheep");
		t.color_hex = "#005E72";
		t.addTrait("greedy");
		t.addResource("meat", 2, pNewList: true);
		t.addResource("leather", 1);
		t.addResource("bones", 1);
		clone("civ_cow", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cow_set");
		t.base_stats["mass_2"] = 175f;
		t.addGenome(("health", 120f), ("stamina", 20f), ("lifespan", 100f), ("mutation", 2f), ("damage", 10f), ("speed", 11f), ("offspring", 2f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addSubspeciesTrait("monophasic_sleep");
		t.addSubspeciesTrait("prolonged_rest");
		t.addLanguageTrait("melodic");
		t.addLanguageTrait("stylish_writing");
		t.addCultureTrait("dense_dwellings");
		t.addTrait("tough");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_cow";
		t.architecture_id = "civ_cow";
		t.banner_id = "civ_cow";
		t.cloneTaxonomyFromForSapiens("cow");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("cow");
		t.color_hex = "#005E72";
		t.addResource("meat", 2);
		clone("civ_armadillo", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("armadillo_set");
		t.base_stats["mass_2"] = 45f;
		t.addGenome(("health", 200f), ("stamina", 50f), ("lifespan", 100f), ("mutation", 1f), ("damage", 20f), ("armor", 20f), ("speed", 17f), ("offspring", 2f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 4f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addCultureTrait("armorsmith_mastery");
		t.addLanguageTrait("powerful_words");
		t.kingdom_id_civilization = "civ_armadillo";
		t.architecture_id = "civ_armadillo";
		t.banner_id = "civ_armadillo";
		t.cloneTaxonomyFromForSapiens("armadillo");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("armadillo");
		t.color_hex = "#005E72";
		t.addResource("meat", 1);
		t.addResource("bones", 2);
		clone("civ_wolf", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.base_stats["mass_2"] = 85f;
		t.addGenome(("health", 130f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 20f), ("offspring", 4f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_short");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("metamorphosis_wolf");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("diet_folivore");
		t.addCultureTrait("city_layout_claws");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("ethnocentric_guard");
		t.addCultureTrait("happiness_from_war");
		t.addClanTrait("blood_pact");
		t.addClanTrait("iron_will");
		t.addClanTrait("combat_instincts");
		t.addLanguageTrait("powerful_words");
		t.addLanguageTrait("scribble");
		t.addReligionTrait("rite_of_restless_dead");
		t.kingdom_id_civilization = "civ_wolf";
		t.architecture_id = "civ_wolf";
		t.banner_id = "civ_wolf";
		t.cloneTaxonomyFromForSapiens("wolf");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("wolf");
		t.color_hex = "#005E72";
		t.addResource("bones", 1);
		t.addResource("leather", 1);
		clone("civ_bear", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bear_set");
		t.base_stats["mass_2"] = 140f;
		t.addGenome(("health", 180f), ("stamina", 150f), ("lifespan", 80f), ("mutation", 3f), ("damage", 30f), ("armor", 5f), ("speed", 14f), ("offspring", 2f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("big_stomach");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("winter_slumberers");
		t.addSubspeciesTrait("energy_preserver");
		t.addSubspeciesTrait("aggressive");
		t.addCultureTrait("city_layout_claws");
		t.addCultureTrait("patriarchy");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("ethnocentric_guard");
		t.addCultureTrait("conscription_male_only");
		t.addCultureTrait("axe_lovers");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("training_potential");
		t.addLanguageTrait("foolish_glyphs");
		t.addClanTrait("blood_of_giants");
		t.addClanTrait("iron_will");
		t.addReligionTrait("rite_of_shattered_earth");
		t.kingdom_id_civilization = "civ_bear";
		t.render_heads_for_babies = false;
		t.architecture_id = "civ_bear";
		t.banner_id = "civ_bear";
		t.cloneTaxonomyFromForSapiens("bear");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("bear");
		t.color_hex = "#005E72";
		t.addResource("meat", 1);
		clone("civ_rhino", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rhino_set");
		t.base_stats["mass_2"] = 295f;
		t.addGenome(("health", 230f), ("stamina", 110f), ("lifespan", 80f), ("mutation", 1f), ("damage", 35f), ("armor", 15f), ("speed", 16f), ("offspring", 2f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 2f), ("intelligence", 2f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("bioproduct_stone");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("aggressive");
		t.addClanTrait("bonebreakers");
		t.addClanTrait("blood_of_giants");
		t.addClanTrait("iron_will");
		t.addClanTrait("void_ban");
		t.addCultureTrait("patriarchy");
		t.addCultureTrait("axe_lovers");
		t.addCultureTrait("city_layout_bricks");
		t.addLanguageTrait("raging_paragraphs");
		t.addLanguageTrait("powerful_words");
		t.addReligionTrait("zeal_of_conquest");
		t.addTrait("dash");
		t.addTrait("block");
		t.addTrait("hard_skin");
		t.addTrait("tough");
		t.addTrait("strong");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_rhino";
		t.architecture_id = "civ_rhino";
		t.banner_id = "civ_rhino";
		t.cloneTaxonomyFromForSapiens("rhino");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("rhino");
		t.color_hex = "#005E72";
		t.addResource("meat", 2);
		clone("civ_buffalo", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("buffalo_set");
		t.base_stats["mass_2"] = 290f;
		t.addGenome(("health", 160f), ("stamina", 120f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 16f), ("offspring", 2f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("city_layout_monolith_mesh");
		t.addCultureTrait("dense_dwellings");
		t.addLanguageTrait("raging_paragraphs");
		t.addLanguageTrait("powerful_words");
		t.addClanTrait("stonefists");
		t.addReligionTrait("rite_of_roaring_skies");
		t.addTrait("tough");
		t.addTrait("dash");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_buffalo";
		t.architecture_id = "civ_buffalo";
		t.banner_id = "civ_buffalo";
		t.cloneTaxonomyFromForSapiens("buffalo");
		t.name_taxonomic_genus = "jecodespecus";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("buffalo");
		t.color_hex = "#005E72";
		t.addResource("meat", 2);
		t.addResource("bones", 1);
		clone("civ_hyena", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("hyena_set");
		t.base_stats["mass_2"] = 60f;
		t.addGenome(("health", 130f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("armor", 5f), ("speed", 20f), ("offspring", 6f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("super_positivity");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addClanTrait("combat_instincts");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("conscription_female_only");
		t.addCultureTrait("axe_lovers");
		t.addCultureTrait("city_layout_tile_wobbly_pattern");
		t.addLanguageTrait("raging_paragraphs");
		t.addLanguageTrait("confusing_semantics");
		t.addReligionTrait("rite_of_dissent");
		t.kingdom_id_civilization = "civ_hyena";
		t.architecture_id = "civ_hyena";
		t.banner_id = "civ_hyena";
		t.cloneTaxonomyFromForSapiens("hyena");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("hyena");
		t.color_hex = "#005E72";
		clone("civ_rat", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rat_set");
		t.base_stats["mass_2"] = 20f;
		t.addGenome(("health", 80f), ("stamina", 50f), ("lifespan", 80f), ("mutation", 4f), ("damage", 12f), ("speed", 16f), ("armor", 5f), ("offspring", 15f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_short");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("nimble");
		t.addClanTrait("we_are_legion");
		t.addCultureTrait("ethnocentric_guard");
		t.addCultureTrait("hive_society");
		t.addCultureTrait("expansionists");
		t.addLanguageTrait("scribble");
		t.kingdom_id_civilization = "civ_rat";
		t.render_heads_for_babies = false;
		t.architecture_id = "civ_rat";
		t.banner_id = "civ_rat";
		t.cloneTaxonomyFromForSapiens("rat");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("rat");
		t.color_hex = "#005E72";
		clone("civ_alpaca", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alpaca_set");
		t.base_stats["mass_2"] = 70f;
		t.addGenome(("health", 110f), ("stamina", 50f), ("lifespan", 150f), ("mutation", 1f), ("damage", 18f), ("speed", 12f), ("offspring", 3f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("diplomatic_ascension");
		t.addLanguageTrait("elegant_words");
		t.addTrait("soft_skin");
		t.addReligionTrait("path_of_unity");
		t.kingdom_id_civilization = "civ_alpaca";
		t.architecture_id = "civ_alpaca";
		t.banner_id = "civ_alpaca";
		t.cloneTaxonomyFromForSapiens("alpaca");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("alpaca");
		t.color_hex = "#005E72";
		t.addResource("meat", 2);
		t.addResource("leather", 1);
		clone("civ_capybara", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("capybara_set");
		t.base_stats["mass_2"] = 70f;
		t.addGenome(("health", 130f), ("stamina", 30f), ("lifespan", 90f), ("mutation", 1f), ("damage", 18f), ("speed", 10f), ("offspring", 4f), ("diplomacy", 4f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("telepathic_link");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addSubspeciesTrait("slow_builders");
		t.addCultureTrait("serenity_now");
		t.addCultureTrait("xenophiles");
		t.addLanguageTrait("melodic");
		t.kingdom_id_civilization = "civ_capybara";
		t.architecture_id = "civ_capybara";
		t.banner_id = "civ_capybara";
		t.cloneTaxonomyFromForSapiens("capybara");
		t.name_taxonomic_genus = "mastefus";
		t.name_taxonomic_species = "yourmomus";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("capybara");
		t.color_hex = "#005E72";
		t.addTrait("peaceful");
		t.addTrait("content");
		t.addTrait("arcane_reflexes");
		clone("civ_goat", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("goat_set");
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 110f), ("stamina", 100f), ("lifespan", 80f), ("mutation", 1f), ("damage", 15f), ("speed", 16f), ("offspring", 3f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_herbivore");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("reading_lovers");
		t.addCultureTrait("expertise_exchange");
		t.addCultureTrait("ancestors_knowledge");
		t.addLanguageTrait("enlightening_script");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_goat";
		t.architecture_id = "civ_goat";
		t.banner_id = "civ_goat";
		t.cloneTaxonomyFromForSapiens("goat");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("goat");
		t.color_hex = "#005E72";
		clone("civ_scorpion", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("scorpion_set");
		t.base_stats["mass_2"] = 25f;
		t.addGenome(("health", 130f), ("stamina", 30f), ("lifespan", 150f), ("mutation", 3f), ("damage", 30f), ("speed", 11f), ("armor", 25f), ("offspring", 25f), ("diplomacy", 1f), ("warfare", 5f), ("stewardship", 2f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_very_long");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_desert");
		t.addClanTrait("combat_instincts");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("patriarchy");
		t.addCultureTrait("conscription_female_only");
		t.addCultureTrait("solitude_seekers");
		t.addLanguageTrait("elegant_words");
		t.addReligionTrait("sands_of_ruin");
		t.addReligionTrait("cast_fire");
		addTrait("venomous");
		addTrait("poison_immune");
		t.kingdom_id_civilization = "civ_scorpion";
		t.architecture_id = "civ_scorpion";
		t.banner_id = "civ_scorpion";
		t.cloneTaxonomyFromForSapiens("scorpion");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("scorpion");
		t.color_hex = "#005E72";
		t.addResource("meat", 2, pNewList: true);
		t.addResource("bones", 1);
		clone("civ_crab", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crab_set");
		t.base_stats["mass_2"] = 30f;
		t.addGenome(("health", 130f), ("stamina", 20f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 12f), ("armor", 25f), ("offspring", 30f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_roe");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("metamorphosis_crab");
		t.addSubspeciesTrait("exoskeleton");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_algivore");
		t.addSubspeciesTrait("fins");
		t.addCultureTrait("ethnocentric_guard");
		t.addCultureTrait("city_layout_pebbles");
		t.addLanguageTrait("powerful_words");
		t.addCultureTrait("dense_dwellings");
		t.addClanTrait("blood_of_sea");
		t.addTrait("hard_skin");
		t.kingdom_id_civilization = "civ_crab";
		t.architecture_id = "civ_crab";
		t.banner_id = "civ_crab";
		t.cloneTaxonomyFromForSapiens("crab");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("crab");
		t.color_hex = "#005E72";
		t.addResource("bones", 2);
		clone("civ_penguin", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("penguin_set");
		t.base_stats["mass_2"] = 35f;
		t.addGenome(("health", 110f), ("stamina", 100f), ("lifespan", 80f), ("mutation", 1f), ("damage", 12f), ("speed", 10f), ("offspring", 2f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_permafrost");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("xenophiles");
		t.addClanTrait("blood_of_sea");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addReligionTrait("rite_of_tempest_call");
		addTrait("freeze_proof");
		t.kingdom_id_civilization = "civ_penguin";
		t.architecture_id = "civ_penguin";
		t.banner_id = "civ_penguin";
		t.cloneTaxonomyFromForSapiens("penguin");
		t.name_taxonomic_genus = "hugovazus";
		t.name_taxonomic_species = "pingus";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("penguin");
		t.color_hex = "#005E72";
		clone("civ_turtle", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("turtle_set");
		t.base_stats["mass_2"] = 110f;
		t.addGenome(("health", 180f), ("stamina", 50f), ("lifespan", 500f), ("mutation", 1f), ("damage", 12f), ("speed", 8f), ("armor", 25f), ("offspring", 20f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_colored");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("cautious_instincts");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("sword_lovers");
		t.addCultureTrait("solitude_seekers");
		t.addLanguageTrait("enlightening_script");
		t.addLanguageTrait("strict_spelling");
		t.addLanguageTrait("eternal_text");
		t.addCultureTrait("dense_dwellings");
		t.addClanTrait("blood_of_sea");
		t.kingdom_id_civilization = "civ_turtle";
		t.architecture_id = "civ_turtle";
		t.banner_id = "civ_turtle";
		t.cloneTaxonomyFromForSapiens("turtle");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("turtle");
		t.color_hex = "#005E72";
		t.addResource("bones", 1);
		clone("civ_crocodile", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crocodile_set");
		t.base_stats["mass_2"] = 200f;
		t.addGenome(("health", 130f), ("stamina", 60f), ("lifespan", 90f), ("mutation", 1f), ("damage", 20f), ("speed", 10f), ("armor", 10f), ("offspring", 10f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 3f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addClanTrait("masters_of_propaganda");
		t.addClanTrait("blood_of_sea");
		t.addClanTrait("combat_instincts");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("patriarchy");
		t.addCultureTrait("warriors_ascension");
		t.addCultureTrait("city_layout_parallels");
		t.addLanguageTrait("scribble");
		t.addReligionTrait("cast_silence");
		t.kingdom_id_civilization = "civ_crocodile";
		t.render_heads_for_babies = false;
		t.architecture_id = "civ_crocodile";
		t.banner_id = "civ_crocodile";
		t.cloneTaxonomyFromForSapiens("crocodile");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("crocodile");
		t.color_hex = "#005E72";
		t.addResource("meat", 1);
		t.addResource("leather", 1);
		clone("civ_snake", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snake_set");
		t.base_stats["mass_2"] = 15f;
		t.addGenome(("health", 80f), ("stamina", 40f), ("lifespan", 150f), ("mutation", 1f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 10f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_shell_plain");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("circadian_drift");
		t.addClanTrait("silver_tongues");
		t.addClanTrait("blood_of_sea");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("ethnocentric_guard");
		t.addCultureTrait("spear_lovers");
		t.addCultureTrait("solitude_seekers");
		t.addLanguageTrait("strict_spelling");
		t.addReligionTrait("rite_of_dissent");
		t.addReligionTrait("cast_curse");
		t.addReligionTrait("cast_silence");
		addTrait("venomous");
		t.kingdom_id_civilization = "civ_snake";
		t.architecture_id = "civ_snake";
		t.banner_id = "civ_snake";
		t.cloneTaxonomyFromForSapiens("snake");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("snake");
		t.color_hex = "#005E72";
		t.addResource("meat", 2, pNewList: true);
		t.addResource("leather", 2);
		clone("civ_frog", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("frog_set");
		t.base_stats["mass_2"] = 15f;
		t.addGenome(("health", 80f), ("stamina", 50f), ("lifespan", 90f), ("mutation", 3f), ("damage", 12f), ("speed", 7f), ("offspring", 15f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_bubble");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("dreamweavers");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addLanguageTrait("melodic");
		t.addCultureTrait("dense_dwellings");
		t.addReligionTrait("cast_blood_rain");
		t.addClanTrait("masters_of_propaganda");
		t.addClanTrait("blood_of_sea");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_frog";
		t.architecture_id = "civ_frog";
		t.banner_id = "civ_frog";
		t.cloneTaxonomyFromForSapiens("frog");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("frog");
		t.color_hex = "#005E72";
		t.addResource("meat", 1, pNewList: true);
		t.addResource("leather", 1);
		clone("civ_piranha", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("piranha_set");
		t.base_stats["mass_2"] = 19f;
		t.addGenome(("health", 40f), ("stamina", 50f), ("lifespan", 30f), ("mutation", 1f), ("damage", 30f), ("speed", 7f), ("armor", 5f), ("offspring", 20f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 1f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_roe");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("aggressive");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_carnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("ethnocentric_guard");
		t.addLanguageTrait("scribble");
		t.addClanTrait("we_are_legion");
		t.addClanTrait("combat_instincts");
		t.addClanTrait("blood_of_sea");
		t.addReligionTrait("cast_blood_rain");
		t.addTrait("battle_reflexes");
		t.kingdom_id_civilization = "civ_piranha";
		t.architecture_id = "civ_piranha";
		t.banner_id = "civ_piranha";
		t.cloneTaxonomyFromForSapiens("piranha");
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("piranha");
		t.color_hex = "#005E72";
		t.addResource("sushi", 2, pNewList: true);
		clone("civ_liliar", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("flower_set");
		t.base_stats["mass_2"] = 90f;
		t.addGenome(("health", 40f), ("stamina", 100f), ("lifespan", 400f), ("mutation", 2f), ("damage", 5f), ("speed", 10f), ("offspring", 10f), ("diplomacy", 6f), ("warfare", 1f), ("stewardship", 6f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("death_grow_plant");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("gaia_roots");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("genetic_mirror");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("conscription_female_only");
		t.addClanTrait("gaia_blood");
		t.addClanTrait("gaia_shield");
		t.addClanTrait("flesh_weavers");
		t.addLanguageTrait("melodic");
		t.addLanguageTrait("nicely_structured_grammar");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addTrait("regeneration");
		t.kingdom_id_civilization = "civ_liliar";
		t.architecture_id = "civ_liliar";
		t.banner_id = "civ_liliar";
		t.cloneTaxonomyFromForSapiens("flower_bud");
		t.name_taxonomic_genus = "luulia";
		t.name_taxonomic_species = "jubkoza";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("flower_bud");
		t.color_hex = "#005E72";
		t.addResource("herbs", 2, pNewList: true);
		clone("civ_garlic_man", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("garlic_man_set");
		t.base_stats["mass_2"] = 30f;
		t.addGenome(("health", 80f), ("stamina", 100f), ("lifespan", 250f), ("mutation", 2f), ("damage", 12f), ("speed", 20f), ("armor", 5f), ("offspring", 9f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("genetic_mirror");
		t.addCultureTrait("legacy_keepers");
		t.addLanguageTrait("confusing_semantics");
		t.addClanTrait("flesh_weavers");
		t.addCultureTrait("hive_society");
		t.addReligionTrait("cast_cure");
		t.addTrait("poison_immune");
		t.addTrait("regeneration");
		t.render_heads_for_babies = false;
		t.kingdom_id_civilization = "civ_garlic_man";
		t.architecture_id = "civ_garlic_man";
		t.banner_id = "civ_garlic_man";
		t.cloneTaxonomyFromForSapiens("garl");
		t.name_taxonomic_species = "lumneskatus";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("garl");
		t.color_hex = "#005E72";
		t.addResource("herbs", 2, pNewList: true);
		clone("civ_lemon_man", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("lemon_man_set");
		t.base_stats["mass_2"] = 45f;
		t.addGenome(("health", 80f), ("stamina", 100f), ("lifespan", 150f), ("mutation", 4f), ("damage", 12f), ("speed", 14f), ("offspring", 5f), ("diplomacy", 6f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_hermaphroditic");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("population_large");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addCultureTrait("hive_society");
		t.addCultureTrait("expertise_exchange");
		t.addLanguageTrait("confusing_semantics");
		t.addLanguageTrait("doomed_glyphs");
		t.addReligionTrait("cast_cure");
		t.kingdom_id_civilization = "civ_lemon_man";
		t.architecture_id = "civ_lemon_man";
		t.banner_id = "civ_lemon_man";
		t.cloneTaxonomyFromForSapiens("lemon_snail");
		t.name_taxonomic_genus = "soursapiens";
		t.name_taxonomic_species = "misbehavius";
		t.icon = "civs/" + t.id;
		t.name_locale = "civ_lemon_man";
		t.clonePhenotype("lemon_snail");
		t.color_hex = "#005E72";
		addTrait("poison_immune");
		addTrait("paranoid");
		addTrait("attractive");
		addTrait("lucky");
		t.addTrait("regeneration");
		t.addResource("lemons", 3, pNewList: true);
		clone("civ_acid_gentleman", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("acid_blob_set");
		t.base_stats["mass_2"] = 99f;
		t.addGenome(("health", 80f), ("stamina", 30f), ("lifespan", 150f), ("mutation", 10f), ("damage", 18f), ("speed", 9f), ("armor", 5f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_blob");
		t.addSubspeciesTrait("reproduction_fission");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("unstable_genome");
		t.addSubspeciesTrait("adaptation_wasteland");
		t.addCultureTrait("pep_talks");
		t.addCultureTrait("city_layout_madman_labyrinth");
		t.addLanguageTrait("elegant_words");
		t.kingdom_id_civilization = "civ_acid_gentleman";
		t.architecture_id = "civ_acid_gentleman";
		t.render_heads_for_babies = false;
		t.banner_id = "civ_acid_gentleman";
		t.cloneTaxonomyFromForSapiens("acid_blob");
		t.name_taxonomic_genus = "gentlemanus";
		t.name_taxonomic_species = "jumpus";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.clonePhenotype("acid_blob");
		t.color_hex = "#005E72";
		t.clonePhenotype("acid_blob");
		t.prevent_unconscious_rotation = true;
		addTrait("acid_blood");
		addTrait("acid_proof");
		addTrait("acid_touch");
		addTrait("poison_immune");
		addTrait("paranoid");
		addTrait("attractive");
		t.addResource("jam", 1, pNewList: true);
		clone("civ_crystal_golem", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crystal_golem_set");
		t.base_stats["mass_2"] = 455f;
		t.addGenome(("health", 250f), ("stamina", 60f), ("lifespan", 1000f), ("mutation", 1f), ("damage", 30f), ("speed", 12f), ("armor", 30f), ("offspring", 2f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 2f), ("intelligence", 4f));
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_crystal");
		t.addSubspeciesTrait("reproduction_hermaphroditic");
		t.addSubspeciesTrait("gestation_extremely_long");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("metamorphosis_sword");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_lithotroph");
		t.addSubspeciesTrait("slow_builders");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addClanTrait("endurance_of_titans");
		t.addClanTrait("best_five");
		t.addClanTrait("blood_of_giants");
		t.addClanTrait("iron_will");
		t.addCultureTrait("fames_crown");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("sword_lovers");
		t.addCultureTrait("city_layout_titan_footprints");
		t.addLanguageTrait("words_of_madness");
		t.addClanTrait("blood_of_eons");
		t.name_locale = "Crystal Golem";
		t.cloneTaxonomyFromForSapiens("crystal_sword");
		t.name_taxonomic_genus = "bigus";
		t.name_taxonomic_species = "crystallus";
		t.kingdom_id_civilization = "civ_crystal_golem";
		t.architecture_id = "civ_crystal_golem";
		t.banner_id = "civ_crystal_golem";
		t.icon = "civs/" + t.id;
		t.has_skin = false;
		t.mush_id = "mush_unit";
		t.clonePhenotype("crystal_sword");
		t.color_hex = "#75D0F4";
		t.sound_hit = "event:/SFX/HIT/HitStone";
		addTrait("shiny");
		addTrait("strong_minded");
		t.addResource("gems", 1, pNewList: true);
		t.addResource("stone", 1);
		t.addResource("crystal_salt", 1);
		clone("civ_candy_man", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("candy_man_set");
		t.base_stats["mass_2"] = 70f;
		t.addGenome(("health", 85f), ("stamina", 60f), ("lifespan", 150f), ("mutation", 5f), ("damage", 12f), ("speed", 10f), ("offspring", 4f), ("diplomacy", 6f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 5f));
		t.addSubspeciesTrait("reproduction_vegetative");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_candy");
		t.addSubspeciesTrait("annoying_fireworks");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("diet_cannibalism");
		t.addSubspeciesTrait("diet_carnivore");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addSubspeciesTrait("genetic_mirror");
		t.addCultureTrait("xenophobic");
		t.addLanguageTrait("words_of_madness");
		t.name_locale = "Candy Man";
		t.kingdom_id_civilization = "civ_candy_man";
		t.architecture_id = "civ_candy_man";
		t.banner_id = "civ_candy_man";
		t.cloneTaxonomyFromForSapiens("smore");
		t.name_taxonomic_genus = "zucker";
		t.name_taxonomic_species = "daddies";
		t.icon = "civs/" + t.id;
		t.name_locale = t.id;
		t.has_skin = false;
		t.mush_id = "mush_unit";
		t.clonePhenotype("smore");
		t.color_hex = "#75D0F4";
		t.sound_hit = "event:/SFX/HIT/HitStone";
		addTrait("flesh_eater");
		addTrait("evil");
		addTrait("gluttonous");
		addTrait("strong_minded");
		t.addResource("candy", 4, pNewList: true);
		t.addResource("evil_beets", 1);
		clone("civ_beetle", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.architecture_id = "civ_beetle";
		t.banner_id = "civ_beetle";
		t.kingdom_id_civilization = "civ_beetle";
		t.default_attack = "rocks";
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_xylophagy");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("fast_builders");
		t.addSubspeciesTrait("high_fecundity");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("exoskeleton");
		t.addSubspeciesTrait("egg_cocoon");
		t.addClanTrait("bonebreakers");
		t.addCultureTrait("city_layout_bricks");
		t.addCultureTrait("dense_dwellings");
		t.clonePhenotype("beetle");
		t.addTrait("hard_skin");
		t.addTrait("slow");
		t.addTrait("strong");
		t.addGenome(("health", 100f), ("stamina", 70f), ("lifespan", 50f), ("mutation", 1f), ("damage", 10f), ("speed", 12f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 4f), ("intelligence", 4f));
		t.icon = "civs/" + t.id;
		t.cloneTaxonomyFromForSapiens("beetle");
		t.name_taxonomic_genus = "hollonus";
		t.name_taxonomic_species = "silkus";
		t.name_locale = t.id;
		t.disable_jump_animation = true;
		t.render_heads_for_babies = false;
		t.shadow = true;
		t.base_stats["mass_2"] = 10f;
		t.addResource("fertilizer", 1);
		clone("civ_seal", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("seal_set");
		t.architecture_id = "civ_seal";
		t.banner_id = "civ_seal";
		t.kingdom_id_civilization = "civ_seal";
		t.default_attack = "jaws";
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("adaptation_corruption");
		t.addSubspeciesTrait("adaptation_desert");
		t.addSubspeciesTrait("adaptation_infernal");
		t.addSubspeciesTrait("adaptation_permafrost");
		t.addSubspeciesTrait("adaptation_swamp");
		t.addSubspeciesTrait("adaptation_wasteland");
		t.addClanTrait("blood_of_sea");
		t.addClanTrait("combat_instincts");
		t.addLanguageTrait("strict_spelling");
		t.addCultureTrait("city_layout_bricks");
		t.addCultureTrait("armorsmith_mastery");
		t.addCultureTrait("weaponsmith_mastery");
		t.addCultureTrait("craft_shotgun");
		t.clonePhenotype("seal");
		t.addTrait("agile");
		t.addTrait("strong");
		t.addTrait("fat");
		t.addTrait("backstep");
		t.addTrait("deflect_projectile");
		t.addTrait("dodge");
		t.addTrait("block");
		t.addTrait("dash");
		t.addGenome(("health", 100f), ("stamina", 70f), ("lifespan", 50f), ("mutation", 1f), ("damage", 10f), ("speed", 12f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 4f), ("intelligence", 4f));
		t.icon = "civs/" + t.id;
		t.cloneTaxonomyFromForSapiens("seal");
		t.name_taxonomic_genus = "phocanavus";
		t.name_taxonomic_species = "militaris";
		t.name_locale = t.id;
		t.disable_jump_animation = true;
		t.render_heads_for_babies = true;
		t.shadow = true;
		clone("civ_unicorn", "$animal_civ$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("unicorn_set");
		t.architecture_id = "civ_unicorn";
		t.banner_id = "civ_unicorn";
		t.kingdom_id_civilization = "civ_unicorn";
		t.default_attack = "hands";
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("egg_rainbow");
		t.addSubspeciesTrait("gestation_moderate");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addCultureTrait("city_layout_royal_checkers");
		t.addCultureTrait("fames_crown");
		t.addClanTrait("magic_blood");
		t.addClanTrait("witchs_vein");
		t.addClanTrait("warlocks_vein");
		t.addTrait("heart_of_wizard");
		t.addTrait("healing_aura");
		t.clonePhenotype("unicorn");
		t.base_stats["mass_2"] = 300f;
		t.addGenome(("health", 500f), ("stamina", 120f), ("mutation", 1f), ("lifespan", 500f), ("damage", 20f), ("speed", 15f), ("armor", 0f), ("offspring", 2f));
		t.icon = "civs/" + t.id;
		t.cloneTaxonomyFromForSapiens("unicorn");
		t.name_taxonomic_genus = "pankus";
		t.name_taxonomic_species = "veryloudus";
		t.name_locale = t.id;
		t.disable_jump_animation = true;
		t.render_heads_for_babies = true;
		t.shadow = true;
	}

	private void initMobsOther()
	{
		clone("cold_one", "$mob$");
		t.render_heads_for_babies = true;
		t.is_humanoid = true;
		t.can_turn_into_ice_one = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cold_one_set");
		t.architecture_id = "civ_cold_one";
		t.kingdom_id_wild = "cold_one";
		t.kingdom_id_civilization = "miniciv_cold_one";
		t.build_order_template_id = "build_order_basic_2";
		t.setSocialStructure("group_blizzard", 40, pCreateOnSpawn: true, pFollowHerd: true, FamilyParentsMode.None);
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("adaptation_permafrost");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_metamorph");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("egg_ice");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("dense_dwellings");
		t.addCultureTrait("true_roots");
		t.addCultureTrait("craft_ice_weapon");
		t.addCultureTrait("city_layout_silk_web");
		t.addLanguageTrait("chilly_font");
		t.addClanTrait("deathbound");
		t.addClanTrait("we_are_legion");
		t.addClanTrait("flesh_weavers");
		t.addReligionTrait("cast_silence");
		t.addReligionTrait("path_of_unity");
		t.addReligionTrait("minds_awakening");
		t.addReligionTrait("rite_of_shattered_earth");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "cnidaria";
		t.name_taxonomic_class = "anthozoa";
		t.name_taxonomic_order = "cryonata";
		t.name_taxonomic_family = "gelididae";
		t.name_taxonomic_genus = "colda";
		t.name_taxonomic_species = "asice";
		t.base_stats["mass_2"] = 85f;
		t.addGenome(("health", 250f), ("stamina", 150f), ("mutation", 1f), ("lifespan", 1000f), ("damage", 40f), ("speed", 30f), ("armor", 15f), ("offspring", 4f));
		t.unit_other = true;
		t.name_locale = "Cold One";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("ice_hammer");
		t.banner_id = "civ_cold_one";
		t.icon = "iconWalker";
		t.color_hex = "#90D2D4";
		t.skeleton_id = "skeleton";
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		t.addDecision("attack_golden_brain");
		addPhenotype("bright_blue");
		addTrait("regeneration");
		addTrait("cold_aura");
		addTrait("weightless");
		addTrait("freeze_proof");
		t.music_theme = "Units_ColdOne";
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.addResource("bones", 1, pNewList: true);
		t.addResource("snow_cucumbers", 2);
		clone("necromancer", "$mob$");
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("necromancer_set");
		t.kingdom_id_wild = "necromancer";
		t.kingdom_id_civilization = "miniciv_necromancer";
		t.architecture_id = "civ_necromancer";
		t.banner_id = "civ_necromancer";
		t.build_order_template_id = "build_order_basic_2";
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_spores");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("egg_face");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("gift_of_death");
		t.addSubspeciesTrait("gift_of_blood");
		t.addSubspeciesTrait("adaptation_corruption");
		t.addSubspeciesTrait("circadian_drift");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addLanguageTrait("spooky_language");
		t.addLanguageTrait("ancient_runes");
		t.addLanguageTrait("cursed_font");
		t.addLanguageTrait("mortal_tongue");
		t.addReligionTrait("shadowroot");
		t.addReligionTrait("cast_silence");
		t.addReligionTrait("rite_of_change");
		t.addReligionTrait("spawn_skeleton");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("true_roots");
		t.addCultureTrait("happiness_from_war");
		t.addCultureTrait("craft_necro_staff");
		t.addClanTrait("deathbound");
		t.addClanTrait("flesh_weavers");
		t.addClanTrait("blood_of_eons");
		t.addClanTrait("witchs_vein");
		t.addClanTrait("iron_will");
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "basidiomycota";
		t.name_taxonomic_class = "pucciniomycetes";
		t.name_taxonomic_order = "pucciniales";
		t.name_taxonomic_family = "umbramagusaceae";
		t.name_taxonomic_genus = "necromagus";
		t.name_taxonomic_species = "boneys";
		t.collective_term = "group_mycelium";
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 300f), ("stamina", 50f), ("mutation", 1f), ("lifespan", 550f), ("damage", 15f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 6f), ("warfare", 8f), ("stewardship", 6f), ("intelligence", 7f));
		t.unit_other = true;
		t.name_locale = "Necromancer";
		t.body_separate_part_hands = true;
		t.icon = "iconNecromancer";
		t.color_hex = "#EE3A42";
		t.skeleton_id = "skeleton";
		t.effect_cast_top = "fx_cast_top_green";
		t.effect_cast_ground = "fx_cast_ground_green";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("necromancer_staff");
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		t.addDecision("attack_golden_brain");
		addPhenotype("skin_mixed");
		addTrait("regeneration");
		addTrait("evil");
		addTrait("fragile_health");
		t.addResource("mushrooms", 1, pNewList: true);
		t.addResource("bones", 1);
		clone("druid", "$mob$");
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("druid_set");
		t.architecture_id = "civ_druid";
		t.kingdom_id_wild = "druid";
		t.banner_id = "civ_druid";
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("egg_cocoon");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("bioproduct_mushrooms");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("gift_of_blood");
		t.addSubspeciesTrait("gift_of_harmony");
		t.addSubspeciesTrait("gift_of_life");
		t.addCultureTrait("ancestors_knowledge");
		t.addCultureTrait("true_roots");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("animal_whisperers");
		t.addCultureTrait("conscription_female_only");
		t.addCultureTrait("city_layout_pillars");
		t.addCultureTrait("craft_druid_staff");
		t.addCultureTrait("spear_lovers");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("ultimogeniture");
		t.addClanTrait("gaia_blood");
		t.addLanguageTrait("melodic");
		t.addReligionTrait("spawn_vegetation");
		t.addReligionTrait("rite_of_entanglement");
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "basidiomycota";
		t.name_taxonomic_class = "agaricomycetes";
		t.name_taxonomic_order = "agaricales";
		t.name_taxonomic_family = "luminomagusaceae";
		t.name_taxonomic_genus = "druidus";
		t.name_taxonomic_species = "greenus";
		t.collective_term = "group_mycelium";
		t.base_stats["mass_2"] = 80f;
		t.addGenome(("health", 100f), ("stamina", 100f), ("lifespan", 200f), ("mutation", 2f), ("damage", 12f), ("speed", 12f), ("armor", 4f), ("offspring", 8f), ("diplomacy", 7f), ("warfare", 5f), ("stewardship", 8f), ("intelligence", 6f));
		t.addSubspeciesTrait("death_grow_tree");
		t.addSubspeciesTrait("death_grow_plant");
		t.unit_other = true;
		t.name_locale = "Druid";
		t.body_separate_part_hands = true;
		t.kingdom_id_wild = "druid";
		t.kingdom_id_civilization = "civ_druid";
		t.icon = "iconDruid";
		t.color_hex = "#4CDB75";
		t.skeleton_id = "skeleton";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("druid_staff");
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		addPhenotype("skin_mixed");
		addTrait("regeneration");
		addTrait("flower_prints");
		addTrait("healing_aura");
		t.addResource("mushrooms", 1, pNewList: true);
		t.addResource("herbs", 2);
		t.addResource("bones", 1);
		clone("plague_doctor", "$mob$");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("plague_doctor_set");
		t.kingdom_id_wild = "plague_doctor";
		t.kingdom_id_civilization = "miniciv_plague_doctor";
		t.architecture_id = "civ_bandit";
		t.banner_id = "civ_bandit";
		t.build_order_template_id = "build_order_basic_2";
		addPhenotype("gray_black");
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("population_moderate");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_spores");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("bioproduct_mushrooms");
		t.addSubspeciesTrait("egg_face");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("gift_of_harmony");
		t.addCultureTrait("legacy_keepers");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("conscription_female_only");
		t.addCultureTrait("animal_whisperers");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("craft_doctor_staff");
		t.addCultureTrait("city_layout_royal_checkers");
		t.addClanTrait("flesh_weavers");
		t.addClanTrait("gaia_blood");
		t.addClanTrait("best_five");
		t.addClanTrait("stonefists");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addLanguageTrait("enlightening_script");
		t.addLanguageTrait("magic_words");
		t.addLanguageTrait("cursed_font");
		t.addReligionTrait("cast_cure");
		t.addReligionTrait("rite_of_change");
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "ascomycota";
		t.name_taxonomic_class = "eurotiomycetes";
		t.name_taxonomic_order = "eurotiales";
		t.name_taxonomic_family = "aspergillaceae";
		t.name_taxonomic_genus = "antiplagus";
		t.name_taxonomic_species = "medicus";
		t.collective_term = "group_mycelium";
		t.base_stats["mass_2"] = 80f;
		t.addGenome(("health", 500f), ("stamina", 100f), ("lifespan", 100f), ("mutation", 2f), ("damage", 1f), ("speed", 20f), ("armor", 4f), ("offspring", 6f), ("diplomacy", 7f), ("warfare", 5f), ("stewardship", 8f), ("intelligence", 6f));
		t.unit_other = true;
		t.name_locale = "Plague Doctor";
		t.immune_to_tumor = true;
		t.body_separate_part_hands = true;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.addDecision("random_move_towards_civ_building");
		t.icon = "iconPlagueDoctor";
		t.color_hex = "#EE3A42";
		t.skeleton_id = "skeleton";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("plague_doctor_staff");
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		addTrait("regeneration");
		addTrait("immune");
		addTrait("fire_proof");
		t.addResource("mushrooms", 1, pNewList: true);
		clone("white_mage", "$mob$");
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("white_mage_set");
		t.kingdom_id_wild = "white_mage";
		t.kingdom_id_civilization = "miniciv_white_mage";
		t.architecture_id = "civ_white_mage";
		t.banner_id = "civ_white_mage";
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_budding");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("egg_orb");
		t.addSubspeciesTrait("bioproduct_mushrooms");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("metamorphosis_butterfly");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("gift_of_void");
		t.addSubspeciesTrait("gift_of_blood");
		t.addSubspeciesTrait("gift_of_water");
		t.addClanTrait("witchs_vein");
		t.addLanguageTrait("ancient_runes");
		t.addLanguageTrait("enlightening_script");
		t.addLanguageTrait("strict_spelling");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addLanguageTrait("magic_words");
		t.addLanguageTrait("melodic");
		t.addCultureTrait("craft_white_staff");
		t.addCultureTrait("animal_whisperers");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("city_layout_rings");
		t.addCultureTrait("city_layout_the_grand_arrangement");
		t.addReligionTrait("cast_cure");
		t.addCultureTrait("ancestors_knowledge");
		addTrait("regeneration");
		addTrait("freeze_proof");
		addTrait("wise");
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "basidiomycota";
		t.name_taxonomic_class = "agaricomycetes";
		t.name_taxonomic_order = "agaricales";
		t.name_taxonomic_family = "luminomagusaceae";
		t.name_taxonomic_genus = "goodmagus";
		t.name_taxonomic_species = "staffus";
		t.collective_term = "group_mycelium";
		addPhenotype("skin_mixed");
		t.addGenome(("health", 300f), ("stamina", 50f), ("lifespan", 500f), ("mutation", 1f), ("damage", 5f), ("speed", 10f), ("armor", 3f), ("offspring", 2f), ("diplomacy", 8f), ("warfare", 4f), ("stewardship", 7f), ("intelligence", 7f));
		t.unit_other = true;
		t.name_locale = "White Mage";
		t.body_separate_part_hands = true;
		t.base_stats["targets"] = 1f;
		t.base_stats["mass_2"] = 75f;
		t.icon = "iconWhiteMage";
		t.color_hex = "#EE3A42";
		t.skeleton_id = "skeleton";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("white_staff");
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		t.addResource("mushrooms", 2, pNewList: true);
		clone("evil_mage", "$mob$");
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("evil_mage_set");
		t.kingdom_id_wild = "evil_mage";
		t.kingdom_id_civilization = "miniciv_evil_mage";
		t.architecture_id = "civ_evil_mage";
		t.banner_id = "civ_evil_mage";
		t.build_order_template_id = "build_order_basic_2";
		t.addSubspeciesTrait("photosynthetic_skin");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_budding");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("egg_flames");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("bioproduct_mushrooms");
		t.addSubspeciesTrait("fire_elemental_form");
		t.addSubspeciesTrait("population_small");
		t.addSubspeciesTrait("spicy_kids");
		t.addSubspeciesTrait("gift_of_void");
		t.addSubspeciesTrait("gift_of_fire");
		t.addSubspeciesTrait("gift_of_thunder");
		t.addSubspeciesTrait("gift_of_air");
		t.addSubspeciesTrait("gift_of_blood");
		t.addSubspeciesTrait("adaptation_infernal");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addCultureTrait("ancestors_knowledge");
		t.addCultureTrait("craft_evil_staff");
		t.addCultureTrait("city_layout_architects_eye");
		t.addCultureTrait("city_layout_the_grand_arrangement");
		t.addClanTrait("deathbound");
		t.addClanTrait("warlocks_vein");
		t.addLanguageTrait("scorching_words");
		t.addLanguageTrait("ancient_runes");
		t.addLanguageTrait("enlightening_script");
		t.addLanguageTrait("strict_spelling");
		t.addLanguageTrait("magic_words");
		t.addLanguageTrait("confusing_semantics");
		t.addReligionTrait("rite_of_infernal_wrath");
		t.name_taxonomic_kingdom = "fungi";
		t.name_taxonomic_phylum = "basidiomycota";
		t.name_taxonomic_class = "pucciniomycetes";
		t.name_taxonomic_order = "pucciniales";
		t.name_taxonomic_family = "umbramagusaceae";
		t.name_taxonomic_genus = "evilmagus";
		t.name_taxonomic_species = "burnus";
		t.collective_term = "group_mycelium";
		addPhenotype("gray_black");
		t.addGenome(("health", 500f), ("stamina", 60f), ("lifespan", 450f), ("mutation", 1f), ("damage", 1f), ("armor", 4f), ("speed", 20f), ("offspring", 2f), ("diplomacy", 5f), ("warfare", 7f), ("stewardship", 5f), ("intelligence", 8f));
		t.unit_other = true;
		t.name_locale = "Evil Mage";
		t.body_separate_part_hands = true;
		t.base_stats["targets"] = 1f;
		t.base_stats["mass_2"] = 75f;
		t.icon = "iconEvilMage";
		t.color_hex = "#EE3A42";
		t.skeleton_id = "skeleton";
		t.effect_teleport = "fx_teleport_red";
		t.effect_cast_top = "fx_cast_top_red";
		t.effect_cast_ground = "fx_cast_ground_red";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("evil_staff");
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.has_soul = true;
		addTrait("evil");
		addTrait("fire_proof");
		addTrait("regeneration");
		addTrait("hotheaded");
		t.addResource("mushrooms", 2, pNewList: true);
		t.addResource("bones", 1);
		clone("skeleton", "$mob$");
		t.species_spawn_radius = 60;
		t.is_humanoid = true;
		t.can_have_subspecies = true;
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("phenotypes");
		t.kingdom_id_civilization = "miniciv_jumpy_skull";
		t.architecture_id = "civ_necromancer";
		t.banner_id = "civ_necromancer";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("skeleton_set");
		t.use_phenotypes = false;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.unit_other = true;
		t.name_locale = "Skeleton";
		t.collective_term = "group_stack";
		t.body_separate_part_hands = true;
		t.has_skin = false;
		t.kingdom_id_wild = "undead";
		t.can_be_killed_by_divine_light = true;
		t.icon = "iconSkeleton";
		t.color_hex = "#ffffff";
		t.job = AssetLibrary<ActorAsset>.a<string>("skeleton_job");
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "ossiphora";
		t.name_taxonomic_class = "calciata";
		t.name_taxonomic_order = "rattlers";
		t.name_taxonomic_family = "osteus";
		t.name_taxonomic_genus = "bonelords";
		t.name_taxonomic_species = "calcius";
		t.addSubspeciesNamePrefix("calcius");
		t.addSubspeciesNamePrefix("bonelords");
		t.addSubspeciesNamePrefix("boney");
		t.addGenome(("health", 100f), ("damage", 10f), ("speed", 10f), ("stamina", 100f), ("lifespan", 100f));
		t.base_stats["mass_2"] = 15f;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("bow_bronze", "bow_steel", "bow_iron", "sword_steel", "spear_steel", "sword_iron");
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.addDecision("attack_golden_brain");
		t.die_from_dispel = true;
		addTrait("weightless");
		addTrait("backstep");
		addTrait("dodge");
		addTrait("dash");
		addTrait("block");
		t.music_theme = "Units_Skeleton";
		t.sound_hit = "event:/SFX/HIT/HitBone";
		t.can_be_surprised = false;
		t.addResource("bones", 2, pNewList: true);
		clone("jumpy_skull", "$mob$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("jumpy_skull_set");
		t.kingdom_id_wild = "jumpy_skull";
		t.kingdom_id_civilization = "miniciv_jumpy_skull";
		t.architecture_id = "civ_necromancer";
		t.banner_id = "civ_necromancer";
		t.addSubspeciesTrait("reproduction_soulborne");
		t.addSubspeciesTrait("aggressive");
		t.addSubspeciesTrait("population_small");
		addPhenotype("white_gray");
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "infernalia";
		t.name_taxonomic_class = "daemonica";
		t.name_taxonomic_order = "skullus";
		t.name_taxonomic_family = "hoppidae";
		t.name_taxonomic_genus = "chere";
		t.name_taxonomic_species = "pushka";
		t.collective_term = "group_stack";
		t.base_stats["mass_2"] = 3.5f;
		t.addDecision("check_swearing");
		t.addGenome(("health", 1f), ("lifespan", 500f), ("damage", 10f), ("speed", 5f));
		t.unit_other = true;
		t.name_locale = "Rude Skull";
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_ice_one = false;
		t.body_separate_part_hands = false;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.has_skin = false;
		t.can_be_killed_by_divine_light = true;
		t.die_from_dispel = true;
		t.icon = "iconJumpySkull";
		t.color_hex = "#ffffff";
		t.disable_jump_animation = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.max_random_amount = 4;
		addTrait("weightless");
		addTrait("block");
		addTrait("paranoid");
		addTrait("hotheaded");
		t.actor_size = ActorSize.S7_Cat;
		t.music_theme = "Units_Skeleton";
		t.sound_hit = "event:/SFX/HIT/HitBone";
		t.addResource("bones", 2, pNewList: true);
		clone("fire_elemental", "$mob$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fire_elemental_set");
		t.use_phenotypes = false;
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "infernalia";
		t.name_taxonomic_class = "daemonica";
		t.name_taxonomic_order = "elementales";
		t.name_taxonomic_family = "ignisidae";
		t.name_taxonomic_genus = "ignis";
		t.name_taxonomic_species = "blazarus";
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
		t.collective_term = "group_blaze";
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTrait("fire_elemental_form");
		t.addSubspeciesTrait("fenix_born");
		t.addSubspeciesTrait("egg_flames");
		t.addSubspeciesTrait("gestation_long");
		t.addSubspeciesTrait("rapid_aging");
		t.addSubspeciesTrait("reproduction_soulborne");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addCultureTrait("matriarchy");
		t.addLanguageTrait("scorching_words");
		t.base_stats["mass_2"] = 50f;
		t.addGenome(("health", 5f), ("lifespan", 450f), ("damage", 10f), ("speed", 10f));
		t.unit_other = true;
		t.name_locale = "Fire Elemental";
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.can_turn_into_tumor = false;
		t.body_separate_part_hands = false;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.use_items = false;
		t.take_items = false;
		t.can_edit_equipment = false;
		t.has_skin = false;
		t.has_soul = false;
		t.die_from_dispel = true;
		t.kingdom_id_wild = "fire_elemental";
		t.architecture_id = "civ_demon";
		t.banner_id = "civ_demon";
		t.die_in_lava = false;
		t.default_attack = "fire_hands";
		t.allowed_status_tiers = StatusTier.Basic;
		t.icon = "iconFireElemental";
		t.color_hex = "#ff0000";
		t.disable_jump_animation = true;
		t.animation_idle = ActorAnimationSequences.idle_0_3;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.walk_0_3;
		t.shadow = false;
		t.max_random_amount = 4;
		addTrait("weightless");
		addTrait("light_lamp");
		addTrait("fire_proof");
		addTrait("fire_blood");
		addTrait("burning_feet");
		t.music_theme = "Units_Skeleton";
		t.sound_hit = null;
		t.sound_spawn = null;
		t.sound_attack = null;
		t.sound_idle = null;
		t.sound_death = null;
		t.generateFmodPaths("fire_elemental");
		t.addResource("peppers", 1, pNewList: true);
		clone("fire_elemental_blob", "fire_elemental");
		t.base_asset_id = "fire_elemental";
		t.show_in_taxonomy_tooltip = false;
		t.show_in_knowledge_window = false;
		t.base_stats["speed"] = 3f;
		t.base_stats["mass_2"] = 66f;
		clone("fire_elemental_horse", "fire_elemental");
		t.base_asset_id = "fire_elemental";
		t.show_in_taxonomy_tooltip = false;
		t.show_in_knowledge_window = false;
		t.base_stats["speed"] = 20f;
		t.base_stats["mass_2"] = 450f;
		clone("fire_elemental_slug", "fire_elemental");
		t.base_asset_id = "fire_elemental";
		t.show_in_taxonomy_tooltip = false;
		t.show_in_knowledge_window = false;
		t.prevent_unconscious_rotation = true;
		t.base_stats["speed"] = 2f;
		t.base_stats["mass_2"] = 30f;
		clone("fire_elemental_snake", "fire_elemental");
		t.base_asset_id = "fire_elemental";
		t.show_in_taxonomy_tooltip = false;
		t.show_in_knowledge_window = false;
		t.base_stats["speed"] = 5f;
		t.base_stats["mass_2"] = 15f;
		clone("ghost", "$mob$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("necromancer_set");
		t.use_phenotypes = false;
		t.unit_other = true;
		t.name_locale = "Ghost";
		t.body_separate_part_hands = false;
		t.has_advanced_textures = true;
		t.has_baby_form = false;
		t.has_skin = false;
		t.shadow = false;
		t.can_turn_into_zombie = false;
		t.kingdom_id_wild = "undead";
		t.kingdom_id_civilization = "civ_ghost";
		t.can_be_killed_by_divine_light = true;
		t.base_stats["mass_2"] = 0f;
		t.addGenome(("health", 200f), ("damage", 10f), ("speed", 15f), ("lifespan", 1000f));
		t.icon = "iconGhost";
		t.color_hex = "#ffffff";
		t.job = AssetLibrary<ActorAsset>.a<string>("skeleton_job");
		t.disable_jump_animation = true;
		t.animation_idle = ActorAnimationSequences.walk_0_3;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.max_random_amount = 1;
		t.can_turn_into_mush = false;
		t.mush_id = string.Empty;
		t.can_turn_into_tumor = false;
		t.tumor_id = string.Empty;
		t.has_skin = false;
		t.immune_to_injuries = true;
		t.die_on_blocks = false;
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.prevent_unconscious_rotation = true;
		t.architecture_id = "civ_ghost";
		t.banner_id = "civ_ghost";
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "otherworldlia";
		t.name_taxonomic_class = "ectoplasmica";
		t.name_taxonomic_order = "soulus";
		t.name_taxonomic_family = "transparencia";
		t.name_taxonomic_genus = "spectrum";
		t.name_taxonomic_species = "umbra";
		t.collective_term = "group_cloud";
		addTrait("weightless");
		addTrait("fire_proof");
		addTrait("freeze_proof");
		t.addLanguageTrait("spooky_language");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("hovering");
		t.addSubspeciesTrait("reproduction_soulborne");
		t.resources_given = null;
		clone("fire_skull", "$mob$");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fire_skull_set");
		t.kingdom_id_wild = "fire_skull";
		t.kingdom_id_civilization = "miniciv_fire_skull";
		t.architecture_id = "civ_demon";
		t.banner_id = "civ_demon";
		t.build_order_template_id = "build_order_basic_2";
		t.use_phenotypes = false;
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "infernalia";
		t.name_taxonomic_class = "daemonica";
		t.name_taxonomic_order = "skullus";
		t.name_taxonomic_family = "pyropidae";
		t.name_taxonomic_genus = "gorit";
		t.name_taxonomic_species = "dumkus";
		t.collective_term = "group_stack";
		t.addLanguageTrait("scorching_words");
		t.addSubspeciesTrait("reproduction_soulborne");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("adaptation_infernal");
		t.addSubspeciesTrait("egg_flames");
		t.base_stats["mass_2"] = 3.5f;
		t.addGenome(("health", 5f), ("damage", 15f), ("speed", 5f));
		t.unit_other = true;
		t.name_locale = "Fire Skull";
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.body_separate_part_hands = false;
		t.has_advanced_textures = false;
		t.has_baby_form = false;
		t.has_skin = false;
		t.icon = "iconFireSkull";
		t.color_hex = "#EE3A42";
		t.disable_jump_animation = true;
		t.animation_idle = ActorAnimationSequences.walk_0_3;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.max_random_amount = 4;
		addTrait("evil");
		addTrait("weightless");
		addTrait("fire_blood");
		addTrait("fire_proof");
		t.addResource("peppers", 1, pNewList: true);
		t.addResource("bones", 2);
		clone("demon", "$mob$");
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("demon_set");
		t.kingdom_id_wild = "demon";
		t.kingdom_id_civilization = "miniciv_demon";
		t.architecture_id = "civ_demon";
		t.banner_id = "civ_demon";
		t.build_order_template_id = "build_order_basic_2";
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("reproduction_soulborne");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("egg_flames");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("spicy_kids");
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTrait("chaos_driven");
		t.addSubspeciesTrait("adaptation_infernal");
		t.addSubspeciesTrait("diet_hematophagy");
		t.addSubspeciesTrait("circadian_drift");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("happiness_from_war");
		t.addCultureTrait("craft_flame_weapon");
		t.addLanguageTrait("scorching_words");
		t.addReligionTrait("rite_of_the_abyss");
		t.addReligionTrait("rite_of_infernal_wrath");
		t.addReligionTrait("infernal_rot");
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "infernalia";
		t.name_taxonomic_class = "daemonica";
		t.name_taxonomic_order = "diabolus";
		t.name_taxonomic_family = "maleficidae";
		t.name_taxonomic_genus = "daemorior";
		t.name_taxonomic_species = "maleficus";
		t.setSocialStructure("group_blaze", 40, pCreateOnSpawn: true, pFollowHerd: true, FamilyParentsMode.None);
		t.base_stats["mass_2"] = 66.6f;
		t.addGenome(("health", 200f), ("stamina", 150f), ("mutation", 2f), ("lifespan", 1000f), ("damage", 35f), ("speed", 15f), ("armor", 10f), ("offspring", 6f));
		t.unit_other = true;
		t.name_locale = "Demon";
		t.body_separate_part_hands = true;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("flame_sword");
		t.can_be_killed_by_divine_light = true;
		t.die_in_lava = false;
		t.icon = "iconDemon";
		t.color_hex = "#EE3A42";
		t.skeleton_id = "skeleton";
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.disable_jump_animation = true;
		t.addDecision("attack_golden_brain");
		t.actor_size = ActorSize.S14_Cow;
		addPhenotype("skin_red");
		addTrait("regeneration");
		addTrait("burning_feet");
		addTrait("fire_blood");
		addTrait("evil");
		t.music_theme = "Units_Demon";
		t.addResource("bones", 1, pNewList: true);
		t.addResource("peppers", 2);
		t.addResource("meat", 1);
		clone("angle", "$mob$");
		t.setUnlockedWithAchievement("achievementAncientWarOfGeometryAndEvil");
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("angle_set");
		t.kingdom_id_wild = "angle";
		t.kingdom_id_civilization = "miniciv_angle";
		t.architecture_id = "civ_angle";
		t.banner_id = "civ_angle";
		t.build_order_template_id = "build_order_basic_2";
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTrait("egg_orb");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("reproduction_divine");
		t.addSubspeciesTrait("pure");
		t.addSubspeciesTrait("gift_of_harmony");
		t.addSubspeciesTrait("hovering");
		t.addClanTrait("gods_chosen");
		t.addClanTrait("iron_will");
		t.addCultureTrait("city_layout_cross");
		t.addCultureTrait("xenophiles");
		t.addCultureTrait("fames_crown");
		t.addLanguageTrait("font_of_gods");
		t.addLanguageTrait("repeated_sentences");
		t.addLanguageTrait("eternal_text");
		t.addReligionTrait("rite_of_infinite_edges");
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "mathematica";
		t.name_taxonomic_class = "geometrica";
		t.name_taxonomic_order = "polygones";
		t.name_taxonomic_family = "holidae";
		t.name_taxonomic_genus = "anglo";
		t.name_taxonomic_species = "holliens";
		t.setSocialStructure("group_polygon", 40, pCreateOnSpawn: true, pFollowHerd: true, FamilyParentsMode.None);
		t.base_stats["mass_2"] = 7.77f;
		t.addGenome(("health", 200f), ("stamina", 200f), ("mutation", 2f), ("lifespan", 1000f), ("damage", 35f), ("speed", 15f), ("armor", 10f), ("offspring", 7f));
		t.unit_other = true;
		t.name_locale = "Angle";
		t.body_separate_part_hands = true;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("ice_hammer");
		t.die_in_lava = false;
		t.icon = "iconAngle";
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.color_hex = "#EE3A42";
		t.animation_idle = ActorAnimationSequences.walk_0_4;
		t.animation_walk = ActorAnimationSequences.walk_0_4;
		t.animation_swim = null;
		t.disable_jump_animation = true;
		t.actor_size = ActorSize.S14_Cow;
		t.prevent_unconscious_rotation = true;
		addPhenotype("bright_yellow");
		addTrait("regeneration");
		addTrait("blessed");
		addTrait("light_lamp");
		addTrait("psychopath");
		t.music_theme = "Units_Demon";
		t.can_be_surprised = false;
		clone("fairy", "$peaceful_animal$");
		t.needs_to_be_explored = true;
		t.has_advanced_textures = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fairy_set");
		t.kingdom_id_wild = "fairy";
		t.kingdom_id_civilization = "miniciv_fairy";
		t.architecture_id = "civ_fairy";
		t.banner_id = "civ_fairy";
		t.addSubspeciesTrait("gift_of_life");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTrait("hyper_intelligence");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("diet_frugivore");
		t.addSubspeciesTrait("diet_florivore");
		t.addSubspeciesTrait("bioproduct_gold");
		t.addSubspeciesTrait("egg_rainbow");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("metamorphosis_butterfly");
		t.addSubspeciesTrait("death_grow_plant");
		t.addSubspeciesTrait("gift_of_harmony");
		t.addSubspeciesTrait("gift_of_thunder");
		t.addSubspeciesTrait("hovering");
		t.addCultureTrait("ultimogeniture");
		t.addCultureTrait("tiny_legends");
		t.addCultureTrait("fames_crown");
		t.addReligionTrait("cast_cure");
		t.addLanguageTrait("melodic");
		t.addClanTrait("magic_blood");
		t.name_taxonomic_kingdom = "mythoria";
		t.name_taxonomic_phylum = "arthropoda";
		t.name_taxonomic_class = "insecta";
		t.name_taxonomic_order = "diptera";
		t.name_taxonomic_family = "fabulidae";
		t.name_taxonomic_genus = "faerina";
		t.name_taxonomic_species = "glitterbug";
		t.collective_term = "group_flutter";
		addPhenotype("bright_pink");
		t.base_stats["mass_2"] = 0.01f;
		t.addGenome(("health", 40f), ("stamina", 100f), ("lifespan", 300f), ("mutation", 2f), ("damage", 8f), ("speed", 15f), ("armor", 2f), ("offspring", 5f));
		t.unit_other = true;
		t.default_animal = false;
		t.name_locale = "Fairy";
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_idle = ActorAnimationSequences.walk_0_3;
		t.animation_swim = null;
		t.source_meat = false;
		t.source_meat_insect = false;
		t.actor_size = ActorSize.S3_Rat;
		t.shadow_texture = "unitShadow_2";
		t.icon = "iconFairy";
		t.color_hex = "#23F3FF";
		t.disable_jump_animation = true;
		t.has_soul = true;
		t.move_from_block = true;
		t.die_on_blocks = false;
		t.prevent_unconscious_rotation = true;
		t.animation_speed_based_on_walk_speed = false;
		addTrait("weightless");
		addTrait("healing_aura");
		addTrait("immune");
		addTrait("light_lamp");
		addTrait("moonchild");
		t.music_theme = "Units_Fairy";
		clone("bandit", "$mob$");
		t.render_heads_for_babies = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bandit_set");
		t.is_humanoid = true;
		t.architecture_id = "civ_bandit";
		t.kingdom_id_wild = "bandit";
		t.kingdom_id_civilization = "miniciv_bandit";
		t.banner_id = "civ_bandit";
		t.addSubspeciesTrait("reproduction_sexual");
		t.addSubspeciesTrait("reproduction_strategy_viviparity");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("nimble");
		t.addSubspeciesTrait("shiny_love");
		t.addSubspeciesTrait("circadian_drift");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("stomach");
		t.addCultureTrait("join_or_die");
		t.addCultureTrait("fames_crown");
		t.addClanTrait("nitroglycerin_blood");
		t.addClanTrait("combat_instincts");
		t.addReligionTrait("rite_of_dissent");
		t.cloneTaxonomyFromForSapiens("raccoon");
		t.name_taxonomic_genus = "banditus";
		t.name_taxonomic_species = "nikonis";
		t.collective_term = "group_gang";
		t.base_stats["mass_2"] = 67f;
		t.addGenome(("health", 100f), ("stamina", 100f), ("lifespan", 60f), ("mutation", 2f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 6f), ("stewardship", 3f), ("intelligence", 4f));
		t.unit_other = true;
		t.name_locale = "Bandit";
		t.body_separate_part_hands = true;
		t.kingdom_id_wild = "bandit";
		t.icon = "iconBandit";
		t.color_hex = "#4A3F35";
		t.skeleton_id = "skeleton";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("spear_bronze", "spear_steel", "spear_iron", "sword_bronze", "sword_steel", "sword_iron", "bow_bronze", "bow_steel", "bow_iron");
		t.has_soul = true;
		addPhenotype("skin_mixed");
		addTrait("bomberman");
		addTrait("thief");
		t.disable_jump_animation = true;
		t.music_theme = "Units_Bandits";
		t.addResource("cider", 1);
		clone("snowman", "$mob$");
		t.render_heads_for_babies = true;
		t.needs_to_be_explored = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snowman_set");
		t.kingdom_id_wild = "snowman";
		t.kingdom_id_civilization = "miniciv_snowman";
		t.architecture_id = "civ_snowman";
		t.banner_id = "civ_snowman";
		t.build_order_template_id = "build_order_basic_2";
		addPhenotype("white_gray");
		t.addSubspeciesTrait("reproduction_fission");
		t.addSubspeciesTrait("genetic_mirror");
		t.addSubspeciesTrait("egg_ice");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("genetic_psychosis");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTrait("good_throwers");
		t.addSubspeciesTrait("adaptation_permafrost");
		t.addLanguageTrait("chilly_font");
		t.addCultureTrait("solitude_seekers");
		t.addReligionTrait("hand_of_order");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "cnidaria";
		t.name_taxonomic_class = "anthozoa";
		t.name_taxonomic_order = "cryonata";
		t.name_taxonomic_family = "niveidae";
		t.name_taxonomic_genus = "snowda";
		t.name_taxonomic_species = "frosti";
		t.collective_term = "group_melt";
		t.base_stats["mass_2"] = 67f;
		t.addGenome(("health", 100f), ("stamina", 50f), ("lifespan", 60f), ("mutation", 5f), ("damage", 10f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 2f), ("warfare", 2f), ("stewardship", 2f), ("intelligence", 2f));
		t.unit_other = true;
		t.name_locale = "Snowman";
		t.default_attack = "snowball";
		t.icon = "iconSnowman";
		t.color_hex = "#FFFFFF";
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		addTrait("heliophobia");
		addTrait("regeneration");
		addTrait("cold_aura");
		addTrait("fat");
		addTrait("freeze_proof");
		t.disable_jump_animation = true;
		t.music_theme = "Units_Snowman";
		t.addResource("pine_cones", 1, pNewList: true);
		clone("alien", "$mob$");
		t.render_heads_for_babies = true;
		t.needs_to_be_explored = true;
		t.is_humanoid = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alien_set");
		t.architecture_id = "civ_alien";
		t.kingdom_id_wild = "aliens";
		t.kingdom_id_civilization = "civ_aliens";
		t.banner_id = "civ_alien";
		t.build_order_template_id = "build_order_basic_2";
		addPhenotype("bright_green");
		t.addSubspeciesTrait("prefrontal_cortex");
		t.addSubspeciesTrait("advanced_hippocampus");
		t.addSubspeciesTrait("amygdala");
		t.addSubspeciesTrait("wernicke_area");
		t.addSubspeciesTrait("stomach");
		t.addSubspeciesTrait("diet_omnivore");
		t.addSubspeciesTrait("accelerated_healing");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTrait("fins");
		t.addSubspeciesTrait("hyper_intelligence");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTrait("egg_alien");
		t.addSubspeciesTrait("reproduction_strategy_oviparity");
		t.addSubspeciesTrait("reproduction_sexual");
		t.addClanTrait("best_five");
		t.addCultureTrait("city_layout_tile_moonsteps");
		t.addCultureTrait("city_layout_iron_weave");
		t.addCultureTrait("craft_blaster");
		t.addReligionTrait("rite_of_fractured_minds");
		t.addReligionTrait("minds_awakening");
		t.name_taxonomic_kingdom = "animalia";
		t.name_taxonomic_phylum = "tardigrada";
		t.name_taxonomic_class = "eutardigrada";
		t.name_taxonomic_order = "apochela";
		t.name_taxonomic_family = "milnesiidae";
		t.name_taxonomic_genus = "abugus";
		t.name_taxonomic_species = "abobicus";
		t.collective_term = "group_topology";
		t.addGenome(("health", 200f), ("stamina", 150f), ("lifespan", 60f), ("mutation", 2f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 7f), ("warfare", 7f), ("stewardship", 7f), ("intelligence", 7f));
		t.unit_other = true;
		t.body_separate_part_hands = true;
		t.name_locale = "Alien";
		t.base_stats["lifespan"] = 1000f;
		t.base_stats["mass_2"] = 32.5f;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("alien_blaster");
		t.icon = "iconAlien";
		t.color_hex = "#00FF00";
		t.can_turn_into_tumor = true;
		t.can_turn_into_mush = true;
		t.mush_id = "mush_unit";
		t.tumor_id = "tumor_monster_unit";
		t.has_soul = true;
		t.family_banner_frame_generation_inclusion = "families/frame_11";
		t.family_banner_frame_only_inclusion = true;
		addTrait("regeneration");
		addTrait("fat");
		addTrait("acid_blood");
		addTrait("acid_proof");
		addTrait("strong_minded");
		t.disable_jump_animation = true;
	}

	private void initTemplates()
	{
		ActorAsset obj = new ActorAsset
		{
			id = "$basic_unit$"
		};
		ActorAsset pAsset = obj;
		t = obj;
		add(pAsset);
		t.base_stats["attack_speed"] = 1f;
		t.base_stats["accuracy"] = 1f;
		t.base_stats["mass"] = 1f;
		t.base_stats["knockback"] = 1.5f;
		t.base_stats["targets"] = 1f;
		t.base_stats["area_of_effect"] = 0.1f;
		t.base_stats["size"] = 0.5f;
		t.base_stats["range"] = 1f;
		t.base_stats["critical_damage_multiplier"] = 2f;
		t.base_stats["scale"] = 0.1f;
		t.base_stats["multiplier_supply_timer"] = 1f;
		t.base_throwing_range = 7f;
		t.affected_by_dust = true;
		t.needs_to_be_explored = false;
		t.job = AssetLibrary<ActorAsset>.a<string>("decision");
		clone("$basic_unit_colored$", "$basic_unit$");
		t.has_advanced_textures = true;
		t.has_baby_form = true;
		t.setSimpleCivSettings();
		t.kingdom_id_wild = "neutral_animals";
		t.can_edit_equipment = true;
		t.use_items = true;
		t.take_items = true;
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.need_colored_sprite = true;
		t.update_z = true;
		t.can_be_killed_by_stuff = true;
		t.can_be_killed_by_life_eraser = true;
		t.can_attack_buildings = true;
		t.can_be_moved_by_powers = true;
		t.can_be_hurt_by_powers = true;
		t.effect_damage = true;
		t.can_flip = true;
		t.death_animation_angle = true;
		t.can_be_inspected = true;
		t.can_have_subspecies = true;
		t.use_phenotypes = true;
		t.addResource("meat", 1);
		t.addResource("bones", 1);
		clone("$animal_base$", "$basic_unit_colored$");
		t.build_order_template_id = "build_order_basic";
		t.has_advanced_textures = false;
		t.default_animal = true;
		clone("$animal_fur$", "$animal_base$");
		addPhenotype("savanna", "biome_savanna");
		addPhenotype("dark_teal", "biome_crystal");
		addPhenotype("dark_blue", "biome_crystal");
		addPhenotype("dark_orange", "biome_savanna");
		addPhenotype("swamp", "biome_swamp");
		addPhenotype("skin_blue", "biome_swamp");
		addPhenotype("corrupted", "biome_corrupted");
		addPhenotype("desert", "biome_desert");
		addPhenotype("skin_yellow", "biome_desert");
		addPhenotype("dark_yellow", "biome_desert");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("lemon", "biome_lemon");
		addPhenotype("pink_yellow_mushroom", "biome_mushroom");
		addPhenotype("dark_orange", "biome_sand");
		addPhenotype("wood", "biome_sand");
		addPhenotype("bright_violet", "biome_singularity");
		addPhenotype("mid_gray", "biome_garlic");
		addPhenotype("dark_orange", "biome_maple");
		addPhenotype("polar", "biome_permafrost");
		addPhenotype("gray_black", "biome_rocklands");
		addPhenotype("bright_purple", "biome_celestial");
		addPhenotype("magical", "biome_celestial");
		addPhenotype("magical", "biome_mushroom");
		addPhenotype("dark_purple", "biome_mushroom");
		addPhenotype("skin_pink", "biome_candy");
		addPhenotype("dark_pink", "biome_candy");
		clone("$animal_skin$", "$animal_base$");
		addPhenotype("corrupted", "biome_corrupted");
		addPhenotype("infernal", "biome_infernal");
		addPhenotype("lemon", "biome_lemon");
		clone("$civ_unit$", "$basic_unit_colored$");
		t.render_heads_for_babies = true;
		t.chromosomes_first = AssetLibrary<ActorAsset>.l<string>("chromosome_big", "chromosome_medium");
		t.setCanTurnIntoZombieAsset("zombie", pAutoZombieAsset: true);
		t.addSubspeciesTrait("prefrontal_cortex");
		t.genome_size = 20;
		t.civ = true;
		t.actor_size = ActorSize.S13_Human;
		t.inspect_home = true;
		t.body_separate_part_hands = true;
		t.has_soul = true;
		t.setSocialStructure("group_family", 10, pCreateOnSpawn: true, pFollowHerd: false, FamilyParentsMode.Normal);
		t.name_taxonomic_species = "sapiens";
		t.civ_base_cities = 5;
		t.can_turn_into_demon_in_age_of_chaos = true;
		t.can_turn_into_mush = true;
		t.can_turn_into_ice_one = true;
		t.mush_id = "mush_unit";
		t.can_turn_into_tumor = true;
		t.tumor_id = "tumor_monster_unit";
		t.animation_walk = ActorAnimationSequences.walk_0_3;
		t.animation_swim = ActorAnimationSequences.swim_0_3;
		t.default_attack = "hands";
		t.skeleton_id = "skeleton";
		t.disable_jump_animation = true;
		t.needs_to_be_explored = false;
		clone("$civ_advanced_unit$", "$civ_unit$");
		t.skin_citizen_male = AssetLibrary<ActorAsset>.a<string>("male_1", "male_2", "male_3", "male_4", "male_5", "male_6", "male_7", "male_8", "male_9", "male_10");
		t.skin_citizen_female = AssetLibrary<ActorAsset>.a<string>("female_1", "female_2", "female_3", "female_4", "female_5", "female_6", "female_7", "female_8", "female_9", "female_10");
		t.skin_warrior = AssetLibrary<ActorAsset>.a<string>("warrior_1", "warrior_2", "warrior_3", "warrior_4", "warrior_5", "warrior_6", "warrior_7", "warrior_8", "warrior_9", "warrior_10");
		t.is_humanoid = true;
		clone("$mob_no_genes$", "$basic_unit_colored$");
		t.inspect_children = false;
		t.default_attack = "base_attack";
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		t.disable_jump_animation = true;
		t.can_have_subspecies = false;
		clone("$mob$", "$basic_unit_colored$");
		t.default_attack = "base_attack";
		t.can_have_subspecies = true;
		t.disable_jump_animation = true;
		t.can_turn_into_mush = true;
		t.can_turn_into_ice_one = true;
		t.mush_id = "mush_unit";
		t.can_turn_into_tumor = true;
		t.tumor_id = "tumor_monster_unit";
		t.setCanTurnIntoZombieAsset("zombie", pAutoZombieAsset: true);
		clone("$animal$", "$animal_base$");
		t.setCanTurnIntoZombieAsset("zombie_animal", pAutoZombieAsset: true);
		t.can_turn_into_mush = true;
		t.mush_id = "mush_animal";
		t.can_turn_into_tumor = true;
		t.tumor_id = "tumor_monster_animal";
		t.source_meat = true;
		t.default_attack = "jaws";
		clone("$peaceful_animal$", "$animal_base$");
		t.setCanTurnIntoZombieAsset("zombie_animal", pAutoZombieAsset: true);
		t.can_turn_into_mush = true;
		t.mush_id = "mush_animal";
		t.can_turn_into_tumor = true;
		t.tumor_id = "tumor_monster_animal";
		t.base_stats["damage"] = 1f;
		addTrait("peaceful");
		clone("$carnivore$", "$animal$");
		t.addSubspeciesTrait("diet_carnivore");
		clone("$herbivore$", "$animal_base$");
		t.can_turn_into_mush = true;
		t.mush_id = "mush_animal";
		t.setCanTurnIntoZombieAsset("zombie_animal", pAutoZombieAsset: true);
		t.addSubspeciesTrait("diet_herbivore");
		clone("$omnivore$", "$animal$");
		t.addSubspeciesTrait("diet_omnivore");
		clone("$insect$", "$animal_base$");
		t.chromosomes_first = AssetLibrary<ActorAsset>.l<string>("chromosome_tiny");
		t.has_baby_form = false;
		t.has_advanced_textures = false;
		t.setCanTurnIntoZombieAsset("zombie", pAutoZombieAsset: true);
		t.kingdom_id_wild = "insect";
		t.kingdom_id_civilization = "miniciv_insect";
		t.source_meat_insect = true;
		t.actor_size = ActorSize.S0_Bug;
		t.shadow_texture = "unitShadow_2";
		t.color_hex = "#23F3FF";
		t.animation_idle = ActorAnimationSequences.walk_0_2;
		t.animation_walk = ActorAnimationSequences.walk_0_2;
		t.animation_swim = null;
		t.base_stats["speed"] = 5f;
		t.base_stats["health"] = 1f;
		t.base_stats["damage"] = 1f;
		t.base_stats["mass_2"] = 0.015f;
		addTrait("peaceful");
		t.max_random_amount = 5;
		t.addResource("jam", 1, pNewList: true);
		clone("$flying_insect$", "$insect$");
		t.animation_idle = ActorAnimationSequences.walk_0_1;
		t.animation_walk = ActorAnimationSequences.walk_0_1;
		t.animation_swim = null;
		t.disable_jump_animation = true;
		t.move_from_block = true;
		addTrait("weightless");
		t.addSubspeciesTrait("hovering");
		clone("$animal_civ$", "$civ_unit$");
		t.render_heads_for_babies = true;
		t.name_locale = "Greg";
		t.icon = "iconHumans";
		t.setCanTurnIntoZombieAsset("zombie", pAutoZombieAsset: true);
		t.color_hex = "#005E72";
		t.disable_jump_animation = true;
		t.addGenome(("diplomacy", 3f), ("warfare", 3f), ("stewardship", 3f), ("intelligence", 3f));
		t.needs_to_be_explored = true;
		t.is_humanoid = true;
	}
}
// --- End of File: ActorAssetLibrary.cs ---



// --- Start of File: ActorAssetWindow.cs ---
using System.Collections.Generic;
using UnityEngine;

public class ActorAssetWindow : BaseDebugAssetWindow<ActorAsset, ActorDebugAssetElement>
{
	public void clickRandomKingdomColor()
	{
		AssetsDebugManager.setRandomKingdomColor(asset.kingdom_id_wild);
		asset_debug_element.setData(asset);
	}

	public void clickRandomSkinColor()
	{
		AssetsDebugManager.setRandomSkinColor(asset);
		asset_debug_element.setData(asset);
	}

	public void clickChangeSex()
	{
		AssetsDebugManager.changeSex();
		asset_debug_element.setData(asset);
	}

	protected override void initSprites()
	{
		base.initSprites();
		string pPath = asset.texture_asset.texture_path_base;
		if (new List<string> { "dragon", "zombie_dragon", "worm" }.Contains(asset.id))
		{
			pPath = "actors_special/t_" + asset.id;
		}
		if (asset.is_boat)
		{
			pPath = "actors/boats/" + asset.id;
		}
		switch (asset.id)
		{
		case "UFO":
			pPath = "actors/special/t_ufo";
			break;
		case "crabzilla":
			pPath = "actors/special/crab";
			break;
		case "god_finger":
			pPath = "actors/species/other/god_finger";
			break;
		}
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pPath);
		foreach (Sprite val in spriteList)
		{
			SpriteElement spriteElement = Object.Instantiate<SpriteElement>(sprite_element_prefab, sprite_elements_parent);
			spriteElement.image.sprite = val;
			spriteElement.text_name.text = ((Object)val).name;
		}
	}
}
// --- End of File: ActorAssetWindow.cs ---



// --- Start of File: ActorAvatar.cs ---
using UnityEngine;

public class ActorAvatar : MonoBehaviour
{
	public Dragon dragon;

	public Boat boat;

	public UFO ufo;

	public Crabzilla crabzilla;

	public GodFinger god_finger;

	public SpriteAnimation sprite_animation;
}
// --- End of File: ActorAvatar.cs ---



// --- Start of File: ActorAvatarData.cs ---
using System.Collections.Generic;
using UnityEngine;

public class ActorAvatarData
{
	public ActorAsset asset;

	public SubspeciesTrait mutation_skin_asset;

	public ActorSex sex;

	public Sprite sprite_head;

	public int head_id;

	public long actor_id;

	public int phenotype_index;

	public int phenotype_skin_shade;

	public ColorAsset kingdom_color;

	public bool is_egg;

	public bool is_king;

	public bool is_warrior;

	public bool is_wise;

	public SubspeciesTrait egg_asset;

	public bool is_adult;

	public bool is_lying;

	public bool is_touching_liquid;

	public bool is_inside_boat;

	public bool is_hovering;

	public bool is_immovable;

	public bool is_unconscious;

	public bool is_stop_idle_animation;

	public IHandRenderer item_renderer;

	public int actor_hash;

	public IEnumerable<string> statuses;

	public IReadOnlyDictionary<string, Status> statuses_gameplay;

	public void setData(Actor pActor)
	{
		ActorAsset actorAsset = pActor.getActorAsset();
		ActorData data = pActor.data;
		setData(actorAsset, pActor.subspecies?.mutation_skin_asset, data.sex, data.id, data.head, pActor.cached_sprite_head, data.phenotype_index, data.phenotype_shade, pActor.kingdom.getColor(), pActor.isEgg(), pActor.isKing(), pActor.isWarrior() && !pActor.equipment.helmet.isEmpty(), pActor.hasTrait("wise"), pActor.subspecies?.egg_asset, pActor.isAdult(), !actorAsset.prevent_unconscious_rotation && pActor.isLying(), pActor.isTouchingLiquid(), pActor.is_inside_boat, pActor.isHovering(), pActor.isImmovable(), !actorAsset.prevent_unconscious_rotation && pActor.is_unconscious, pActor.hasStopIdleAnimation(), pActor.getHandRendererAsset(), pActor.GetHashCode(), pActor.getStatusesIds(), pActor.getStatusesDict());
	}

	public void setData(ActorAsset pAsset, SubspeciesTrait pMutation, ActorSex pSex, long pActorId, int pHeadId, Sprite pSpriteHead, int pPhenotypeIndex, int pPhenotypeSkinShade, ColorAsset pKingdomColor, bool pIsEgg, bool pIsKing, bool pIsWarrior, bool pIsWise, SubspeciesTrait pEggAsset, bool pIsAdult, bool pIsLying, bool pIsTouchingLiquid, bool pIsInsideBoat, bool pIsHovering, bool pIsImmovable, bool pIsUnconscious, bool pIsStopIdleAnimation, IHandRenderer pItemPath, int pActorHash, IEnumerable<string> pStatuses, IReadOnlyDictionary<string, Status> pGameplayStatuses)
	{
		asset = pAsset;
		mutation_skin_asset = pMutation;
		sex = pSex;
		sprite_head = pSpriteHead;
		actor_id = pActorId;
		head_id = pHeadId;
		phenotype_index = pPhenotypeIndex;
		phenotype_skin_shade = pPhenotypeSkinShade;
		kingdom_color = pKingdomColor;
		is_egg = pIsEgg;
		is_king = pIsKing;
		is_warrior = pIsWarrior;
		is_wise = pIsWise;
		egg_asset = pEggAsset;
		is_adult = pIsAdult;
		is_lying = pIsLying;
		is_touching_liquid = pIsTouchingLiquid;
		is_inside_boat = pIsInsideBoat;
		is_hovering = pIsHovering;
		is_immovable = pIsImmovable;
		is_unconscious = pIsUnconscious;
		is_stop_idle_animation = pIsStopIdleAnimation;
		item_renderer = pItemPath;
		actor_hash = pActorHash;
		statuses = pStatuses;
		statuses_gameplay = pGameplayStatuses;
	}

	public ActorTextureSubAsset getTextureAsset()
	{
		if (mutation_skin_asset != null)
		{
			return mutation_skin_asset.texture_asset;
		}
		return asset.texture_asset;
	}

	public Sprite getColoredSprite(Sprite pSprite, AnimationContainerUnit pContainer)
	{
		return DynamicActorSpriteCreatorUI.getUnitSpriteForUI(asset, pSprite, pContainer, is_adult, sex, phenotype_index, phenotype_skin_shade, kingdom_color, actor_id, head_id, is_egg, is_king, is_warrior, is_wise);
	}

	public bool hasRenderedSpriteHead()
	{
		return (Object)(object)sprite_head != (Object)null;
	}
}
// --- End of File: ActorAvatarData.cs ---



// --- Start of File: ActorBag.cs ---
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

[Serializable]
public class ActorBag
{
	[JsonProperty]
	internal Dictionary<string, ResourceContainer> dict;

	[JsonProperty]
	internal string last_item_to_render;
}
// --- End of File: ActorBag.cs ---



// --- Start of File: ActorBagExtensions.cs ---
using System.Collections.Generic;

public static class ActorBagExtensions
{
	public static ActorBag add(this ActorBag pBag, ResourceContainer pResourceContainer)
	{
		return pBag.add(pResourceContainer.id, pResourceContainer.amount);
	}

	public static ActorBag add(this ActorBag pBag, string pID, int pAmount)
	{
		if (pBag == null)
		{
			pBag = new ActorBag();
		}
		if (pBag.dict == null)
		{
			pBag.dict = new Dictionary<string, ResourceContainer>();
		}
		if (pBag.dict.TryGetValue(pID, out var value))
		{
			value.amount += pAmount;
		}
		else
		{
			value = new ResourceContainer(pID, pAmount);
		}
		pBag.dict[pID] = value;
		pBag.last_item_to_render = null;
		return pBag;
	}

	public static ActorBag remove(this ActorBag pBag, string pID, int pAmount)
	{
		if (pBag.isEmpty())
		{
			return null;
		}
		if (pBag.dict.TryGetValue(pID, out var value))
		{
			value.amount -= pAmount;
			if (value.amount <= 0)
			{
				pBag.dict.Remove(pID);
			}
			else
			{
				pBag.dict[pID] = value;
			}
			pBag.last_item_to_render = null;
		}
		return pBag;
	}

	public static Dictionary<string, ResourceContainer> getResources(this ActorBag pBag)
	{
		return pBag.dict;
	}

	public static bool hasResources(this ActorBag pBag)
	{
		if (pBag == null)
		{
			return false;
		}
		return pBag.dict?.Count > 0;
	}

	public static bool isEmpty(this ActorBag pBag)
	{
		return !pBag.hasResources();
	}

	public static string getRandomResourceID(this ActorBag pBag)
	{
		if (pBag.isEmpty())
		{
			return string.Empty;
		}
		if (pBag.dict.Count == 0)
		{
			return string.Empty;
		}
		int num = Randy.randomInt(0, pBag.dict.Count);
		int num2 = 0;
		foreach (string key in pBag.dict.Keys)
		{
			if (num2 == num)
			{
				return key;
			}
			num2++;
		}
		return string.Empty;
	}

	public static int getResource(this ActorBag pBag, string pID)
	{
		if (pBag.isEmpty())
		{
			return 0;
		}
		if (pBag.dict.TryGetValue(pID, out var value))
		{
			return value.amount;
		}
		return 0;
	}

	public static void empty(this ActorBag pBag)
	{
		if (!pBag.isEmpty())
		{
			pBag.dict.Clear();
		}
		pBag = null;
	}

	public static string getItemIDToRender(this ActorBag pBag)
	{
		if (pBag.hasResources())
		{
			if (!string.IsNullOrEmpty(pBag.last_item_to_render))
			{
				return pBag.last_item_to_render;
			}
			using Dictionary<string, ResourceContainer>.ValueCollection.Enumerator enumerator = pBag.getResources().Values.GetEnumerator();
			if (enumerator.MoveNext())
			{
				pBag.last_item_to_render = enumerator.Current.id;
				return pBag.last_item_to_render;
			}
		}
		return string.Empty;
	}

	public static int countResources(this ActorBag pBag)
	{
		if (pBag.isEmpty())
		{
			return 0;
		}
		return pBag.dict.Count;
	}
}
// --- End of File: ActorBagExtensions.cs ---



// --- Start of File: ActorColorEffect.cs ---
public enum ActorColorEffect
{
	Red,
	White
}
// --- End of File: ActorColorEffect.cs ---



// --- Start of File: ActorContainer.cs ---
public class ActorContainer : ObjectContainer<Actor>
{
}
// --- End of File: ActorContainer.cs ---



// --- Start of File: ActorDamageEffectData.cs ---
public struct ActorDamageEffectData
{
	public Actor actor;

	public double timestamp;
}
// --- End of File: ActorDamageEffectData.cs ---



// --- Start of File: ActorData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public class ActorData : BaseObjectData
{
	public List<long> saved_items;

	[DefaultValue(null)]
	public ActorBag inventory;

	public int x;

	public int y;

	[DefaultValue(-1L)]
	public long transportID = -1L;

	[DefaultValue(-1L)]
	public long homeBuildingID = -1L;

	[DefaultValue(UnitProfession.Nothing)]
	public UnitProfession profession;

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public List<string> saved_traits;

	[DefaultValue(-1L)]
	public long cityID { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long civ_kingdom_id { get; set; } = -1L;


	[Preserve]
	[Obsolete("use .id instead", true)]
	public long actorID
	{
		set
		{
			if (value.hasValue() && !base.id.hasValue())
			{
				base.id = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .name instead", true)]
	public string firstName
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(base.name))
			{
				base.name = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .asset_id instead", true)]
	public string statsID
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(asset_id))
			{
				asset_id = value;
			}
		}
	}

	[DefaultValue("")]
	public string favorite_food { get; set; } = "";


	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(ActorSex.Male)]
	public ActorSex sex { get; set; }

	[DefaultValue(-1)]
	public int head { get; set; } = -1;


	[DefaultValue(-1L)]
	public long culture { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long clan { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long subspecies { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long language { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long plot { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long religion { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long family { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long army { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long lover { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long best_friend_id { get; set; } = -1L;


	[DefaultValue(0)]
	public int renown { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string asset_id { get; set; }

	[DefaultValue(0)]
	public int kills { get; set; }

	[DefaultValue(0)]
	public int food_consumed { get; set; }

	[DefaultValue(1)]
	public int age_overgrowth { get; set; } = 1;


	[DefaultValue(0)]
	public int births { get; set; }

	[DefaultValue(-1L)]
	public long parent_id_1 { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long parent_id_2 { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long ancestor_family { get; set; } = -1L;


	[DefaultValue(1)]
	public int generation { get; set; } = 1;


	[DefaultValue(0)]
	public int pollen { get; set; }

	[DefaultValue(0)]
	public int loot { get; set; }

	[DefaultValue(0)]
	public int money { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(0)]
	public int nutrition { get; set; }

	[DefaultValue(0)]
	public int happiness { get; set; }

	[DefaultValue(0)]
	public int stamina { get; set; }

	[DefaultValue(0)]
	public int mana { get; set; }

	[DefaultValue(1)]
	public int level { get; set; } = 1;


	[DefaultValue(0)]
	public int experience { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(0)]
	public int phenotype_shade { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(0)]
	public int phenotype_index { get; set; }

	[Preserve]
	[Obsolete("use .nutrition instead", true)]
	public int hunger
	{
		set
		{
			if (nutrition == 0 && value != 0)
			{
				nutrition = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .saved_traits instead", true)]
	public List<string> traits
	{
		set
		{
			if (value != null && value.Count != 0)
			{
				List<string> list = saved_traits;
				if (list == null || list.Count <= 0)
				{
					saved_traits = value;
				}
			}
		}
	}

	[Preserve]
	[Obsolete("use .sex instead", true)]
	public ActorGender gender
	{
		set
		{
			if (sex == ActorSex.Male)
			{
				switch (value)
				{
				case ActorGender.Male:
					sex = ActorSex.Male;
					break;
				case ActorGender.Female:
					sex = ActorSex.Female;
					break;
				default:
					sex = ActorSex.Male;
					break;
				}
			}
		}
	}

	public int getAge()
	{
		return Date.getYearsSince(base.created_time) + age_overgrowth;
	}
}
// --- End of File: ActorData.cs ---



// --- Start of File: ActorDataObsolete.cs ---
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Scripting;

[Preserve]
public class ActorDataObsolete
{
	public List<long> saved_items;

	[DefaultValue(null)]
	public ActorBag inventory;

	public ActorData status;

	[DefaultValue(-1L)]
	public long cityID = -1L;

	public int x;

	public int y;
}
// --- End of File: ActorDataObsolete.cs ---



// --- Start of File: ActorDebugAnimationElement.cs ---
using System;
using UnityEngine;
using UnityEngine.UI;

public class ActorDebugAnimationElement : BaseDebugAnimationElement<ActorAsset>
{
	public SpriteAnimation adult;

	public SpriteAnimation baby;

	protected override void Start()
	{
		base.Start();
		adult.create();
		baby.create();
	}

	public override void update()
	{
		if (is_playing)
		{
			adult.update(Time.deltaTime);
			if (asset.has_baby_form)
			{
				baby.update(Time.deltaTime);
			}
			frame_number_text.text = adult.currentFrameIndex.ToString();
		}
	}

	public override void setData(ActorAsset pAsset)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		base.setData(pAsset);
		if (!asset.has_baby_form)
		{
			((Behaviour)baby).enabled = false;
			baby.image.sprite = null;
			((Graphic)baby.image).color = Color.clear;
		}
	}

	protected override void clear()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		((Behaviour)adult).enabled = true;
		((Graphic)adult.image).color = Color.white;
		adult.frames = Array.Empty<Sprite>();
		adult.resetAnim();
		((Behaviour)baby).enabled = true;
		((Graphic)baby.image).color = Color.white;
		baby.frames = Array.Empty<Sprite>();
		baby.resetAnim();
	}

	public override void stopAnimations()
	{
		base.stopAnimations();
		adult.isOn = false;
		baby.isOn = false;
		frame_number_text.text = adult.currentFrameIndex.ToString();
	}

	public override void startAnimations()
	{
		base.startAnimations();
		adult.isOn = true;
		baby.isOn = true;
	}

	protected override void clickNextFrame()
	{
		if (!is_playing)
		{
			int num = adult.frames.Length;
			adult.currentFrameIndex++;
			baby.currentFrameIndex++;
			if (adult.currentFrameIndex > num - 1)
			{
				adult.currentFrameIndex = 0;
				baby.currentFrameIndex = 0;
			}
			frame_number_text.text = adult.currentFrameIndex.ToString();
			adult.updateFrame();
			baby.updateFrame();
		}
	}
}
// --- End of File: ActorDebugAnimationElement.cs ---



// --- Start of File: ActorDebugAssetElement.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ActorDebugAssetElement : BaseDebugAssetElement<ActorAsset>
{
	public Image icon_left;

	public Image icon_right;

	public ActorDebugAnimationElement animation_idle;

	public ActorDebugAnimationElement animation_walk;

	public ActorDebugAnimationElement animation_swim;

	public Image egg;

	public Sprite no_animation_baby;

	private AnimationContainerUnit _animation_container_adult;

	private AnimationContainerUnit _animation_container_baby;

	private int _phenotype_index;

	private int _phenotype_shade_id;

	public override void setData(ActorAsset pAsset)
	{
		asset = pAsset;
		Sprite spriteIcon = asset.getSpriteIcon();
		icon_left.sprite = spriteIcon;
		icon_right.sprite = spriteIcon;
		title.text = asset.id;
		((Component)egg).gameObject.SetActive(true);
		initAnimations();
		initStats();
	}

	protected override void initAnimations()
	{
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		if (asset.hasDefaultEggForm())
		{
			((Component)egg).gameObject.SetActive(true);
			SubspeciesTrait subspeciesTrait = AssetManager.subspecies_traits.get(asset.getDefaultEggID());
			egg.sprite = SpriteTextureLoader.getSprite(subspeciesTrait.sprite_path);
		}
		else
		{
			((Component)egg).gameObject.SetActive(false);
		}
		animation_idle.setData(asset);
		animation_walk.setData(asset);
		animation_swim.setData(asset);
		if (asset.special)
		{
			Sprite sprite = icon_left.sprite;
			animation_idle.adult.image.sprite = sprite;
			animation_walk.adult.image.sprite = sprite;
			animation_swim.adult.image.sprite = sprite;
			((Component)egg).gameObject.SetActive(false);
			stopAnimations();
			return;
		}
		if (asset.use_phenotypes)
		{
			_phenotype_index = AssetManager.phenotype_library.get(asset.debug_phenotype_colors).phenotype_index;
			_phenotype_shade_id = Actor.getRandomPhenotypeShade();
		}
		else
		{
			_phenotype_index = 0;
			_phenotype_shade_id = 0;
		}
		if (asset.is_boat)
		{
			AnimationDataBoat animationDataBoat = ActorAnimationLoader.loadAnimationBoat(asset.id);
			setAnimation(DynamicActorSpriteCreatorUI.getBoatAnimation(animationDataBoat), animation_idle, asset.animation_idle_speed, pIsAdult: true, pHasAnimation: true, pShouldHaveAnimation: true);
			setAnimation(animationDataBoat.normal, animation_walk, asset.animation_walk_speed, pIsAdult: true, pHasAnimation: true, pShouldHaveAnimation: true);
			setAnimation(animationDataBoat.broken, animation_swim, asset.animation_swim_speed, pIsAdult: true, pHasAnimation: true, pShouldHaveAnimation: true);
			return;
		}
		string[] array = asset.animation_idle;
		bool pShouldHaveAnimation = array != null && array.Length != 0;
		string[] array2 = asset.animation_walk;
		bool pShouldHaveAnimation2 = array2 != null && array2.Length != 0;
		string[] array3 = asset.animation_swim;
		bool pShouldHaveAnimation3 = array3 != null && array3.Length != 0;
		_animation_container_adult = DynamicActorSpriteCreatorUI.getContainerForUI(asset, pAdult: true, asset.texture_asset);
		setAnimation(_animation_container_adult.idle, animation_idle, asset.animation_idle_speed, pIsAdult: true, _animation_container_adult.has_idle, pShouldHaveAnimation);
		setAnimation(_animation_container_adult.walking, animation_walk, asset.animation_walk_speed, pIsAdult: true, _animation_container_adult.has_walking, pShouldHaveAnimation2);
		List<string> default_subspecies_traits = asset.default_subspecies_traits;
		if (default_subspecies_traits != null && !default_subspecies_traits.Contains("hovering") && !asset.flying)
		{
			setAnimation(_animation_container_adult.swimming, animation_swim, asset.animation_swim_speed, pIsAdult: true, _animation_container_adult.has_swimming, pShouldHaveAnimation3);
		}
		else
		{
			((Graphic)animation_swim.adult.image).color = Color.clear;
			((Behaviour)animation_swim.adult).enabled = false;
		}
		if (asset.has_baby_form)
		{
			_animation_container_baby = DynamicActorSpriteCreatorUI.getContainerForUI(asset, pAdult: false, asset.texture_asset);
			setAnimation(_animation_container_baby.idle, animation_idle, asset.animation_idle_speed, pIsAdult: false, _animation_container_baby.has_idle, pShouldHaveAnimation);
			setAnimation(_animation_container_baby.walking, animation_walk, asset.animation_walk_speed, pIsAdult: false, _animation_container_baby.has_walking, pShouldHaveAnimation2);
			if (!asset.default_subspecies_traits.Contains("hovering") && !asset.flying)
			{
				setAnimation(_animation_container_baby.swimming, animation_swim, asset.animation_swim_speed, pIsAdult: false, _animation_container_baby.has_swimming, pShouldHaveAnimation3);
				return;
			}
			((Graphic)animation_swim.baby.image).color = Color.clear;
			((Behaviour)animation_swim.baby).enabled = false;
		}
	}

	public override void update()
	{
		if (((Component)this).gameObject.activeSelf)
		{
			animation_idle.update();
			animation_walk.update();
			animation_swim.update();
		}
	}

	public override void stopAnimations()
	{
		animation_idle.stopAnimations();
		animation_walk.stopAnimations();
		animation_swim.stopAnimations();
	}

	public override void startAnimations()
	{
		animation_idle.startAnimations();
		animation_walk.startAnimations();
		animation_swim.startAnimations();
	}

	private void setAnimation(ActorAnimation pAnimation, ActorDebugAnimationElement pElement, float pAnimationSpeed, bool pIsAdult, bool pHasAnimation, bool pShouldHaveAnimation)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		SpriteAnimation spriteAnimation = (pIsAdult ? pElement.adult : pElement.baby);
		if (!pShouldHaveAnimation)
		{
			((Graphic)spriteAnimation.image).color = Color.clear;
			spriteAnimation.image.sprite = null;
			((Behaviour)spriteAnimation).enabled = false;
			return;
		}
		if (!pHasAnimation)
		{
			((Graphic)spriteAnimation.image).color = Color.white;
			spriteAnimation.image.sprite = (pIsAdult ? no_animation : no_animation_baby);
			((Behaviour)spriteAnimation).enabled = false;
			return;
		}
		AnimationContainerUnit pContainer = (pIsAdult ? _animation_container_adult : _animation_container_baby);
		Sprite[] array = (Sprite[])(object)new Sprite[pAnimation.frames.Length];
		ColorAsset debug_color_asset = AssetManager.kingdoms.get(asset.kingdom_id_wild).debug_color_asset;
		for (int i = 0; i < pAnimation.frames.Length; i++)
		{
			array[i] = DynamicActorSpriteCreatorUI.getUnitSpriteForUI(asset, pAnimation.frames[i], pContainer, pIsAdult, AssetsDebugManager.actors_sex, _phenotype_index, _phenotype_shade_id, debug_color_asset, 0L, 0);
		}
		((Behaviour)spriteAnimation).enabled = true;
		spriteAnimation.setFrames(array);
		spriteAnimation.timeBetweenFrames = 1f / pAnimationSpeed;
		pElement.startAnimations();
	}

	protected override void initStats()
	{
		base.initStats();
		BaseStats statsForOverview = asset.getStatsForOverview();
		showStat("health", statsForOverview["health"]);
		showStat("damage", statsForOverview["damage"]);
		showStat("speed", statsForOverview["speed"]);
		showStat("lifespan", statsForOverview["lifespan"]);
	}

	protected override void showAssetWindow()
	{
		base.showAssetWindow();
		ScrollWindow.showWindow("actor_asset");
	}
}
// --- End of File: ActorDebugAssetElement.cs ---



// --- Start of File: ActorDebugAssetsComponent.cs ---
using System.Collections.Generic;

public class ActorDebugAssetsComponent : BaseDebugAssetsComponent<ActorAsset, ActorDebugAssetElement, ActorAssetElementPlace>
{
	protected override List<ActorAsset> getAssetsList()
	{
		return AssetManager.actor_library.list;
	}

	protected override void init()
	{
		sorting_tab.addButton("ui/Icons/iconHealth", "sort_by_health", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByHealth);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/iconDamage", "sort_by_damage", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByDamage);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/iconSpeed", "sort_by_speed", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortBySpeed);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/iconAge", "sort_by_lifespan", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByLifespan);
			checkReverseSort();
		});
		base.init();
	}

	private int sortByHealth(ActorAsset pObject1, ActorAsset pObject2)
	{
		return -pObject1.getStatsForOverview()["health"].CompareTo(pObject2.getStatsForOverview()["health"]);
	}

	private int sortByDamage(ActorAsset pObject1, ActorAsset pObject2)
	{
		return -pObject1.getStatsForOverview()["damage"].CompareTo(pObject2.getStatsForOverview()["damage"]);
	}

	private int sortBySpeed(ActorAsset pObject1, ActorAsset pObject2)
	{
		return -pObject1.getStatsForOverview()["speed"].CompareTo(pObject2.getStatsForOverview()["speed"]);
	}

	private int sortByLifespan(ActorAsset pObject1, ActorAsset pObject2)
	{
		return -pObject1.getStatsForOverview()["lifespan"].CompareTo(pObject2.getStatsForOverview()["lifespan"]);
	}

	protected override List<ActorAsset> getListCivsSort()
	{
		bool flag = sorting_tab.getCurrentButton().getState() == SortButtonState.Up;
		List<ActorAsset> list = new List<ActorAsset>();
		foreach (ActorAsset assets in getAssetsList())
		{
			if (assets.civ == flag)
			{
				list.Add(assets);
			}
		}
		return list;
	}
}
// --- End of File: ActorDebugAssetsComponent.cs ---



// --- Start of File: ActorDirection.cs ---
public enum ActorDirection
{
	Up,
	UpRight,
	Right,
	UpLeft,
	Down,
	DownRight,
	DownLeft,
	Left
}
// --- End of File: ActorDirection.cs ---



// --- Start of File: ActorEquipment.cs ---
using System.Collections;
using System.Collections.Generic;

public class ActorEquipment : IEnumerable<ActorEquipmentSlot>, IEnumerable
{
	public const int SLOTS_AMOUNT = 6;

	public const string NONE = "none";

	public ActorEquipmentSlot helmet = new ActorEquipmentSlot(EquipmentType.Helmet);

	public ActorEquipmentSlot armor = new ActorEquipmentSlot();

	public ActorEquipmentSlot weapon = new ActorEquipmentSlot(EquipmentType.Weapon);

	public ActorEquipmentSlot boots = new ActorEquipmentSlot(EquipmentType.Boots);

	public ActorEquipmentSlot ring = new ActorEquipmentSlot(EquipmentType.Ring);

	public ActorEquipmentSlot amulet = new ActorEquipmentSlot(EquipmentType.Amulet);

	private Dictionary<EquipmentType, ActorEquipmentSlot> _dictionary;

	public ActorEquipment()
	{
		initDictionary();
	}

	public void destroyAllEquipment()
	{
		foreach (ActorEquipmentSlot value in _dictionary.Values)
		{
			if (!value.isEmpty())
			{
				value.takeAwayItem();
			}
		}
	}

	private void initDictionary()
	{
		_dictionary = new Dictionary<EquipmentType, ActorEquipmentSlot>();
		_dictionary.Add(EquipmentType.Helmet, helmet);
		_dictionary.Add(EquipmentType.Armor, armor);
		_dictionary.Add(EquipmentType.Weapon, weapon);
		_dictionary.Add(EquipmentType.Boots, boots);
		_dictionary.Add(EquipmentType.Ring, ring);
		_dictionary.Add(EquipmentType.Amulet, amulet);
	}

	public bool hasItems()
	{
		foreach (ActorEquipmentSlot value in _dictionary.Values)
		{
			if (!value.isEmpty())
			{
				return true;
			}
		}
		return false;
	}

	public IEnumerable<Item> getItems()
	{
		foreach (ActorEquipmentSlot value in _dictionary.Values)
		{
			if (!value.isEmpty())
			{
				yield return value.getItem();
			}
		}
	}

	public List<long> getDataForSave()
	{
		List<long> list = new List<long>();
		using (IEnumerator<ActorEquipmentSlot> enumerator = GetEnumerator())
		{
			while (enumerator.MoveNext())
			{
				ActorEquipmentSlot current = enumerator.Current;
				list.Add(current.getItem().data.id);
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		return list;
	}

	public void load(List<long> pList, Actor pActor)
	{
		if (pList == null || pList.Count == 0)
		{
			return;
		}
		foreach (long p in pList)
		{
			Item item = World.world.items.get(p);
			if (item != null)
			{
				EquipmentAsset asset = item.getAsset();
				if (asset != null)
				{
					getSlot(asset.equipment_type).setItem(item, pActor);
				}
			}
		}
		initDictionary();
	}

	public void setItem(Item pItem, Actor pActor)
	{
		getSlot(pItem.getAsset().equipment_type).setItem(pItem, pActor);
	}

	public ActorEquipmentSlot getSlot(EquipmentType pType)
	{
		return _dictionary[pType];
	}

	public IEnumerator<ActorEquipmentSlot> GetEnumerator()
	{
		foreach (ActorEquipmentSlot value in _dictionary.Values)
		{
			if (!value.isEmpty())
			{
				yield return value;
			}
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}
// --- End of File: ActorEquipment.cs ---



// --- Start of File: ActorEquipmentSlot.cs ---
using UnityEngine;

public class ActorEquipmentSlot
{
	private Item _item;

	public EquipmentType type;

	public bool is_empty => isEmpty();

	public ActorEquipmentSlot(EquipmentType pType = EquipmentType.Armor)
	{
		type = pType;
	}

	public Item getItem()
	{
		return _item;
	}

	public bool isEmpty()
	{
		if (_item == null)
		{
			return true;
		}
		if (_item.shouldbe_removed)
		{
			Debug.LogError((object)"Item should be removed but it's still in the slot!");
			return true;
		}
		return false;
	}

	public void takeAwayItem()
	{
		if (!isEmpty())
		{
			_item.clearUnit();
			_item = null;
		}
	}

	public void setEmptyDebug()
	{
		_item = null;
	}

	internal void setItem(Item pItem, Actor pActor)
	{
		if (!isEmpty())
		{
			takeAwayItem();
		}
		_item = pItem;
		_item.setUnitHasIt(pActor);
		pActor.setStatsDirty();
	}

	public bool canChangeSlot()
	{
		if (!isEmpty())
		{
			return !getItem().isCursed();
		}
		return true;
	}
}
// --- End of File: ActorEquipmentSlot.cs ---



// --- Start of File: ActorGender.cs ---
using System;

[Obsolete("use ActorSex instead", true)]
public enum ActorGender
{
	Male = 1,
	Female
}
// --- End of File: ActorGender.cs ---



// --- Start of File: ActorGetSprite.cs ---
using UnityEngine;

public delegate Sprite ActorGetSprite(Actor pActor);
// --- End of File: ActorGetSprite.cs ---



// --- Start of File: ActorGetSprites.cs ---
using UnityEngine;

public delegate Sprite[] ActorGetSprites(Actor pActor);
// --- End of File: ActorGetSprites.cs ---



// --- Start of File: ActorHighlightEffectData.cs ---
public struct ActorHighlightEffectData
{
	public Actor actor;

	public double timestamp;
}
// --- End of File: ActorHighlightEffectData.cs ---



// --- Start of File: ActorIdleLoopSound.cs ---
using FMOD.Studio;

public class ActorIdleLoopSound
{
	internal EventInstance fmod_instance;

	private Actor _actor;

	public ActorIdleLoopSound(ActorAsset pAsset, Actor pActor)
	{
	}

	public void stop()
	{
		stopLoopCallback(_actor);
	}

	internal void stopLoopCallback(Actor pActor)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (((EventInstance)(ref fmod_instance)).isValid())
		{
			((EventInstance)(ref fmod_instance)).stop((STOP_MODE)0);
			((EventInstance)(ref fmod_instance)).release();
		}
	}
}
// --- End of File: ActorIdleLoopSound.cs ---



// --- Start of File: ActorJob.cs ---
using System;

[Serializable]
public class ActorJob : JobAsset<BehaviourActorCondition, Actor>
{
}
// --- End of File: ActorJob.cs ---



// --- Start of File: ActorJobLibrary.cs ---
using ai.behaviours.conditions;

public class ActorJobLibrary : AssetLibrary<ActorJob>
{
	public override void init()
	{
		base.init();
		initJobsCivs();
		initJobsMobs();
	}

	private void initJobsCivs()
	{
		add(new ActorJob
		{
			id = "unit_citizen"
		});
		t.addTask("make_decision");
		t.addTask("check_city_destroyed");
		add(new ActorJob
		{
			id = "hunter"
		});
		t.addTask("random_move");
		t.addTask("do_hunting");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "builder"
		});
		t.addTask("try_build_building");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "cleaner"
		});
		t.addTask("cleaning");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "manure_cleaner"
		});
		t.addTask("manure_cleaning");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "road_builder"
		});
		t.addTask("build_road");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "woodcutter"
		});
		t.addTask("chop_trees");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "miner"
		});
		t.addTask("mine");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "miner_deposit"
		});
		t.addTask("mine_deposit");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "gatherer_bushes"
		});
		t.addTask("collect_fruits");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "gatherer_herbs"
		});
		t.addTask("collect_herbs");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "gatherer_honey"
		});
		t.addTask("collect_honey");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "farmer"
		});
		t.addTask("farmer_make_field");
		t.addTask("farmer_plant_crops");
		t.addTask("farmer_harvest");
		t.addTask("farmer_fertilize_crops");
		t.addTask("farmer_random_move");
		t.addTask("check_end_job");
		t.addTask("check_city_destroyed");
		add(new ActorJob
		{
			id = "attacker"
		});
		t.addTask("make_decision");
	}

	private void initJobsMobs()
	{
		add(new ActorJob
		{
			id = "crab"
		});
		t.addTask("swim_to_island");
		t.addTask("crab_danger_check");
		t.addTask("random_move");
		t.addTask("crab_danger_check");
		t.addTask("crab_eat");
		t.addTask("crab_danger_check");
		add(new ActorJob
		{
			id = "crab_burrow"
		});
		t.addTask("crab_burrow");
		add(new ActorJob
		{
			id = "decision"
		});
		t.addTask("make_decision");
		add(new ActorJob
		{
			id = "egg"
		});
		t.addTask("wait10");
		t.addTask("end_job");
		add(new ActorJob
		{
			id = "random_move"
		});
		t.addTask("random_move");
		add(new ActorJob
		{
			id = "random_swim"
		});
		t.addTask("random_swim");
		add(new ActorJob
		{
			id = "printer_job"
		});
		t.addTask("print_start");
		t.addTask("print_step");
		add(new ActorJob
		{
			id = "godfinger_job",
			random = true
		});
		t.addTask("godfinger_move");
		t.addTask("godfinger_move");
		t.addTask("godfinger_find_target");
		t.addTask("godfinger_random_fun_move");
		t.addTask("godfinger_random_fun_move");
		t.addTask("godfinger_circle_move");
		t.addTask("godfinger_circle_move");
		t.addTask("godfinger_circle_move_big");
		t.addTask("godfinger_circle_move_big");
		t.addTask("godfinger_circle_move_small");
		t.addTask("godfinger_circle_move_small");
		add(new ActorJob
		{
			id = "dragon_job",
			random = true
		});
		t.addTask("dragon_slide");
		t.addCondition(new CondActorFlying());
		t.addCondition(new CondNoPeace());
		t.addCondition(new CondDragonHasTargets());
		t.addCondition(new CondDragonCanSlide());
		t.addTask("dragon_fly");
		t.addCondition(new CondActorFlying());
		t.addTask("dragon_land");
		t.addCondition(new CondActorFlying());
		t.addCondition(new CondDragonCanLand());
		t.addTask("dragon_sleep");
		t.addCondition(new CondActorFlying(), pExpectedResult: false);
		t.addCondition(new CondDragonSleepy());
		t.addCondition(new CondDragonHasTargets(), pExpectedResult: false);
		t.addCondition(new CondDragonHasCityTarget(), pExpectedResult: false);
		t.addCondition(new CondCurrentTileNoOtherUnits());
		t.addTask("dragon_wakeup");
		t.addCondition(new CondActorFlying(), pExpectedResult: false);
		t.addCondition(new CondDragonSleeping());
		t.addTask("dragon_land_attack");
		t.addCondition(new CondActorFlying(), pExpectedResult: false);
		t.addCondition(new CondNoPeace());
		t.addCondition(new CondDragonCanLandAttack());
		t.addTask("dragon_idle");
		t.addCondition(new CondActorFlying(), pExpectedResult: false);
		t.addCondition(new CondDragonHasTargets(), pExpectedResult: false);
		t.addCondition(new CondDragonHasCityTarget(), pExpectedResult: false);
		t.addTask("dragon_up");
		t.addCondition(new CondActorFlying(), pExpectedResult: false);
		t.addCondition(new CondActorNotJustLanded());
		t.addCondition(new CondDragonCanLandAttack(), pExpectedResult: false);
		add(new ActorJob
		{
			id = "ufo_job"
		});
		t.addTask("ufo_idle");
		t.addTask("ufo_fly");
		t.addTask("ufo_explore");
		add(new ActorJob
		{
			id = "worm_job"
		});
		t.addTask("worm_move");
		add(new ActorJob
		{
			id = "sandspider_job"
		});
		t.addTask("sandspider_move");
		add(new ActorJob
		{
			id = "ant_black"
		});
		t.addTask("ant_black_island");
		t.addTask("ant_black_sand");
		add(new ActorJob
		{
			id = "ant_red"
		});
		t.addTask("ant_red_move");
		add(new ActorJob
		{
			id = "ant_blue"
		});
		t.addTask("ant_blue_move");
		add(new ActorJob
		{
			id = "ant_green"
		});
		t.addTask("ant_green_move");
		add(new ActorJob
		{
			id = "skeleton_job"
		});
		t.addTask("skeleton_move");
		t.addTask("make_decision");
	}
}
// --- End of File: ActorJobLibrary.cs ---



// --- Start of File: ActorManager.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using ai;
using ai.behaviours;

public class ActorManager : SimSystemManager<Actor, ActorData>
{
	private JobManagerActors _job_manager;

	public readonly ActorRenderData render_data = new ActorRenderData(4096);

	public readonly ActorVisibleDataArray visible_units_avatars = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_alive = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_with_status = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_with_favorite = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_with_banner = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_just_ate = new ActorVisibleDataArray();

	public readonly ActorVisibleDataArray visible_units_socialize = new ActorVisibleDataArray();

	private double _timestamp_sleeping_units;

	public readonly List<Actor> cached_sleeping_units = new List<Actor>();

	private readonly List<ActorVisibleDataArray> _unit_visible_lists = new List<ActorVisibleDataArray>();

	public bool have_dying_units;

	public readonly List<Actor> units_only_wild = new List<Actor>();

	public readonly List<Actor> units_only_civ = new List<Actor>();

	public readonly List<Actor> units_only_alive = new List<Actor>();

	public readonly List<Actor> units_only_dying = new List<Actor>();

	public ActorManager()
	{
		type_id = "unit";
		_job_manager = new JobManagerActors("actors");
		_unit_visible_lists.Add(visible_units);
		_unit_visible_lists.Add(visible_units_avatars);
		_unit_visible_lists.Add(visible_units_alive);
		_unit_visible_lists.Add(visible_units_with_status);
		_unit_visible_lists.Add(visible_units_with_favorite);
		_unit_visible_lists.Add(visible_units_with_banner);
		_unit_visible_lists.Add(visible_units_just_ate);
		_unit_visible_lists.Add(visible_units_socialize);
	}

	public void prepareForMetaChecks()
	{
		units_only_wild.Clear();
		units_only_alive.Clear();
		units_only_dying.Clear();
		units_only_civ.Clear();
		have_dying_units = false;
		List<Actor> simpleList = getSimpleList();
		for (int i = 0; i < simpleList.Count; i++)
		{
			Actor actor = simpleList[i];
			if (actor.isAlive())
			{
				if (actor.kingdom.wild)
				{
					units_only_wild.Add(actor);
				}
				else
				{
					units_only_civ.Add(actor);
				}
				units_only_alive.Add(actor);
			}
			else
			{
				units_only_dying.Add(actor);
				have_dying_units = true;
			}
		}
	}

	public void calculateVisibleActors()
	{
		Bench.bench("actors_prepare_lists", "game_total");
		clearLists();
		prepareLists();
		Bench.benchEnd("actors_prepare_lists", "game_total", pSaveCounter: false, 0L);
		Bench.bench("actors_fill_visible", "game_total");
		fillVisibleObjects();
		Bench.benchEnd("actors_fill_visible", "game_total", pSaveCounter: false, 0L);
		Bench.bench("actors_precalc_render_data_parallel", "game_total");
		precalculateRenderDataParallel();
		Bench.benchEnd("actors_precalc_render_data_parallel", "game_total", pSaveCounter: false, 0L);
		Bench.bench("actors_precalc_render_data_normal", "game_total");
		precalculateRenderDataNormal();
		Bench.benchEnd("actors_precalc_render_data_normal", "game_total", pSaveCounter: false, 0L);
	}

	private void precalculateRenderDataParallel()
	{
		int tDebugItemScale = ((!DebugConfig.isOn(DebugOption.RenderBigItems)) ? 1 : 10);
		bool tShouldRenderUnitShadows = World.world.quality_changer.shouldRenderUnitShadows();
		int tTotalVisibleObjects = visible_units.count;
		Actor[] tArray = visible_units.array;
		int tDynamicBatchSize = 256;
		int toExclusive = ParallelHelper.calcTotalBatches(tTotalVisibleObjects, tDynamicBatchSize);
		Parallel.For(0, toExclusive, World.world.parallel_options, delegate(int pBatchIndex)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0459: Unknown result type (might be due to invalid IL or missing references)
			//IL_0461: Unknown result type (might be due to invalid IL or missing references)
			//IL_0466: Unknown result type (might be due to invalid IL or missing references)
			//IL_0499: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_04db: Unknown result type (might be due to invalid IL or missing references)
			//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_04df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0504: Unknown result type (might be due to invalid IL or missing references)
			//IL_051b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0520: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_023c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_021d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_0246: Unknown result type (might be due to invalid IL or missing references)
			//IL_024b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0250: Unknown result type (might be due to invalid IL or missing references)
			//IL_053c: Unknown result type (might be due to invalid IL or missing references)
			//IL_053e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_026f: Unknown result type (might be due to invalid IL or missing references)
			//IL_027e: Unknown result type (might be due to invalid IL or missing references)
			//IL_028d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Unknown result type (might be due to invalid IL or missing references)
			//IL_029f: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_037f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0380: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0307: Unknown result type (might be due to invalid IL or missing references)
			//IL_030c: Unknown result type (might be due to invalid IL or missing references)
			//IL_030d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0312: Unknown result type (might be due to invalid IL or missing references)
			//IL_031c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0324: Unknown result type (might be due to invalid IL or missing references)
			//IL_032d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0357: Unknown result type (might be due to invalid IL or missing references)
			//IL_035d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_0367: Unknown result type (might be due to invalid IL or missing references)
			int num = ParallelHelper.calculateBatchBeg(pBatchIndex, tDynamicBatchSize);
			int num2 = ParallelHelper.calculateBatchEnd(num, tDynamicBatchSize, tTotalVisibleObjects);
			Vector3 point = default(Vector3);
			Vector3 pivot = default(Vector3);
			for (int i = num; i < num2; i++)
			{
				Actor actor = tArray[i];
				Vector3 current_scale = actor.current_scale;
				Vector3 val = actor.updateRotation();
				Vector3 val2 = actor.updatePos();
				bool flag = actor.checkHasRenderedItem();
				bool flag2 = !actor.asset.ignore_generic_render;
				Sprite val3;
				if (flag)
				{
					Sprite renderedItemSprite = actor.getRenderedItemSprite();
					IHandRenderer cachedHandRendererAsset = actor.getCachedHandRendererAsset();
					int pColorID = -900000;
					if (cachedHandRendererAsset.is_colored)
					{
						pColorID = actor.kingdom.getColor().GetHashCode();
					}
					val3 = DynamicSprites.getCachedAtlasItemSprite(DynamicSprites.getItemSpriteID(renderedItemSprite, pColorID), renderedItemSprite);
				}
				else
				{
					val3 = null;
				}
				render_data.positions[i] = val2;
				render_data.scales[i] = current_scale;
				render_data.rotations[i] = val;
				render_data.flip_x_states[i] = actor.flip;
				render_data.colors[i] = actor.color;
				render_data.has_normal_render[i] = flag2;
				render_data.has_item[i] = flag;
				render_data.item_sprites[i] = val3;
				AnimationFrameData animationFrameData = actor.getAnimationFrameData();
				bool flag3 = false;
				if (tShouldRenderUnitShadows && actor.show_shadow)
				{
					ActorTextureSubAsset actorTextureSubAsset = ((!actor.hasSubspecies() || !actor.subspecies.has_mutation_reskin) ? actor.asset.texture_asset : actor.subspecies.mutation_skin_asset.texture_asset);
					flag3 = actorTextureSubAsset.shadow;
					if (actorTextureSubAsset.shadow)
					{
						Vector2 val4;
						if (actor.isEgg())
						{
							render_data.shadow_sprites[i] = actorTextureSubAsset.shadow_sprite_egg;
							val4 = actorTextureSubAsset.shadow_size_egg;
						}
						else if (actor.isBaby())
						{
							render_data.shadow_sprites[i] = actorTextureSubAsset.shadow_sprite_baby;
							val4 = actorTextureSubAsset.shadow_size_baby;
						}
						else
						{
							render_data.shadow_sprites[i] = actorTextureSubAsset.shadow_sprite;
							val4 = actorTextureSubAsset.shadow_size;
						}
						val4 *= Vector2.op_Implicit(current_scale);
						int num3 = (actor.flip ? 1 : (-1));
						float num4 = val4.x / 2f;
						float num5 = val4.y * 0.6f;
						float num6 = Mathf.Abs(val.z);
						Vector2 current_shadow_position = actor.current_shadow_position;
						current_shadow_position.x += num4 * (val.z * (float)num3) / 90f;
						current_shadow_position.y -= num5 * num6 / 90f;
						render_data.shadow_position[i] = Vector2.op_Implicit(current_shadow_position);
						if (animationFrameData != null && animationFrameData.size_unit != default(Vector2))
						{
							float num7 = (animationFrameData.size_unit * Vector2.op_Implicit(current_scale)).y / val4.x * current_scale.x;
							float num8 = Mathf.Lerp(current_scale.x, num7, num6 / 90f);
							render_data.shadow_scales[i] = Vector2.op_Implicit(new Vector2(num8, current_scale.y));
						}
						else
						{
							render_data.shadow_scales[i] = current_scale;
						}
					}
				}
				render_data.shadows[i] = flag3;
				if (flag2)
				{
					if (actor.canParallelSetColoredSprite())
					{
						Sprite val5 = actor.calculateMainSprite();
						render_data.main_sprites[i] = val5;
						if (actor.hasColoredSprite())
						{
							if (!actor.isColoredSpriteNeedsCheck(val5))
							{
								render_data.main_sprite_colored[i] = actor.getLastColoredSprite();
							}
							else
							{
								render_data.main_sprite_colored[i] = null;
							}
						}
						else
						{
							render_data.main_sprite_colored[i] = val5;
						}
					}
					else
					{
						render_data.main_sprites[i] = null;
						render_data.main_sprite_colored[i] = null;
					}
					if (flag)
					{
						render_data.item_scale[i] = current_scale * (float)tDebugItemScale;
						float num9 = 0f;
						float num10 = 0f;
						if (animationFrameData != null)
						{
							num9 = animationFrameData.pos_item.x;
							num10 = animationFrameData.pos_item.y;
						}
						float num11 = val2.x + num9 * current_scale.x;
						float num12 = val2.y + num10 * current_scale.y;
						float z = -0.01f + num10 * current_scale.y;
						((Vector3)(ref point))._002Ector(num11, num12);
						Vector3 angles = val;
						if (angles.y != 0f || angles.z != 0f)
						{
							((Vector3)(ref pivot))._002Ector(val2.x, val2.y, 0f);
							point = Toolbox.RotatePointAroundPivot(ref point, ref pivot, ref angles);
						}
						point.z = z;
						render_data.item_pos[i] = point;
					}
				}
			}
		});
	}

	private void precalculateRenderDataNormal()
	{
		ActorRenderData actorRenderData = render_data;
		int count = visible_units.count;
		Actor[] array = visible_units.array;
		for (int i = 0; i < count; i++)
		{
			Actor actor = array[i];
			if (actorRenderData.has_normal_render[i] && actorRenderData.main_sprite_colored[i] == null)
			{
				Sprite val = actorRenderData.main_sprites[i];
				if (val == null)
				{
					val = actor.calculateMainSprite();
				}
				actorRenderData.main_sprite_colored[i] = actor.calculateColoredSprite(val);
			}
		}
	}

	private void fillVisibleObjects()
	{
		prepareArray();
		Actor[] simpleArray = getSimpleArray();
		int count = Count;
		bool flag = MapBox.isRenderGameplay();
		int count2 = 0;
		int count3 = 0;
		Actor[] array = visible_units.array;
		Actor[] array2 = visible_units_alive.array;
		for (int i = 0; i < count; i++)
		{
			Actor actor = simpleArray[i];
			ActorAsset asset = actor.asset;
			TileZone zone = actor.current_tile.zone;
			if (asset.has_avatar_prefab)
			{
				visible_units_avatars.array[visible_units_avatars.count++] = actor;
			}
			if (actor.isFavorite() && !asset.hide_favorite_icon && zone.visible && !ControllableUnit.isControllingUnit(actor))
			{
				visible_units_with_favorite.array[visible_units_with_favorite.count++] = actor;
			}
			if (!zone.visible || !flag || !actor.is_visible)
			{
				continue;
			}
			array[count2++] = actor;
			if (actor.isAlive())
			{
				array2[count3++] = actor;
				if (actor.is_army_captain)
				{
					visible_units_with_banner.array[visible_units_with_banner.count++] = actor;
				}
				if (asset.render_status_effects && actor.hasAnyStatusEffectToRender())
				{
					visible_units_with_status.array[visible_units_with_status.count++] = actor;
				}
				if (actor.timestamp_session_ate_food > 0.0)
				{
					visible_units_just_ate.array[visible_units_just_ate.count++] = actor;
				}
				BehaviourActionActor action = actor.ai.action;
				if (action != null && action.socialize)
				{
					visible_units_socialize.array[visible_units_socialize.count++] = actor;
				}
				else if (actor.is_forced_socialize_icon && !actor.is_moving && !actor.isLying() && actor.isAttackReady() && Date.getMonthsSince(actor.is_forced_socialize_timestamp) < 1)
				{
					visible_units_socialize.array[visible_units_socialize.count++] = actor;
				}
			}
		}
		visible_units.count = count2;
		visible_units_alive.count = count3;
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		Bench.bench("actors", "game_total");
		checkContainer();
		_job_manager.updateBase(pElapsed);
		checkContainer();
		Bench.benchEnd("actors", "game_total", pSaveCounter: false, 0L);
	}

	private void checkOverrideUnitShooting()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!DebugConfig.isOn(DebugOption.OverrideUnitShooting) || !Input.GetMouseButtonDown(0))
		{
			return;
		}
		Vector2 mousePos = World.world.getMousePos();
		WorldTile mouseTilePos = World.world.getMouseTilePos();
		Actor actorNearCursor = World.world.getActorNearCursor();
		if (mouseTilePos == null)
		{
			return;
		}
		using IEnumerator<Actor> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			Actor current = enumerator.Current;
			if (current != actorNearCursor && current.isAlive() && current.hasRangeAttack())
			{
				AttackData pData = new AttackData(current, pKingdom: current.kingdom, pInitiatorPosition: Vector2.op_Implicit(current.current_position), pHitTile: mouseTilePos, pHitPosition: Vector2.op_Implicit(mousePos), pTarget: null, pAttackType: AttackType.Weapon, pMetallicWeapon: false, pSkipShake: true, pProjectile: false, pProjectileID: current.getWeaponAsset().projectile);
				CombatActionLibrary.combat_attack_range.action(pData);
			}
		}
	}

	protected override void destroyObject(Actor pActor)
	{
		base.destroyObject(pActor);
		if (pActor.hasKingdom())
		{
			pActor.setKingdom(null);
		}
		if (pActor.hasSubspecies())
		{
			pActor.setSubspecies(null);
		}
		if (pActor.tile_target != null)
		{
			pActor.clearTileTarget();
		}
		pActor.asset.units.Remove(pActor);
		removeObject(pActor);
		_job_manager.removeObject(pActor, pActor.batch);
		if ((Object)(object)pActor.avatar != (Object)null)
		{
			Object.Destroy((Object)(object)pActor.avatar);
			pActor.avatar = null;
		}
		if (pActor.idle_loop_sound != null)
		{
			pActor.idle_loop_sound.stop();
		}
	}

	internal override void scheduleDestroyOnPlay(Actor pObject)
	{
		triggerActionsOnRemove(pObject);
		base.scheduleDestroyOnPlay(pObject);
	}

	private void triggerActionsOnRemove(Actor pActor)
	{
		foreach (ActorTrait trait in pActor.traits)
		{
			trait.action_on_object_remove?.Invoke(pActor, trait);
		}
	}

	public override void loadFromSave(List<ActorData> pList)
	{
		base.loadFromSave(pList);
		checkContainer();
	}

	public Actor evolutionEvent(Actor pTargetActor, bool pWithBiomeEffect, bool pAscension)
	{
		Subspecies subspecies = pTargetActor.subspecies;
		bool flag = false;
		Subspecies subspecies2 = null;
		string pID = pTargetActor.asset.id;
		if (subspecies.hasEvolvedIntoForm() && !pAscension)
		{
			subspecies2 = subspecies.getEvolvedInto();
			if (subspecies2 != null)
			{
				pID = subspecies2.getActorAsset().id;
			}
		}
		if (subspecies2 == null)
		{
			bool flag2 = false;
			if (pTargetActor.asset.can_evolve_into_new_species)
			{
				flag2 = subspecies.isSapient() || Randy.randomBool();
				if (flag2)
				{
					pID = pTargetActor.asset.evolution_id;
				}
			}
			if (!flag2)
			{
				Subspecies subspecies3 = World.world.subspecies.newSpecies(pTargetActor.asset, pTargetActor.current_tile, pMutation: true);
				flag = true;
				subspecies3.mutateFrom(subspecies);
				subspecies2 = subspecies3;
			}
		}
		if (subspecies2 == null)
		{
			subspecies2 = World.world.subspecies.newSpecies(AssetManager.actor_library.get(pID), pTargetActor.current_tile);
			flag = true;
			subspecies2.mutateFrom(subspecies);
		}
		if (flag)
		{
			subspecies2.addTrait("uplifted");
			subspecies2.makeSapient();
			subspecies2.data.biome_variant = subspecies.data.biome_variant;
		}
		ActorAsset asset = AssetManager.actor_library.get(pID);
		pTargetActor.setAsset(asset);
		pTargetActor.setSubspecies(subspecies2);
		subspecies2.data.parent_subspecies = subspecies.id;
		if (pAscension)
		{
			string name = subspecies2.name;
			if (!name.Contains("Ascentus"))
			{
				name += " Ascentus";
				subspecies2.setName(name);
			}
		}
		else
		{
			subspecies.setEvolutionSubspecies(subspecies2);
		}
		if (pWithBiomeEffect && Randy.randomChance(0.1f))
		{
			BiomeAsset biome = pTargetActor.current_tile.getBiome();
			if (biome != null && biome.evolution_trait_subspecies != null && biome.evolution_trait_subspecies.Count > 0)
			{
				SubspeciesTrait subspeciesTrait = AssetManager.subspecies_traits.get(biome.evolution_trait_subspecies.GetRandom());
				if (subspeciesTrait != null)
				{
					subspecies2.addTrait(subspeciesTrait);
				}
			}
		}
		pTargetActor.afterEvolutionEvents();
		return pTargetActor;
	}

	public bool cloneUnit(Actor pCloneFrom, WorldTile pTileTarget = null)
	{
		if (pCloneFrom == null)
		{
			return false;
		}
		if (!pCloneFrom.asset.can_be_cloned)
		{
			return false;
		}
		pCloneFrom.prepareForSave();
		ActorData data = pCloneFrom.data;
		string name = pCloneFrom.getName();
		ActorData actorData = new ActorData();
		ActorTool.copyImportantData(data, actorData, pCopyAge: true);
		actorData.created_time = World.world.getCurWorldTime();
		actorData.id = World.world.map_stats.getNextId("unit");
		actorData.name = name;
		actorData.custom_name = data.custom_name;
		actorData.age_overgrowth = data.getAge();
		actorData.parent_id_1 = data.id;
		pCloneFrom.increaseBirths();
		if (pTileTarget == null)
		{
			pTileTarget = pCloneFrom.current_tile.neighboursAll.GetRandom();
		}
		actorData.x = pTileTarget.x;
		actorData.y = pTileTarget.y;
		Actor actor = World.world.units.loadObject(actorData);
		actor.created_time_unscaled = Time.time;
		actor.addTrait("fragile_health");
		foreach (ActorTrait trait in pCloneFrom.getTraits())
		{
			actor.addTrait(trait);
		}
		actor.addTrait("miracle_born");
		if (!pCloneFrom.hasFamily() && pCloneFrom.asset.create_family_at_spawn)
		{
			World.world.families.newFamily(pCloneFrom, pCloneFrom.current_tile, null);
		}
		actor.data.cloneCustomDataFrom(pCloneFrom.data);
		actor.setReligion(pCloneFrom.religion);
		actor.setClan(pCloneFrom.clan);
		actor.setCulture(pCloneFrom.culture);
		actor.setSubspecies(pCloneFrom.subspecies);
		actor.joinLanguage(pCloneFrom.language);
		actor.setFamily(pCloneFrom.family);
		actor.setHealth(data.health, pClamp: false);
		actor.setMana(data.mana, pClamp: false);
		actor.setStamina(data.stamina, pClamp: false);
		actor.setHappiness(data.happiness, pClamp: false);
		actor.setNutrition(data.nutrition, pClamp: false);
		actor.addTrait("clone");
		if (data.saved_items != null)
		{
			foreach (long saved_item in data.saved_items)
			{
				Item item = World.world.items.get(saved_item);
				if (item != null)
				{
					Item item2 = World.world.items.generateItem(item.getAsset(), null, null, 1, pCloneFrom);
					item2.data.modifiers.Clear();
					item2.data.modifiers.AddRange(item.data.modifiers);
					item2.data.modifiers.Remove("eternal");
					item2.initItem();
					actor.equipment.setItem(item2, actor);
				}
			}
		}
		actor.applyRandomForce();
		if (actor.isRendered())
		{
			EffectsLibrary.spawn("fx_spawn", pTileTarget);
		}
		if (actor.asset.has_sound_spawn)
		{
			MusicBox.playSound(actor.asset.sound_spawn, pTileTarget);
		}
		return true;
	}

	public Actor createNewUnit(string pStatsID, WorldTile pTile, bool pMiracleSpawn = false, float pSpawnHeight = 0f, Subspecies pSubspecies = null, Subspecies pSubspeciesMutateFrom = null, bool pSpawnWithItems = true, bool pAdultAge = false, bool pGiveOwnerlessItems = false, bool pSapientSubspecies = false)
	{
		ActorAsset actorAsset = AssetManager.actor_library.get(pStatsID);
		if (actorAsset == null)
		{
			return null;
		}
		Actor actor = newObject();
		actor.setAsset(actorAsset);
		if (!pSubspecies.isRekt())
		{
			actor.setSubspecies(pSubspecies);
		}
		else
		{
			checkNewSpecies(actorAsset, pTile, actor, out var pClosestActor, pGlobalSearch: false, pSapientSubspecies, pSubspeciesMutateFrom);
			if (pMiracleSpawn && pClosestActor != null)
			{
				if (pClosestActor.hasCulture())
				{
					actor.setCulture(pClosestActor.culture);
				}
				if (pClosestActor.hasReligion())
				{
					actor.setReligion(pClosestActor.religion);
				}
				if (pClosestActor.hasLanguage())
				{
					actor.setLanguage(pClosestActor.language);
				}
			}
		}
		addRandomTraitFromBiomeToActor(actor, pTile);
		finalizeActor(pStatsID, actor, pTile, pSpawnHeight);
		if (pMiracleSpawn || pAdultAge)
		{
			if (pMiracleSpawn)
			{
				actor.addTrait("miracle_born");
			}
			if (actor.hasSubspecies())
			{
				actor.data.age_overgrowth = (int)Math.Ceiling(actor.subspecies.age_breeding);
			}
			else
			{
				actor.data.age_overgrowth = actorAsset.age_spawn;
			}
			if (HotkeyLibrary.isHoldingAlt())
			{
				actor.data.age_overgrowth = 0;
			}
		}
		actor.newCreature();
		if (pSpawnWithItems)
		{
			actor.generateDefaultSpawnWeapons(pGiveOwnerlessItems);
		}
		actor.clearSprites();
		return actor;
	}

	private void finalizeActor(string pStats, Actor pActor, WorldTile pTile, float pZHeight = 0f)
	{
		ActorAsset asset = AssetManager.actor_library.get(pStats);
		pActor.setAsset(asset);
		ActorData data = pActor.data;
		pActor.spawnOn(pTile, pZHeight);
		if (data.subspecies.hasValue())
		{
			pActor.setSubspecies(World.world.subspecies.get(data.subspecies));
		}
		if (data.family.hasValue())
		{
			pActor.setFamily(World.world.families.get(data.family));
		}
		if (data.language.hasValue())
		{
			pActor.setLanguage(World.world.languages.get(data.language));
		}
		if (data.plot.hasValue())
		{
			pActor.setPlot(World.world.plots.get(data.plot));
		}
		if (data.religion.hasValue())
		{
			pActor.setReligion(World.world.religions.get(data.religion));
		}
		if (data.clan.hasValue())
		{
			pActor.setClan(World.world.clans.get(data.clan));
		}
		if (data.culture.hasValue())
		{
			pActor.setCulture(World.world.cultures.get(data.culture));
		}
		if (data.army.hasValue())
		{
			pActor.setArmy(World.world.armies.get(data.army));
		}
		pActor.create();
		pActor.checkDefaultKingdom();
		pActor.checkDefaultProfession();
		pActor.updateStats();
		if (pActor.asset.can_be_killed_by_stuff)
		{
			pActor.batch.c_main_tile_action.Add(pActor);
		}
	}

	public Actor createBabyActorFromData(ActorData pData, WorldTile pTile, City pCity)
	{
		ActorAsset actorAsset = AssetManager.actor_library.get(pData.asset_id);
		Actor actor = base.loadObject(pData);
		actor.setData(pData);
		actor.created_time_unscaled = Time.time;
		finalizeActor(actorAsset.id, actor, pTile);
		return actor;
	}

	public Actor spawnNewUnitByPlayer(string pStatsID, WorldTile pTile, bool pSpawnSound = false, bool pMiracleSpawn = false, float pSpawnHeight = 6f, Subspecies pSubspecies = null)
	{
		Actor actor = spawnNewUnit(pStatsID, pTile, pSpawnSound, pMiracleSpawn, pSpawnHeight, pSubspecies, pGiveOwnerlessItems: true);
		if (actor.current_zone.hasCity() && actor.isSapient())
		{
			City city = actor.current_zone.city;
			if (!city.isNeutral() && city.isPossibleToJoin(actor))
			{
				actor.joinCity(city);
			}
		}
		return actor;
	}

	public Actor spawnNewUnit(string pActorAssetID, WorldTile pTile, bool pSpawnSound = false, bool pMiracleSpawn = false, float pSpawnHeight = 6f, Subspecies pSubspecies = null, bool pGiveOwnerlessItems = false, bool pAdultAge = false)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		bool pGiveOwnerlessItems2 = pGiveOwnerlessItems;
		Actor actor = createNewUnit(pActorAssetID, pTile, pMiracleSpawn, pSpawnHeight, pSubspecies, null, pSpawnWithItems: true, pAdultAge, pGiveOwnerlessItems2);
		if (pSpawnSound && actor.asset.has_sound_spawn)
		{
			string sound_spawn = actor.asset.sound_spawn;
			Vector2Int pos = pTile.pos;
			float pX = ((Vector2Int)(ref pos)).x;
			pos = pTile.pos;
			MusicBox.playSound(sound_spawn, pX, ((Vector2Int)(ref pos)).y);
		}
		if (actor.kingdom == null)
		{
			Kingdom kingdom = World.world.kingdoms_wild.get(actor.asset.kingdom_id_wild);
			actor.setKingdom(kingdom);
		}
		actor.setStatsDirty();
		actor.setNutrition(SimGlobals.m.nutrition_level_on_spawn);
		return actor;
	}

	private void checkNewSpecies(ActorAsset pAsset, WorldTile pTile, Actor pActor, out Actor pClosestActor, bool pGlobalSearch = false, bool pLookForSapientSubspecies = false, Subspecies pSubspeciesMutateFrom = null)
	{
		pClosestActor = null;
		if (!pAsset.can_have_subspecies)
		{
			return;
		}
		Subspecies subspecies = null;
		if (pGlobalSearch)
		{
			foreach (Subspecies subspecy in World.world.subspecies)
			{
				if (subspecy.isSpecies(pAsset.id))
				{
					subspecies = subspecy;
					break;
				}
			}
		}
		if (subspecies == null)
		{
			subspecies = World.world.subspecies.getNearbySpecies(pAsset, pTile, out var pSubspeciesActor, pLookForSapientSubspecies, pStopAtFirst: true);
			pClosestActor = pSubspeciesActor;
		}
		if (subspecies == null)
		{
			subspecies = World.world.subspecies.newSpecies(pAsset, pTile);
			if (pSubspeciesMutateFrom != null)
			{
				subspecies.mutateFrom(pSubspeciesMutateFrom);
			}
			subspecies.forceRecalcBaseStats();
		}
		pActor.setSubspecies(subspecies);
		pActor.event_full_stats = true;
		pActor.setStatsDirty();
	}

	public ActorTrait addRandomTraitFromBiomeToActor(Actor pActor, WorldTile pTile)
	{
		if (!pTile.Type.is_biome)
		{
			return null;
		}
		BiomeAsset biome_asset = pTile.Type.biome_asset;
		List<string> spawn_trait_actor = biome_asset.spawn_trait_actor;
		if (spawn_trait_actor != null && spawn_trait_actor.Count > 0 && Randy.randomBool())
		{
			string random = biome_asset.spawn_trait_actor.GetRandom();
			ActorTrait actorTrait = AssetManager.traits.get(random);
			pActor.addTrait(actorTrait);
			return actorTrait;
		}
		return null;
	}

	public override Actor loadObject(ActorData pData)
	{
		if (dict.ContainsKey(pData.id))
		{
			Debug.Log((object)("Trying to load unit with same ID, that already is loaded. " + pData.id));
			return null;
		}
		WorldTile tile = World.world.GetTile(pData.x, pData.y);
		if (tile == null)
		{
			return null;
		}
		ActorAsset actorAsset = AssetManager.actor_library.get(pData.asset_id);
		if (actorAsset == null)
		{
			return null;
		}
		int health = pData.health;
		int nutrition = pData.nutrition;
		int stamina = pData.stamina;
		int mana = pData.mana;
		Actor actor = base.loadObject(pData);
		actor.setData(pData);
		finalizeActor(actorAsset.id, actor, tile);
		if (actor.canUseItems())
		{
			actor.equipment.load(pData.saved_items, actor);
		}
		if (actor.isSapient())
		{
			actor.reloadInventory();
		}
		actor.loadFromSave();
		actor.updateStats();
		actor.setHealth(health);
		actor.setNutrition(nutrition);
		actor.setStamina(stamina);
		actor.setMana(mana);
		if (actor.asset.can_have_subspecies && !actor.hasSubspecies())
		{
			checkNewSpecies(actor.asset, actor.current_tile, actor, out var _, pGlobalSearch: true);
		}
		actor.makeWait(Randy.randomFloat(0.1f, 2f));
		return actor;
	}

	protected override void addObject(Actor pObject)
	{
		base.addObject(pObject);
		_job_manager.addNewObject(pObject);
	}

	private void clearLists()
	{
		for (int i = 0; i < _unit_visible_lists.Count; i++)
		{
			_unit_visible_lists[i].count = 0;
		}
	}

	private void prepareLists()
	{
		for (int i = 0; i < _unit_visible_lists.Count; i++)
		{
			_unit_visible_lists[i].prepare(Count);
		}
		render_data.checkSize(Count);
		checkContainer();
	}

	public override void clear()
	{
		_job_manager.clear();
		cached_sleeping_units.Clear();
		clearLists();
		checkContainer();
		scheduleDestroyAllOnWorldClear();
		checkObjectsToDestroy();
		base.clear();
	}

	public void debugJobManager(DebugTool pTool)
	{
		_job_manager.debug(pTool);
	}

	public JobManagerActors getJobManager()
	{
		return _job_manager;
	}

	public void checkSleepingUnits()
	{
		if (World.world.getWorldTimeElapsedSince(_timestamp_sleeping_units) < 10f)
		{
			return;
		}
		cached_sleeping_units.Clear();
		_timestamp_sleeping_units = World.world.getCurWorldTime();
		foreach (Status item in World.world.statuses.list.LoopRandom())
		{
			if (item.is_finished || item.asset.id != "sleeping")
			{
				continue;
			}
			Actor a = item.sim_object.a;
			if (a.isAlive())
			{
				cached_sleeping_units.Add(a);
				if (cached_sleeping_units.Count > 10)
				{
					break;
				}
			}
		}
	}
}
// --- End of File: ActorManager.cs ---



// --- Start of File: ActorMove.cs ---
using System;
using System.Collections.Generic;
using EpPathFinding.cs;
using UnityEngine;
using ai;

public class ActorMove
{
	private const float CHUNK_MULTIPLIER = 4f;

	public static ExecuteEvent goTo(Actor pActor, WorldTile pTileTarget, bool pPathOnLiquid = false, bool pWalkOnBlocks = false, bool pPathOnLava = false, int pLimitPathfindingRegions = 0)
	{
		pActor.clearOldPath();
		ActorAsset asset = pActor.asset;
		bool is_boat = asset.is_boat;
		if (!DebugConfig.isOn(DebugOption.SystemUnitPathfinding))
		{
			pActor.current_path.Add(pTileTarget);
			return ExecuteEvent.True;
		}
		if (is_boat && !pTileTarget.isGoodForBoat())
		{
			return ExecuteEvent.False;
		}
		if (pActor.isFlying())
		{
			pActor.current_path.Add(pTileTarget);
			return ExecuteEvent.True;
		}
		WorldTile current_tile = pActor.current_tile;
		bool flag = current_tile.isSameIsland(pTileTarget);
		bool flag2 = pActor.isWaterCreature();
		bool flag3 = pActor.isInLiquid();
		bool flag4 = pActor.isImmuneToFire();
		if (flag && !flag3)
		{
			pPathOnLiquid = false;
		}
		AStarParam pathfinding_param = World.world.pathfinding_param;
		pathfinding_param.resetParam();
		pathfinding_param.block = pWalkOnBlocks;
		pathfinding_param.lava = flag4;
		pathfinding_param.fire = flag4;
		if (pActor.hasStatus("burning") || current_tile.isOnFire())
		{
			pathfinding_param.fire = true;
		}
		if (current_tile.Type.lava)
		{
			pathfinding_param.lava = true;
		}
		if (pPathOnLava)
		{
			pathfinding_param.lava = true;
		}
		pathfinding_param.ocean = flag2;
		if (pPathOnLiquid && !pActor.isDamagedByOcean())
		{
			pathfinding_param.ocean = true;
		}
		else if (flag3)
		{
			pathfinding_param.ocean = true;
		}
		pathfinding_param.ground = !flag2 || asset.force_land_creature;
		if (flag2 && !pActor.isInWater())
		{
			pathfinding_param.ground = true;
		}
		pathfinding_param.boat = is_boat && current_tile.isGoodForBoat();
		pathfinding_param.limit = true;
		if (PathfinderTools.tryToGetSimplePath(current_tile, pTileTarget, pActor.current_path, asset, pathfinding_param))
		{
			int num = (int)((float)pLimitPathfindingRegions * 4f);
			List<WorldTile> lastRaycastResult = PathfinderTools.getLastRaycastResult();
			if (pLimitPathfindingRegions > 0 && lastRaycastResult.Count > num)
			{
				lastRaycastResult.RemoveRange(num, lastRaycastResult.Count - num);
				pActor.current_path.Add(lastRaycastResult.Last());
			}
			else
			{
				pActor.current_path.Add(pTileTarget);
			}
		}
		World.world.path_finding_visualiser.showPath(null, pActor.current_path);
		if (pActor.isUsingPath())
		{
			pActor.setTileTarget(pTileTarget);
			return ExecuteEvent.True;
		}
		if (!flag)
		{
			TileTypeBase type = pTileTarget.Type;
			if ((!type.ground || !pathfinding_param.ground) && (!type.ocean || !pathfinding_param.ocean) && (!type.lava || !pathfinding_param.lava) && (!type.block || !pathfinding_param.block))
			{
				return ExecuteEvent.False;
			}
			TileIsland island = current_tile.region.island;
			TileIsland island2 = pTileTarget.region.island;
			if (island2.getTileCount() < island.getTileCount())
			{
				if (!island2.isConnectedWith(island))
				{
					return ExecuteEvent.False;
				}
				pathfinding_param.end_to_start_path = true;
			}
			else if (!island.isConnectedWith(island2))
			{
				return ExecuteEvent.False;
			}
		}
		bool flag5 = DebugConfig.isOn(DebugOption.UseGlobalPathLock);
		if (flag5)
		{
			if (is_boat)
			{
				flag5 = true;
			}
			else if (!flag)
			{
				flag5 = false;
			}
		}
		PathFinderResult pathFinderResult = PathFinderResult.PathFound;
		if (flag5)
		{
			switch (World.world.region_path_finder.getGlobalPath(current_tile, pTileTarget, is_boat))
			{
			case PathFinderResult.SamePlace:
				pActor.current_path.Add(pTileTarget);
				return ExecuteEvent.True;
			case PathFinderResult.NotFound:
				return ExecuteEvent.True;
			case PathFinderResult.DifferentIslands:
				return ExecuteEvent.True;
			}
			if (World.world.region_path_finder.last_globalPath != null)
			{
				pActor.current_path_global = World.world.region_path_finder.last_globalPath;
				lockRegionsForAStarSearch(pActor, pLimitPathfindingRegions);
			}
			else
			{
				current_tile.region.used_by_path_lock = true;
				current_tile.region.region_path_id = 0;
			}
		}
		pathfinding_param.use_global_path_lock = flag5;
		WorldTile pTargetTile = pTileTarget;
		if (flag5 && pActor.current_path_global != null && pActor.current_path_global.Count > 4)
		{
			int index = 4;
			pTargetTile = pActor.current_path_global[index].getRandomTile();
		}
		World.world.calcPath(current_tile, pTargetTile, pActor.current_path);
		if (AStarFinder.result_split_path)
		{
			pActor.split_path = SplitPathStatus.Prepare;
		}
		if (flag5)
		{
			cleanRegionSearch(pActor);
		}
		if (pLimitPathfindingRegions > 0 && pActor.current_path_global != null)
		{
			pTileTarget = pActor.current_path_global.Last().getRandomTile();
		}
		pActor.setTileTarget(pTileTarget);
		return ExecuteEvent.True;
	}

	private static void lockRegionsForAStarSearch(Actor pActor, int pLimitPathfindingRegions)
	{
		int num = 0;
		List<MapRegion> current_path_global = pActor.current_path_global;
		int limitedPathfindingRegions = getLimitedPathfindingRegions(current_path_global, pLimitPathfindingRegions);
		for (int i = 0; i < limitedPathfindingRegions; i++)
		{
			MapRegion mapRegion = current_path_global[i];
			mapRegion.used_by_path_lock = true;
			mapRegion.region_path_id = num++;
		}
		if (limitedPathfindingRegions < current_path_global.Count)
		{
			current_path_global.RemoveRange(limitedPathfindingRegions, current_path_global.Count - limitedPathfindingRegions);
		}
	}

	private static int getLimitedPathfindingRegions(List<MapRegion> pPath, int pLimitPathfindingRegions)
	{
		if (pLimitPathfindingRegions <= 0)
		{
			return pPath.Count;
		}
		return Mathf.Min(pPath.Count, pLimitPathfindingRegions);
	}

	private static void cleanRegionSearch(Actor pActor)
	{
		if (pActor.current_path_global != null)
		{
			List<MapRegion> current_path_global = pActor.current_path_global;
			for (int i = 0; i < current_path_global.Count; i++)
			{
				MapRegion mapRegion = current_path_global[i];
				mapRegion.used_by_path_lock = false;
				mapRegion.region_path_id = -1;
			}
		}
		MapRegion region = pActor.current_tile.region;
		region.used_by_path_lock = false;
		region.region_path_id = -1;
	}

	public unsafe static ExecuteEvent goToCurved(Actor pActor, params WorldTile[] pTargets)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		Span<Vector3> span;
		if (pTargets.Length < 128)
		{
			int num = pTargets.Length;
			span = new Span<Vector3>(stackalloc Vector3[num], num);
		}
		else
		{
			span = (Vector3[]?)(object)new Vector3[pTargets.Length];
		}
		Span<Vector3> pPoints = span;
		for (int i = 0; i < pTargets.Length; i++)
		{
			pPoints[i] = pTargets[i].posV3;
		}
		pActor.clearOldPath();
		float num2 = 0f;
		for (int j = 1; j < pTargets.Length; j++)
		{
			WorldTile pT = pTargets[j - 1];
			WorldTile pT2 = pTargets[j];
			num2 += Toolbox.DistTile(pT, pT2);
		}
		float num3 = (int)(num2 / 4f);
		num3 = Mathf.Clamp(num3, 5f, 100f);
		for (int k = 0; (float)k < num3; k++)
		{
			Vector2 pPos = Toolbox.cubeBezierN(Toolbox.easeInOutQuart((float)(k + 1) / num3), pPoints);
			Toolbox.clampToMap(ref pPos);
			WorldTile tileSimple = World.world.GetTileSimple((int)pPos.x, (int)pPos.y);
			if (pActor.current_path.Count <= 0 || pActor.current_path.Last() != tileSimple)
			{
				pActor.current_path.Add(tileSimple);
			}
		}
		WorldTile worldTile = pTargets.Last();
		pActor.current_path.Add(worldTile);
		World.world.path_finding_visualiser.showPath(null, pActor.current_path);
		pActor.setTileTarget(worldTile);
		return ExecuteEvent.True;
	}
}
// --- End of File: ActorMove.cs ---



// --- Start of File: ActorRenderData.cs ---
using UnityEngine;

public class ActorRenderData
{
	public Vector3[] positions;

	public Vector3[] scales;

	public Vector3[] rotations;

	public Color[] colors;

	public bool[] has_normal_render;

	public Sprite[] main_sprites;

	public Sprite[] main_sprite_colored;

	public Material[] materials;

	public bool[] flip_x_states;

	public bool[] shadows;

	public Vector3[] shadow_position;

	public Vector3[] shadow_scales;

	public Sprite[] shadow_sprites;

	public bool[] has_item;

	public Vector3[] item_scale;

	public Vector3[] item_pos;

	public Sprite[] item_sprites;

	public ActorRenderData(int pCapacity)
	{
		checkSize(pCapacity);
	}

	public void checkSize(int pTargetSize)
	{
		if (positions == null || positions.Length < pTargetSize)
		{
			positions = Toolbox.checkArraySize(positions, pTargetSize);
			scales = Toolbox.checkArraySize(scales, pTargetSize);
			rotations = Toolbox.checkArraySize(rotations, pTargetSize);
			colors = Toolbox.checkArraySize(colors, pTargetSize);
			has_normal_render = Toolbox.checkArraySize(has_normal_render, pTargetSize);
			main_sprites = Toolbox.checkArraySize(main_sprites, pTargetSize);
			main_sprite_colored = Toolbox.checkArraySize(main_sprite_colored, pTargetSize);
			materials = Toolbox.checkArraySize(materials, pTargetSize);
			flip_x_states = Toolbox.checkArraySize(flip_x_states, pTargetSize);
			shadows = Toolbox.checkArraySize(shadows, pTargetSize);
			shadow_sprites = Toolbox.checkArraySize(shadow_sprites, pTargetSize);
			shadow_position = Toolbox.checkArraySize(shadow_position, pTargetSize);
			shadow_scales = Toolbox.checkArraySize(shadow_scales, pTargetSize);
			has_item = Toolbox.checkArraySize(has_item, pTargetSize);
			item_scale = Toolbox.checkArraySize(item_scale, pTargetSize);
			item_pos = Toolbox.checkArraySize(item_pos, pTargetSize);
			item_sprites = Toolbox.checkArraySize(item_sprites, pTargetSize);
		}
	}
}
// --- End of File: ActorRenderData.cs ---



// --- Start of File: ActorSelectedContainerEquipment.cs ---
using UnityEngine;

public class ActorSelectedContainerEquipment : SelectedElementBase<EquipmentButton>
{
	[SerializeField]
	private EquipmentButton _prefab_equipment;

	private void Awake()
	{
		_pool = new ObjectPoolGenericMono<EquipmentButton>(_prefab_equipment, _grid);
	}

	public void update(Actor pActor)
	{
		if (!pActor.hasEquipment())
		{
			clear();
		}
		else
		{
			refresh(pActor);
		}
	}

	protected override void refresh(NanoObject pNano)
	{
		clear();
		foreach (Item item in ((Actor)pNano).equipment.getItems())
		{
			loadEquipmentButton(item);
		}
	}

	private void loadEquipmentButton(Item pItem)
	{
		_pool.getNext().load(pItem);
	}
}
// --- End of File: ActorSelectedContainerEquipment.cs ---



// --- Start of File: ActorSelectedContainerStatus.cs ---
using UnityEngine;

public class ActorSelectedContainerStatus : SelectedElementBase<StatusEffectButton>
{
	[SerializeField]
	private StatusEffectButton _prefab_status;

	private void Awake()
	{
		_pool = new ObjectPoolGenericMono<StatusEffectButton>(_prefab_status, _grid);
	}

	public void update(NanoObject pNano)
	{
		refresh(pNano);
	}

	protected override void refresh(NanoObject pNano)
	{
		clear();
		foreach (Status status in ((Actor)pNano).getStatuses())
		{
			if (!status.is_finished)
			{
				loadStatusButton(status);
			}
		}
	}

	private void loadStatusButton(Status pStatus)
	{
		StatusEffectButton next = _pool.getNext();
		next.load(pStatus);
		next.setUpdatableTooltip(pState: true);
	}
}
// --- End of File: ActorSelectedContainerStatus.cs ---



// --- Start of File: ActorSelectedContainerTraits.cs ---
using System.Collections.Generic;

public class ActorSelectedContainerTraits : SelectedContainerTraits<ActorTrait, ActorTraitButton, ActorTraitsContainer, ActorTraitsEditor>
{
	protected override MetaType meta_type => MetaType.Unit;

	protected override IReadOnlyCollection<ActorTrait> getTraits()
	{
		return SelectedUnit.unit.getTraits();
	}

	protected override bool canEditTraits()
	{
		return SelectedUnit.unit.asset.can_edit_traits;
	}
}
// --- End of File: ActorSelectedContainerTraits.cs ---



// --- Start of File: ActorSelectedMetaBanners.cs ---
public class ActorSelectedMetaBanners : UnitMetaBanners, ISelectedTabBanners<Actor>
{
	public void update(Actor pActor)
	{
		setActor(pActor);
		clear();
		foreach (MetaBannerElement banner in _banners)
		{
			if (banner.check())
			{
				metaBannerShow(banner);
			}
		}
	}

	protected override void checkSetActor()
	{
	}

	protected override void OnEnable()
	{
	}

	protected override void checkSetWindow()
	{
	}

	public int countVisibleBanners()
	{
		return base.visible_banners;
	}
}
// --- End of File: ActorSelectedMetaBanners.cs ---



// --- Start of File: ActorSex.cs ---
public enum ActorSex
{
	Male,
	Female,
	None
}
// --- End of File: ActorSex.cs ---



// --- Start of File: ActorSimpleComponent.cs ---
using System;

public abstract class ActorSimpleComponent : IDisposable
{
	internal Actor actor;

	internal virtual void create(Actor pActor)
	{
		actor = pActor;
	}

	public virtual void update(float pElapsed)
	{
	}

	public virtual void Dispose()
	{
		actor = null;
	}
}
// --- End of File: ActorSimpleComponent.cs ---



// --- Start of File: ActorSize.cs ---
public enum ActorSize
{
	S0_Bug,
	S1_Egg,
	S2_Crab,
	S3_Rat,
	S4_Piranha,
	S5_Snake,
	S6_Chicken,
	S7_Cat,
	S8_Fox,
	S9_Monkey,
	S10_Dog,
	S11_Sheep,
	S12_Wolf,
	S13_Human,
	S14_Cow,
	S15_Bear,
	S16_Buffalo,
	S17_Dragon
}
// --- End of File: ActorSize.cs ---



// --- Start of File: ActorTaskLibrary.cs ---
namespace ai.behaviours;

public class ActorTaskLibrary : BehaviourTaskActorLibrary
{
}
// --- End of File: ActorTaskLibrary.cs ---



// --- Start of File: ActorTextureSubAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

[Serializable]
public class ActorTextureSubAsset : ICloneable
{
	[DefaultValue("male_1")]
	public const string skin_civ_default_male = "male_1";

	[DefaultValue("female_1")]
	public const string skin_civ_default_female = "female_1";

	public static List<Sprite> all_preloaded_sprites_units = new List<Sprite>();

	[NonSerialized]
	public readonly Dictionary<string, Sprite[]> dict_mains = new Dictionary<string, Sprite[]>();

	private static Dictionary<string, Sprite> _shadow_sprites = new Dictionary<string, Sprite>();

	public string texture_path_base;

	public string texture_path_base_male;

	public string texture_path_base_female;

	public string texture_path_main;

	public string texture_path_baby;

	public string texture_path_king;

	public string texture_path_leader;

	public string texture_path_warrior;

	public string texture_path_zombie;

	public bool has_advanced_textures;

	public bool has_old_heads;

	[DefaultValue("")]
	public string texture_heads = string.Empty;

	[DefaultValue("")]
	public string texture_head_king = string.Empty;

	[DefaultValue("")]
	public string texture_head_warrior = string.Empty;

	[DefaultValue("")]
	public string texture_heads_old_male = string.Empty;

	[DefaultValue("")]
	public string texture_heads_old_female = string.Empty;

	[DefaultValue("")]
	public string texture_heads_male = string.Empty;

	[DefaultValue("")]
	public string texture_heads_female = string.Empty;

	public bool render_heads_for_children;

	public bool prevent_unconscious_rotation;

	[DefaultValue(true)]
	public bool shadow = true;

	[DefaultValue("unitShadow_5")]
	public string shadow_texture = "unitShadow_5";

	[NonSerialized]
	internal Sprite shadow_sprite;

	[NonSerialized]
	internal Vector2 shadow_size;

	[DefaultValue("unitShadow_2")]
	public string shadow_texture_egg = "unitShadow_2";

	[NonSerialized]
	internal Sprite shadow_sprite_egg;

	[NonSerialized]
	internal Vector2 shadow_size_egg;

	[DefaultValue("unitShadow_4")]
	public string shadow_texture_baby = "unitShadow_4";

	[NonSerialized]
	internal Sprite shadow_sprite_baby;

	[NonSerialized]
	internal Vector2 shadow_size_baby;

	private string _base_path;

	private static int _total;

	private static readonly Regex _regex_heads_sorter = new Regex("(\\D*)(\\d+)");

	public ActorTextureSubAsset(string pBasePath, bool pHasAdvancedTextures)
	{
		_total++;
		has_advanced_textures = pHasAdvancedTextures;
		_base_path = pBasePath;
		texture_path_base = pBasePath;
		texture_path_base_male = pBasePath + "male_1";
		texture_path_base_female = pBasePath + "female_1";
		if (string.IsNullOrEmpty(texture_head_warrior))
		{
			texture_head_warrior = pBasePath + "head_warrior";
		}
		if (string.IsNullOrEmpty(texture_head_king))
		{
			texture_head_king = pBasePath + "head_king";
		}
		if (string.IsNullOrEmpty(texture_heads_old_female))
		{
			texture_heads_old_female = pBasePath + "head_old_female";
		}
		if (string.IsNullOrEmpty(texture_heads_old_male))
		{
			texture_heads_old_male = pBasePath + "head_old_male";
		}
		if (string.IsNullOrEmpty(texture_heads_male))
		{
			texture_heads_male = pBasePath + "heads_male";
		}
		if (string.IsNullOrEmpty(texture_heads_female))
		{
			texture_heads_female = pBasePath + "heads_female";
		}
		texture_path_main = pBasePath + "main";
		if (!hasSpriteInResources(texture_path_main))
		{
			texture_path_main = texture_path_base_male;
		}
		if (string.IsNullOrEmpty(texture_path_king))
		{
			texture_path_king = pBasePath + "king";
		}
		if (string.IsNullOrEmpty(texture_path_leader))
		{
			texture_path_leader = pBasePath + "leader";
		}
		if (string.IsNullOrEmpty(texture_path_warrior))
		{
			texture_path_warrior = pBasePath + "warrior_1";
		}
		if (string.IsNullOrEmpty(texture_path_zombie))
		{
			texture_path_zombie = pBasePath + "zombie";
		}
		if (string.IsNullOrEmpty(texture_heads))
		{
			texture_heads = pBasePath + "heads";
			if (!hasSpriteInResources(texture_path_main))
			{
				texture_path_main = texture_heads_male;
			}
		}
		if (hasSpriteInResources(texture_heads_old_male))
		{
			has_old_heads = true;
		}
		texture_path_baby = pBasePath + "child";
	}

	private void logAssetError(string pMessage, string pPath)
	{
		BaseAssetLibrary.logAssetError(pMessage, pPath);
	}

	public string getUnitTexturePath(Actor pActor)
	{
		Subspecies subspecies = pActor.subspecies;
		if (pActor.isEgg())
		{
			return subspecies.egg_sprite_path;
		}
		if (pActor.isBaby())
		{
			return texture_path_baby;
		}
		if (pActor.hasSubspecies() && pActor.subspecies.has_mutation_reskin && pActor.asset.unit_zombie)
		{
			return texture_path_zombie;
		}
		string result = texture_path_main;
		ProfessionAsset profession_asset = pActor.profession_asset;
		if (profession_asset == null || profession_asset.profession_id == UnitProfession.Nothing)
		{
			return result;
		}
		if (!has_advanced_textures)
		{
			return result;
		}
		switch (profession_asset.profession_id)
		{
		case UnitProfession.Warrior:
		{
			string text = texture_path_warrior;
			if (pActor.hasSubspecies())
			{
				text = pActor.subspecies.getSkinWarrior();
			}
			if (subspecies.has_mutation_reskin)
			{
				List<string> skin_warrior = subspecies.mutation_skin_asset.skin_warrior;
				int index = Toolbox.loopIndex(pActor.asset.skin_warrior.IndexOf(text), skin_warrior.Count);
				text = skin_warrior[index];
			}
			return texture_path_base + text;
		}
		case UnitProfession.King:
			return texture_path_king;
		case UnitProfession.Leader:
			return texture_path_leader;
		default:
			return getTextureSkinBasedOnSex(pActor);
		}
	}

	private string getTextureSkinBasedOnSex(Actor pActor)
	{
		if (pActor.isSexFemale())
		{
			if (pActor.hasSubspecies())
			{
				return texture_path_base + pActor.subspecies.getSkinFemale();
			}
			return texture_path_base_female;
		}
		if (pActor.hasSubspecies())
		{
			return texture_path_base + pActor.subspecies.getSkinMale();
		}
		return texture_path_base_male;
	}

	public string getUnitTexturePathForUI(ActorAsset pAsset)
	{
		string result = texture_path_main;
		if (!pAsset.civ)
		{
			return result;
		}
		if (AssetsDebugManager.actors_sex == ActorSex.Male)
		{
			return texture_path_base + pAsset.skin_citizen_male[0];
		}
		return texture_path_base + pAsset.skin_citizen_female[0];
	}

	private bool hasSpriteInResources(string pPath)
	{
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pPath, pSkipIfEmpty: true);
		if (spriteList == null)
		{
			return false;
		}
		all_preloaded_sprites_units.AddRange(spriteList);
		return spriteList.Length != 0;
	}

	public object Clone()
	{
		return new ActorTextureSubAsset(_base_path, has_advanced_textures);
	}

	public void preloadSprites(bool pCivTextures, bool pHasBabyForm, IAnimationFrames pAnimationAsset)
	{
		if (!pCivTextures)
		{
			preloadSpritePath("texture_path_main", texture_path_main, pAnimationAsset);
		}
		if (pHasBabyForm)
		{
			preloadSpritePath("texture_path_baby", texture_path_baby, pAnimationAsset);
		}
		if (has_advanced_textures)
		{
			preloadSpritePath("texture_path_base_male", texture_path_base_male, pAnimationAsset);
			preloadSpritePath("texture_path_base_female", texture_path_base_female, pAnimationAsset);
			preloadSpritePath("texture_path_king", texture_path_king, pAnimationAsset);
			preloadSpritePath("texture_path_leader", texture_path_leader, pAnimationAsset);
			preloadSpritePath("texture_path_warrior", texture_path_warrior, pAnimationAsset);
			preloadSpritePath("texture_head_king", texture_head_king, pAnimationAsset, pLoadHeads: true, pThrowError: true, pSpecialHead: true);
			preloadSpritePath("texture_head_warrior", texture_head_warrior, pAnimationAsset, pLoadHeads: true, pThrowError: true, pSpecialHead: true);
			preloadSpritePath("texture_heads_male", texture_heads_male, pAnimationAsset, pLoadHeads: true);
			preloadSpritePath("texture_heads_female", texture_heads_female, pAnimationAsset, pLoadHeads: true);
		}
		else
		{
			preloadSpritePath("texture_heads", texture_heads, pAnimationAsset, pLoadHeads: true, pThrowError: false);
		}
	}

	private bool preloadSpritePath(string pType, string pPath, IAnimationFrames pAnimationAsset, bool pLoadHeads = false, bool pThrowError = true, bool pSpecialHead = false)
	{
		if (string.IsNullOrEmpty(pPath))
		{
			return false;
		}
		if (dict_mains.ContainsKey(pPath))
		{
			return false;
		}
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pPath);
		if (!pLoadHeads)
		{
			dict_mains.Add(pPath, spriteList);
		}
		all_preloaded_sprites_units.AddRange(spriteList);
		if (spriteList.Length == 0)
		{
			if (pThrowError)
			{
				logAssetError("ActorAssetLibrary: <e>" + pType + "</e> doesn't exist for <e>" + ((Asset)pAnimationAsset).id + "</e> at ", pPath);
			}
			return false;
		}
		if (pLoadHeads)
		{
			if (has_advanced_textures)
			{
				for (int i = 0; i < spriteList.Length; i++)
				{
					if (pSpecialHead)
					{
						ActorAnimationLoader.getHeadSpecial(pPath);
					}
					else
					{
						ActorAnimationLoader.getHead(pPath, i);
					}
				}
			}
			checkHeads(spriteList, pPath, pAnimationAsset);
		}
		else
		{
			checkAnimations(spriteList, pPath, (Asset)pAnimationAsset, pAnimationAsset);
		}
		return true;
	}

	internal void loadShadow()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = (shadow_sprite = getShadowSprite(shadow_texture)).rect;
		shadow_size = ((Rect)(ref rect)).size;
		rect = (shadow_sprite_egg = getShadowSprite(shadow_texture_egg)).rect;
		shadow_size_egg = ((Rect)(ref rect)).size;
		rect = (shadow_sprite_baby = getShadowSprite(shadow_texture_baby)).rect;
		shadow_size_baby = ((Rect)(ref rect)).size;
	}

	private Sprite getShadowSprite(string pTexturePath)
	{
		if (!_shadow_sprites.ContainsKey(pTexturePath))
		{
			Sprite sprite = SpriteTextureLoader.getSprite("shadows/" + pTexturePath);
			if ((Object)(object)sprite == (Object)null)
			{
				Debug.LogError((object)("Shadow not found " + pTexturePath));
			}
			_shadow_sprites.Add(pTexturePath, sprite);
		}
		Sprite obj = _shadow_sprites[pTexturePath];
		return DynamicSprites.getShadowUnit(obj, ((object)obj).GetHashCode());
	}

	private void checkHeads(Sprite[] pSprites, string pPath, IAnimationFrames pAnimationAsset)
	{
		using ListPool<string> listPool = new ListPool<string>();
		for (int i = 0; i < pSprites.Length; i++)
		{
			string name = ((Object)pSprites[i]).name;
			if (name.Any(char.IsDigit))
			{
				if (listPool.Contains(name))
				{
					Debug.LogError((object)("Duplicate head " + name));
				}
				listPool.Add(name);
			}
		}
		listPool.Sort(headSorter);
		string text = "";
		int num = -1;
		foreach (ref string item in listPool)
		{
			string[] array = item.Split("_");
			string text2 = array[0];
			if (!int.TryParse(array[1], out var result))
			{
				continue;
			}
			if (text2 != text)
			{
				text = text2;
				if (result != 0)
				{
					logAssetError("ActorAssetLibrary: <e>" + ((Asset)pAnimationAsset).id + "</e> missing head: <e>" + text2 + "_0</e> at ", pPath);
				}
			}
			else if (result != num + 1)
			{
				logAssetError($"ActorAssetLibrary: <e>{((Asset)pAnimationAsset).id}</e> missing head: <e>{text2}_{num + 1}</e> at ", pPath);
			}
			num = result;
		}
	}

	private int headSorter(string x, string y)
	{
		Match match = _regex_heads_sorter.Match(x);
		Match match2 = _regex_heads_sorter.Match(y);
		if (match.Success && match2.Success && match.Groups[1].Value == match2.Groups[1].Value && int.TryParse(match.Groups[2].Value, out var result) && int.TryParse(match2.Groups[2].Value, out var result2))
		{
			return result.CompareTo(result2);
		}
		return x.CompareTo(y);
	}

	private void checkAnimations(Sprite[] pSprites, string pPath, Asset pAsset, IAnimationFrames pAnimationFrames)
	{
		using ListPool<string> listPool = new ListPool<string>();
		foreach (Sprite val in pSprites)
		{
			listPool.Add(((Object)val).name);
		}
		using ListPool<string> listPool2 = new ListPool<string>();
		string[] walk = pAnimationFrames.getWalk();
		string[] walk2;
		if (walk != null && walk.Length != 0)
		{
			listPool2.Clear();
			bool flag = false;
			walk2 = pAnimationFrames.getWalk();
			foreach (string item in walk2)
			{
				if (!listPool.Contains(item))
				{
					listPool2.Add(item);
				}
				else
				{
					flag = true;
				}
			}
			if (!flag)
			{
				logAssetError("ActorAssetLibrary: <e>" + pAsset.id + "</e> missing all animation_walk sprites: <e>" + string.Join(", ", listPool2) + "</e> at ", pPath);
			}
		}
		string[] swim = pAnimationFrames.getSwim();
		if (swim != null && swim.Length != 0)
		{
			listPool2.Clear();
			bool flag2 = false;
			walk2 = pAnimationFrames.getSwim();
			foreach (string item2 in walk2)
			{
				if (!listPool.Contains(item2))
				{
					listPool2.Add(item2);
				}
				else
				{
					flag2 = true;
				}
			}
			if (!flag2)
			{
				logAssetError("ActorAssetLibrary: <e>" + pAsset.id + "</e> missing all animation_swim sprites: <e>" + string.Join(", ", listPool2) + "</e> at ", pPath);
			}
		}
		string[] idle = pAnimationFrames.getIdle();
		if (idle == null || idle.Length == 0)
		{
			return;
		}
		listPool2.Clear();
		bool flag3 = false;
		walk2 = pAnimationFrames.getIdle();
		foreach (string item3 in walk2)
		{
			if (!listPool.Contains(item3))
			{
				listPool2.Add(item3);
			}
			else
			{
				flag3 = true;
			}
		}
		if (!flag3)
		{
			logAssetError("ActorAssetLibrary: <e>" + pAsset.id + "</e> missing all animation_idle sprites: <e>" + string.Join(", ", listPool2) + "</e> at ", pPath);
		}
	}

	public static int getTotal()
	{
		return _total;
	}
}
// --- End of File: ActorTextureSubAsset.cs ---



// --- Start of File: ActorTileTarget.cs ---
namespace ai;

public enum ActorTileTarget
{
	RandomTNT,
	RandomBurnableTile,
	RandomTileWithUnits,
	RandomTileWithCivStructures
}
// --- End of File: ActorTileTarget.cs ---



// --- Start of File: ActorTool.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ai;

public static class ActorTool
{
	public static int countContagiousNearby(Actor pActor)
	{
		int num = 0;
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, 1, 10f))
		{
			if (item.hasTrait("contagious"))
			{
				num++;
			}
		}
		return num;
	}

	public static Building findNewBuildingTarget(Actor pActor, string pType, bool pOnlyFreeTile = true)
	{
		using ListPool<Building> listPool = new ListPool<Building>(64);
		switch (pType)
		{
		case "new_building":
		{
			Building buildingToBuild = pActor.city.getBuildingToBuild();
			if (buildingToBuild != null && buildingToBuild.tiles.Count != 0)
			{
				WorldTile constructionTile = buildingToBuild.getConstructionTile();
				if (constructionTile != null && constructionTile.isSameIsland(pActor.current_tile))
				{
					return buildingToBuild;
				}
			}
			break;
		}
		case "random_house_building":
			foreach (Building item in pActor.city.buildings.LoopRandom())
			{
				if (item.isSameIslandAs(pActor) && !item.isUnderConstruction() && item.isUsable() && item.asset.hasHousingSlots())
				{
					return item;
				}
			}
			break;
		case "ruins":
			foreach (TileZone item2 in pActor.city.zones.LoopRandom())
			{
				HashSet<Building> hashset = item2.getHashset(BuildingList.Ruins);
				if (hashset != null)
				{
					listPool.AddRange(hashset);
				}
				HashSet<Building> hashset2 = item2.getHashset(BuildingList.Abandoned);
				if (hashset2 != null)
				{
					listPool.AddRange(hashset2);
				}
				if (listPool.Count > 0)
				{
					break;
				}
			}
			break;
		case "type_mine":
		case "type_bonfire":
		case "type_training_dummies":
		{
			Building buildingOfType = pActor.city.getBuildingOfType(pType, pCountOnlyFinished: true, pRandom: false, pOnlyFreeTile, pActor.current_island);
			if (buildingOfType != null)
			{
				return buildingOfType;
			}
			break;
		}
		default:
			return findNewTargetInZones(pActor, pType, listPool);
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	public static Building findNewTargetInZones(Actor pActor, string pType, ListPool<Building> pPossibleBuildings)
	{
		foreach (TileZone zone in pActor.city.zones)
		{
			HashSet<Building> hashSet = null;
			switch (pType)
			{
			case "type_flower":
			case "type_vegetation":
				hashSet = zone.getHashset(BuildingList.Flora);
				break;
			case "type_tree":
				hashSet = zone.getHashset(BuildingList.Trees);
				break;
			case "type_mineral":
				hashSet = zone.getHashset(BuildingList.Minerals);
				break;
			case "type_fruits":
				hashSet = zone.getHashset(BuildingList.Food);
				break;
			case "type_hive":
				hashSet = zone.getHashset(BuildingList.Hives);
				break;
			case "type_poop":
				hashSet = zone.getHashset(BuildingList.Poops);
				break;
			}
			if (hashSet == null || hashSet.Count == 0)
			{
				continue;
			}
			foreach (Building item in hashSet)
			{
				BuildingAsset asset = item.asset;
				if (!item.current_tile.isTargeted() && item.isSameIslandAs(pActor) && ((asset.building_type != BuildingType.Building_Fruits && asset.building_type != BuildingType.Building_Tree) || item.hasResourcesToCollect()) && (asset.building_type != BuildingType.Building_Tree || asset.can_be_chopped_down))
				{
					pPossibleBuildings.Add(item);
				}
			}
			if (pPossibleBuildings.Count > 0)
			{
				break;
			}
		}
		if (pPossibleBuildings.Count == 0)
		{
			return null;
		}
		return pPossibleBuildings.GetRandom();
	}

	public static WorldTile getTileNearby(ActorTileTarget pTarget, MapChunk pChunk)
	{
		ListPool<WorldTile> tPossibleMoves = new ListPool<WorldTile>(64);
		try
		{
			(MapChunk[], int) allChunksFromChunk = Toolbox.getAllChunksFromChunk(pChunk);
			MapChunk[] item = allChunksFromChunk.Item1;
			int item2 = allChunksFromChunk.Item2;
			for (int i = 0; i < item2; i++)
			{
				MapChunk mapChunk = item[i];
				if (tPossibleMoves.Count > 20)
				{
					continue;
				}
				WorldTile[] tiles = mapChunk.tiles;
				int num = tiles.Length;
				for (int j = 0; j < num; j++)
				{
					WorldTile tTile = tiles[j];
					if (tPossibleMoves.Count > 20)
					{
						continue;
					}
					switch (pTarget)
					{
					case ActorTileTarget.RandomTNT:
						if (tTile.Type.explodable)
						{
							tPossibleMoves.Add(tTile);
						}
						break;
					case ActorTileTarget.RandomTileWithUnits:
						tTile.doUnits(delegate
						{
							tPossibleMoves.Add(tTile);
						});
						break;
					case ActorTileTarget.RandomBurnableTile:
						if (tTile.Type.burnable)
						{
							tPossibleMoves.Add(tTile);
						}
						break;
					case ActorTileTarget.RandomTileWithCivStructures:
						if (tTile.hasBuilding() && tTile.building.hasCity())
						{
							tPossibleMoves.Add(tTile);
						}
						if (tTile.Type.burnable && tTile.zone.city != null)
						{
							tPossibleMoves.Add(tTile);
						}
						break;
					}
				}
			}
			if (tPossibleMoves.Count == 0)
			{
				return null;
			}
			return tPossibleMoves.GetRandom();
		}
		finally
		{
			if (tPossibleMoves != null)
			{
				((IDisposable)tPossibleMoves).Dispose();
			}
		}
	}

	public static Docks getDockTradeTarget(Actor pActor)
	{
		return getDockTradeTarget(pActor.current_tile, pActor);
	}

	private static Docks getDockTradeTarget(WorldTile pTile, Actor pActor)
	{
		return getDockTradeTarget(pTile.region, pActor);
	}

	private static Docks getDockTradeTarget(MapRegion pRegion, Actor pActor)
	{
		return getDockTradeTarget(pRegion.island, pActor);
	}

	private static Docks getDockTradeTarget(TileIsland pIsland, Actor pActor)
	{
		return getDockTradeTarget(pIsland.docks, pActor);
	}

	private static Docks getDockTradeTarget(ListPool<Docks> pList, Actor pActor)
	{
		if (pList == null || pList.Count == 0)
		{
			return null;
		}
		foreach (Docks item in pList.LoopRandom())
		{
			if (item.building.hasCity() && pActor.getHomeBuilding() != item.building && item.building.isUsable() && !item.building.isAbandoned() && !item.building.city.kingdom.isEnemy(pActor.kingdom) && (item.isDockGood() || item.hasOceanTiles()))
			{
				return item;
			}
		}
		return null;
	}

	public static WorldTile getRandomTileForBoat(Actor pActor)
	{
		MapRegion mapRegion = pActor.current_tile.region;
		if (mapRegion.neighbours.Count > 0 && Randy.randomBool())
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			return mapRegion.tiles.GetRandom();
		}
		return null;
	}

	public static int attributeDice(Actor pActor, int pAmount = 2)
	{
		if (pActor == null)
		{
			return int.MinValue;
		}
		int num = 0;
		int num2 = (int)(pActor.stats["diplomacy"] + pActor.stats["warfare"] + pActor.stats["stewardship"]);
		if (pActor.hasCulture())
		{
			Culture culture = pActor.culture;
			bool flag = culture.hasTrait("patriarchy");
			bool num3 = culture.hasTrait("matriarchy");
			if (flag && pActor.isSexMale())
			{
				num2 += 999;
			}
			if (num3 && pActor.isSexFemale())
			{
				num2 += 999;
			}
		}
		for (int i = 0; i < pAmount; i++)
		{
			num += Randy.randomInt(0, num2);
		}
		return num;
	}

	public static void checkHomeDocks(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding == null)
		{
			ListPool<Docks> docks = pActor.current_tile.region.island.docks;
			if (docks != null && docks.Count > 0)
			{
				for (int i = 0; i < docks.Count; i++)
				{
					Docks docks2 = docks[i];
					if (docks2.building.isUsable() && !docks2.building.isAbandoned() && !docks2.building.isUnderConstruction() && docks2.building.hasCity() && docks2.building.city.kingdom == pActor.kingdom && !docks2.building.city.kingdom.isEnemy(pActor.kingdom) && !docks2.isFull(pActor.asset.boat_type))
					{
						docks2.addBoatToDock(pActor);
						return;
					}
				}
			}
		}
		if (homeBuilding == null)
		{
			return;
		}
		if (!homeBuilding.isSameIslandAs(pActor))
		{
			pActor.clearHomeBuilding();
			return;
		}
		Docks component_docks = homeBuilding.component_docks;
		if (!component_docks.isDockGood() && !component_docks.hasOceanTiles())
		{
			pActor.clearHomeBuilding();
		}
	}

	public static void copyImportantData(ActorData pFrom, ActorData pCloneTo, bool pCopyAge)
	{
		pCloneTo.name = pFrom.name;
		pCloneTo.custom_name = pFrom.custom_name;
		if (pCopyAge)
		{
			pCloneTo.created_time = pFrom.created_time;
			pCloneTo.age_overgrowth = pFrom.age_overgrowth;
		}
		pCloneTo.asset_id = pFrom.asset_id;
		pCloneTo.kills = pFrom.kills;
		pCloneTo.births = pFrom.births;
		pCloneTo.favorite = pFrom.favorite;
		pCloneTo.food_consumed = pFrom.food_consumed;
		pCloneTo.favorite_food = pFrom.favorite_food;
		pCloneTo.head = pFrom.head;
		pCloneTo.generation = pFrom.generation;
		pCloneTo.parent_id_1 = pFrom.parent_id_1;
		pCloneTo.parent_id_2 = pFrom.parent_id_2;
		pCloneTo.ancestor_family = pFrom.ancestor_family;
		pCloneTo.best_friend_id = pFrom.best_friend_id;
		pCloneTo.lover = pFrom.lover;
		pCloneTo.experience = pFrom.experience;
		pCloneTo.renown = pFrom.renown;
		pCloneTo.loot = pFrom.loot;
		pCloneTo.money = pFrom.money;
		pCloneTo.level = pFrom.level;
		pCloneTo.sex = pFrom.sex;
		pCloneTo.phenotype_shade = pFrom.phenotype_shade;
		pCloneTo.phenotype_index = pFrom.phenotype_index;
		pCloneTo["diplomacy"] = pFrom["diplomacy"];
		pCloneTo["intelligence"] = pFrom["intelligence"];
		pCloneTo["stewardship"] = pFrom["stewardship"];
		pCloneTo["warfare"] = pFrom["warfare"];
	}

	public static void copyUnitToOtherUnit(Actor pParent, Actor pCloneTarget, bool pCopyAge = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		pCloneTarget.current_position = pParent.current_position;
		pCloneTarget.current_rotation = pParent.current_rotation;
		copyImportantData(pParent.data, pCloneTarget.data, pCopyAge);
		pCloneTarget.takeItems(pParent);
		foreach (ActorTrait trait in pParent.getTraits())
		{
			pCloneTarget.addTrait(trait);
		}
		pCloneTarget.setStatsDirty();
		if (MoveCamera.inSpectatorMode() && pParent.isCameraFollowingUnit())
		{
			MoveCamera.setFocusUnit(pCloneTarget);
		}
	}

	public static bool canBeCuredFromTraitsOrStatus(Actor pActor)
	{
		foreach (ActorTrait trait in pActor.getTraits())
		{
			if (trait.can_be_cured)
			{
				return true;
			}
		}
		if (pActor.hasAnyStatusEffect())
		{
			foreach (Status status in pActor.getStatuses())
			{
				if (status.asset.can_be_cured)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static void applyForceToUnit(AttackData pData, BaseSimObject pTargetToCheck, float pMod = 1f, bool pCheckCancelJobOnLand = false)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		float num = pData.knockback * pMod;
		if (num > 0f && pTargetToCheck.isActor())
		{
			Vector2 val = Vector2.op_Implicit(pTargetToCheck.cur_transform_position);
			Vector2 val2 = Vector2.op_Implicit(pData.hit_position);
			pTargetToCheck.a.calculateForce(val.x, val.y, val2.x, val2.y, num, 0f, pCheckCancelJobOnLand);
		}
	}

	public static int countUnitsFrom(string pActorID)
	{
		return AssetManager.actor_library.get(pActorID).units.Count;
	}

	public static void checkFallInLove(Actor pActor, Actor pTarget)
	{
		if (pActor.canFallInLoveWith(pTarget) && pTarget.canFallInLoveWith(pActor))
		{
			pActor.becomeLoversWith(pTarget);
		}
	}

	public static void checkBecomingBestFriends(Actor pActor, Actor pTarget)
	{
		if (!pActor.hasBestFriend() && !pTarget.hasBestFriend() && (!pActor.isBaby() || !pTarget.isAdult()) && (!pActor.isAdult() || !pTarget.isBaby()))
		{
			float num = 0f;
			if (pActor.hasEmotions() && pTarget.hasEmotions())
			{
				float num2 = 1f - Mathf.Abs(pActor.getHappinessRatio() - pTarget.getHappinessRatio());
				num += num2 * 0.25f;
			}
			if (pActor.family == pTarget.family)
			{
				num += 0.1f;
			}
			num += calcLikeability(pActor, pTarget);
			if (!(num <= 0f) && Randy.randomChance(num))
			{
				pActor.setBestFriend(pTarget, pNew: true);
				pTarget.setBestFriend(pActor, pNew: true);
			}
		}
	}

	private static float calcLikeability(Actor pActor, Actor pTarget)
	{
		float num = 0f;
		foreach (ActorTrait trait in pActor.getTraits())
		{
			float num2 = 1f;
			if (trait.same_trait_mod != 0 && pTarget.hasTrait(trait))
			{
				num2 += (float)trait.same_trait_mod / 100f;
			}
			if (trait.opposite_trait_mod != 0)
			{
				foreach (ActorTrait opposite_trait in trait.opposite_traits)
				{
					if (pTarget.hasTrait(opposite_trait))
					{
						num2 += (float)trait.opposite_trait_mod / 100f;
					}
				}
			}
			num = ((trait.likeability != 0f) ? (num + trait.likeability * num2) : (num + num2 * 0.1f));
		}
		foreach (ActorTrait trait2 in pTarget.getTraits())
		{
			if (trait2.same_trait_mod == 0 && trait2.opposite_trait_mod == 0)
			{
				num += trait2.likeability;
			}
		}
		num *= 0.5f;
		if (pActor.areFoes(pTarget))
		{
			num -= 0.5f;
		}
		num = ((pActor.religion != pTarget.religion) ? (num - 0.25f) : (num + 0.1f));
		if (pActor.clan == pTarget.clan)
		{
			num += 0.1f;
		}
		if (pActor.culture == pTarget.culture)
		{
			num += 0.1f;
		}
		return num;
	}
}
// --- End of File: ActorTool.cs ---



// --- Start of File: ActorTrait.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

[Serializable]
public class ActorTrait : BaseTrait<ActorTrait>
{
	public int rate_birth;

	public int rate_acquire_grow_up;

	public bool acquire_grow_up_sapient_only;

	public int rate_inherit;

	public bool is_mutation_box_allowed = true;

	public int same_trait_mod;

	public int opposite_trait_mod;

	public bool only_active_on_era_flag;

	public bool era_active_moon;

	public bool era_active_night;

	[DefaultValue(TraitType.Other)]
	public TraitType type = TraitType.Other;

	public bool remove_for_zombie_actor_asset;

	public bool can_be_cured;

	public bool affects_mind;

	public bool is_kingdom_affected;

	[DefaultValue("")]
	public string forced_kingdom = string.Empty;

	public bool can_be_removed_by_divine_light;

	public bool can_be_removed_by_accelerated_healing;

	public float likeability;

	public bool in_training_dummy_combat_pot;

	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_actor;

	public override string typed_id => "trait";

	public override BaseCategoryAsset getGroup()
	{
		return AssetManager.trait_groups.get(group_id);
	}

	public int getRate(string pGroup)
	{
		if (pGroup == "body")
		{
			return rate_birth;
		}
		return rate_acquire_grow_up;
	}

	public Kingdom getForcedKingdom()
	{
		if (forced_kingdom == string.Empty)
		{
			Debug.LogError((object)("Shouldn't call this from a trait that doesn't have a forced kingdom! " + id));
			return null;
		}
		return World.world.kingdoms_wild.get(forced_kingdom);
	}

	protected override IEnumerable<ITraitsOwner<ActorTrait>> getRelatedMetaList()
	{
		return World.world.units;
	}

	public override string getCountRows()
	{
		return getCountRowsByCategories();
	}

	protected override bool isSapient(ITraitsOwner<ActorTrait> pObject)
	{
		return ((Actor)pObject).isSapient();
	}
}
// --- End of File: ActorTrait.cs ---



// --- Start of File: ActorTraitButton.cs ---
public class ActorTraitButton : TraitButton<ActorTrait>
{
	protected override string tooltip_type => "trait";

	internal override void load(string pTraitID)
	{
		ActorTrait pElement = AssetManager.traits.get(pTraitID);
		load(pElement);
	}

	protected override TooltipData tooltipDataBuilder()
	{
		return new TooltipData
		{
			trait = augmentation_asset
		};
	}
}
// --- End of File: ActorTraitButton.cs ---



// --- Start of File: ActorTraitEditorButton.cs ---
public class ActorTraitEditorButton : TraitEditorButton<ActorTraitButton, ActorTrait>
{
}
// --- End of File: ActorTraitEditorButton.cs ---



// --- Start of File: ActorTraitGroupAsset.cs ---
using System;

[Serializable]
public class ActorTraitGroupAsset : BaseTraitGroupAsset
{
}
// --- End of File: ActorTraitGroupAsset.cs ---



// --- Start of File: ActorTraitGroupElement.cs ---
public class ActorTraitGroupElement : TraitGroupElement<ActorTrait, ActorTraitButton, ActorTraitEditorButton>
{
}
// --- End of File: ActorTraitGroupElement.cs ---



// --- Start of File: ActorTraitGroupLibrary.cs ---
public class ActorTraitGroupLibrary : BaseCategoryLibrary<ActorTraitGroupAsset>
{
	public override void init()
	{
		base.init();
		add(new ActorTraitGroupAsset
		{
			id = "cognitive",
			name = "trait_group_cognitive",
			color = "#5EFFFF"
		});
		add(new ActorTraitGroupAsset
		{
			id = "mind",
			name = "trait_group_mind",
			color = "#BAF0F4"
		});
		add(new ActorTraitGroupAsset
		{
			id = "spirit",
			name = "trait_group_spirit",
			color = "#BC42FF"
		});
		add(new ActorTraitGroupAsset
		{
			id = "physique",
			name = "trait_group_physique",
			color = "#FF6145"
		});
		add(new ActorTraitGroupAsset
		{
			id = "health",
			name = "trait_group_health",
			color = "#89FF56"
		});
		add(new ActorTraitGroupAsset
		{
			id = "body",
			name = "trait_group_body",
			color = "#FF6B86"
		});
		add(new ActorTraitGroupAsset
		{
			id = "appearance",
			name = "trait_group_appearance",
			color = "#FF6DEB"
		});
		add(new ActorTraitGroupAsset
		{
			id = "protection",
			name = "trait_group_protection",
			color = "#FF6B86"
		});
		add(new ActorTraitGroupAsset
		{
			id = "skills",
			name = "trait_group_skills",
			color = "#BCBCBC"
		});
		add(new ActorTraitGroupAsset
		{
			id = "merits",
			name = "trait_group_merits",
			color = "#FFDA23"
		});
		add(new ActorTraitGroupAsset
		{
			id = "acquired",
			name = "trait_group_acquired",
			color = "#A3AFFF"
		});
		add(new ActorTraitGroupAsset
		{
			id = "fun",
			name = "trait_group_fun",
			color = "#FFFAA3"
		});
		add(new ActorTraitGroupAsset
		{
			id = "fate",
			name = "trait_group_fate",
			color = "#ffd82f"
		});
		add(new ActorTraitGroupAsset
		{
			id = "miscellaneous",
			name = "trait_group_miscellaneous",
			color = "#D8D8D8"
		});
		add(new ActorTraitGroupAsset
		{
			id = "special",
			name = "trait_group_special",
			color = "#FF8F44"
		});
	}
}
// --- End of File: ActorTraitGroupLibrary.cs ---



// --- Start of File: ActorTraitLibrary.cs ---
using System;
using System.Collections.Generic;
using Beebyte.Obfuscator;

[Serializable]
[ObfuscateLiterals]
public class ActorTraitLibrary : BaseTraitLibrary<ActorTrait>
{
	public const int COMBAT_SKILLS_AMOUNT = 5;

	[NonSerialized]
	public List<ActorTrait> pot_traits_mutation_box = new List<ActorTrait>();

	[NonSerialized]
	public List<ActorTrait> pot_traits_birth = new List<ActorTrait>();

	[NonSerialized]
	public List<ActorTrait> pot_traits_growup = new List<ActorTrait>();

	[NonSerialized]
	public List<ActorTrait> pot_traits_combat = new List<ActorTrait>();

	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	{
		return pAsset.traits;
	}

	public override void init()
	{
		base.init();
		addTraitsSpecial();
		addTraitsBody();
		addTraitsMind();
		addTraitsSpirit();
		addTraitsAcquired();
		addTraitsFun();
		addTraitsMisc();
	}

	private void addTraitsBody()
	{
		add(new ActorTrait
		{
			id = "dash",
			path_icon = "ui/Icons/skills/iconSkillDash",
			group_id = "skills",
			in_training_dummy_combat_pot = true
		});
		t.addCombatAction("combat_dash");
		add(new ActorTrait
		{
			id = "block",
			path_icon = "ui/Icons/skills/iconSkillBlock",
			group_id = "skills",
			in_training_dummy_combat_pot = true
		});
		t.addCombatAction("combat_block");
		add(new ActorTrait
		{
			id = "dodge",
			path_icon = "ui/Icons/skills/iconSkillDodge",
			group_id = "skills",
			in_training_dummy_combat_pot = true
		});
		t.addCombatAction("combat_dodge");
		add(new ActorTrait
		{
			id = "backstep",
			path_icon = "ui/Icons/skills/iconSkillBackstep",
			group_id = "skills",
			in_training_dummy_combat_pot = true
		});
		t.addCombatAction("combat_backstep");
		add(new ActorTrait
		{
			id = "deflect_projectile",
			path_icon = "ui/Icons/skills/iconSkillDeflectProjectile",
			group_id = "skills",
			in_training_dummy_combat_pot = true
		});
		t.addCombatAction("combat_deflect_projectile");
		add(new ActorTrait
		{
			id = "mute",
			path_icon = "ui/Icons/actor_traits/iconMute",
			group_id = "body",
			rate_birth = 1,
			rate_inherit = 5,
			likeability = -0.1f
		});
		add(new ActorTrait
		{
			id = "sunblessed",
			path_icon = "ui/Icons/actor_traits/iconSunblessed",
			group_id = "body",
			rate_birth = 2,
			rate_inherit = 5
		});
		t.special_effect_interval = 5f;
		ActorTrait actorTrait = t;
		actorTrait.action_special_effect = (WorldAction)Delegate.Combine(actorTrait.action_special_effect, new WorldAction(ActionLibrary.sunblessedEffect));
		add(new ActorTrait
		{
			id = "clumsy",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconClumsy",
			group_id = "physique",
			rate_birth = 5,
			rate_inherit = 5
		});
		t.addOpposite("long_liver");
		t.base_stats["multiplier_lifespan"] = -0.5f;
		add(new ActorTrait
		{
			id = "fragile_health",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconFrail",
			group_id = "health",
			rate_birth = 5,
			rate_inherit = 5
		});
		t.addOpposite("boosted_vitality");
		t.base_stats["multiplier_health"] = -0.5f;
		add(new ActorTrait
		{
			id = "boosted_vitality",
			path_icon = "ui/Icons/actor_traits/iconBoostedVitality",
			group_id = "health",
			rate_birth = 5,
			rate_inherit = 5
		});
		t.addOpposite("fragile_health");
		t.base_stats["multiplier_health"] = 0.5f;
		add(new ActorTrait
		{
			id = "hard_skin",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconHardSkin",
			group_id = "physique",
			rate_birth = 5,
			rate_inherit = 5
		});
		t.addOpposite("soft_skin");
		t.base_stats["armor"] = 5f;
		add(new ActorTrait
		{
			id = "soft_skin",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconSoftSkin",
			group_id = "physique",
			rate_birth = 5,
			rate_inherit = 5
		});
		t.addOpposite("hard_skin");
		t.base_stats["armor"] = -5f;
		add(new ActorTrait
		{
			id = "long_liver",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconLongLiver",
			group_id = "health",
			rate_birth = 2,
			rate_inherit = 5
		});
		t.addOpposite("clumsy");
		t.base_stats["multiplier_lifespan"] = 0.5f;
		add(new ActorTrait
		{
			id = "acid_touch",
			path_icon = "ui/Icons/actor_traits/iconAcidTouch",
			unlocked_with_achievement = true,
			achievement_id = "achievementLetsNot",
			group_id = "body",
			likeability = -0.1f
		});
		ActorTrait actorTrait2 = t;
		actorTrait2.action_special_effect = (WorldAction)Delegate.Combine(actorTrait2.action_special_effect, new WorldAction(ActionLibrary.acidTouchEffect));
		add(new ActorTrait
		{
			id = "acid_blood",
			path_icon = "ui/Icons/actor_traits/iconAcidBlood",
			unlocked_with_achievement = true,
			achievement_id = "achievementLetsNot",
			group_id = "body",
			rate_inherit = 5,
			likeability = -0.1f
		});
		ActorTrait actorTrait3 = t;
		actorTrait3.action_death = (WorldAction)Delegate.Combine(actorTrait3.action_death, new WorldAction(ActionLibrary.acidBloodEffect));
		add(new ActorTrait
		{
			id = "acid_proof",
			path_icon = "ui/Icons/actor_traits/iconAcidProof",
			unlocked_with_achievement = true,
			achievement_id = "achievementLetsNot",
			group_id = "protection",
			rate_inherit = 5
		});
		add(new ActorTrait
		{
			id = "fire_blood",
			path_icon = "ui/Icons/actor_traits/iconFireBlood",
			group_id = "body",
			rate_inherit = 5
		});
		ActorTrait actorTrait4 = t;
		actorTrait4.action_death = (WorldAction)Delegate.Combine(actorTrait4.action_death, new WorldAction(ActionLibrary.fireDropsSpawn));
		add(new ActorTrait
		{
			id = "fire_proof",
			path_icon = "ui/Icons/actor_traits/iconFireProof",
			group_id = "protection",
			rate_inherit = 5
		});
		t.base_stats.addTag("immunity_fire");
		add(new ActorTrait
		{
			id = "freeze_proof",
			path_icon = "ui/Icons/actor_traits/iconFreezeProof",
			group_id = "protection",
			rate_inherit = 5
		});
		t.base_stats.addTag("immunity_cold");
		add(new ActorTrait
		{
			id = "regeneration",
			path_icon = "ui/Icons/actor_traits/iconRegeneration",
			rate_birth = 1,
			rate_inherit = 5,
			group_id = "health",
			type = TraitType.Positive,
			special_effect_interval = 3f
		});
		ActorTrait actorTrait5 = t;
		actorTrait5.action_special_effect = (WorldAction)Delegate.Combine(actorTrait5.action_special_effect, new WorldAction(ActionLibrary.regenerationEffect));
		add(new ActorTrait
		{
			id = "heliophobia",
			path_icon = "ui/Icons/actor_traits/iconHeliophobia",
			rate_inherit = 10,
			group_id = "body",
			type = TraitType.Negative,
			special_effect_interval = 10f
		});
		ActorTrait actorTrait6 = t;
		actorTrait6.action_special_effect = (WorldAction)Delegate.Combine(actorTrait6.action_special_effect, new WorldAction(ActionLibrary.heliophobiaEffect));
		add(new ActorTrait
		{
			id = "ugly",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconUgly",
			rate_birth = 7,
			same_trait_mod = 5,
			opposite_trait_mod = -15,
			likeability = -0.1f,
			group_id = "appearance",
			type = TraitType.Negative
		});
		t.base_stats["multiplier_offspring"] = -0.3f;
		t.addOpposite("attractive");
		add(new ActorTrait
		{
			id = "fat",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconFat",
			rate_birth = 7,
			rate_inherit = 5,
			opposite_trait_mod = -10,
			same_trait_mod = 10,
			likeability = -0.1f,
			group_id = "physique",
			type = TraitType.Negative
		});
		t.addOpposite("agile");
		t.addOpposite("weightless");
		t.base_stats["multiplier_mass"] = 0.3f;
		t.base_stats["scale"] = 0.02f;
		t.base_stats["multiplier_stamina"] = -0.5f;
		t.base_stats["multiplier_damage"] = 0.1f;
		add(new ActorTrait
		{
			id = "attractive",
			path_icon = "ui/Icons/actor_traits/iconAttractive",
			rate_birth = 3,
			rate_inherit = 5,
			same_trait_mod = 10,
			likeability = 0.1f,
			group_id = "appearance",
			type = TraitType.Positive
		});
		t.addOpposite("ugly");
		t.base_stats["diplomacy"] = 2f;
		t.base_stats["stewardship"] = 1f;
		t.base_stats["critical_chance"] = 0.1f;
		t.base_stats["multiplier_offspring"] = 0.6f;
		add(new ActorTrait
		{
			id = "fast",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconFast",
			rate_birth = 4,
			rate_inherit = 5,
			remove_for_zombie_actor_asset = true,
			group_id = "physique",
			type = TraitType.Positive
		});
		t.addOpposite("slow");
		t.base_stats["multiplier_speed"] = 0.3f;
		t.base_stats["attack_speed"] = 5f;
		add(new ActorTrait
		{
			id = "slow",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconSlow",
			rate_birth = 6,
			rate_inherit = 5,
			group_id = "physique",
			type = TraitType.Negative
		});
		t.addOpposite("fast");
		t.addOpposite("agile");
		t.base_stats["multiplier_speed"] = -0.5f;
		t.base_stats["attack_speed"] = -5f;
		add(new ActorTrait
		{
			id = "gluttonous",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconGluttonous",
			rate_birth = 4,
			rate_inherit = 5,
			same_trait_mod = 5,
			group_id = "mind",
			type = TraitType.Negative
		});
		add(new ActorTrait
		{
			id = "giant",
			path_icon = "ui/Icons/actor_traits/iconGiant",
			group_id = "physique",
			type = TraitType.Positive,
			rate_birth = 2,
			rate_inherit = 7,
			unlocked_with_achievement = true,
			achievement_id = "achievementTORNADO"
		});
		t.addOpposite("tiny");
		t.base_stats["scale"] = 0.05f;
		t.base_stats["multiplier_health"] = 0.5f;
		t.base_stats["multiplier_speed"] = -0.25f;
		add(new ActorTrait
		{
			id = "tiny",
			path_icon = "ui/Icons/actor_traits/iconTiny",
			group_id = "physique",
			type = TraitType.Negative,
			rate_birth = 4,
			rate_inherit = 7,
			unlocked_with_achievement = true,
			achievement_id = "achievementBabyTornado"
		});
		t.addOpposite("giant");
		t.base_stats["diplomacy"] = -1f;
		t.base_stats["scale"] = -0.02f;
		t.base_stats["multiplier_health"] = -0.25f;
		t.base_stats["multiplier_speed"] = 0.25f;
		add(new ActorTrait
		{
			id = "eagle_eyed",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconEagleEye",
			rate_birth = 3,
			rate_inherit = 5,
			group_id = "cognitive",
			type = TraitType.Positive
		});
		t.addOpposite("short_sighted");
		t.base_stats["accuracy"] = 5f;
		t.base_stats["critical_chance"] = 0.15f;
		add(new ActorTrait
		{
			id = "short_sighted",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconShortsighted",
			rate_birth = 5,
			rate_inherit = 5,
			group_id = "cognitive",
			type = TraitType.Negative
		});
		t.addOpposite("eagle_eyed");
		t.base_stats["accuracy"] = -5f;
		t.base_stats["critical_chance"] = -0.05f;
		add(new ActorTrait
		{
			id = "infertile",
			path_icon = "ui/Icons/actor_traits/iconInfertile",
			rate_birth = 1,
			rate_inherit = 5,
			group_id = "health",
			type = TraitType.Negative
		});
		t.addOpposite("fertile");
		t.base_stats["offspring"] = -99999f;
		add(new ActorTrait
		{
			id = "fertile",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconFertile",
			rate_birth = 3,
			rate_inherit = 7,
			group_id = "health",
			type = TraitType.Positive,
			likeability = 0.1f
		});
		t.addOpposite("infertile");
		t.base_stats["multiplier_offspring"] = 0.8f;
		t.base_stats["birth_rate"] = 4f;
		add(new ActorTrait
		{
			id = "thorns",
			path_icon = "ui/Icons/actor_traits/iconThorns",
			group_id = "protection",
			rate_inherit = 5
		});
		ActorTrait actorTrait7 = t;
		actorTrait7.action_get_hit = (GetHitAction)Delegate.Combine(actorTrait7.action_get_hit, new GetHitAction(ActionLibrary.thornsDefense));
		add(new ActorTrait
		{
			id = "bubble_defense",
			path_icon = "ui/Icons/actor_traits/iconBubbleDefense",
			group_id = "protection",
			rate_inherit = 3
		});
		ActorTrait actorTrait8 = t;
		actorTrait8.action_get_hit = (GetHitAction)Delegate.Combine(actorTrait8.action_get_hit, new GetHitAction(ActionLibrary.bubbleDefense));
		add(new ActorTrait
		{
			id = "immune",
			path_icon = "ui/Icons/actor_traits/iconImmune",
			rate_birth = 1,
			rate_inherit = 10,
			group_id = "health",
			type = TraitType.Positive
		});
		t.addOpposite("plague");
		t.addOpposite("tumor_infection");
		t.addOpposite("mush_spores");
		t.addOpposite("infected");
		add(new ActorTrait
		{
			id = "agile",
			path_icon = "ui/Icons/actor_traits/iconAgile",
			rate_birth = 3,
			rate_inherit = 5,
			same_trait_mod = 5,
			remove_for_zombie_actor_asset = true,
			group_id = "physique",
			type = TraitType.Positive
		});
		t.addOpposite("fat");
		t.addOpposite("slow");
		t.base_stats["lifespan"] = 3f;
		t.base_stats["scale"] = -0.01f;
		t.base_stats["stamina"] = 20f;
		t.base_stats["skill_combat"] = 0.2f;
		add(new ActorTrait
		{
			id = "weightless",
			path_icon = "ui/Icons/actor_traits/iconWeightless",
			rate_birth = 1,
			rate_inherit = 5,
			group_id = "physique"
		});
		t.addOpposite("fat");
		add(new ActorTrait
		{
			id = "poisonous",
			path_icon = "ui/Icons/actor_traits/iconPoisonous",
			group_id = "body",
			rate_inherit = 5
		});
		add(new ActorTrait
		{
			id = "venomous",
			path_icon = "ui/Icons/actor_traits/iconVenomous",
			group_id = "body",
			rate_inherit = 5
		});
		t.action_attack_target = ActionLibrary.addPoisonedEffectOnTarget;
		add(new ActorTrait
		{
			id = "poison_immune",
			path_icon = "ui/Icons/actor_traits/iconPoisonImmune",
			group_id = "protection",
			rate_inherit = 5
		});
		add(new ActorTrait
		{
			id = "tough",
			path_icon = "ui/Icons/actor_traits/iconTough",
			rate_birth = 2,
			group_id = "physique",
			type = TraitType.Positive,
			same_trait_mod = -5,
			unlocked_with_achievement = true,
			achievement_id = "achievementDestroyWorldBox"
		});
		t.base_stats["armor"] = 10f;
		t.base_stats["warfare"] = 1f;
		t.base_stats["lifespan"] = 4f;
		add(new ActorTrait
		{
			id = "strong",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconStrong",
			rate_birth = 4,
			opposite_trait_mod = -10,
			same_trait_mod = 5,
			group_id = "physique",
			type = TraitType.Positive
		});
		t.addOpposite("weak");
		t.base_stats["multiplier_damage"] = 0.5f;
		t.base_stats["warfare"] = 2f;
		t.base_stats["lifespan"] = 3f;
		add(new ActorTrait
		{
			id = "weak",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconWeak",
			rate_birth = 5,
			opposite_trait_mod = -10,
			group_id = "physique",
			type = TraitType.Negative
		});
		t.addOpposite("strong");
		t.base_stats["multiplier_damage"] = -0.5f;
		t.base_stats["warfare"] = -2f;
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["lifespan"] = -6f;
	}

	private void addTraitsMind()
	{
		add(new ActorTrait
		{
			id = "lustful",
			path_icon = "ui/Icons/actor_traits/iconLustful",
			group_id = "mind",
			rate_acquire_grow_up = 5,
			rate_birth = 1,
			likeability = 0.1f
		});
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["multiplier_offspring"] = 0.2f;
		add(new ActorTrait
		{
			id = "miner",
			path_icon = "ui/Icons/actor_traits/iconMiner",
			group_id = "miscellaneous",
			type = TraitType.Positive,
			rate_acquire_grow_up = 5
		});
		add(new ActorTrait
		{
			id = "psychopath",
			path_icon = "ui/Icons/actor_traits/iconPsychopath",
			group_id = "mind",
			rate_birth = 1,
			type = TraitType.Negative
		});
		add(new ActorTrait
		{
			id = "strong_minded",
			path_icon = "ui/Icons/actor_traits/iconStrongMinded",
			group_id = "mind",
			type = TraitType.Positive,
			remove_for_zombie_actor_asset = true
		});
		t.base_stats.addTag("strong_mind");
		t.addOpposite("madness");
		t.addOpposite("desire_golden_egg");
		t.addOpposite("desire_harp");
		add(new ActorTrait
		{
			id = "peaceful",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconPeaceful",
			remove_for_zombie_actor_asset = true,
			group_id = "mind",
			type = TraitType.Positive
		});
		t.base_stats.addTag("love_peace");
		add(new ActorTrait
		{
			id = "evil",
			path_icon = "ui/Icons/actor_traits/iconEvil",
			group_id = "mind",
			likeability = -0.2f
		});
		t.addOpposite("blessed");
		t.base_stats["cities"] = -2f;
		t.base_stats["warfare"] = 10f;
		add(new ActorTrait
		{
			id = "hotheaded",
			path_icon = "ui/Icons/actor_traits/iconHotheaded",
			rate_birth = 1,
			same_trait_mod = -10,
			group_id = "mind",
			type = TraitType.Negative
		});
		add(new ActorTrait
		{
			id = "thief",
			path_icon = "ui/Icons/actor_traits/iconThief",
			rate_birth = 1,
			same_trait_mod = 10,
			group_id = "cognitive",
			type = TraitType.Negative
		});
		t.setUnlockedWithAchievement("achievementNotOnMyWatch");
		t.addOpposite("honest");
		t.addOpposite("content");
		t.base_stats.addTag("steal_items");
		t.addDecision("try_to_steal_money");
		add(new ActorTrait
		{
			id = "stupid",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconStupid",
			rate_birth = 3,
			same_trait_mod = 30,
			group_id = "cognitive",
			type = TraitType.Negative
		});
		t.addOpposite("genius");
		t.addOpposite("wise");
		t.base_stats["damage"] = 5f;
		t.base_stats["cities"] = -3f;
		t.base_stats["intelligence"] = -5f;
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["warfare"] = -2f;
		t.base_stats["stewardship"] = -5f;
		t.base_stats["loyalty_traits"] = -15f;
		t.base_stats["personality_rationality"] = -0.5f;
		add(new ActorTrait
		{
			id = "genius",
			path_icon = "ui/Icons/actor_traits/iconGenius",
			rate_birth = 1,
			remove_for_zombie_actor_asset = true,
			same_trait_mod = 20,
			opposite_trait_mod = -20,
			unlocked_with_achievement = true,
			achievement_id = "achievementTraitsExplorer60",
			group_id = "cognitive",
			type = TraitType.Positive
		});
		t.base_stats.addTag("can_read_any_book");
		t.addOpposite("stupid");
		t.base_stats["intelligence"] = 10f;
		t.base_stats["diplomacy"] = 5f;
		t.base_stats["warfare"] = 5f;
		t.base_stats["stewardship"] = 7f;
		t.base_stats["loyalty_traits"] = -10f;
		t.base_stats["cities"] = 3f;
		add(new ActorTrait
		{
			id = "deceitful",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconDeceitful",
			rate_acquire_grow_up = 5,
			same_trait_mod = -15,
			opposite_trait_mod = -5,
			likeability = 0.1f,
			group_id = "mind",
			type = TraitType.Negative
		});
		t.addOpposite("honest");
		t.base_stats["diplomacy"] = 1f;
		t.base_stats["stewardship"] = 4f;
		t.base_stats["loyalty_traits"] = -20f;
		add(new ActorTrait
		{
			id = "ambitious",
			path_icon = "ui/Icons/actor_traits/iconAmbitious",
			rate_acquire_grow_up = 5,
			rate_birth = 1,
			same_trait_mod = -10,
			group_id = "mind",
			achievement_id = "achievement4RaceCities",
			unlocked_with_achievement = true
		});
		t.addOpposite("content");
		t.base_stats["diplomacy"] = 2f;
		t.base_stats["warfare"] = 4f;
		t.base_stats["stewardship"] = 1f;
		t.base_stats["loyalty_traits"] = -15f;
		t.base_stats["cities"] = 5f;
		add(new ActorTrait
		{
			id = "content",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconContent",
			rate_acquire_grow_up = 5,
			rate_birth = 2,
			same_trait_mod = 15,
			likeability = 0.1f,
			group_id = "mind",
			type = TraitType.Positive
		});
		t.addOpposite("ambitious");
		t.addOpposite("greedy");
		t.addOpposite("thief");
		t.base_stats["multiplier_supply_timer"] = -0.3f;
		t.base_stats["loyalty_traits"] = 10f;
		t.base_stats["diplomacy"] = 2f;
		t.base_stats["stewardship"] = 2f;
		t.base_stats["warfare"] = -2f;
		add(new ActorTrait
		{
			id = "honest",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconHonest",
			rate_acquire_grow_up = 5,
			rate_birth = 2,
			same_trait_mod = 10,
			opposite_trait_mod = -10,
			likeability = -0.1f,
			group_id = "mind",
			type = TraitType.Positive
		});
		t.addOpposite("deceitful");
		t.addOpposite("thief");
		t.base_stats["stewardship"] = 3f;
		t.base_stats["diplomacy"] = 2f;
		t.base_stats["warfare"] = -2f;
		t.base_stats["loyalty_traits"] = 5f;
		add(new ActorTrait
		{
			id = "paranoid",
			path_icon = "ui/Icons/actor_traits/iconParanoid",
			rate_acquire_grow_up = 5,
			rate_birth = 1,
			group_id = "mind",
			type = TraitType.Negative
		});
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["warfare"] = 4f;
		t.base_stats["multiplier_supply_timer"] = 0.5f;
		t.base_stats["loyalty_traits"] = -15f;
		t.base_stats["cities"] = -1f;
		add(new ActorTrait
		{
			id = "greedy",
			path_icon = "ui/Icons/actor_traits/iconGreedy",
			rate_acquire_grow_up = 5,
			rate_birth = 1,
			likeability = -0.1f,
			group_id = "mind",
			type = TraitType.Negative
		});
		t.addOpposite("content");
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["stewardship"] = -3f;
		t.base_stats["warfare"] = 4f;
		t.base_stats["multiplier_supply_timer"] = 4f;
		t.base_stats["loyalty_traits"] = -5f;
		t.base_stats["cities"] = 2f;
	}

	private void addTraitsSpirit()
	{
		add(new ActorTrait
		{
			id = "chosen_one",
			path_icon = "ui/Icons/actor_traits/iconChosenOne",
			likeability = 0.25f,
			group_id = "fate",
			achievement_id = "achievementLavaStrike",
			unlocked_with_achievement = true
		});
		t.is_mutation_box_allowed = false;
		t.base_stats["stamina"] = 1000f;
		t.base_stats["mana"] = 1000f;
		t.addCombatAction("combat_backstep");
		t.addCombatAction("combat_block");
		t.addCombatAction("combat_dash");
		t.addCombatAction("combat_deflect_projectile");
		t.addCombatAction("combat_dodge");
		t.addSpell("cast_fire");
		t.addSpell("summon_lightning");
		t.addSpell("summon_tornado");
		t.addSpell("cast_blood_rain");
		t.addSpell("cast_blood_rain");
		t.addSpell("cast_cure");
		t.addSpell("cast_shield");
		t.addSpell("cast_grass_seeds");
		t.addSpell("spawn_vegetation");
		t.addSpell("cast_curse");
		ActorTrait actorTrait = t;
		actorTrait.action_death = (WorldAction)Delegate.Combine(actorTrait.action_death, new WorldAction(ActionLibrary.mageSlayerCheck));
		add(new ActorTrait
		{
			id = "moonchild",
			path_icon = "ui/Icons/actor_traits/iconMoonchild",
			only_active_on_era_flag = true,
			era_active_moon = true,
			group_id = "spirit",
			rate_inherit = 5,
			rate_birth = 1
		});
		t.base_stats["multiplier_damage"] = 0.5f;
		t.base_stats["multiplier_speed"] = 0.1f;
		t.base_stats["armor"] = 1f;
		t.base_stats["intelligence"] = 3f;
		add(new ActorTrait
		{
			id = "nightchild",
			path_icon = "ui/Icons/actor_traits/iconNightchild",
			only_active_on_era_flag = true,
			era_active_night = true,
			group_id = "spirit",
			rate_inherit = 5,
			rate_birth = 1
		});
		t.base_stats["multiplier_damage"] = 0.5f;
		t.base_stats["multiplier_speed"] = 0.1f;
		t.base_stats["critical_chance"] = 0.03f;
		t.base_stats["warfare"] = 3f;
		add(new ActorTrait
		{
			id = "flesh_eater",
			path_icon = "ui/Icons/actor_traits/iconFleshEater",
			group_id = "spirit",
			rate_inherit = 5,
			rate_birth = 1
		});
		t.action_attack_target = ActionLibrary.restoreHealthOnHit;
		add(new ActorTrait
		{
			id = "titan_lungs",
			path_icon = "ui/Icons/actor_traits/iconTitanLungs",
			group_id = "body",
			rate_inherit = 5
		});
		t.setUnlockedWithAchievement("achievementNinjaTurtle");
		t.base_stats["multiplier_stamina"] = 10f;
		add(new ActorTrait
		{
			id = "heart_of_wizard",
			path_icon = "ui/Icons/actor_traits/iconHeartWizard",
			group_id = "spirit",
			rate_inherit = 5
		});
		t.base_stats["multiplier_mana"] = 10f;
		add(new ActorTrait
		{
			id = "battle_reflexes",
			path_icon = "ui/Icons/actor_traits/iconBattleReflexes",
			group_id = "mind",
			rate_inherit = 5
		});
		t.base_stats["skill_combat"] = 0.5f;
		add(new ActorTrait
		{
			id = "arcane_reflexes",
			path_icon = "ui/Icons/actor_traits/iconArcaneReflexes",
			group_id = "mind",
			rate_inherit = 5
		});
		t.base_stats["skill_spell"] = 0.5f;
		add(new ActorTrait
		{
			id = "healing_aura",
			path_icon = "ui/Icons/actor_traits/iconHealingAura",
			group_id = "spirit",
			rate_inherit = 5,
			special_effect_interval = 2f,
			likeability = 0.1f
		});
		ActorTrait actorTrait2 = t;
		actorTrait2.action_special_effect = (WorldAction)Delegate.Combine(actorTrait2.action_special_effect, new WorldAction(ActionLibrary.healingAuraEffect));
		add(new ActorTrait
		{
			id = "savage",
			path_icon = "ui/Icons/actor_traits/iconSavage",
			group_id = "spirit",
			type = TraitType.Positive,
			same_trait_mod = 5,
			rate_acquire_grow_up = 2,
			rate_inherit = 5
		});
		add(new ActorTrait
		{
			id = "immortal",
			path_icon = "ui/Icons/actor_traits/iconImmortal",
			same_trait_mod = -20,
			type = TraitType.Positive,
			unlocked_with_achievement = true,
			achievement_id = "achievementTheKing",
			group_id = "health"
		});
		t.addOpposite("plague");
		t.addOpposite("boat");
		t.base_stats["loyalty_traits"] = -20f;
		add(new ActorTrait
		{
			id = "burning_feet",
			path_icon = "ui/Icons/actor_traits/iconBurningFeet",
			unlocked_with_achievement = true,
			achievement_id = "achievementTheHell",
			group_id = "spirit",
			rate_inherit = 3
		});
		ActorTrait actorTrait3 = t;
		actorTrait3.action_special_effect = (WorldAction)Delegate.Combine(actorTrait3.action_special_effect, new WorldAction(ActionLibrary.burningFeetEffect));
		add(new ActorTrait
		{
			id = "cold_aura",
			path_icon = "ui/Icons/actor_traits/iconColdAura",
			group_id = "spirit",
			rate_inherit = 3
		});
		ActorTrait actorTrait4 = t;
		actorTrait4.action_special_effect = (WorldAction)Delegate.Combine(actorTrait4.action_special_effect, new WorldAction(ActionLibrary.coldAuraEffect));
		add(new ActorTrait
		{
			id = "lucky",
			path_icon = "ui/Icons/actor_traits/iconLucky",
			rate_birth = 2,
			rate_inherit = 5,
			likeability = 0.1f,
			group_id = "spirit",
			type = TraitType.Positive
		});
		t.addOpposite("unlucky");
		t.base_stats["lifespan"] = 7f;
		t.base_stats["accuracy"] = 4f;
		t.base_stats["critical_chance"] = 0.3f;
		t.base_stats["birth_rate"] = 5f;
		add(new ActorTrait
		{
			id = "unlucky",
			path_icon = "ui/Icons/actor_traits/iconUnlucky",
			rate_birth = 3,
			rate_inherit = 5,
			likeability = -0.1f,
			special_effect_interval = 20f,
			group_id = "spirit",
			type = TraitType.Negative
		});
		t.addOpposite("lucky");
		t.base_stats["lifespan"] = -13f;
		ActorTrait actorTrait5 = t;
		actorTrait5.action_special_effect = (WorldAction)Delegate.Combine(actorTrait5.action_special_effect, new WorldAction(ActionLibrary.unluckyFall));
		t.base_stats["accuracy"] = -4f;
		t.base_stats["critical_chance"] = -0.3f;
		add(new ActorTrait
		{
			id = "bloodlust",
			path_icon = "ui/Icons/actor_traits/iconBloodlust",
			rate_acquire_grow_up = 4,
			rate_birth = 1,
			rate_inherit = 5,
			group_id = "spirit",
			type = TraitType.Negative,
			unlocked_with_achievement = true,
			achievement_id = "achievementTheDemon"
		});
		t.addOpposite("pacifist");
		t.base_stats["multiplier_supply_timer"] = 1.5f;
		t.base_stats["loyalty_traits"] = -20f;
		t.base_stats["warfare"] = 5f;
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["cities"] = 3f;
		add(new ActorTrait
		{
			id = "pacifist",
			path_icon = "ui/Icons/actor_traits/iconPacifist",
			rate_acquire_grow_up = 3,
			rate_inherit = 5,
			likeability = 0.1f,
			group_id = "spirit",
			type = TraitType.Positive
		});
		t.addOpposite("bloodlust");
		t.base_stats["multiplier_supply_timer"] = -0.1f;
		t.base_stats["loyalty_traits"] = 50f;
		t.base_stats["diplomacy"] = 10f;
		t.base_stats["warfare"] = -4f;
	}

	private void addTraitsAcquired()
	{
		add(new ActorTrait
		{
			id = "veteran",
			path_icon = "ui/Icons/actor_traits/iconVeteran",
			group_id = "merits",
			type = TraitType.Positive,
			same_trait_mod = 5,
			is_mutation_box_allowed = false
		});
		t.base_stats["skill_combat"] = 0.1f;
		t.base_stats["multiplier_damage"] = 0.1f;
		t.base_stats["multiplier_health"] = 0.1f;
		add(new ActorTrait
		{
			id = "wise",
			path_icon = "ui/Icons/actor_traits/iconWise",
			group_id = "cognitive",
			type = TraitType.Positive,
			is_mutation_box_allowed = false
		});
		t.addOpposite("stupid");
		t.addOpposite("boat");
		t.base_stats["diplomacy"] = 1f;
		t.base_stats["stewardship"] = 1f;
		t.base_stats["warfare"] = 1f;
		t.base_stats["intelligence"] = 1f;
		add(new ActorTrait
		{
			id = "infected",
			path_icon = "ui/Icons/actor_traits/iconInfected",
			rate_inherit = 20,
			group_id = "acquired",
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			is_mutation_box_allowed = false
		});
		t.addOpposite("immune");
		t.addOpposite("boat");
		t.can_be_cured = true;
		ActorTrait actorTrait = t;
		actorTrait.action_special_effect = (WorldAction)Delegate.Combine(actorTrait.action_special_effect, new WorldAction(ActionLibrary.infectedEffect));
		t.special_effect_interval = 1.5f;
		ActorTrait actorTrait2 = t;
		actorTrait2.action_death = (WorldAction)Delegate.Combine(actorTrait2.action_death, new WorldAction(ActionLibrary.turnIntoZombie));
		t.base_stats["multiplier_speed"] = 0.1f;
		t.base_stats["loyalty_traits"] = -15f;
		add(new ActorTrait
		{
			id = "mush_spores",
			path_icon = "ui/Icons/actor_traits/iconMushSpores",
			rate_inherit = 30,
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			group_id = "acquired",
			is_mutation_box_allowed = false
		});
		t.addOpposite("immune");
		t.addOpposite("boat");
		t.can_be_cured = true;
		ActorTrait actorTrait3 = t;
		actorTrait3.action_death = (WorldAction)Delegate.Combine(actorTrait3.action_death, new WorldAction(ActionLibrary.mushSporesEffect));
		ActorTrait actorTrait4 = t;
		actorTrait4.action_death = (WorldAction)Delegate.Combine(actorTrait4.action_death, new WorldAction(ActionLibrary.turnIntoMush));
		t.base_stats["multiplier_speed"] = 0.3f;
		t.base_stats["loyalty_traits"] = -15f;
		add(new ActorTrait
		{
			id = "tumor_infection",
			path_icon = "ui/Icons/actor_traits/iconTumorInfection",
			rate_inherit = 30,
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			group_id = "acquired",
			is_mutation_box_allowed = false
		});
		t.addOpposite("immune");
		t.addOpposite("boat");
		t.can_be_cured = true;
		ActorTrait actorTrait5 = t;
		actorTrait5.action_special_effect = (WorldAction)Delegate.Combine(actorTrait5.action_special_effect, new WorldAction(ActionLibrary.tumorEffect));
		ActorTrait actorTrait6 = t;
		actorTrait6.action_death = (WorldAction)Delegate.Combine(actorTrait6.action_death, new WorldAction(ActionLibrary.turnIntoTumorMonster));
		t.base_stats["multiplier_speed"] = 0.3f;
		t.base_stats["loyalty_traits"] = -15f;
		add(new ActorTrait
		{
			id = "plague",
			path_icon = "ui/Icons/actor_traits/iconPlague",
			rate_inherit = 30,
			unlocked_with_achievement = true,
			achievement_id = "achievementGreatPlague",
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			group_id = "acquired",
			is_mutation_box_allowed = false
		});
		t.addOpposite("immune");
		t.addOpposite("immortal");
		t.addOpposite("contagious");
		t.addOpposite("boat");
		t.can_be_cured = true;
		ActorTrait actorTrait7 = t;
		actorTrait7.action_special_effect = (WorldAction)Delegate.Combine(actorTrait7.action_special_effect, new WorldAction(ActionLibrary.plagueEffect));
		t.base_stats["multiplier_speed"] = -0.3f;
		t.base_stats["multiplier_damage"] = -0.5f;
		t.base_stats["stamina"] = -10f;
		t.base_stats["armor"] = -2f;
		t.base_stats["loyalty_traits"] = -15f;
		t.base_stats["lifespan"] = -30f;
		add(new ActorTrait
		{
			id = "blessed",
			likeability = 0.1f,
			path_icon = "ui/Icons/actor_traits/iconBlessing",
			group_id = "acquired",
			is_mutation_box_allowed = false
		});
		t.addOpposite("evil");
		t.base_stats["multiplier_damage"] = 0.5f;
		t.base_stats["multiplier_health"] = 0.5f;
		t.base_stats["multiplier_speed"] = 0.5f;
		t.base_stats["multiplier_diplomacy"] = 0.2f;
		t.base_stats["multiplier_crit"] = 0.1f;
		t.base_stats["lifespan"] = 5f;
		add(new ActorTrait
		{
			id = "kingslayer",
			path_icon = "ui/Icons/actor_traits/iconKingslayer",
			group_id = "merits",
			is_mutation_box_allowed = false
		});
		t.base_stats["multiplier_supply_timer"] = 2f;
		t.base_stats["loyalty_traits"] = -25f;
		t.base_stats["diplomacy"] = -5f;
		t.base_stats["warfare"] = 5f;
		add(new ActorTrait
		{
			id = "mageslayer",
			group_id = "merits",
			path_icon = "ui/Icons/actor_traits/iconMageslayer",
			is_mutation_box_allowed = false
		});
		t.base_stats["loyalty_traits"] = -10f;
		t.base_stats["warfare"] = 5f;
		t.base_stats["critical_chance"] = 0.03f;
		add(new ActorTrait
		{
			id = "dragonslayer",
			group_id = "merits",
			path_icon = "ui/Icons/actor_traits/iconDragonslayer",
			is_mutation_box_allowed = false
		});
		t.base_stats["warfare"] = 5f;
		t.base_stats["critical_chance"] = 0.04f;
		t.base_stats["multiplier_diplomacy"] = 0.1f;
		add(new ActorTrait
		{
			id = "crippled",
			path_icon = "ui/Icons/actor_traits/iconCrippled",
			same_trait_mod = 10,
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			type = TraitType.Negative,
			group_id = "acquired",
			is_mutation_box_allowed = false
		});
		t.base_stats["multiplier_speed"] = -0.5f;
		t.base_stats["diplomacy"] = -3f;
		t.base_stats["multiplier_offspring"] = -0.5f;
		add(new ActorTrait
		{
			id = "golden_tooth",
			path_icon = "ui/Icons/actor_traits/iconGoldenTooth",
			same_trait_mod = 5,
			type = TraitType.Positive,
			group_id = "appearance",
			is_mutation_box_allowed = false
		});
		t.base_stats["diplomacy"] = 2f;
		add(new ActorTrait
		{
			id = "eyepatch",
			path_icon = "ui/Icons/actor_traits/iconEyePatch",
			same_trait_mod = 20,
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			type = TraitType.Negative,
			group_id = "appearance",
			is_mutation_box_allowed = false
		});
		t.base_stats["accuracy"] = -5f;
		t.base_stats["diplomacy"] = 1f;
		t.base_stats["warfare"] = -1f;
		t.base_stats["critical_chance"] = -0.15f;
		add(new ActorTrait
		{
			id = "skin_burns",
			path_icon = "ui/Icons/actor_traits/iconSkinBurns",
			same_trait_mod = 40,
			can_be_removed_by_divine_light = true,
			can_be_removed_by_accelerated_healing = true,
			type = TraitType.Negative,
			group_id = "appearance",
			is_mutation_box_allowed = false
		});
		t.base_stats["diplomacy"] = -2f;
		t.base_stats["warfare"] = 2f;
		t.base_stats["multiplier_speed"] = -0.25f;
		t.base_stats["lifespan"] = -5f;
	}

	private void addTraitsFun()
	{
		add(new ActorTrait
		{
			id = "super_health",
			path_icon = "ui/Icons/actor_traits/iconSuperHealth",
			unlocked_with_achievement = true,
			achievement_id = "achievementTraitsExplorer90",
			group_id = "health",
			rate_inherit = 3
		});
		t.base_stats["lifespan"] = 100f;
		t.base_stats["multiplier_health"] = 100f;
		add(new ActorTrait
		{
			id = "death_nuke",
			path_icon = "ui/Icons/actor_traits/iconDeathNuke",
			unlocked_with_achievement = true,
			achievement_id = "achievementFinalResolution",
			group_id = "fun",
			rate_inherit = 1,
			is_mutation_box_allowed = false
		});
		t.addOpposite("death_bomb");
		ActorTrait actorTrait = t;
		actorTrait.action_death = (WorldAction)Delegate.Combine(actorTrait.action_death, new WorldAction(ActionLibrary.deathNuke));
		add(new ActorTrait
		{
			id = "death_bomb",
			path_icon = "ui/Icons/actor_traits/iconDeathBomb",
			unlocked_with_achievement = true,
			achievement_id = "achievementManyBombs",
			group_id = "fun",
			rate_inherit = 1
		});
		t.addOpposite("death_nuke");
		ActorTrait actorTrait2 = t;
		actorTrait2.action_death = (WorldAction)Delegate.Combine(actorTrait2.action_death, new WorldAction(ActionLibrary.deathBomb));
		add(new ActorTrait
		{
			id = "death_mark",
			path_icon = "ui/Icons/actor_traits/iconDeathMark",
			unlocked_with_achievement = true,
			achievement_id = "achievementTraitsExplorer40",
			group_id = "fate",
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait3 = t;
		actorTrait3.action_special_effect = (WorldAction)Delegate.Combine(actorTrait3.action_special_effect, new WorldAction(ActionLibrary.deathMark));
		add(new ActorTrait
		{
			id = "energized",
			path_icon = "ui/Icons/actor_traits/iconLightning",
			group_id = "fun",
			spawn_random_trait_allowed = false
		});
		t.addOpposite("boat");
		t.base_stats["multiplier_speed"] = 2f;
		t.base_stats["lifespan"] = 7f;
		ActorTrait actorTrait4 = t;
		actorTrait4.action_death = (WorldAction)Delegate.Combine(actorTrait4.action_death, new WorldAction(ActionLibrary.energizedLightning));
		add(new ActorTrait
		{
			id = "mega_heartbeat",
			path_icon = "ui/Icons/actor_traits/iconMegaHeartbeat",
			group_id = "fun",
			rate_inherit = 4,
			unlocked_with_achievement = true,
			achievement_id = "achievementPrintHeart",
			special_effect_interval = 5f,
			likeability = 0.1f,
			spawn_random_trait_allowed = false,
			is_mutation_box_allowed = false
		});
		t.addOpposite("whirlwind");
		ActorTrait actorTrait5 = t;
		actorTrait5.action_special_effect = (WorldAction)Delegate.Combine(actorTrait5.action_special_effect, new WorldAction(ActionLibrary.megaHeartbeat));
		add(new ActorTrait
		{
			id = "bomberman",
			path_icon = "ui/Icons/actor_traits/iconGrenade",
			group_id = "fun"
		});
		t.addCombatAction("combat_throw_bomb");
		add(new ActorTrait
		{
			id = "pyromaniac",
			path_icon = "ui/Icons/actor_traits/iconPyromaniac",
			rate_acquire_grow_up = 1,
			achievement_id = "achievementWorldWar",
			unlocked_with_achievement = true,
			group_id = "mind",
			acquire_grow_up_sapient_only = true,
			rate_inherit = 1
		});
		t.addCombatAction("combat_throw_torch");
		add(new ActorTrait
		{
			id = "whirlwind",
			path_icon = "ui/Icons/iconTornado",
			group_id = "fun",
			action_special_effect = ActionLibrary.whirlwind,
			special_effect_interval = 0.1f,
			unlocked_with_achievement = true,
			spawn_random_trait_allowed = false,
			is_mutation_box_allowed = false,
			achievement_id = "achievementRainTornado"
		});
		t.addOpposite("mega_heartbeat");
	}

	private void addTraitsMisc()
	{
		add(new ActorTrait
		{
			id = "light_lamp",
			path_icon = "ui/Icons/actor_traits/iconLightLamp",
			group_id = "miscellaneous"
		});
		t.base_stats.addTag("generate_light");
		add(new ActorTrait
		{
			id = "shiny",
			path_icon = "ui/Icons/actor_traits/iconShiny",
			group_id = "miscellaneous",
			rate_inherit = 10
		});
		t.base_stats["diplomacy"] = 5f;
		t.action_special_effect = ActionLibrary.shiny;
		add(new ActorTrait
		{
			id = "flower_prints",
			path_icon = "ui/Icons/actor_traits/iconFlowerPrints",
			unlocked_with_achievement = true,
			achievement_id = "achievementTouchTheGrass",
			group_id = "miscellaneous",
			rate_inherit = 10
		});
		ActorTrait actorTrait = t;
		actorTrait.action_special_effect = (WorldAction)Delegate.Combine(actorTrait.action_special_effect, new WorldAction(ActionLibrary.flowerPrintsEffect));
	}

	private void addTraitsSpecial()
	{
		add(new ActorTrait
		{
			id = "metamorphed",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconMetamorphed",
			can_be_given = false,
			group_id = "special",
			is_mutation_box_allowed = false
		});
		add(new ActorTrait
		{
			id = "clone",
			rarity = Rarity.R0_Normal,
			path_icon = "ui/Icons/actor_traits/iconClone",
			can_be_given = false,
			group_id = "special",
			is_mutation_box_allowed = false
		});
		add(new ActorTrait
		{
			id = "boat",
			path_icon = "ui/Icons/iconBoat",
			can_be_given = false,
			group_id = "special",
			is_mutation_box_allowed = false
		});
		t.addOpposite("infected");
		t.addOpposite("tumor_infection");
		t.addOpposite("mush_spores");
		t.addOpposite("plague");
		t.addOpposite("immortal");
		t.addOpposite("energized");
		t.addOpposite("wise");
		add(new ActorTrait
		{
			id = "scar_of_divinity",
			path_icon = "ui/Icons/actor_traits/iconDivineScar",
			can_be_removed = false,
			can_be_given = false,
			rate_inherit = 0,
			group_id = "special",
			is_mutation_box_allowed = false
		});
		add(new ActorTrait
		{
			id = "miracle_born",
			path_icon = "ui/Icons/actor_traits/iconMiracleBorn",
			group_id = "special",
			can_be_given = false,
			can_be_removed = false,
			is_mutation_box_allowed = false
		});
		t.base_stats["lifespan"] = 20f;
		t.base_stats["multiplier_offspring"] = 2f;
		t.base_stats["birth_rate"] = 2f;
		add(new ActorTrait
		{
			id = "miracle_bearer",
			path_icon = "ui/Icons/actor_traits/iconMiracleBearer",
			group_id = "special",
			can_be_given = false,
			can_be_removed = false,
			is_mutation_box_allowed = false
		});
		add(new ActorTrait
		{
			id = "contagious",
			path_icon = "ui/Icons/iconRat",
			group_id = "miscellaneous",
			is_mutation_box_allowed = false
		});
		t.addOpposite("plague");
		ActorTrait actorTrait = t;
		actorTrait.action_special_effect = (WorldAction)Delegate.Combine(actorTrait.action_special_effect, new WorldAction(ActionLibrary.contagiousEffect));
		add(new ActorTrait
		{
			id = "zombie",
			path_icon = "ui/Icons/iconZombie",
			can_be_given = false,
			group_id = "special",
			is_mutation_box_allowed = false
		});
		t.action_special_effect = ActionLibrary.zombieEffect;
		t.action_attack_target = ActionLibrary.zombieInfectAttack;
		add(new ActorTrait
		{
			id = "madness",
			path_icon = "ui/Icons/actor_traits/iconMadness",
			group_id = "special",
			can_be_removed_by_divine_light = true,
			can_be_given = false,
			can_be_removed = false,
			is_kingdom_affected = true,
			affects_mind = true,
			forced_kingdom = "mad",
			likeability = -1f,
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait2 = t;
		actorTrait2.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(actorTrait2.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.forcedKingdomAdd));
		ActorTrait actorTrait3 = t;
		actorTrait3.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(actorTrait3.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.forcedKingdomEffectRemove));
		ActorTrait actorTrait4 = t;
		actorTrait4.action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(actorTrait4.action_on_augmentation_load, new WorldActionTrait(ActionLibrary.madnessEffectLoad));
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_golden_egg", "desire_harp" };
		t.addOpposite("strong_minded");
		t.addOpposite("desire_alien_mold");
		t.addOpposite("desire_computer");
		t.addOpposite("desire_golden_egg");
		t.addOpposite("desire_harp");
		t.addDecision("madness_random_emotion");
		t.base_stats["multiplier_speed"] = 0.1f;
		t.base_stats["diplomacy"] = -100f;
		t.base_stats["loyalty_traits"] = -100f;
		add(new ActorTrait
		{
			id = "desire_alien_mold",
			path_icon = "ui/Icons/actor_traits/iconWaypointAlienMoldDrop",
			group_id = "special",
			can_be_removed_by_divine_light = true,
			can_be_given = false,
			can_be_removed = false,
			is_kingdom_affected = true,
			affects_mind = true,
			forced_kingdom = "alien_mold",
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait5 = t;
		actorTrait5.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(actorTrait5.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.forcedKingdomAdd));
		ActorTrait actorTrait6 = t;
		actorTrait6.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(actorTrait6.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.forcedKingdomEffectRemove));
		ActorTrait actorTrait7 = t;
		actorTrait7.action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(actorTrait7.action_on_augmentation_load, new WorldActionTrait(ActionLibrary.madnessEffectLoad));
		t.addDecision("follow_desire_target");
		t.traits_to_remove_ids = new string[4] { "desire_computer", "desire_golden_egg", "desire_harp", "madness" };
		t.addOpposite("madness");
		t.addOpposite("desire_computer");
		t.addOpposite("desire_golden_egg");
		t.addOpposite("desire_harp");
		t.base_stats["targets"] = 1f;
		t.base_stats["multiplier_crit"] = 0.3f;
		t.base_stats["damage_range"] = 0.3f;
		t.base_stats["armor"] = 10f;
		add(new ActorTrait
		{
			id = "desire_computer",
			path_icon = "ui/Icons/actor_traits/iconWaypointComputerDrop",
			group_id = "special",
			can_be_removed_by_divine_light = true,
			can_be_given = false,
			can_be_removed = false,
			is_kingdom_affected = true,
			affects_mind = true,
			forced_kingdom = "computer",
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait8 = t;
		actorTrait8.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(actorTrait8.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.forcedKingdomAdd));
		ActorTrait actorTrait9 = t;
		actorTrait9.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(actorTrait9.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.forcedKingdomEffectRemove));
		ActorTrait actorTrait10 = t;
		actorTrait10.action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(actorTrait10.action_on_augmentation_load, new WorldActionTrait(ActionLibrary.madnessEffectLoad));
		t.addDecision("follow_desire_target");
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_golden_egg", "desire_harp", "madness" };
		t.addOpposite("madness");
		t.addOpposite("desire_alien_mold");
		t.addOpposite("desire_golden_egg");
		t.addOpposite("desire_harp");
		t.base_stats["multiplier_health"] = 0.3f;
		t.base_stats["multiplier_lifespan"] = 0.5f;
		add(new ActorTrait
		{
			id = "desire_golden_egg",
			path_icon = "ui/Icons/actor_traits/iconWaypointGoldenEggDrop",
			group_id = "special",
			can_be_removed_by_divine_light = true,
			can_be_given = false,
			can_be_removed = false,
			is_kingdom_affected = true,
			affects_mind = true,
			forced_kingdom = "golden_egg",
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait11 = t;
		actorTrait11.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(actorTrait11.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.forcedKingdomAdd));
		ActorTrait actorTrait12 = t;
		actorTrait12.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(actorTrait12.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.forcedKingdomEffectRemove));
		ActorTrait actorTrait13 = t;
		actorTrait13.action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(actorTrait13.action_on_augmentation_load, new WorldActionTrait(ActionLibrary.madnessEffectLoad));
		t.addDecision("follow_desire_target");
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_harp", "madness" };
		t.addOpposite("strong_minded");
		t.addOpposite("madness");
		t.addOpposite("desire_alien_mold");
		t.addOpposite("desire_computer");
		t.addOpposite("desire_harp");
		t.base_stats["multiplier_damage"] = 0.5f;
		add(new ActorTrait
		{
			id = "desire_harp",
			path_icon = "ui/Icons/actor_traits/iconWaypointHarpDrop",
			group_id = "special",
			can_be_removed_by_divine_light = true,
			can_be_given = false,
			can_be_removed = false,
			is_kingdom_affected = true,
			affects_mind = true,
			forced_kingdom = "harp",
			is_mutation_box_allowed = false
		});
		ActorTrait actorTrait14 = t;
		actorTrait14.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(actorTrait14.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.forcedKingdomAdd));
		ActorTrait actorTrait15 = t;
		actorTrait15.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(actorTrait15.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.forcedKingdomEffectRemove));
		ActorTrait actorTrait16 = t;
		actorTrait16.action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(actorTrait16.action_on_augmentation_load, new WorldActionTrait(ActionLibrary.madnessEffectLoad));
		t.addDecision("follow_desire_target");
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_golden_egg", "madness" };
		t.addOpposite("strong_minded");
		t.addOpposite("madness");
		t.addOpposite("desire_alien_mold");
		t.addOpposite("desire_computer");
		t.addOpposite("desire_golden_egg");
		t.base_stats["multiplier_speed"] = 0.3f;
		t.base_stats["multiplier_attack_speed"] = 0.3f;
	}

	public override void post_init()
	{
		base.post_init();
		foreach (ActorTrait item in list)
		{
			if (item.base_stats["health"] > 0f || item.base_stats["mana"] > 0f || item.base_stats["stamina"] > 0f || item.base_stats["multiplier_health"] > 0f || item.base_stats["multiplier_mana"] > 0f || item.base_stats["multiplier_stamina"] > 0f)
			{
				item.action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(item.action_on_augmentation_add, new WorldActionTrait(ActionLibrary.restoreFullStats));
			}
			if (item.base_stats["health"] < 0f || item.base_stats["mana"] < 0f || item.base_stats["stamina"] < 0f || item.base_stats["multiplier_health"] < 0f || item.base_stats["multiplier_mana"] < 0f || item.base_stats["multiplier_stamina"] < 0f)
			{
				item.action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(item.action_on_augmentation_remove, new WorldActionTrait(ActionLibrary.restoreFullStats));
			}
		}
	}

	public override ActorTrait add(ActorTrait pAsset)
	{
		base.add(pAsset);
		checkDefault(pAsset);
		return pAsset;
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (ActorTrait item in list)
		{
			if (item.is_mutation_box_allowed)
			{
				pot_traits_mutation_box.Add(item);
			}
		}
		foreach (ActorTrait item2 in list)
		{
			if (item2.rate_birth != 0)
			{
				for (int i = 0; i < item2.rate_birth; i++)
				{
					pot_traits_birth.Add(item2);
				}
			}
		}
		foreach (ActorTrait item3 in list)
		{
			if (item3.rate_acquire_grow_up != 0)
			{
				for (int j = 0; j < item3.rate_acquire_grow_up; j++)
				{
					pot_traits_growup.Add(item3);
				}
			}
		}
		foreach (ActorTrait item4 in list)
		{
			if (item4.in_training_dummy_combat_pot)
			{
				pot_traits_combat.Add(item4);
			}
		}
	}

	private void checkDefault(ActorTrait pAsset)
	{
		if (pAsset.rate_inherit == 0)
		{
			pAsset.rate_inherit = pAsset.rate_birth * 10;
		}
	}

	public int checkTraitsMod(Actor pMain, Actor pTarget)
	{
		int num = 0;
		foreach (ActorTrait trait in pMain.getTraits())
		{
			if (trait.same_trait_mod != 0 && pTarget.hasTrait(trait))
			{
				num += trait.same_trait_mod;
			}
			if (trait.opposite_trait_mod == 0)
			{
				continue;
			}
			foreach (ActorTrait opposite_trait in trait.opposite_traits)
			{
				if (pTarget.hasTrait(opposite_trait))
				{
					num += trait.opposite_trait_mod;
				}
			}
		}
		return num;
	}
}
// --- End of File: ActorTraitLibrary.cs ---



// --- Start of File: ActorTraitsContainer.cs ---
public class ActorTraitsContainer : TraitsContainer<ActorTrait, ActorTraitButton>
{
}
// --- End of File: ActorTraitsContainer.cs ---



// --- Start of File: ActorTraitsEditor.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ActorTraitsEditor : TraitsEditor<ActorTrait, ActorTraitButton, ActorTraitEditorButton, ActorTraitGroupAsset, ActorTraitGroupElement>
{
	protected override MetaType meta_type => MetaType.Unit;

	protected override List<ActorTraitGroupAsset> augmentation_groups_list => AssetManager.trait_groups.list;

	protected override ActorTrait edited_marker_augmentation => AssetManager.traits.get("scar_of_divinity");

	protected override List<ActorTrait> all_augmentations_list => AssetManager.traits.list;

	protected override void onEnableRain()
	{
		TraitRainAsset tAsset = AssetManager.trait_rains.get(Config.selected_trait_editor);
		augmentations_list_link = tAsset.get_list();
		rain_editor_state = tAsset.get_state();
		rain_state_toggle_action = delegate
		{
			toggleRainState(tAsset);
		};
		art.sprite = ((rain_editor_state == RainState.Add) ? tAsset.getSpriteArt() : tAsset.getSpriteArtVoid());
		validateRainData();
		rain_state_switcher.toggleState(rain_editor_state == RainState.Remove);
		augmentations_hashset.Clear();
		augmentations_hashset.UnionWith(augmentations_list_link);
		saveRainValues();
		loadEditorSelectedAugmentations();
		GodPower godPower = AssetManager.powers.get(Config.selected_trait_editor);
		window_title_text.key = godPower.getLocaleID();
		window_title_text.updateText();
		power_icon.sprite = godPower.getIconSprite();
		for (int i = 0; i < powers_icons.childCount; i++)
		{
			((Component)((Component)powers_icons).transform.GetChild(i)).GetComponent<Image>().sprite = godPower.getIconSprite();
		}
	}

	protected override bool addTrait(ActorTrait pTrait)
	{
		return base.addTrait(pTrait);
	}

	protected override void onNanoWasModified()
	{
		base.onNanoWasModified();
		Actor obj = (Actor)getTraitsOwner();
		obj.makeStunnedFromUI();
		obj.updateStats();
	}

	protected override void loadEditorSelectedButton(ActorTraitButton pButton, string pAugmentationId)
	{
		base.loadEditorSelectedButton(pButton, pAugmentationId);
		pButton.load(pAugmentationId);
	}

	protected override bool isAugmentationExists(string pId)
	{
		return AssetManager.traits.has(pId);
	}

	public override void scrollToGroupStarter(GameObject pButton, bool pIgnoreTooltipCheck)
	{
		if (rain_editor || getActorAsset().can_edit_traits)
		{
			base.scrollToGroupStarter(pButton, pIgnoreTooltipCheck);
		}
	}

	protected void toggleRainState(TraitRainAsset pAsset)
	{
		RainState pState;
		if (pAsset.get_state() == RainState.Add)
		{
			pState = RainState.Remove;
			rain_state_switcher.toggleState(pState: true);
			art.sprite = pAsset.getSpriteArtVoid();
		}
		else
		{
			pState = RainState.Add;
			rain_state_switcher.toggleState(pState: false);
			art.sprite = pAsset.getSpriteArt();
		}
		IllustrationFadeIn component = ((Component)art).GetComponent<IllustrationFadeIn>();
		if ((Object)(object)component != (Object)null)
		{
			component.startTween();
		}
		pAsset.set_state(pState);
		rain_editor_state = pState;
		reloadButtons();
	}
}
// --- End of File: ActorTraitsEditor.cs ---



// --- Start of File: ActorVisibleDataArray.cs ---
using System.Collections;

public class ActorVisibleDataArray
{
	public Actor[] array = new Actor[0];

	public int count;

	public void prepare(int pTargetSize)
	{
		array = Toolbox.checkArraySize(array, pTargetSize);
	}

	public void addFromCollection(ICollection pList)
	{
		if (pList.Count != 0)
		{
			pList.CopyTo(array, count);
			count += pList.Count;
		}
	}
}
// --- End of File: ActorVisibleDataArray.cs ---



// --- Start of File: AdButtonTimer.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AdButtonTimer : MonoBehaviour
{
	internal static AdButtonTimer instance;

	public Text timer;

	public Button button;

	public Image icon;

	private double adTimer;

	private Color transparent = new Color(1f, 1f, 1f, 0.3f);

	private int tRecalc;

	private void Awake()
	{
		instance = this;
		adTimer = 10.0;
	}

	internal static void setAdTimer()
	{
		if (PlayerConfig.instance != null)
		{
			double nextAdTimestamp = PlayerConfig.instance.data.nextAdTimestamp;
			nextAdTimestamp -= Epoch.Current();
			instance.adTimer = nextAdTimestamp;
			if (instance.adTimer < 0.0 || PlayerConfig.instance.data.nextAdTimestamp == -1.0)
			{
				instance.adTimer = -1.0;
			}
		}
	}

	private void OnEnable()
	{
		setAdTimer();
		updateButton();
	}

	private void Update()
	{
		if (Config.hasPremium)
		{
			((Component)this).gameObject.SetActive(false);
			return;
		}
		if (adTimer > 0.0)
		{
			adTimer -= Time.deltaTime;
		}
		updateButton();
	}

	private void updateButton()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (tRecalc > 0)
		{
			tRecalc--;
		}
		else
		{
			tRecalc = 10;
			setAdTimer();
		}
		if (adTimer > 0.0)
		{
			((Component)timer).gameObject.SetActive(true);
			timer.text = Toolbox.formatTimer((float)adTimer);
			((Graphic)icon).color = transparent;
		}
		else
		{
			((Component)timer).gameObject.SetActive(false);
			((Graphic)icon).color = Color.white;
		}
	}
}
// --- End of File: AdButtonTimer.cs ---



// --- Start of File: AdLoadingButton.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AdLoadingButton : MonoBehaviour
{
	public Text button_text;

	public LocalizedText button_localized_text;

	public Button button;

	private Image button_image;

	public Sprite spriteOn;

	public Sprite spriteOff;

	private AdLoadingButtonState state;

	private void Awake()
	{
		button_image = ((Component)button).GetComponent<Image>();
		button_localized_text = ((Component)button_text).GetComponent<LocalizedText>();
		state = AdLoadingButtonState.None;
	}

	private void Update()
	{
		AdLoadingButtonState adLoadingButtonState = AdLoadingButtonState.None;
		if (Config.isEditor && Config.editor_test_rewards_from_ads)
		{
			adLoadingButtonState = AdLoadingButtonState.AdReady;
			state = adLoadingButtonState;
			toggleState();
			return;
		}
		if (RewardedAds.isReady())
		{
			adLoadingButtonState = AdLoadingButtonState.AdReady;
		}
		else if (!Config.adsInitialized)
		{
			adLoadingButtonState = AdLoadingButtonState.Initializing;
		}
		else
		{
			adLoadingButtonState = AdLoadingButtonState.AdLoading;
			RewardedAds.trimTimeout();
		}
		if (adLoadingButtonState != state)
		{
			state = adLoadingButtonState;
			toggleState();
		}
	}

	private void toggleState()
	{
		switch (state)
		{
		case AdLoadingButtonState.Initializing:
			((Selectable)button).interactable = false;
			button_localized_text.setKeyAndUpdate("waiting_for_ad");
			button_image.sprite = spriteOff;
			break;
		case AdLoadingButtonState.AdLoading:
			((Selectable)button).interactable = false;
			button_localized_text.setKeyAndUpdate("loading_ads");
			button_image.sprite = spriteOff;
			break;
		case AdLoadingButtonState.AdReady:
			((Selectable)button).interactable = true;
			button_localized_text.setKeyAndUpdate("watch_ad");
			button_image.sprite = spriteOn;
			break;
		}
	}
}
// --- End of File: AdLoadingButton.cs ---



// --- Start of File: AdLoadingButtonState.cs ---
internal enum AdLoadingButtonState
{
	None,
	Initializing,
	AdLoading,
	AdReady
}
// --- End of File: AdLoadingButtonState.cs ---



// --- Start of File: AfterHatchFromEggAction.cs ---
public delegate void AfterHatchFromEggAction(Actor pActor);
// --- End of File: AfterHatchFromEggAction.cs ---



// --- Start of File: AIHistoryElement.cs ---
public struct AIHistoryElement
{
	public string id;

	public double timestamp;
}
// --- End of File: AIHistoryElement.cs ---



// --- Start of File: AIHistoryElementDecision.cs ---
public struct AIHistoryElementDecision
{
	public string id;

	public int amount;

	public double last_timestamp;
}
// --- End of File: AIHistoryElementDecision.cs ---



// --- Start of File: AILibrary.cs ---
namespace ai.behaviours;

public class AILibrary : BehaviourTaskActorLibrary
{
}
// --- End of File: AILibrary.cs ---



// --- Start of File: AiSystem.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using ai.behaviours;

public abstract class AiSystem<TSimObject, TJob, TTask, TAction, TCondition> where TJob : JobAsset<TCondition, TSimObject> where TTask : BehaviourTaskBase<TAction> where TAction : BehaviourActionBase<TSimObject> where TCondition : BehaviourBaseCondition<TSimObject>
{
	public AssetLibrary<TJob> jobs_library;

	public AssetLibrary<TTask> task_library;

	private List<SingleAction<TTask, TAction>> _single_actions;

	internal int action_index;

	internal int restarts;

	internal int task_index;

	private int[] _random_tasks = new int[0];

	public TJob job;

	internal TTask task;

	internal TAction action;

	private double _timestamp_task_start;

	protected readonly TSimObject ai_object;

	public GetNextJobID next_job_delegate;

	public JobAction clear_action_delegate;

	private TaskSwitchAction _task_switch_action;

	private string _scheduled_task_id;

	public AiSystem(TSimObject pObject)
	{
		ai_object = pObject;
		next_job_delegate = nextJobDefault;
	}

	public void scheduleTask(string pTaskID)
	{
		_scheduled_task_id = pTaskID;
	}

	public void addSingleTask(string pID)
	{
		TTask pTask = task_library.get(pID);
		if (_single_actions == null)
		{
			_single_actions = new List<SingleAction<TTask, TAction>>();
		}
		SingleAction<TTask, TAction> singleAction = new SingleAction<TTask, TAction>(pTask);
		_single_actions.Add(singleAction);
		singleAction.reset();
	}

	private void updateNewBehJob()
	{
		if (_scheduled_task_id != null)
		{
			setTask(_scheduled_task_id);
			_scheduled_task_id = null;
			return;
		}
		if (job == null)
		{
			string text = next_job_delegate();
			setJob(text);
		}
		if (task_index >= job.tasks.Count)
		{
			task_index = 0;
		}
		TaskContainer<TCondition, TSimObject> nextTask = getNextTask(job);
		if (nextTask.has_conditions)
		{
			if (checkConditionsForTask(nextTask))
			{
				setTask(nextTask.id);
			}
			else
			{
				setTask("nothing");
			}
		}
		else
		{
			setTask(nextTask.id);
		}
	}

	private TaskContainer<TCondition, TSimObject> getNextTask(TJob pJob)
	{
		List<TaskContainer<TCondition, TSimObject>> tasks = pJob.tasks;
		if (pJob.random)
		{
			if (task_index == 0 && _random_tasks.Length != tasks.Count)
			{
				_random_tasks = new int[tasks.Count];
				for (int i = 0; i < _random_tasks.Length; i++)
				{
					_random_tasks[i] = i;
				}
				_random_tasks.Shuffle();
			}
			return tasks[_random_tasks[task_index++]];
		}
		return tasks[task_index++];
	}

	private bool checkConditionsForTask(TaskContainer<TCondition, TSimObject> pTaskContainer)
	{
		if (pTaskContainer.conditions.Count == 0)
		{
			Debug.LogError((object)"TOO MANY COOKS");
		}
		foreach (var (val2, flag2) in pTaskContainer.conditions)
		{
			if (val2.check(ai_object) != flag2)
			{
				return false;
			}
		}
		return true;
	}

	public void subscribeToTaskSwitch(TaskSwitchAction pAction)
	{
		_task_switch_action = (TaskSwitchAction)Delegate.Combine(_task_switch_action, pAction);
	}

	public virtual void setTask(string pTaskId, bool pClean = true, bool pCleanJob = false, bool pForceAction = false)
	{
		if (pClean)
		{
			clearBeh();
		}
		if (pCleanJob)
		{
			job = null;
			task_index = 0;
			clearAction();
		}
		task = task_library.get(pTaskId);
		action_index = 0;
		restarts = 0;
		_timestamp_task_start = World.world.getCurWorldTime();
		if (pForceAction)
		{
			setAction(task.get(action_index));
		}
		_task_switch_action?.Invoke();
	}

	protected virtual void setAction(TAction pAction)
	{
		action = pAction;
	}

	private void clearAction()
	{
		action = null;
	}

	public void restartJob()
	{
		action_index = 0;
		task_index = 0;
		clearAction();
	}

	internal void clearBeh()
	{
		if (clear_action_delegate != null)
		{
			clear_action_delegate();
		}
	}

	public void clearJob()
	{
		job = null;
		task_index = 0;
	}

	public virtual void setJob(string pJobID)
	{
		job = jobs_library.get(pJobID);
		task_index = 0;
	}

	public void updateSingleTasks(float pElapsed)
	{
		if (_single_actions == null)
		{
			return;
		}
		for (int i = 0; i < _single_actions.Count; i++)
		{
			SingleAction<TTask, TAction> singleAction = _single_actions[i];
			singleAction.timer -= pElapsed;
			if (singleAction.timer <= 0f)
			{
				singleAction.task.list[0].startExecute(ai_object);
				singleAction.reset();
			}
		}
	}

	internal void update()
	{
		if (Bench.bench_ai_enabled)
		{
			if (task != null)
			{
				_ = task.id;
			}
			double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
			run();
			double pValue = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
			if (task != null)
			{
				task.rate_counter_calls.registerEvent();
				task.rate_counter_performance.registerEvent(pValue);
			}
		}
		else
		{
			run();
		}
	}

	public void decisionRun()
	{
		run();
	}

	private void run()
	{
		if (task == null)
		{
			updateNewBehJob();
			if (task == null)
			{
				return;
			}
		}
		if (action_index >= task.list.Count)
		{
			setTaskBehFinished();
			return;
		}
		setAction(task.get(action_index));
		BehResult behResult;
		if (Bench.bench_ai_enabled)
		{
			_ = action.id;
			double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
			behResult = action.startExecute(ai_object);
			double pValue = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
			if (action != null)
			{
				action.rate_counter_calls.registerEvent();
				action.rate_counter_performance.registerEvent(pValue);
			}
		}
		else
		{
			behResult = action.startExecute(ai_object);
		}
		if (task == null)
		{
			return;
		}
		switch (behResult)
		{
		case BehResult.Continue:
			action_index++;
			break;
		case BehResult.Stop:
			setTaskBehFinished();
			break;
		case BehResult.StepBack:
			action_index--;
			if (action_index < 0)
			{
				action_index = 0;
			}
			break;
		case BehResult.RestartTask:
			action_index = 0;
			restarts++;
			break;
		case BehResult.ImmediateRun:
			run();
			break;
		case BehResult.RepeatStep:
		case BehResult.Skip:
		case BehResult.ActiveTaskReturn:
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasTask()
	{
		return task != null;
	}

	public void setTaskBehFinished()
	{
		task = null;
		action_index = -1;
		clearAction();
	}

	protected virtual void debugLogAction()
	{
	}

	protected virtual void debugLogActionResult(BehResult pResult)
	{
	}

	protected string getActionID(TAction pAction)
	{
		string text = pAction?.GetType().ToString();
		if (text != null)
		{
			text = text.Replace("ai.behaviours.", "");
		}
		return text;
	}

	public void debug(DebugTool pTool)
	{
		string text = getActionID(action);
		if (text != null)
		{
			text = text.Replace("ai.behaviours.", "");
		}
		pTool.setText("job:", (job == null) ? "-" : job.id, 0f, pShowBar: false, 0L);
		string text2;
		if (task_index + 1 < job?.tasks.Count)
		{
			if (job.random)
			{
				text2 = job?.tasks[_random_tasks[task_index + 1]].id;
				text2 += " (R)";
			}
			else
			{
				text2 = job?.tasks[task_index + 1].id;
				text2 += " (S)";
			}
		}
		else
		{
			text2 = "-";
		}
		pTool.setText("next task:", text2, 0f, pShowBar: false, 0L);
		pTool.setSeparator();
		pTool.setText(": task:", task?.id, 0f, pShowBar: false, 0L);
		pTool.setText(": task index:", task_index + "/" + job?.tasks.Count, 0f, pShowBar: false, 0L);
		pTool.setSeparator();
		pTool.setText(":: action:", text, 0f, pShowBar: false, 0L);
		pTool.setText(":: action index:", action_index + "/" + task?.list.Count, 0f, pShowBar: false, 0L);
		pTool.setSeparator();
	}

	public static string nextJobDefault()
	{
		return null;
	}

	internal virtual void reset()
	{
		jobs_library = null;
		task_library = null;
		_single_actions = null;
		action_index = 0;
		task_index = 0;
		restarts = 0;
		job = null;
		task = null;
		action = null;
		next_job_delegate = null;
		clear_action_delegate = null;
		_task_switch_action = null;
	}

	public string getTaskTime()
	{
		return Date.formatSeconds(World.world.getWorldTimeElapsedSince(_timestamp_task_start));
	}
}
// --- End of File: AiSystem.cs ---



// --- Start of File: AiSystemActor.cs ---
using ai.behaviours;

public class AiSystemActor : AiSystem<Actor, ActorJob, BehaviourTaskActor, BehaviourActionActor, BehaviourActorCondition>
{
	public AiSystemActor(Actor pObject)
		: base(pObject)
	{
	}
}
// --- End of File: AiSystemActor.cs ---



// --- Start of File: AiSystemCity.cs ---
public class AiSystemCity : AiSystem<City, JobCityAsset, BehaviourTaskCity, BehaviourActionCity, BehaviourCityCondition>
{
	public AiSystemCity(City pObject)
		: base(pObject)
	{
	}
}
// --- End of File: AiSystemCity.cs ---



// --- Start of File: AISystemDebug.cs ---
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public static class AISystemDebug
{
	private static string dataName = "/ai_system.log";

	private static List<string> debug_list_actions = new List<string>();

	public static void clear()
	{
		debug_list_actions.Clear();
	}

	public static void debugLog(string pString)
	{
		debug_list_actions.Add(pString);
		if (debug_list_actions.Count > 1000)
		{
			debug_list_actions.RemoveAt(0);
		}
	}

	public static void log()
	{
		string text = "";
		foreach (string debug_list_action in debug_list_actions)
		{
			text = text + debug_list_action + "\n";
		}
		File.WriteAllText(getPath(), text);
	}

	public static string getPath()
	{
		return Application.persistentDataPath + dataName;
	}
}
// --- End of File: AISystemDebug.cs ---



// --- Start of File: AiSystemKingdom.cs ---
public class AiSystemKingdom : AiSystem<Kingdom, KingdomJob, BehaviourTaskKingdom, BehaviourActionKingdom, BehaviourKingdomCondition>
{
	public AiSystemKingdom(Kingdom pObject)
		: base(pObject)
	{
	}
}
// --- End of File: AiSystemKingdom.cs ---



// --- Start of File: AiSystemTester.cs ---
public class AiSystemTester : AiSystem<AutoTesterBot, JobTesterAsset, BehaviourTaskTester, BehaviourActionTester, BehaviourTesterCondition>
{
	public AiSystemTester(AutoTesterBot pObject)
		: base(pObject)
	{
		jobs_library = AssetManager.tester_jobs;
		task_library = AssetManager.tester_tasks;
	}
}
// --- End of File: AiSystemTester.cs ---



// --- Start of File: AITask.cs ---
namespace ai.behaviours;

public class AITask : BehaviourTaskActorLibrary
{
}
// --- End of File: AITask.cs ---



// --- Start of File: Alliance.cs ---
using System.Collections.Generic;
using UnityEngine;
using db;

public class Alliance : MetaObject<AllianceData>
{
	public List<Kingdom> kingdoms_list = new List<Kingdom>();

	public HashSet<Kingdom> kingdoms_hashset = new HashSet<Kingdom>();

	public int power;

	protected override MetaType meta_type => MetaType.Alliance;

	public override BaseSystemManager manager => World.world.alliances;

	public void createNewAlliance()
	{
		string pName = NameGenerator.getName("alliance_name");
		setName(pName);
		generateNewMetaObject();
	}

	protected sealed override void setDefaultValues()
	{
		base.setDefaultValues();
		power = 0;
	}

	public override int countTotalMoney()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countTotalMoney();
		}
		return num;
	}

	public override int countHappyUnits()
	{
		if (kingdoms_list.Count == 0)
		{
			return 0;
		}
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countHappyUnits();
		}
		return num;
	}

	public override int countSick()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countSick();
		}
		return num;
	}

	public override int countHungry()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countHungry();
		}
		return num;
	}

	public override int countStarving()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countStarving();
		}
		return num;
	}

	public override int countChildren()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countChildren();
		}
		return num;
	}

	public override int countAdults()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countAdults();
		}
		return num;
	}

	public override int countHomeless()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countHomeless();
		}
		return num;
	}

	public override IEnumerable<Family> getFamilies()
	{
		List<Kingdom> tKingdoms = kingdoms_list;
		for (int i = 0; i < tKingdoms.Count; i++)
		{
			Kingdom kingdom = tKingdoms[i];
			foreach (Family family in kingdom.getFamilies())
			{
				yield return family;
			}
		}
	}

	public override bool hasFamilies()
	{
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].hasFamilies())
			{
				return true;
			}
		}
		return false;
	}

	public override int countMales()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countMales();
		}
		return num;
	}

	public override int countFemales()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countFemales();
		}
		return num;
	}

	public override int countHoused()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countHoused();
		}
		return num;
	}

	public void setType(AllianceType pType)
	{
		data.alliance_type = pType;
	}

	public bool isForcedType()
	{
		return data.alliance_type == AllianceType.Forced;
	}

	public bool isNormalType()
	{
		return data.alliance_type == AllianceType.Normal;
	}

	protected override ColorLibrary getColorLibrary()
	{
		return AssetManager.kingdom_colors_library;
	}

	public override void generateBanner()
	{
		Sprite[] backgroundsList = World.world.alliances.getBackgroundsList();
		data.banner_background_id = Randy.randomInt(0, backgroundsList.Length);
		Sprite[] iconsList = World.world.alliances.getIconsList();
		data.banner_icon_id = Randy.randomInt(0, iconsList.Length);
	}

	public void addFounders(Kingdom pKingdom1, Kingdom pKingdom2)
	{
		data.founder_kingdom_name = pKingdom1.data.name;
		data.founder_kingdom_id = pKingdom1.getID();
		data.founder_actor_name = pKingdom1.king?.getName();
		data.founder_actor_id = pKingdom1.king?.getID() ?? (-1);
		join(pKingdom1, pRecalc: true, pForce: true);
		join(pKingdom2, pRecalc: true, pForce: true);
	}

	public void update()
	{
		power = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			power += kingdom.power;
		}
	}

	public bool checkActive()
	{
		bool flag = false;
		List<Kingdom> list = kingdoms_list;
		for (int num = list.Count - 1; num >= 0; num--)
		{
			Kingdom kingdom = list[num];
			if (!kingdom.isAlive())
			{
				leave(kingdom, pRecalc: false);
				kingdoms_list.RemoveAt(num);
				flag = true;
			}
		}
		if (flag)
		{
			recalculate();
		}
		if (kingdoms_list.Count >= 2)
		{
			return true;
		}
		return false;
	}

	public void dissolve()
	{
		foreach (Kingdom item in kingdoms_hashset)
		{
			item.allianceLeave(this);
		}
		kingdoms_hashset.Clear();
	}

	public void recalculate()
	{
		kingdoms_list.Clear();
		kingdoms_list.AddRange(kingdoms_hashset);
		mergeWars();
	}

	public bool canJoin(Kingdom pKingdom)
	{
		foreach (Kingdom item in kingdoms_hashset)
		{
			if (!pKingdom.isOpinionTowardsKingdomGood(item))
			{
				return false;
			}
		}
		return true;
	}

	public bool join(Kingdom pKingdom, bool pRecalc = true, bool pForce = false)
	{
		if (hasKingdom(pKingdom))
		{
			return false;
		}
		if (!pForce && !canJoin(pKingdom))
		{
			return false;
		}
		kingdoms_hashset.Add(pKingdom);
		if (hasWars())
		{
			if (hasWarsWith(pKingdom))
			{
				foreach (War attackerWar in getAttackerWars())
				{
					if (attackerWar.isDefender(pKingdom))
					{
						attackerWar.leaveWar(pKingdom);
					}
				}
				foreach (War defenderWar in getDefenderWars())
				{
					if (defenderWar.isAttacker(pKingdom))
					{
						defenderWar.leaveWar(pKingdom);
					}
				}
			}
			foreach (War attackerWar2 in getAttackerWars())
			{
				attackerWar2.joinAttackers(pKingdom);
			}
			foreach (War defenderWar2 in getDefenderWars())
			{
				if (!defenderWar2.isTotalWar())
				{
					defenderWar2.joinDefenders(pKingdom);
				}
			}
		}
		if (pKingdom.hasEnemies())
		{
			foreach (War war in pKingdom.getWars())
			{
				if (war.isTotalWar())
				{
					continue;
				}
				if (war.isMainAttacker(pKingdom))
				{
					foreach (Kingdom item in kingdoms_list)
					{
						war.joinAttackers(item);
					}
				}
				if (!war.isMainDefender(pKingdom))
				{
					continue;
				}
				foreach (Kingdom item2 in kingdoms_list)
				{
					war.joinDefenders(item2);
				}
			}
		}
		pKingdom.allianceJoin(this);
		if (pRecalc)
		{
			recalculate();
		}
		data.timestamp_member_joined = World.world.getCurWorldTime();
		return true;
	}

	public void leave(Kingdom pKingdom, bool pRecalc = true)
	{
		kingdoms_hashset.Remove(pKingdom);
		if (hasWars())
		{
			foreach (War attackerWar in getAttackerWars())
			{
				if (!attackerWar.isMainAttacker(pKingdom))
				{
					attackerWar.leaveWar(pKingdom);
					continue;
				}
				foreach (Kingdom item in kingdoms_hashset)
				{
					attackerWar.leaveWar(item);
				}
			}
			foreach (War defenderWar in getDefenderWars())
			{
				if (!defenderWar.isMainDefender(pKingdom))
				{
					defenderWar.leaveWar(pKingdom);
					continue;
				}
				foreach (Kingdom item2 in kingdoms_hashset)
				{
					defenderWar.leaveWar(item2);
				}
			}
		}
		pKingdom.allianceLeave(this);
		if (pRecalc)
		{
			recalculate();
		}
	}

	public override void save()
	{
		base.save();
		data.kingdoms = new List<long>();
		foreach (Kingdom item in kingdoms_hashset)
		{
			data.kingdoms.Add(item.id);
		}
	}

	public override void loadData(AllianceData pData)
	{
		base.loadData(pData);
		foreach (long kingdom2 in data.kingdoms)
		{
			Kingdom kingdom = World.world.kingdoms.get(kingdom2);
			if (kingdom != null)
			{
				kingdoms_hashset.Add(kingdom);
			}
		}
		recalculate();
	}

	public int countBuildings()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countBuildings();
		}
		return num;
	}

	public int countZones()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countZones();
		}
		return num;
	}

	public override int countUnits()
	{
		return countPopulation();
	}

	public int countPopulation()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.getPopulationPeople();
		}
		return num;
	}

	public int countCities()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countCities();
		}
		return num;
	}

	public int countKingdoms()
	{
		return kingdoms_hashset.Count;
	}

	public string getMotto()
	{
		if (string.IsNullOrEmpty(data.motto))
		{
			data.motto = NameGenerator.getName("alliance_mottos");
		}
		return data.motto;
	}

	public int countWarriors()
	{
		int num = 0;
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom kingdom = list[i];
			num += kingdom.countTotalWarriors();
		}
		return num;
	}

	public static bool isSame(Alliance pAlliance1, Alliance pAlliance2)
	{
		if (pAlliance1 == null || pAlliance2 == null)
		{
			return false;
		}
		return pAlliance1 == pAlliance2;
	}

	public bool hasWarsWith(Kingdom pKingdom)
	{
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom pKingdom2 = list[i];
			if (pKingdom.isInWarWith(pKingdom2))
			{
				return true;
			}
		}
		return false;
	}

	public bool hasSupremeKingdom()
	{
		if (DiplomacyManager.kingdom_supreme == null)
		{
			return false;
		}
		return hasKingdom(DiplomacyManager.kingdom_supreme);
	}

	public bool hasKingdom(Kingdom pKingdom)
	{
		return kingdoms_hashset.Contains(pKingdom);
	}

	public bool hasSharedBordersWithKingdom(Kingdom pKingdom)
	{
		List<Kingdom> list = kingdoms_list;
		for (int i = 0; i < list.Count; i++)
		{
			Kingdom pTarget = list[i];
			if (DiplomacyHelpers.areKingdomsClose(pKingdom, pTarget))
			{
				return true;
			}
		}
		return false;
	}

	public bool hasWars()
	{
		return World.world.wars.hasWars(this);
	}

	public IEnumerable<War> getWars(bool pRandom = false)
	{
		return World.world.wars.getWars(this, pRandom);
	}

	public void mergeWars()
	{
		if (!hasWars())
		{
			return;
		}
		using ListPool<War> listPool = new ListPool<War>(getWars());
		for (int i = 0; i < listPool.Count; i++)
		{
			War war = listPool[i];
			if (war.hasEnded())
			{
				continue;
			}
			for (int j = i + 1; j < listPool.Count; j++)
			{
				War war2 = listPool[j];
				if (!war2.hasEnded() && war.isSameAs(war2))
				{
					if (war.data.created_time < war2.data.created_time)
					{
						World.world.wars.endWar(war2, WarWinner.Merged);
					}
					else
					{
						World.world.wars.endWar(war, WarWinner.Merged);
					}
					mergeWars();
					return;
				}
			}
		}
	}

	public IEnumerable<War> getAttackerWars()
	{
		foreach (War war in getWars())
		{
			foreach (Kingdom item in kingdoms_list)
			{
				if (war.isAttacker(item))
				{
					yield return war;
					break;
				}
			}
		}
	}

	public IEnumerable<War> getDefenderWars()
	{
		foreach (War war in getWars())
		{
			foreach (Kingdom item in kingdoms_list)
			{
				if (war.isDefender(item))
				{
					yield return war;
					break;
				}
			}
		}
	}

	public override IEnumerable<Actor> getUnits()
	{
		List<Kingdom> tKingdoms = kingdoms_list;
		for (int i = 0; i < tKingdoms.Count; i++)
		{
			Kingdom kingdom = tKingdoms[i];
			foreach (Actor unit in kingdom.getUnits())
			{
				yield return unit;
			}
		}
	}

	public override bool isReadyForRemoval()
	{
		return false;
	}

	public override Actor getRandomUnit()
	{
		return kingdoms_list.GetRandom().getRandomUnit();
	}

	public Sprite getBackgroundSprite()
	{
		return World.world.alliances.getBackgroundsList()[data.banner_background_id];
	}

	public Sprite getIconSprite()
	{
		return World.world.alliances.getIconsList()[data.banner_icon_id];
	}

	public override void Dispose()
	{
		DBInserter.deleteData(getID(), "alliance");
		kingdoms_list.Clear();
		kingdoms_hashset.Clear();
		base.Dispose();
	}
}
// --- End of File: Alliance.cs ---



// --- Start of File: AllianceBanner.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AllianceBanner : BannerGeneric<Alliance, AllianceData>
{
	public Sprite frame_normal;

	public Sprite frame_forced;

	protected override MetaType meta_type => MetaType.Alliance;

	protected override string tooltip_id => "alliance";

	protected override TooltipData getTooltipData()
	{
		TooltipData tooltipData = base.getTooltipData();
		tooltipData.alliance = meta_object;
		return tooltipData;
	}

	protected override void setupBanner()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.setupBanner();
		part_background.sprite = meta_object.getBackgroundSprite();
		part_icon.sprite = meta_object.getIconSprite();
		ColorAsset colorAsset = meta_object.getColor();
		((Graphic)part_background).color = colorAsset.getColorMainSecond();
		((Graphic)part_icon).color = colorAsset.getColorBanner();
		if (meta_object.isNormalType())
		{
			part_frame.sprite = frame_normal;
		}
		else
		{
			part_frame.sprite = frame_forced;
		}
	}
}
// --- End of File: AllianceBanner.cs ---



// --- Start of File: AllianceBannersContainer.cs ---
using UnityEngine;

public class AllianceBannersContainer<TBanner, TMetaObject, TData> : AllianceElement where TBanner : BannerGeneric<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
{
	protected ObjectPoolGenericMono<TBanner> pool_elements;

	[SerializeField]
	private TBanner _prefab;

	[SerializeField]
	private Transform _container;

	protected override void Awake()
	{
		pool_elements = new ObjectPoolGenericMono<TBanner>(_prefab, _container);
		base.Awake();
	}

	protected override void clear()
	{
		pool_elements.clear();
		base.clear();
	}
}
// --- End of File: AllianceBannersContainer.cs ---



// --- Start of File: AllianceCustomizeWindow.cs ---
public class AllianceCustomizeWindow : GenericCustomizeWindow<Alliance, AllianceData, AllianceBanner>
{
	protected override MetaType meta_type => MetaType.Alliance;

	protected override Alliance meta_object => SelectedMetas.selected_alliance;

	protected override void onBannerChange()
	{
		image_banner_option_1.sprite = meta_object.getBackgroundSprite();
		image_banner_option_2.sprite = meta_object.getIconSprite();
	}
}
// --- End of File: AllianceCustomizeWindow.cs ---



// --- Start of File: AllianceData.cs ---
using System.Collections.Generic;
using System.ComponentModel;

public class AllianceData : MetaObjectData
{
	public List<long> kingdoms;

	public double timestamp_member_joined;

	[DefaultValue(AllianceType.Normal)]
	public AllianceType alliance_type;

	public string motto { get; set; }

	public int banner_background_id { get; set; }

	public int banner_icon_id { get; set; }

	public string founder_actor_name { get; set; }

	[DefaultValue(-1L)]
	public long founder_actor_id { get; set; } = -1L;


	public string founder_kingdom_name { get; set; }

	[DefaultValue(-1L)]
	public long founder_kingdom_id { get; set; } = -1L;

}
// --- End of File: AllianceData.cs ---



// --- Start of File: AllianceElement.cs ---
public class AllianceElement : WindowMetaElement<Alliance, AllianceData>
{
	protected Alliance alliance => meta_object;
}
// --- End of File: AllianceElement.cs ---



// --- Start of File: AllianceKingdomsContainer.cs ---
using System.Collections;
using UnityEngine;

public class AllianceKingdomsContainer : AllianceBannersContainer<KingdomBanner, Kingdom, KingdomData>
{
	protected override IEnumerator showContent()
	{
		if (base.alliance.kingdoms_hashset.Count == 0)
		{
			yield break;
		}
		using ListPool<Kingdom> tList = new ListPool<Kingdom>(base.alliance.kingdoms_hashset);
		track_objects.AddRange(tList);
		foreach (ref Kingdom item in tList)
		{
			Kingdom tKingdom = item;
			yield return (object)new WaitForSecondsRealtime(0.025f);
			showBanner(tKingdom);
		}
	}

	protected void showBanner(Kingdom pKingdom)
	{
		KingdomBanner next = pool_elements.getNext();
		next.load(pKingdom);
		((Component)(object)next).AddComponent<DraggableLayoutElement>();
	}
}
// --- End of File: AllianceKingdomsContainer.cs ---



// --- Start of File: AllianceListComponent.cs ---
public class AllianceListComponent : ComponentListBase<AllianceListElement, Alliance, AllianceData, AllianceListComponent>
{
	protected override MetaType meta_type => MetaType.Alliance;

	protected override void setupSortingTabs()
	{
		genericMetaSortByAge(base.sortByAge);
		genericMetaSortByRenown(base.sortByRenown);
		genericMetaSortByPopulation(ComponentListBase<AllianceListElement, Alliance, AllianceData, AllianceListComponent>.sortByPopulation);
		sorting_tab.tryAddButton("ui/Icons/iconArmy", "sort_by_army", show, delegate
		{
			current_sort = sortByArmy;
		});
		sorting_tab.tryAddButton("ui/Icons/iconKingdomList", "sort_by_kingdoms", show, delegate
		{
			current_sort = sortByKingdoms;
		});
		sorting_tab.tryAddButton("ui/Icons/iconVillages", "sort_by_villages", show, delegate
		{
			current_sort = sortByVillages;
		});
	}

	public static int sortByArmy(Alliance pAlliance1, Alliance pAlliance2)
	{
		return pAlliance2.countWarriors().CompareTo(pAlliance1.countWarriors());
	}

	public static int sortByKingdoms(Alliance pAlliance1, Alliance pAlliance2)
	{
		return pAlliance2.countKingdoms().CompareTo(pAlliance1.countKingdoms());
	}

	public static int sortByVillages(Alliance pAlliance1, Alliance pAlliance2)
	{
		return pAlliance2.countCities().CompareTo(pAlliance1.countCities());
	}
}
// --- End of File: AllianceListComponent.cs ---



// --- Start of File: AllianceListElement.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AllianceListElement : WindowListElementBase<Alliance, AllianceData>
{
	public Text text_name;

	public CountUpOnClick age;

	public CountUpOnClick population;

	public CountUpOnClick warriors;

	public CountUpOnClick villages;

	public CountUpOnClick kingdoms;

	public Text level;

	public KingdomBanner prefabMiniKingdomBanner;

	public GameObject grid;

	private ObjectPoolGenericMono<KingdomBanner> pool_mini_banners;

	internal override void show(Alliance pAlliance)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.show(pAlliance);
		text_name.text = meta_object.name;
		((Graphic)text_name).color = meta_object.getColor().getColorText();
		age.setValue(meta_object.getAge());
		population.setValue(meta_object.countPopulation());
		warriors.setValue(meta_object.countWarriors());
		villages.setValue(meta_object.countCities());
		kingdoms.setValue(meta_object.countKingdoms());
		showKingdomBanners(meta_object.kingdoms_list);
	}

	public void showKingdomBanners(List<Kingdom> pList)
	{
		if (pool_mini_banners == null)
		{
			pool_mini_banners = new ObjectPoolGenericMono<KingdomBanner>(prefabMiniKingdomBanner, grid.transform);
		}
		pool_mini_banners.clear();
		foreach (Kingdom p in pList)
		{
			KingdomBanner next = pool_mini_banners.getNext();
			next.load(p);
			((Behaviour)((Component)next).GetComponentInChildren<RotateOnHover>()).enabled = false;
		}
	}

	protected override void tooltipAction()
	{
		Tooltip.show(this, "alliance", new TooltipData
		{
			alliance = meta_object
		});
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		pool_mini_banners?.clear();
	}
}
// --- End of File: AllianceListElement.cs ---



// --- Start of File: AllianceManager.cs ---
using System.Collections.Generic;
using UnityEngine;

public class AllianceManager : MetaSystemManager<Alliance, AllianceData>
{
	public Sprite[] _cached_banner_backgrounds;

	public Sprite[] _cached_banner_icons;

	private List<Alliance> _to_dissolve = new List<Alliance>();

	public AllianceManager()
	{
		type_id = "alliance";
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		using (IEnumerator<Alliance> enumerator = GetEnumerator())
		{
			while (enumerator.MoveNext())
			{
				Alliance current = enumerator.Current;
				current.clearCursorOver();
				if (!current.checkActive())
				{
					_to_dissolve.Add(current);
				}
				else
				{
					current.update();
				}
			}
		}
		foreach (Alliance item in _to_dissolve)
		{
			dissolveAlliance(item);
		}
		_to_dissolve.Clear();
	}

	public void dissolveAlliance(Alliance pAlliance)
	{
		World.world.game_stats.data.alliancesDissolved++;
		World.world.map_stats.alliancesDissolved++;
		WorldLog.logAllianceDisolved(pAlliance);
		pAlliance.dissolve();
		removeObject(pAlliance);
	}

	private void addTest()
	{
	}

	public bool forceAlliance(Kingdom pKingdom1, Kingdom pKingdom2)
	{
		Alliance alliance = pKingdom1.getAlliance();
		if (alliance == null)
		{
			alliance = pKingdom2.getAlliance();
		}
		bool result = false;
		if (alliance == null)
		{
			alliance = newAlliance(pKingdom1, pKingdom2);
			result = true;
		}
		else
		{
			alliance.join(pKingdom1, pRecalc: true, pForce: true);
			alliance.join(pKingdom2, pRecalc: true, pForce: true);
		}
		alliance.setType(AllianceType.Forced);
		return result;
	}

	public void useDiscordPower(Alliance pAlliance, City pCity)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Kingdom kingdom = pCity.kingdom;
		pAlliance.leave(kingdom);
		EffectsLibrary.highlightKingdomZones(kingdom, Color.white);
		if (pAlliance.kingdoms_hashset.Count == 0)
		{
			dissolveAlliance(pAlliance);
		}
	}

	public Alliance newAlliance(Kingdom pKingdom, Kingdom pKingdom2)
	{
		World.world.game_stats.data.alliancesMade++;
		World.world.map_stats.alliancesMade++;
		Alliance alliance = newObject();
		alliance.createNewAlliance();
		alliance.addFounders(pKingdom, pKingdom2);
		WorldLog.logAllianceCreated(alliance);
		return alliance;
	}

	public Sprite[] getBackgroundsList()
	{
		if (_cached_banner_backgrounds == null)
		{
			_cached_banner_backgrounds = SpriteTextureLoader.getSpriteList("alliances/backgrounds/");
		}
		return _cached_banner_backgrounds;
	}

	public Sprite[] getIconsList()
	{
		if (_cached_banner_icons == null)
		{
			_cached_banner_icons = SpriteTextureLoader.getSpriteList("alliances/icons/");
		}
		return _cached_banner_icons;
	}

	public bool anyAlliances()
	{
		return Count > 0;
	}

	public override void clear()
	{
		base.clear();
	}

	protected override void updateDirtyUnits()
	{
	}
}
// --- End of File: AllianceManager.cs ---



// --- Start of File: AllianceSelectedKingdomsContainer.cs ---
public class AllianceSelectedKingdomsContainer : AllianceKingdomsContainer
{
	protected override void OnEnable()
	{
	}

	public void update(Alliance pAlliance)
	{
		meta_object = pAlliance;
		clear();
		using ListPool<Kingdom> listPool = new ListPool<Kingdom>(base.alliance.kingdoms_hashset);
		track_objects.AddRange(listPool);
		foreach (ref Kingdom item in listPool)
		{
			Kingdom current = item;
			showBanner(current);
		}
	}
}
// --- End of File: AllianceSelectedKingdomsContainer.cs ---



// --- Start of File: AllianceStatsElement.cs ---
using System.Collections;
using UnityEngine;

public class AllianceStatsElement : AllianceElement, IStatsElement, IRefreshElement
{
	private StatsIconContainer _stats_icons;

	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	{
		_stats_icons.setIconValue(pName, pMainVal, pMax, pColor, pFloat, pEnding, pSeparator);
	}

	protected override void Awake()
	{
		_stats_icons = ((Component)this).gameObject.AddOrGetComponent<StatsIconContainer>();
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.alliance != null && base.alliance.isAlive())
		{
			_stats_icons.showGeneralIcons<Alliance, AllianceData>(base.alliance);
			setIconValue("i_population", base.alliance.countPopulation());
			setIconValue("i_army", base.alliance.countWarriors());
			setIconValue("i_kingdoms", base.alliance.countKingdoms());
			setIconValue("i_cities", base.alliance.countCities());
			setIconValue("i_buildings", base.alliance.countBuildings());
			setIconValue("i_zones", base.alliance.countZones());
		}
		yield break;
	}

	GameObject IStatsElement.get_gameObject()
	{
		return ((Component)this).gameObject;
	}
}
// --- End of File: AllianceStatsElement.cs ---



// --- Start of File: AllianceType.cs ---
public enum AllianceType
{
	Normal,
	Forced
}
// --- End of File: AllianceType.cs ---



// --- Start of File: AllianceWindow.cs ---
using UnityEngine.UI;

public class AllianceWindow : WindowMetaGeneric<Alliance, AllianceData>
{
	public NameInput mottoInput;

	public StatBar bar_experience;

	public override MetaType meta_type => MetaType.Alliance;

	protected override Alliance meta_object => SelectedMetas.selected_alliance;

	protected override void initNameInput()
	{
		base.initNameInput();
		mottoInput.addListener(applyInputMotto);
	}

	private void applyInputMotto(string pInput)
	{
		if (pInput != null && meta_object != null)
		{
			meta_object.data.motto = pInput;
		}
	}

	protected override void showTopPartInformation()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		base.showTopPartInformation();
		Alliance alliance = meta_object;
		if (alliance != null)
		{
			mottoInput.setText(alliance.getMotto());
			((Graphic)mottoInput.textField).color = alliance.getColor().getColorText();
		}
	}

	internal override void showStatsRows()
	{
		Alliance alliance = meta_object;
		tryShowPastNames();
		showStatRow("founded", alliance.getFoundedDate(), MetaType.None, -1L, "iconAge");
		tryToShowActor("alliance_founder", alliance.data.founder_actor_id, alliance.data.founder_actor_name, null, "actor_traits/iconStupid");
		tryToShowMetaKingdom("alliance_founder_kingdom", alliance.data.founder_kingdom_id, alliance.data.founder_kingdom_name);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		mottoInput.inputField.DeactivateInputField();
	}
}
// --- End of File: AllianceWindow.cs ---



// --- Start of File: Analytics.cs ---
using System.Collections.Generic;
using Firebase.Analytics;

public class Analytics
{
	private static Dictionary<string, string> _event_slugs = new Dictionary<string, string>();

	public static void trackWindow(string pName)
	{
		if (!Config.isEditor && !Config.isComputer)
		{
			string text = slugify(pName);
			if (Config.firebase_available)
			{
				FirebaseAnalytics.LogEvent("open_window", "window_id", text);
				logScreen("ScrollWindow", text);
			}
		}
	}

	public static void hideWindow()
	{
		logScreen("GamePlay", "gameplay");
	}

	public static void worldLoaded()
	{
		logScreen("GamePlay", "gameplay");
	}

	public static void worldLoading()
	{
		logScreen("LoadingScreen", "loading");
	}

	private static void logScreen(string pClass, string pName)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Expected O, but got Unknown
		if (Config.firebase_available)
		{
			Parameter[] array = (Parameter[])(object)new Parameter[2]
			{
				new Parameter(FirebaseAnalytics.ParameterScreenClass, pClass),
				new Parameter(FirebaseAnalytics.ParameterScreenName, pName)
			};
			FirebaseAnalytics.LogEvent(FirebaseAnalytics.EventScreenView, array);
		}
	}

	public static void LogEvent(string pName, bool pFirebase = true, bool pFacebook = true)
	{
		if (Config.isEditor || Config.isComputer)
		{
			return;
		}
		MapBox world = World.world;
		if (world == null || world.auto_tester?.active != true)
		{
			string text = slugify(pName);
			if (Config.firebase_available && pFirebase)
			{
				FirebaseAnalytics.LogEvent(text);
			}
		}
	}

	public static void LogEvent(string pName, string parameterName, string parameterValue)
	{
		if (Config.isEditor || Config.isComputer)
		{
			return;
		}
		MapBox world = World.world;
		if (world == null || world.auto_tester?.active != true)
		{
			string text = slugify(pName);
			if (Config.firebase_available)
			{
				FirebaseAnalytics.LogEvent(text, parameterName, parameterValue);
			}
		}
	}

	public static string slugify(string pPhrase)
	{
		if (!_event_slugs.TryGetValue(pPhrase, out var value))
		{
			value = pPhrase.Trim().Replace(" ", "_").ToLower();
			_event_slugs[pPhrase] = value;
		}
		return value;
	}
}
// --- End of File: Analytics.cs ---



// --- Start of File: AnchorPresets.cs ---
public enum AnchorPresets
{
	TopLeft,
	TopCenter,
	TopRight,
	MiddleLeft,
	MiddleCenter,
	MiddleRight,
	BottomLeft,
	BottonCenter,
	BottomRight,
	BottomStretch,
	VertStretchLeft,
	VertStretchRight,
	VertStretchCenter,
	HorStretchTop,
	HorStretchMiddle,
	HorStretchBottom,
	StretchAll
}
// --- End of File: AnchorPresets.cs ---



// --- Start of File: AngleAnimationTarget.cs ---
public enum AngleAnimationTarget
{
	Tile,
	Building,
	Actor,
	Ruin,
	Nothing
}
// --- End of File: AngleAnimationTarget.cs ---



// --- Start of File: AnimationContainerUnit.cs ---
using System.Collections.Generic;
using UnityEngine;

public class AnimationContainerUnit
{
	public bool child;

	internal readonly string id;

	internal readonly Dictionary<string, Sprite> sprites = new Dictionary<string, Sprite>();

	internal readonly Dictionary<string, AnimationFrameData> dict_frame_data = new Dictionary<string, AnimationFrameData>();

	internal ActorAnimation idle;

	internal ActorAnimation walking;

	internal ActorAnimation swimming;

	public bool has_swimming;

	public bool has_idle;

	public bool has_walking;

	public bool render_heads_for_children;

	internal Sprite[] heads;

	internal Sprite[] heads_male;

	internal Sprite[] heads_female;

	public AnimationContainerUnit(string pTexturePath)
	{
		id = pTexturePath;
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList(pTexturePath);
		foreach (Sprite val in spriteList)
		{
			sprites.Add(((Object)val).name, val);
		}
	}
}
// --- End of File: AnimationContainerUnit.cs ---



// --- Start of File: AnimationDataBoat.cs ---
using System.Collections.Generic;

public class AnimationDataBoat
{
	internal string id;

	internal Dictionary<int, ActorAnimation> dict = new Dictionary<int, ActorAnimation>();

	internal ActorAnimation broken;

	internal ActorAnimation normal;
}
// --- End of File: AnimationDataBoat.cs ---



// --- Start of File: AnimationFrameData.cs ---
using UnityEngine;

public class AnimationFrameData
{
	internal string id;

	internal string sheet_path;

	internal Vector2 pos_head;

	internal Vector2 pos_head_new;

	internal Vector2 pos_item;

	internal Vector2 size_unit;

	public bool show_head;

	public bool show_item;
}
// --- End of File: AnimationFrameData.cs ---



// --- Start of File: AnimationHelper.cs ---
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public static class AnimationHelper
{
	private static float animationTimeMax = 100f;

	private static float _time_simulation;

	private static float _time_session;

	public static float getTime()
	{
		return _time_simulation;
	}

	public static void updateTime(float pElapsedScaled, float pElapsedSession)
	{
		updateTimeSimulation(pElapsedScaled);
		updateTimeSession(pElapsedSession);
	}

	private static void updateTimeSimulation(float pElapsed)
	{
		if (!World.world.isPaused())
		{
			_time_simulation += pElapsed;
			if (_time_simulation >= animationTimeMax)
			{
				_time_simulation -= animationTimeMax;
			}
		}
	}

	private static void updateTimeSession(float pElapsed)
	{
		_time_session += pElapsed;
		if (_time_session >= animationTimeMax)
		{
			_time_session -= animationTimeMax;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float getAnimationGlobalTime(float pAnimationSpeed)
	{
		return _time_simulation * pAnimationSpeed;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Sprite getSpriteFromListSessionTime(int pHashCodeOffset, IList<Sprite> pFrames, float pAnimationSpeed)
	{
		return getSpriteFromList(_time_session * pAnimationSpeed, pHashCodeOffset, pFrames);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Sprite getSpriteFromList(int pHashCodeOffset, IList<Sprite> pFrames, float pAnimationSpeed)
	{
		return getSpriteFromList(getAnimationGlobalTime(pAnimationSpeed), pHashCodeOffset, pFrames);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Sprite getSpriteFromList(float pTime, int pHashCodeOffset, IList<Sprite> pFrames)
	{
		int spriteIndex = getSpriteIndex(pTime, pHashCodeOffset, pFrames.Count);
		return pFrames[spriteIndex];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getSpriteIndex(float pTime, int pHashCodeOffset, int pFrameCount)
	{
		if (pHashCodeOffset < 0)
		{
			pHashCodeOffset = -pHashCodeOffset;
		}
		return (int)(Mathf.Abs(pTime + (float)(pHashCodeOffset * 100)) % (float)pFrameCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getSpriteIndex(long pHashCodeOffset, int pFrameCount)
	{
		if (pHashCodeOffset < 0)
		{
			pHashCodeOffset = -pHashCodeOffset;
		}
		return (int)(Mathf.Abs((float)(1 + pHashCodeOffset * 100)) % (float)pFrameCount);
	}
}
// --- End of File: AnimationHelper.cs ---



// --- Start of File: AnimPlayType.cs ---
public enum AnimPlayType
{
	Forward,
	Backward
}
// --- End of File: AnimPlayType.cs ---



// --- Start of File: Ant.cs ---
using System.Collections.Generic;

internal static class Ant
{
	private static List<WorldTile> _axis_neighbours = new List<WorldTile>(4);

	public static WorldTile getNextTile(WorldTile pTile, ActorDirection pDirection)
	{
		return pDirection switch
		{
			ActorDirection.Up => pTile.tile_up, 
			ActorDirection.UpRight => pTile?.tile_up?.tile_right, 
			ActorDirection.UpLeft => pTile?.tile_up?.tile_left, 
			ActorDirection.Right => pTile.tile_right, 
			ActorDirection.Down => pTile.tile_down, 
			ActorDirection.DownRight => pTile?.tile_down?.tile_right, 
			ActorDirection.DownLeft => pTile?.tile_down?.tile_left, 
			ActorDirection.Left => pTile.tile_left, 
			_ => null, 
		};
	}

	public static WorldTile randomNeighbour(WorldTile pTile)
	{
		try
		{
			_axis_neighbours.Add(pTile.tile_up);
			_axis_neighbours.Add(pTile.tile_right);
			_axis_neighbours.Add(pTile.tile_left);
			_axis_neighbours.Add(pTile.tile_down);
			foreach (WorldTile item in _axis_neighbours.LoopRandom())
			{
				if (item != null)
				{
					return item;
				}
			}
			return null;
		}
		finally
		{
			_axis_neighbours.Clear();
		}
	}

	internal static void antUseOnTile(WorldTile pTile, string pType)
	{
		MapAction.terraformMain(pTile, AssetManager.tiles.get(pType), TerraformLibrary.destroy);
		MusicBox.playSound("event:/SFX/UNIQUE/langton/ant_step", pTile);
	}
}
// --- End of File: Ant.cs ---



// --- Start of File: AntimatterBombEffect.cs ---
public class AntimatterBombEffect : BaseEffect
{
	private bool used;

	private void Update()
	{
		World.world.startShake(0.03f, 0.01f, 0.3f);
		if (sprite_animation.currentFrameIndex >= 6 && !used)
		{
			used = true;
			World.world.applyForceOnTile(tile, 10, 0f, pForceOut: true, 1000);
			World.world.loopWithBrush(tile, Brush.get(11), tileAntimatter);
		}
	}

	public bool tileAntimatter(WorldTile pTile, string pPowerID)
	{
		TileType pType = TileLibrary.pit_deep_ocean;
		bool pSkipTerraform = false;
		if (!MapAction.checkTileDamageGaiaCovenant(pTile, pDamage: true))
		{
			pType = null;
			pSkipTerraform = true;
		}
		MapAction.terraformMain(pTile, pType, TerraformLibrary.destroy_no_flash, pSkipTerraform);
		return true;
	}

	internal override void spawnOnTile(WorldTile pTile)
	{
		tile = pTile;
		used = false;
		prepare(pTile);
		resetAnim();
	}
}
// --- End of File: AntimatterBombEffect.cs ---



// --- Start of File: AotTypeEnforcer.cs ---
using Newtonsoft.Json.Utilities;
using UnityEngine;

public class AotTypeEnforcer : MonoBehaviour
{
	public void Awake()
	{
		AotHelper.EnsureType<CustomDataContainer<int>>();
		AotHelper.EnsureType<CustomDataContainer<float>>();
		AotHelper.EnsureType<CustomDataContainer<bool>>();
		AotHelper.EnsureType<CustomDataContainer<string>>();
		AotHelper.EnsureList<int>();
		AotHelper.EnsureList<float>();
		AotHelper.EnsureList<bool>();
		AotHelper.EnsureList<string>();
	}
}
// --- End of File: AotTypeEnforcer.cs ---



// --- Start of File: AppleTangle.cs ---
using System;

namespace UnityEngine.Purchasing.Security;

public class AppleTangle
{
	private static byte[] data = Convert.FromBase64String("K7kpflnrzFWnC4KQoki4nljwqXMioaCmqYom6CZXw8SloZAhUpCKpscvqBSAV2sMjIDP0BafoZAsF+Nv19eOwdDQzMWOw8/Nj8HQ0MzFw8GtpqmKJugmV62hoaWloKMioaGg/IyAw8XS1MnGycPB1MWA0M/MycPZhpCEpqP1pKuzveHQ0MzFgOPF0tTyxczJwc7DxYDPzoDUyMnTgMPF0oDBzsSAw8XS1MnGycPB1MnPzoDQrz2dU4vpiLpoXm4VGa55/rx2a50eVNM7TnLEr2vZ75R4Ap5Z2F/LaNDMxYDyz8/UgOPhkL63rZCWkJSSwszFgNPUwc7EwdLEgNTF0s3TgMFgw5PXV5qnjPZLeq+Brnoa07nvFaj+kCKhsaaj9b2ApCKhqJAioaSQljnsjdgXTSw7fFPXO1LWcteQ72HQzMWA48XS1MnGycPB1MnPzoDh1cnGycPB1MnPzoDh1dTIz9LJ1NmRgOPhkCKhgpCtpqmKJugmV62hoaGmkK+mo/W9s6GhX6SlkKOhoV+Qvaaj9b2upLaktItwyec01qleVMstnYbHgCqTyletIm9+SwOPWfPK+8STlvqQwpGrkKmmo/WkprOi9fORs9TJxsnDwdTFgMLZgMHO2YDQwdLUpKazovXzkbOQsaaj9aSqs6rh0NBpudJV/a513/87UoWjGvUv7f2tUdTIz9LJ1NmRtpC0pqP1pKOzreHQCHzegpVqhXV5r3bLdAKEg7FXAQy2kLSmo/Wko7Ot4dDQzMWA8s/P1HmW32En9XkHORmS4lt4ddE+3gHy0sHD1MnDxYDT1MHUxc3FztTTjpCKJugmV62hoaWloJDCkauQqaaj9fkHpanct+D2sb7Ucxcrg5vnA3XPvzF7vufwS6VN/tkkjUuWAvfs9UzakCKh1pCupqP1va+hoV+kpKOioczFgOnOw46RhpCEpqP1pKuzveHQp0zdmSMr84BzmGQRHzrvqstfi1zpeNY/k7TFAdc0aY2io6GgoQMioSC0i3DJ5zTWqV5Uyy2O4AZX5+3fF7sdM+KEsopnr70W7Tz+w2jrILeO4AZX5+3fqP6Qv6aj9b2DpLiQtt/hCDhZcWrGPITLsXADG0S7imO/xJWDteu1+b0TNFdWPD5v8Bph+PCloKMioa+gkCKhqqIioaGgRDEJqb8lIyW7OZ3nl1IJO+AujHQRMLJ4CwPRMufz9WEPj+ETWFtD0G1GA+wv0yHAZrv7qY8yEljk6FDAmD61VdmAwdPT1c3F04DBw8PF0NTBzsPFj5AhY6aoi6ahpaWnoqKQIRa6IROVkpGUkJOW+retk5WQkpCZkpGUkJCxpqP1pKqzquHQ0MzFgOnOw46RgM/GgNTIxYDUyMXOgMHQ0MzJw8EVmg1Ur66gMqsRgbaO1HWcrXvCtuXev+zL8DbhKWTUwquwI+EnkyohqIumoaWlp6Khtr7I1NTQ05qPj9fOxIDDz87EydTJz87TgM/GgNXTxRGQ+Ez6pJIsyBMvvX7F01/H/sUckCKkG5AiowMAo6KhoqKhopCtpqk1PtqsBOcr+3S2l5NrZK/tbrTJcYRCS3EX0H+v5UGHalHN2E1HFbe38AoqdXpEXHCpp5cQ1dWB");

	private static int[] order = new int[61]
	{
		16, 34, 21, 36, 47, 44, 10, 38, 45, 22,
		50, 50, 42, 57, 33, 48, 47, 50, 57, 29,
		30, 56, 45, 39, 56, 29, 44, 54, 42, 58,
		46, 34, 52, 48, 42, 36, 51, 54, 52, 59,
		42, 50, 46, 48, 49, 56, 55, 55, 54, 52,
		56, 56, 59, 58, 56, 56, 59, 59, 59, 59,
		60
	};

	private static int key = 160;

	public static readonly bool IsPopulated = true;

	public static byte[] Data()
	{
		if (!IsPopulated)
		{
			return null;
		}
		return Obfuscator.DeObfuscate(data, order, key);
	}
}
// --- End of File: AppleTangle.cs ---



// --- Start of File: ApplyAttackState.cs ---
public enum ApplyAttackState
{
	Hit,
	Miss,
	Block,
	Deflect,
	Continue
}
// --- End of File: ApplyAttackState.cs ---



// --- Start of File: ArchitectMood.cs ---
using System;
using UnityEngine;

[Serializable]
public class ArchitectMood : Asset, ILocalizedAsset
{
	public string color_main;

	public string color_text;

	public string path_icon;

	private Color _cached_color = Color.clear;

	private Color _cached_color_text = Color.clear;

	private Sprite _cached_sprite;

	public Sprite getSprite()
	{
		if ((Object)(object)_cached_sprite == (Object)null)
		{
			_cached_sprite = SpriteTextureLoader.getSprite(path_icon);
		}
		return _cached_sprite;
	}

	public string getLocaleID()
	{
		return "architect_mood_" + id;
	}

	public Color getColor()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (_cached_color == Color.clear)
		{
			_cached_color = Toolbox.makeColor(color_main);
		}
		return _cached_color;
	}

	public Color getColorText()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (_cached_color_text == Color.clear)
		{
			_cached_color_text = Toolbox.makeColor(color_text);
		}
		return _cached_color_text;
	}
}
// --- End of File: ArchitectMood.cs ---



// --- Start of File: ArchitectMoodAction.cs ---
public delegate void ArchitectMoodAction(ArchitectMoodButton pElement);
// --- End of File: ArchitectMoodAction.cs ---



// --- Start of File: ArchitectMoodButton.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ArchitectMoodButton : MonoBehaviour
{
	[SerializeField]
	protected Button button;

	[SerializeField]
	protected TipButton _tip_button;

	[SerializeField]
	protected Image _icon;

	[SerializeField]
	private Image _selected;

	private ArchitectMood _asset;

	private ArchitectMoodAction _click_callback;

	private void Awake()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
		{
			_click_callback?.Invoke(this);
		});
	}

	public ArchitectMood getAsset()
	{
		return _asset;
	}

	public virtual void setAsset(ArchitectMood pAsset)
	{
		_asset = pAsset;
		_icon.sprite = _asset.getSprite();
		_tip_button.textOnClick = pAsset.getLocaleID();
	}

	public void toggleSelectedButton(bool pState)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_selected != (Object)null)
		{
			((Graphic)_selected).color = Toolbox.makeColor(_asset.color_main);
			((Behaviour)_selected).enabled = pState;
		}
	}

	public void setIconActiveColor(bool pState)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float num = ((!pState) ? 0.55f : 1f);
		Color color = default(Color);
		((Color)(ref color))._002Ector(num, num, num);
		((Graphic)_icon).color = color;
	}

	public void addClickCallback(ArchitectMoodAction pAction)
	{
		_click_callback = (ArchitectMoodAction)Delegate.Combine(_click_callback, pAction);
	}
}
// --- End of File: ArchitectMoodButton.cs ---



// --- Start of File: ArchitectMoodLibrary.cs ---
using UnityEngine;

public class ArchitectMoodLibrary : AssetLibrary<ArchitectMood>
{
	public const string DEFAULT_MOOD = "serene";

	public override void init()
	{
		base.init();
		add(new ArchitectMood
		{
			id = "trickster",
			color_main = "#1cf713",
			color_text = "#1cf713"
		});
		add(new ArchitectMood
		{
			id = "benevolent",
			color_main = "#ffe90b",
			color_text = "#ffe90b"
		});
		add(new ArchitectMood
		{
			id = "malevolent",
			color_main = "#a00cfc",
			color_text = "#a00cfc"
		});
		add(new ArchitectMood
		{
			id = "serene",
			color_main = "#68FFFF",
			color_text = "#68FFFF"
		});
		add(new ArchitectMood
		{
			id = "chaotic",
			color_main = "#ff0e0e",
			color_text = "#ff0e0e"
		});
		add(new ArchitectMood
		{
			id = "orderly",
			color_main = "#ff870e",
			color_text = "#ff870e"
		});
		add(new ArchitectMood
		{
			id = "mysterious",
			color_main = "#f01fb4",
			color_text = "#f01fb4"
		});
		add(new ArchitectMood
		{
			id = "apathetic",
			color_main = "#000000",
			color_text = "#AAAAAA"
		});
		add(new ArchitectMood
		{
			id = "ethereal",
			color_main = "#73a18e",
			color_text = "#73a18e"
		});
	}

	public override void editorDiagnosticLocales()
	{
		foreach (ArchitectMood item in list)
		{
			string localeID = item.getLocaleID();
			checkLocale(item, localeID);
		}
		base.editorDiagnosticLocales();
	}

	public override void post_init()
	{
		base.post_init();
		foreach (ArchitectMood item in list)
		{
			item.path_icon = "ui/Icons/architect_moods/architect_mood_" + item.id;
		}
	}

	public override void editorDiagnostic()
	{
		foreach (ArchitectMood item in list)
		{
			if ((Object)(object)SpriteTextureLoader.getSprite(item.path_icon) == (Object)null)
			{
				BaseAssetLibrary.logAssetError("Missing icon file", item.path_icon);
			}
		}
		base.editorDiagnostic();
	}
}
// --- End of File: ArchitectMoodLibrary.cs ---



// --- Start of File: ArchitectTab.cs ---
using System.Collections.Generic;
using UnityEngine;

public class ArchitectTab : MonoBehaviour
{
	private Dictionary<ArchitectMood, ArchitectMoodButton> _buttons = new Dictionary<ArchitectMood, ArchitectMoodButton>();

	[SerializeField]
	private ArchitectMoodButton _mood_prefab;

	[SerializeField]
	private Transform _grid_placement;

	private void Awake()
	{
		initButtons();
	}

	private void initButtons()
	{
		for (int i = 0; i < AssetManager.architect_mood_library.list.Count; i++)
		{
			ArchitectMood architectMood = AssetManager.architect_mood_library.list[i];
			ArchitectMoodButton value = initButton(architectMood);
			_buttons.Add(architectMood, value);
		}
	}

	private ArchitectMoodButton initButton(ArchitectMood pAsset)
	{
		ArchitectMoodButton architectMoodButton = Object.Instantiate<ArchitectMoodButton>(_mood_prefab, _grid_placement);
		architectMoodButton.setAsset(pAsset);
		architectMoodButton.addClickCallback(buttonAction);
		return architectMoodButton;
	}

	private void buttonAction(ArchitectMoodButton pElement)
	{
		ArchitectMood asset = pElement.getAsset();
		World.world.map_stats.player_mood = asset.id;
		World.world.clearArchitectMood();
		updateElements();
	}

	private void updateElements()
	{
		ArchitectMood architectMood = World.world.getArchitectMood();
		foreach (ArchitectMoodButton value in _buttons.Values)
		{
			bool flag = value.getAsset() == architectMood;
			value.toggleSelectedButton(flag);
			value.setIconActiveColor(flag);
		}
	}

	private void OnEnable()
	{
		updateElements();
	}
}
// --- End of File: ArchitectTab.cs ---



// --- Start of File: ArchitectureAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;

[Serializable]
public class ArchitectureAsset : Asset
{
	public bool generate_buildings;

	public string generation_target;

	public bool spread_biome;

	public string spread_biome_id;

	[DefaultValue("")]
	public string projectile_id = string.Empty;

	[DefaultValue(true)]
	public bool burnable_buildings = true;

	[DefaultValue(true)]
	public bool acid_affected_buildings = true;

	[DefaultValue(true)]
	public bool has_shadows = true;

	[DefaultValue("building")]
	public string material = "building";

	public Dictionary<string, string> building_ids_for_construction;

	public string[] styled_building_orders;

	public (string, string)[] shared_building_orders;

	[DefaultValue("boat_fishing")]
	public string actor_asset_id_boat_fishing = "boat_fishing";

	public string actor_asset_id_trading;

	public string actor_asset_id_transport;

	public void addBuildingOrderKey(string pKey, string pID)
	{
		if (building_ids_for_construction == null)
		{
			building_ids_for_construction = new Dictionary<string, string>();
		}
		building_ids_for_construction[pKey] = pID;
	}

	public void replaceSharedID(string pID, string pNewID)
	{
		for (int i = 0; i < shared_building_orders.Length; i++)
		{
			if (shared_building_orders[i].Item1 == pID)
			{
				shared_building_orders[i].Item2 = pNewID;
				break;
			}
		}
	}

	public BuildingAsset getBuilding(string pOrderID)
	{
		string buildingID = getBuildingID(pOrderID);
		return AssetManager.buildings.get(buildingID);
	}

	public string getBuildingID(string pOrderID)
	{
		return building_ids_for_construction[pOrderID];
	}
}
// --- End of File: ArchitectureAsset.cs ---



// --- Start of File: ArchitectureLibrary.cs ---
public class ArchitectureLibrary : AssetLibrary<ArchitectureAsset>
{
	private const string TEMPLATE_WITH_GENERATED_BUILDINGS = "$template_with_generated_buildings$";

	public override void init()
	{
		base.init();
		addTemplates();
		addClassic();
		addUnique();
		addAnimal();
	}

	private void addTemplates()
	{
		add(new ArchitectureAsset
		{
			id = "$template_with_generated_buildings$",
			generation_target = "human",
			generate_buildings = true
		});
		t.styled_building_orders = new string[9] { "order_docks_0", "order_docks_1", "order_house_0", "order_hall_0", "order_windmill_0", "order_watch_tower", "order_temple", "order_library", "order_barracks" };
		t.shared_building_orders = new(string, string)[6]
		{
			("order_bonfire", "bonfire"),
			("order_statue", "statue"),
			("order_well", "well"),
			("order_stockpile", "stockpile"),
			("order_mine", "mine"),
			("order_training_dummy", "training_dummy")
		};
		t.actor_asset_id_trading = "boat_trading_human";
		t.actor_asset_id_transport = "boat_transport_human";
	}

	private void addClassic()
	{
		add(new ArchitectureAsset
		{
			id = "human"
		});
		t.actor_asset_id_trading = "boat_trading_human";
		t.actor_asset_id_transport = "boat_transport_human";
		t.styled_building_orders = new string[19]
		{
			"order_docks_0", "order_tent", "order_house_0", "order_house_1", "order_house_2", "order_house_3", "order_house_4", "order_house_5", "order_hall_0", "order_hall_1",
			"order_hall_2", "order_windmill_0", "order_windmill_1", "order_docks_1", "order_watch_tower", "order_temple", "order_library", "order_market", "order_barracks"
		};
		t.shared_building_orders = new(string, string)[6]
		{
			("order_bonfire", "bonfire"),
			("order_statue", "statue"),
			("order_well", "well"),
			("order_stockpile", "stockpile"),
			("order_mine", "mine"),
			("order_training_dummy", "training_dummy")
		};
		clone("orc", "human");
		t.actor_asset_id_trading = "boat_trading_orc";
		t.actor_asset_id_transport = "boat_transport_orc";
		clone("elf", "human");
		t.actor_asset_id_trading = "boat_trading_elf";
		t.actor_asset_id_transport = "boat_transport_elf";
		clone("dwarf", "human");
		t.actor_asset_id_trading = "boat_trading_dwarf";
		t.actor_asset_id_transport = "boat_transport_dwarf";
	}

	private void addUnique()
	{
		clone("civ_necromancer", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_necromancer";
		t.actor_asset_id_transport = "boat_transport_necromancer";
		t.spread_biome_id = "biome_corrupted";
		clone("civ_alien", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_alien";
		t.actor_asset_id_transport = "boat_transport_alien";
		t.projectile_id = "plasma_ball";
		clone("civ_druid", "$template_with_generated_buildings$");
		t.spread_biome_id = "biome_jungle";
		t.actor_asset_id_trading = "boat_trading_druid";
		t.actor_asset_id_transport = "boat_transport_druid";
		clone("civ_bee", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_bee";
		t.actor_asset_id_transport = "boat_transport_bee";
		clone("civ_beetle", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_beetle";
		t.actor_asset_id_transport = "boat_transport_beetle";
		clone("civ_seal", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_seal";
		t.actor_asset_id_transport = "boat_transport_seal";
		clone("civ_unicorn", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_unicorn";
		t.actor_asset_id_transport = "boat_transport_unicorn";
		clone("civ_ghost", "$template_with_generated_buildings$");
		t.has_shadows = false;
		t.material = "jelly";
		t.actor_asset_id_trading = "boat_trading_ghost";
		t.actor_asset_id_transport = "boat_transport_ghost";
		clone("civ_fairy", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_fairy";
		t.actor_asset_id_transport = "boat_transport_fairy";
		clone("civ_evil_mage", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_evil_mage";
		t.actor_asset_id_transport = "boat_transport_evil_mage";
		t.replaceSharedID("order_stockpile", "stockpile_fireproof");
		t.burnable_buildings = false;
		clone("civ_white_mage", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_white_mage";
		t.actor_asset_id_transport = "boat_transport_white_mage";
		clone("civ_bandit", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_bandit";
		t.actor_asset_id_transport = "boat_transport_bandit";
		clone("civ_demon", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_demon";
		t.actor_asset_id_transport = "boat_transport_demon";
		t.burnable_buildings = false;
		t.spread_biome_id = "biome_infernal";
		t.replaceSharedID("order_stockpile", "stockpile_fireproof");
		clone("civ_cold_one", "$template_with_generated_buildings$");
		t.spread_biome_id = "biome_permafrost";
		t.actor_asset_id_trading = "boat_trading_cold_one";
		t.actor_asset_id_transport = "boat_transport_cold_one";
		clone("civ_angle", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_angle";
		t.actor_asset_id_transport = "boat_transport_angle";
		clone("civ_snowman", "$template_with_generated_buildings$");
		t.spread_biome_id = "biome_permafrost";
		t.actor_asset_id_trading = "boat_trading_snowman";
		t.actor_asset_id_transport = "boat_transport_snowman";
		clone("civ_garlic_man", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_garlic_man";
		t.actor_asset_id_transport = "boat_transport_garlic_man";
		t.spread_biome_id = "biome_garlic";
		clone("civ_lemon_man", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_lemon_man";
		t.actor_asset_id_transport = "boat_transport_lemon_man";
		t.spread_biome_id = "biome_lemon";
		clone("civ_acid_gentleman", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_acid_gentleman";
		t.actor_asset_id_transport = "boat_transport_acid_gentleman";
		t.spread_biome_id = "biome_wasteland";
		t.acid_affected_buildings = false;
		t.replaceSharedID("order_stockpile", "stockpile_acidproof");
		clone("civ_crystal_golem", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_crystal_golem";
		t.actor_asset_id_transport = "boat_transport_crystal_golem";
		t.spread_biome_id = "biome_crystal";
		t.burnable_buildings = false;
		clone("civ_candy_man", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_candy_man";
		t.actor_asset_id_transport = "boat_transport_candy_man";
		t.spread_biome_id = "biome_candy";
		clone("civ_liliar", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_liliar";
		t.actor_asset_id_transport = "boat_transport_liliar";
		t.spread_biome_id = "biome_flower";
		clone("civ_greg", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_greg";
		t.actor_asset_id_transport = "boat_transport_greg";
	}

	private void addAnimal()
	{
		clone("civ_cat", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_cat";
		t.actor_asset_id_transport = "boat_transport_cat";
		clone("civ_dog", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_dog";
		t.actor_asset_id_transport = "boat_transport_dog";
		clone("civ_chicken", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_chicken";
		t.actor_asset_id_transport = "boat_transport_chicken";
		clone("civ_rabbit", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_rabbit";
		t.actor_asset_id_transport = "boat_transport_rabbit";
		clone("civ_monkey", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_monkey";
		t.actor_asset_id_transport = "boat_transport_monkey";
		clone("civ_fox", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_fox";
		t.actor_asset_id_transport = "boat_transport_fox";
		clone("civ_sheep", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_sheep";
		t.actor_asset_id_transport = "boat_transport_sheep";
		clone("civ_cow", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_cow";
		t.actor_asset_id_transport = "boat_transport_cow";
		clone("civ_armadillo", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_armadillo";
		t.actor_asset_id_transport = "boat_transport_armadillo";
		clone("civ_wolf", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_wolf";
		t.actor_asset_id_transport = "boat_transport_wolf";
		clone("civ_bear", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_bear";
		t.actor_asset_id_transport = "boat_transport_bear";
		clone("civ_rhino", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_rhino";
		t.actor_asset_id_transport = "boat_transport_rhino";
		clone("civ_buffalo", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_buffalo";
		t.actor_asset_id_transport = "boat_transport_buffalo";
		clone("civ_hyena", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_hyena";
		t.actor_asset_id_transport = "boat_transport_hyena";
		clone("civ_rat", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_rat";
		t.actor_asset_id_transport = "boat_transport_rat";
		clone("civ_alpaca", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_alpaca";
		t.actor_asset_id_transport = "boat_transport_alpaca";
		clone("civ_capybara", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_capybara";
		t.actor_asset_id_transport = "boat_transport_capybara";
		clone("civ_goat", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_goat";
		t.actor_asset_id_transport = "boat_transport_goat";
		clone("civ_scorpion", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_scorpion";
		t.actor_asset_id_transport = "boat_transport_scorpion";
		clone("civ_crab", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_crab";
		t.actor_asset_id_transport = "boat_transport_crab";
		clone("civ_penguin", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_penguin";
		t.actor_asset_id_transport = "boat_transport_penguin";
		t.spread_biome_id = "biome_permafrost";
		clone("civ_turtle", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_turtle";
		t.actor_asset_id_transport = "boat_transport_turtle";
		clone("civ_crocodile", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_crocodile";
		t.actor_asset_id_transport = "boat_transport_crocodile";
		clone("civ_snake", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_snake";
		t.actor_asset_id_transport = "boat_transport_snake";
		clone("civ_frog", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_frog";
		t.actor_asset_id_transport = "boat_transport_frog";
		clone("civ_piranha", "$template_with_generated_buildings$");
		t.actor_asset_id_trading = "boat_trading_piranha";
		t.actor_asset_id_transport = "boat_transport_piranha";
	}

	public override void post_init()
	{
		base.post_init();
		foreach (ArchitectureAsset item in list)
		{
			if (!string.IsNullOrEmpty(item.spread_biome_id))
			{
				item.spread_biome = true;
			}
		}
		initBuildingKeys();
	}

	private void initBuildingKeys()
	{
		foreach (ArchitectureAsset item in list)
		{
			if (!item.isTemplateAsset())
			{
				loadAutoBuildingsForAsset(item);
				(string, string)[] shared_building_orders = item.shared_building_orders;
				for (int i = 0; i < shared_building_orders.Length; i++)
				{
					(string, string) tuple = shared_building_orders[i];
					item.addBuildingOrderKey(tuple.Item1, tuple.Item2);
				}
			}
		}
	}

	private void loadAutoBuildingsForAsset(ArchitectureAsset pAsset)
	{
		string text = pAsset.id;
		string[] styled_building_orders = pAsset.styled_building_orders;
		foreach (string text2 in styled_building_orders)
		{
			string text3 = null;
			switch (text2)
			{
			case "order_tent":
				text3 = "tent_" + text;
				break;
			case "order_house_0":
			case "order_house_1":
			case "order_house_2":
			case "order_house_3":
			case "order_house_4":
			case "order_house_5":
				text3 = "house_" + text + "_" + text2.Substring(text2.Length - 1);
				break;
			case "order_hall_0":
			case "order_hall_1":
			case "order_hall_2":
				text3 = "hall_" + text + "_" + text2.Substring(text2.Length - 1);
				break;
			case "order_windmill_0":
			case "order_windmill_1":
				text3 = "windmill_" + text + "_" + text2.Substring(text2.Length - 1);
				break;
			case "order_docks_0":
				text3 = "fishing_docks_" + text;
				break;
			case "order_docks_1":
				text3 = "docks_" + text;
				break;
			case "order_watch_tower":
				text3 = "watch_tower_" + text;
				break;
			case "order_temple":
				text3 = "temple_" + text;
				break;
			case "order_library":
				text3 = "library_" + text;
				break;
			case "order_market":
				text3 = "market_" + text;
				break;
			case "order_barracks":
				text3 = "barracks_" + text;
				break;
			case "order_bonfire":
				text3 = "bonfire";
				break;
			case "order_statue":
				text3 = "statue";
				break;
			case "order_well":
				text3 = "well";
				break;
			case "order_mine":
				text3 = "mine";
				break;
			case "order_stockpile":
				text3 = "stockpile";
				break;
			case "order_training_dummy":
				text3 = "training_dummy";
				break;
			}
			if (text3 != null)
			{
				pAsset.addBuildingOrderKey(text2, text3);
			}
		}
	}
}
// --- End of File: ArchitectureLibrary.cs ---



// --- Start of File: ArmiesColorsLibrary.cs ---
public class ArmiesColorsLibrary : ColorLibrary
{
	public ArmiesColorsLibrary()
	{
		file_path = "colors/colors_general";
	}

	public override void init()
	{
		base.init();
		loadFromFile<ArmiesColorsLibrary>();
	}

	public override bool isColorUsedInWorld(ColorAsset pAsset)
	{
		foreach (Army army in World.world.armies)
		{
			if (checkColor(pAsset, army.data.color_id))
			{
				return true;
			}
		}
		return base.isColorUsedInWorld(pAsset);
	}
}
// --- End of File: ArmiesColorsLibrary.cs ---



// --- Start of File: Army.cs ---
using System.Collections.Generic;
using JetBrains.Annotations;

public class Army : MetaObject<ArmyData>
{
	private Actor _captain;

	private WorldTile _prev_captain_position;

	private City _city;

	private Kingdom _kingdom;

	protected override MetaType meta_type => MetaType.Army;

	public override BaseSystemManager manager => World.world.armies;

	public override ActorAsset getActorAsset()
	{
		return getKingdom().getActorAsset();
	}

	public void createArmy(Actor pActor, City pCity)
	{
		_city = pCity;
		_kingdom = _city.kingdom;
		setCaptain(pActor);
		generateNewMetaObject();
		generateName();
	}

	public void checkCity()
	{
		if (_city.kingdom != _kingdom)
		{
			_kingdom = _city.kingdom;
			updateColor(_kingdom?.getColor());
			generateName(_kingdom);
		}
	}

	public void onKingdomNameChange()
	{
		generateName();
	}

	protected override void generateColor()
	{
		if (isAlive())
		{
			Kingdom kingdom = getKingdom();
			if (!kingdom.isRekt())
			{
				data.setColorID(kingdom.data.color_id);
			}
		}
	}

	public override void trackName(bool pPostChange = false)
	{
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
		{
			ArmyData armyData = data;
			if (armyData.past_names == null)
			{
				armyData.past_names = new List<NameEntry>();
			}
			if (data.past_names.Count == 0)
			{
				NameEntry item = new NameEntry(data.name, pCustom: false, data.original_color_id, data.created_time);
				data.past_names.Add(item);
			}
			else if (!(data.past_names.Last().name == data.name))
			{
				NameEntry item2 = new NameEntry(data.name, data.custom_name, data.color_id);
				data.past_names.Add(item2);
			}
		}
	}

	private void generateName(Kingdom pKingdom = null)
	{
		if (data.custom_name && !string.IsNullOrEmpty(data.name))
		{
			return;
		}
		Kingdom kingdom = null;
		kingdom = ((pKingdom == null) ? getKingdom() : pKingdom);
		if (kingdom == null)
		{
			setName("Forgotten Army");
			return;
		}
		string text = kingdom.name ?? "";
		string text2 = data.name;
		if (text2 != null && text2.StartsWith(text + " "))
		{
			return;
		}
		using ListPool<string> listPool = new ListPool<string>(World.world.armies.Count);
		foreach (Army army in World.world.armies)
		{
			if (army != this && army.getKingdom() == kingdom)
			{
				listPool.Add(army.name);
			}
		}
		int num = 1;
		string text4;
		while (true)
		{
			string text3 = num.ToRoman();
			text4 = text + " " + text3;
			if (!listPool.Contains(text4))
			{
				break;
			}
			num++;
		}
		setName(text4);
	}

	public Actor getCaptain()
	{
		return _captain;
	}

	public override void save()
	{
		base.save();
		data.id_city = _city?.id ?? (-1);
		data.id_kingdom = _city?.kingdom?.id ?? _kingdom?.id ?? (-1);
		data.id_captain = (hasCaptain() ? _captain.data.id : (-1));
	}

	public override void loadData(ArmyData pData)
	{
		base.loadData(pData);
		_city = World.world.cities.get(pData.id_city);
		if (_city != null)
		{
			_city.setArmy(this);
		}
		_kingdom = World.world.kingdoms.get(pData.id_kingdom);
		if (string.IsNullOrEmpty(name))
		{
			generateName();
		}
	}

	public void loadDataCaptains()
	{
		Actor actor = World.world.units.get(data.id_captain);
		if (actor != null && actor.army == this)
		{
			setCaptain(actor, pFromLoad: true);
		}
		updateColor(getColor());
	}

	public override void generateBanner()
	{
	}

	protected override ColorLibrary getColorLibrary()
	{
		return AssetManager.kingdom_colors_library;
	}

	public override ColorAsset getColor()
	{
		return getKingdom().getColor();
	}

	public void clearCity()
	{
		_city = null;
		data.id_city = -1L;
	}

	public void disband()
	{
		for (int i = 0; i < base.units.Count; i++)
		{
			base.units[i].stopBeingWarrior();
		}
		setCaptain(null);
	}

	public void updateCaptains()
	{
		if (data.past_captains == null || data.past_captains.Count == 0)
		{
			return;
		}
		foreach (LeaderEntry past_captain in data.past_captains)
		{
			Actor actor = World.world.units.get(past_captain.id);
			if (!actor.isRekt())
			{
				past_captain.name = actor.name;
			}
		}
	}

	public void addCaptain(Actor pActor)
	{
		ArmyData armyData = data;
		if (armyData.past_captains == null)
		{
			armyData.past_captains = new List<LeaderEntry>();
		}
		captainLeft();
		data.past_captains.Add(new LeaderEntry
		{
			id = pActor.getID(),
			name = pActor.name,
			color_id = (getKingdom()?.data.color_id ?? data.color_id),
			timestamp_ago = World.world.getCurWorldTime()
		});
		if (data.past_captains.Count > 30)
		{
			data.past_captains.Shift();
		}
	}

	public void captainLeft()
	{
		if (data.past_captains != null && data.past_captains.Count != 0)
		{
			LeaderEntry leaderEntry = data.past_captains.Last();
			if (!(leaderEntry.timestamp_end >= leaderEntry.timestamp_ago))
			{
				leaderEntry.timestamp_end = World.world.getCurWorldTime();
				updateCaptains();
			}
		}
	}

	public void setCaptain(Actor pActor, bool pFromLoad = false)
	{
		_captain = pActor;
		if (data == null)
		{
			return;
		}
		if (pActor.isRekt())
		{
			data.id_captain = -1L;
			if (!pFromLoad)
			{
				captainLeft();
			}
		}
		else
		{
			data.id_captain = pActor.getID();
			if (!pFromLoad)
			{
				addCaptain(pActor);
			}
		}
	}

	public void checkCaptainExistence()
	{
		Actor captain = getCaptain();
		if (!captain.isRekt() && captain.current_tile != null)
		{
			_prev_captain_position = captain.current_tile;
		}
		if (captain.isRekt())
		{
			setCaptain(null);
		}
		findCaptain();
	}

	public void checkCaptainRemoval(Actor pActor)
	{
		if (_captain == pActor)
		{
			setCaptain(null);
		}
	}

	public int countMelee()
	{
		int num = 0;
		for (int i = 0; i < base.units.Count; i++)
		{
			Actor actor = base.units[i];
			if (actor.isAlive())
			{
				if (!actor.hasWeapon())
				{
					num++;
				}
				else if (actor.getWeaponAsset().attack_type == WeaponType.Melee)
				{
					num++;
				}
			}
		}
		return num;
	}

	public int countRange()
	{
		int num = 0;
		for (int i = 0; i < base.units.Count; i++)
		{
			Actor actor = base.units[i];
			if (actor.isAlive() && actor.hasWeapon() && actor.getWeaponAsset().attack_type == WeaponType.Range)
			{
				num++;
			}
		}
		return num;
	}

	public bool isGroupInCityAndHaveLeader()
	{
		if (!isAlive())
		{
			return false;
		}
		if (base.units.Count == 0)
		{
			return true;
		}
		if (!hasCaptain())
		{
			return false;
		}
		Actor captain = getCaptain();
		if (captain.isInsideSomething())
		{
			return false;
		}
		if (!captain.current_zone.isSameCityHere(_city))
		{
			return false;
		}
		return true;
	}

	private void findCaptain()
	{
		if (isLocked())
		{
			return;
		}
		if (hasCaptain())
		{
			if (getCaptain().isKingdomCiv())
			{
				return;
			}
			setCaptain(null);
		}
		if (base.units.Count != 0)
		{
			Actor actor = null;
			actor = ((_prev_captain_position != null) ? getNearbyUnitForCaptain(_prev_captain_position) : getRandomActorForCaptain());
			if (actor != null)
			{
				setCaptain(actor);
			}
		}
	}

	private Actor getRandomActorForCaptain()
	{
		foreach (Actor item in base.units.LoopRandom())
		{
			if (!item.isRekt() && item.army == this)
			{
				return item;
			}
		}
		return null;
	}

	private Actor getNearbyUnitForCaptain(WorldTile pLastPosition)
	{
		Actor result = null;
		int num = int.MaxValue;
		List<Actor> list = base.units;
		for (int i = 0; i < list.Count; i++)
		{
			Actor actor = list[i];
			if (actor.army == this && !actor.isRekt())
			{
				int num2 = Toolbox.SquaredDistTile(actor.current_tile, pLastPosition);
				if (num2 < num)
				{
					result = actor;
					num = num2;
				}
			}
		}
		return result;
	}

	public string getDebug()
	{
		string text = base.units.Count.ToString() ?? "";
		if (_captain != null)
		{
			text = text + " " + _captain.getName() + "(" + _captain.getAge() + ")";
		}
		return text;
	}

	[CanBeNull]
	public Kingdom getKingdom()
	{
		Kingdom kingdom = null;
		if (hasCaptain())
		{
			kingdom = getCaptain().kingdom;
		}
		if (kingdom == null)
		{
			kingdom = (_city.isRekt() ? _kingdom : _city.kingdom);
		}
		return kingdom;
	}

	public bool hasKingdom()
	{
		return !_kingdom.isRekt();
	}

	public bool hasCaptain()
	{
		return !_captain.isRekt();
	}

	public City getCity()
	{
		return _city;
	}

	public bool hasCity()
	{
		return !_city.isRekt();
	}

	public override bool isReadyForRemoval()
	{
		if (base.units.Count > 0)
		{
			return false;
		}
		if (hasCaptain())
		{
			return false;
		}
		if (hasCity())
		{
			return false;
		}
		if (!base.isReadyForRemoval())
		{
			return false;
		}
		return true;
	}

	public override void Dispose()
	{
		base.Dispose();
		base.units.Clear();
		_captain = null;
		_prev_captain_position = null;
		_city = null;
		_kingdom = null;
	}

	public override string ToString()
	{
		if (data == null)
		{
			return "[Army is null]";
		}
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[Army:{base.id} ");
		if (!isAlive())
		{
			stringBuilderPool.Append("[DEAD] ");
		}
		stringBuilderPool.Append("\"" + name + "\" ");
		Kingdom kingdom = getKingdom();
		stringBuilderPool.Append($"Kingdom:{kingdom?.id ?? (-1)} ");
		if (hasCity())
		{
			stringBuilderPool.Append($"{_city} ");
		}
		if (kingdom != _kingdom)
		{
			stringBuilderPool.Append($"_kingdom:{_kingdom} ");
		}
		if (hasCaptain())
		{
			stringBuilderPool.Append($"Captain:{_captain?.id ?? (-1)} ");
			if (_captain?.kingdom != kingdom)
			{
				stringBuilderPool.Append($"CaptainKingdom:{_captain?.kingdom?.id ?? (-1)} ");
			}
		}
		stringBuilderPool.Append($"Units:{base.units.Count} ");
		if (manager.isUnitsDirty())
		{
			stringBuilderPool.Append("[Dirty] ");
		}
		return stringBuilderPool.ToString().Trim() + "]";
	}
}
// --- End of File: Army.cs ---



// --- Start of File: ArmyBanner.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ArmyBanner : BannerGeneric<Army, ArmyData>
{
	[SerializeField]
	private Image _species_icon;

	protected override MetaType meta_type => MetaType.Army;

	protected override string tooltip_id => "army";

	protected override void setupBanner()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		base.setupBanner();
		Kingdom kingdom = meta_object.getKingdom();
		part_background.sprite = kingdom.getElementBackground();
		part_icon.sprite = kingdom.getElementIcon();
		ColorAsset colorAsset = kingdom.getColor();
		Color colorMainSecond = colorAsset.getColorMainSecond();
		Color colorBanner = colorAsset.getColorBanner();
		colorMainSecond = Color.Lerp(colorMainSecond, Color.black, 0.05f);
		colorBanner = Color.Lerp(colorBanner, Color.black, 0.05f);
		((Graphic)part_background).color = colorMainSecond;
		((Graphic)part_icon).color = colorBanner;
		((Component)_species_icon).gameObject.SetActive(false);
	}

	protected override TooltipData getTooltipData()
	{
		TooltipData tooltipData = base.getTooltipData();
		tooltipData.army = meta_object;
		return tooltipData;
	}
}
// --- End of File: ArmyBanner.cs ---



// --- Start of File: ArmyCaptainElement.cs ---
using System.Collections;
using UnityEngine;

public class ArmyCaptainElement : ArmyElement
{
	[SerializeField]
	private GameObject _title_element;

	[SerializeField]
	private PrefabUnitElement _captain_element;

	protected override IEnumerator showContent()
	{
		if (base.army.hasCaptain())
		{
			track_objects.Add(base.army.getCaptain());
			_title_element.gameObject.SetActive(true);
			((Component)_captain_element).gameObject.SetActive(true);
			_captain_element.show(base.army.getCaptain());
		}
		yield break;
	}

	protected override void clear()
	{
		_title_element.gameObject.SetActive(false);
		((Component)_captain_element).gameObject.SetActive(false);
		base.clear();
	}

	public override bool checkRefreshWindow()
	{
		if (((Component)_captain_element).gameObject.activeSelf && !base.army.hasCaptain())
		{
			return true;
		}
		return base.checkRefreshWindow();
	}
}
// --- End of File: ArmyCaptainElement.cs ---



// --- Start of File: ArmyData.cs ---
using System.Collections.Generic;
using System.ComponentModel;

public class ArmyData : MetaObjectData
{
	[DefaultValue(-1L)]
	public long id_city = -1L;

	[DefaultValue(-1L)]
	public long id_captain = -1L;

	[DefaultValue(-1L)]
	public long id_kingdom = -1L;

	public List<LeaderEntry> past_captains;

	public override void Dispose()
	{
		base.Dispose();
		past_captains?.Clear();
		past_captains = null;
	}
}
// --- End of File: ArmyData.cs ---



// --- Start of File: ArmyElement.cs ---
public class ArmyElement : WindowMetaElement<Army, ArmyData>
{
	protected Army army => meta_object;
}
// --- End of File: ArmyElement.cs ---



// --- Start of File: ArmyListComponent.cs ---
public class ArmyListComponent : ComponentListBase<ArmyListElement, Army, ArmyData, ArmyListComponent>
{
	protected override MetaType meta_type => MetaType.Army;

	protected override void setupSortingTabs()
	{
		genericMetaSortByAge(base.sortByAge);
		genericMetaSortByRenown(base.sortByRenown);
		genericMetaSortByPopulation(ComponentListBase<ArmyListElement, Army, ArmyData, ArmyListComponent>.sortByPopulation);
		genericMetaSortByKills(ComponentListBase<ArmyListElement, Army, ArmyData, ArmyListComponent>.sortByKills);
		genericMetaSortByDeath(ComponentListBase<ArmyListElement, Army, ArmyData, ArmyListComponent>.sortByDeaths);
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
		{
			current_sort = sortByKingdom;
		});
	}

	private static int sortByKingdom(Army p1, Army p2)
	{
		return p2.getKingdom().CompareTo(p1.getKingdom());
	}
}
// --- End of File: ArmyListComponent.cs ---



// --- Start of File: ArmyListElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ArmyListElement : WindowListElementBase<Army, ArmyData>
{
	[SerializeField]
	private Text _text_name;

	[SerializeField]
	private CountUpOnClick _amount;

	[SerializeField]
	private CountUpOnClick _age;

	[SerializeField]
	private CountUpOnClick _renown;

	[SerializeField]
	private CountUpOnClick _kills;

	[SerializeField]
	private CountUpOnClick _deaths;

	[SerializeField]
	private UiUnitAvatarElement _captain;

	[SerializeField]
	private ArmyBanner _army_banner;

	internal override void show(Army pArmy)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.show(pArmy);
		_text_name.text = pArmy.name;
		Color colorText = pArmy.getColor().getColorText();
		((Graphic)_text_name).color = colorText;
		bool flag = pArmy.hasCaptain();
		((Component)_captain).gameObject.SetActive(flag);
		if (flag)
		{
			_captain.show(pArmy.getCaptain());
		}
		_amount.setValue(pArmy.countUnits());
		_age.setValue(pArmy.getAge());
		_renown.setValue(pArmy.getRenown());
		_kills.setValue((int)pArmy.getTotalKills());
		_deaths.setValue((int)pArmy.getTotalDeaths());
	}

	protected override void initMonoFields()
	{
	}

	protected override void loadBanner()
	{
		_army_banner.load(meta_object);
	}

	protected override void tooltipAction()
	{
		Tooltip.show(this, "army", new TooltipData
		{
			army = meta_object
		});
	}

	protected override ActorAsset getActorAsset()
	{
		return meta_object.getActorAsset();
	}
}
// --- End of File: ArmyListElement.cs ---



// --- Start of File: ArmyManager.cs ---
using System.Collections.Generic;

public class ArmyManager : MetaSystemManager<Army, ArmyData>
{
	public ArmyManager()
	{
		type_id = "army";
	}

	public Army newArmy(Actor pActor, City pCity)
	{
		World.world.game_stats.data.armiesCreated++;
		World.world.map_stats.armiesCreated++;
		Army army = newObject();
		army.createArmy(pActor, pCity);
		pActor.setArmy(army);
		pCity.setArmy(army);
		return army;
	}

	public override void removeObject(Army pObject)
	{
		World.world.game_stats.data.armiesDestroyed++;
		World.world.map_stats.armiesDestroyed++;
		base.removeObject(pObject);
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		using IEnumerator<Army> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.checkCaptainExistence();
		}
	}

	protected override void updateDirtyUnits()
	{
		List<Actor> units_only_alive = World.world.units.units_only_alive;
		for (int i = 0; i < units_only_alive.Count; i++)
		{
			Actor actor = units_only_alive[i];
			Army army = actor.army;
			if (army != null && army.isDirtyUnits())
			{
				army.listUnit(actor);
			}
		}
	}
}
// --- End of File: ArmyManager.cs ---



// --- Start of File: ArmyMemberIcons.cs ---
using System.Collections;
using UnityEngine;

public class ArmyMemberIcons : ArmyElement
{
	[SerializeField]
	private UnitAvatarLoader _top;

	[SerializeField]
	private UnitAvatarLoader _top_left;

	[SerializeField]
	private UnitAvatarLoader _top_right;

	[SerializeField]
	private UnitAvatarLoader _left;

	[SerializeField]
	private UnitAvatarLoader _right;

	[SerializeField]
	private UnitAvatarLoader _bottom;

	[SerializeField]
	private UnitAvatarLoader _bottom_left;

	[SerializeField]
	private UnitAvatarLoader _bottom_right;

	[SerializeField]
	private ArmyBanner _banner;

	private UnitAvatarLoader[] _list_warrior_avatars;

	protected override void Awake()
	{
		_list_warrior_avatars = new UnitAvatarLoader[8] { _top, _top_left, _right, _bottom_right, _bottom, _bottom_left, _left, _top_right };
		base.Awake();
	}

	protected override void clear()
	{
		UnitAvatarLoader[] list_warrior_avatars = _list_warrior_avatars;
		for (int i = 0; i < list_warrior_avatars.Length; i++)
		{
			((Component)list_warrior_avatars[i]).gameObject.SetActive(false);
		}
		((Component)_banner).gameObject.SetActive(false);
	}

	protected override IEnumerator showContent()
	{
		((Component)_banner).gameObject.SetActive(true);
		_banner.load(base.army);
		using ListPool<Actor> tUnits = new ListPool<Actor>(base.army.getUnits());
		if (tUnits.Count == 0)
		{
			yield break;
		}
		tUnits.Shuffle();
		for (int i = 0; i < _list_warrior_avatars.Length; i++)
		{
			yield return (object)new WaitForEndOfFrame();
			if (tUnits.Count != 0)
			{
				UnitAvatarLoader obj = _list_warrior_avatars[i];
				Actor pActor = tUnits.Pop();
				((Component)obj).gameObject.SetActive(true);
				obj.load(pActor);
				continue;
			}
			break;
		}
	}
}
// --- End of File: ArmyMemberIcons.cs ---



// --- Start of File: ArmyMetaBanners.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ArmyMetaBanners : ArmyElement, IBaseMetaBanners
{
	[SerializeField]
	private CityBanner _banner_city;

	[SerializeField]
	private AllianceBanner _banner_alliance;

	[SerializeField]
	private KingdomBanner _banner_kingdom;

	protected List<MetaBannerElement> banners = new List<MetaBannerElement>();

	private const float DELAY = 0.025f;

	private int _visible_banners;

	public int visible_banners => _visible_banners;

	protected override void Awake()
	{
		base.Awake();
		banners.Add(new MetaBannerElement
		{
			banner = _banner_kingdom,
			check = () => base.army.hasKingdom(),
			nano = () => base.army.getKingdom()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_alliance,
			check = () => base.army.hasKingdom() && base.army.getKingdom().hasAlliance(),
			nano = () => base.army.getKingdom().getAlliance()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_city,
			check = () => base.army.hasCity(),
			nano = () => base.army.getCity()
		});
		((IBaseMetaBanners)this).enableClickAnimation();
	}

	protected override IEnumerator showContent()
	{
		banners.Sort((MetaBannerElement x, MetaBannerElement y) => ((Component)x.banner).transform.GetSiblingIndex().CompareTo(((Component)y.banner).transform.GetSiblingIndex()));
		yield return (object)new WaitForSecondsRealtime(0.025f);
		foreach (MetaBannerElement banner in banners)
		{
			if (banner.check())
			{
				track_objects.Add(banner.nano());
				metaBannerShow(banner);
			}
		}
	}

	protected override void clear()
	{
		base.clear();
		_visible_banners = 0;
		foreach (MetaBannerElement banner in banners)
		{
			metaBannerHide(banner);
		}
	}

	public void metaBannerShow(MetaBannerElement pAsset)
	{
		((Component)pAsset.banner).gameObject.SetActive(true);
		pAsset.banner.load(pAsset.nano());
		_visible_banners++;
	}

	public void metaBannerHide(MetaBannerElement pAsset)
	{
		if (((Component)pAsset.banner).gameObject.activeSelf)
		{
			((Component)pAsset.banner).gameObject.SetActive(false);
		}
	}

	public IReadOnlyCollection<MetaBannerElement> getBanners()
	{
		return banners;
	}
}
// --- End of File: ArmyMetaBanners.cs ---



// --- Start of File: ArmySelectedMetaBanners.cs ---
public class ArmySelectedMetaBanners : ArmyMetaBanners, ISelectedTabBanners<Army>
{
	public void update(Army pArmy)
	{
		meta_object = pArmy;
		clear();
		foreach (MetaBannerElement banner in banners)
		{
			if (banner.check())
			{
				metaBannerShow(banner);
			}
		}
	}

	protected override void OnEnable()
	{
	}

	public int countVisibleBanners()
	{
		return base.visible_banners;
	}
}
// --- End of File: ArmySelectedMetaBanners.cs ---



// --- Start of File: ArmyStatsElement.cs ---
using System.Collections;
using UnityEngine;

public class ArmyStatsElement : ArmyElement, IStatsElement, IRefreshElement
{
	private StatsIconContainer _stats_icons;

	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	{
		_stats_icons.setIconValue(pName, pMainVal, pMax, pColor, pFloat, pEnding, pSeparator);
	}

	protected override void Awake()
	{
		_stats_icons = ((Component)this).gameObject.AddOrGetComponent<StatsIconContainer>();
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.army != null && base.army.isAlive())
		{
			_stats_icons.showGeneralIcons<Army, ArmyData>(base.army);
			setIconValue("i_army_size", base.army.countUnits());
			setIconValue("i_kills", base.army.getTotalKills());
			setIconValue("i_melee", base.army.countMelee());
			setIconValue("i_range", base.army.countRange());
		}
		yield break;
	}

	GameObject IStatsElement.get_gameObject()
	{
		return ((Component)this).gameObject;
	}
}
// --- End of File: ArmyStatsElement.cs ---



// --- Start of File: ArmyWindow.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ArmyWindow : WindowMetaGeneric<Army, ArmyData>
{
	[SerializeField]
	private Image _race_top_left;

	[SerializeField]
	private Image _race_top_right;

	public override MetaType meta_type => MetaType.Army;

	protected override Army meta_object => SelectedMetas.selected_army;

	protected override void showTopPartInformation()
	{
		base.showTopPartInformation();
		Army army = meta_object;
		if (army != null)
		{
			_race_top_left.sprite = army.getSpriteIcon();
			_race_top_right.sprite = army.getSpriteIcon();
		}
	}

	internal override void showStatsRows()
	{
		Army army = meta_object;
		if (army != null)
		{
			tryShowPastNames();
			showStatRow("founded", army.getFoundedDate(), MetaType.None, -1L, "iconAge");
			showStatRow("males", army.countMales(), MetaType.None, -1L, "iconMale");
			showStatRow("females", army.countFemales(), MetaType.None, -1L, "iconFemale");
			showStatRow("deaths", army.getTotalDeaths(), MetaType.None, -1L, "iconDead");
			showStatRow("kills", army.getTotalKills(), MetaType.None, -1L, "iconKills");
			tryToShowActor("captain", -1L, null, army.getCaptain(), "iconCaptain");
			tryShowPastCaptains();
			tryToShowMetaCity("village", -1L, null, army.getCity());
			tryToShowMetaKingdom("kingdom", -1L, null, army.getKingdom());
		}
	}

	private void tryShowPastCaptains()
	{
		List<LeaderEntry> past_captains = meta_object.data.past_captains;
		if (past_captains != null && past_captains.Count > 1)
		{
			showStatRow("past_captains", meta_object.data.past_captains.Count, MetaType.None, -1L, "iconCaptain", "past_rulers", getTooltipPastCaptains);
		}
	}

	private TooltipData getTooltipPastCaptains()
	{
		return new TooltipData
		{
			tip_name = "past_captains",
			meta_type = MetaType.Army,
			past_rulers = new ListPool<LeaderEntry>(meta_object.data.past_captains)
		};
	}
}
// --- End of File: ArmyWindow.cs ---



// --- Start of File: ArrayExtensions.cs ---
using System;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;
using UnityEngine;

public static class ArrayExtensions
{
	private static Random rnd => Randy.rnd;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static T First<T>(this T[] pArray)
	{
		return pArray[0];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static T Last<T>(this T[] pArray)
	{
		return pArray[^1];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static int IndexOf<T>(this T[] pArray, T pValue)
	{
		return Array.IndexOf(pArray, pValue);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static bool Contains<T>(this T[] pArray, T pValue)
	{
		return Array.IndexOf(pArray, pValue) > -1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static int FreeIndex<T>(this T[] pArray)
	{
		return Array.IndexOf(pArray, null);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static T GetRandom<T>(this T[] pArray)
	{
		return pArray[rnd.Next(0, pArray.Length)];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Pure]
	public static T GetRandom<T>(this T[] pArray, int pLength)
	{
		return pArray[rnd.Next(0, pLength)];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Swap<T>(this T[] pArray, int pIndex1, int pIndex2)
	{
		T val = pArray[pIndex1];
		pArray[pIndex1] = pArray[pIndex2];
		pArray[pIndex2] = val;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Shuffle<T>(this T[] pArray)
	{
		if (pArray.Length >= 2)
		{
			int num = pArray.Length;
			for (int i = 0; i < num; i++)
			{
				pArray.Swap(i, rnd.Next(i, num));
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Shuffle<T>(this T[] pArray, int pCount)
	{
		if (pCount >= 2)
		{
			for (int i = 0; i < pCount; i++)
			{
				pArray.Swap(i, rnd.Next(i, pCount));
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void ShuffleOne<T>(this T[] pArray)
	{
		if (pArray.Length >= 2)
		{
			pArray.Swap(0, rnd.Next(0, pArray.Length));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void ShuffleOne<T>(this T[] pArray, int pItem)
	{
		if (pArray.Length >= 2 && pArray.Length >= pItem + 1)
		{
			pArray.Swap(pItem, rnd.Next(pItem, pArray.Length));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void ShuffleOne<T>(this T[] pArray, int pItem, int pCount)
	{
		if (pCount >= 2 && pCount >= pItem + 1)
		{
			pArray.Swap(pItem, rnd.Next(pItem, pCount));
		}
	}

	public static void Clear<T>(this T[] pArray)
	{
		Array.Clear(pArray, 0, pArray.Length);
	}

	public static void Clear<T>(this T[] pArray, int pCount)
	{
		Array.Clear(pArray, 0, pCount);
	}

	[Pure]
	public static bool AnyTrue(this bool[] pArray)
	{
		for (int i = 0; i < pArray.Length; i++)
		{
			if (pArray[i])
			{
				return true;
			}
		}
		return false;
	}

	[Pure]
	public static bool AnyFalse(this bool[] pArray)
	{
		for (int i = 0; i < pArray.Length; i++)
		{
			if (!pArray[i])
			{
				return true;
			}
		}
		return false;
	}

	public static string AsString<T>(this T[] pArray)
	{
		if (pArray == null)
		{
			return "";
		}
		using ListPool<string> listPool = new ListPool<string>(pArray.Length);
		for (int i = 0; i < pArray.Length; i++)
		{
			T val = pArray[i];
			listPool.Add(val?.ToString() ?? "null");
		}
		return string.Join(", ", listPool.ToArray());
	}

	public static void PrintToConsole<T>(this T[] pArray, string pMessage = null)
	{
		if (pArray != null)
		{
			string text = "";
			for (int i = 0; i < pArray.Length; i++)
			{
				T val = pArray[i];
				text = text + val.ToString() + ",";
			}
			if (text.Length > 0)
			{
				text = text.TrimEnd(',');
			}
			if (pMessage != null)
			{
				Debug.Log((object)(pMessage + ": [" + text + "]"));
			}
			else
			{
				Debug.Log((object)text);
			}
		}
	}

	public static bool AllTrue(this bool[] pArray)
	{
		return !pArray.AnyFalse();
	}

	public static bool AllFalse(this bool[] pArray)
	{
		return !pArray.AnyTrue();
	}
}
// --- End of File: ArrayExtensions.cs ---



// --- Start of File: ArticleSettings.cs ---
public class ArticleSettings : StructureSettings
{
	public override void create(LanguageStructure pStructure, int pSizeMin, int pSizeMax)
	{
		WordType[] word_types = LanguageStructureHelpers.word_types;
		foreach (WordType pWord in word_types)
		{
			generate(pStructure, pWord, pSizeMin, pSizeMax);
		}
	}

	public void generate(LanguageStructure pStructure, WordType pWord, int pSizeMin, int pSizeMax)
	{
		bool flag = Randy.randomBool();
		enabled[(int)pWord] = flag;
		if (flag)
		{
			sets[(int)pWord] = generateSets(pStructure, Randy.randomInt(pSizeMin, pSizeMax));
			separator[(int)pWord] = LanguageStructureHelpers.possible_article_separators.GetRandom();
		}
	}

	private string[] generateSets(LanguageStructure pStructure, int pAmount)
	{
		string[] array = new string[pAmount];
		for (int i = 0; i < pAmount; i++)
		{
			array[i] = Randy.randomInt(0, 5) switch
			{
				0 => pStructure.sets_consonants.GetRandom() + pStructure.sets_vowels.GetRandom() + pStructure.sets_consonants.GetRandom(), 
				1 => pStructure.sets_onset_2.GetRandom() + pStructure.sets_vowels.GetRandom(), 
				2 => pStructure.sets_consonants.GetRandom() + pStructure.sets_vowels.GetRandom(), 
				3 => pStructure.sets_vowels.GetRandom() + pStructure.sets_consonants.GetRandom() + pStructure.sets_vowels.GetRandom(), 
				_ => pStructure.sets_vowels.GetRandom() ?? "", 
			};
		}
		return array;
	}
}
// --- End of File: ArticleSettings.cs ---



// --- Start of File: AssemblyInfo.cs ---
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyVersion("0.0.0.0")]
// --- End of File: AssemblyInfo.cs ---



// --- Start of File: Asset.cs ---
using System;
using Newtonsoft.Json;

[Serializable]
public abstract class Asset : IEquatable<Asset>
{
	public const string DEFAULT_ASSET_ID = "ASSET_ID";

	[JsonProperty(Order = -1)]
	public string id = "ASSET_ID";

	private int _hashcode;

	private int _index;

	public virtual void create()
	{
	}

	public void setHash(int pHash)
	{
		_hashcode = pHash;
	}

	public void setIndexID(int pValue)
	{
		_index = pValue;
	}

	public int getIndexID()
	{
		return _index;
	}

	public bool Equals(Asset pAsset)
	{
		return _hashcode == pAsset.GetHashCode();
	}

	public override int GetHashCode()
	{
		return _hashcode;
	}

	public bool isTemplateAsset()
	{
		if (id.StartsWith("$"))
		{
			return true;
		}
		if (id.StartsWith("_"))
		{
			return true;
		}
		return false;
	}
}
// --- End of File: Asset.cs ---



// --- Start of File: AssetLibrary.cs ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using Beebyte.Obfuscator;
using UnityEngine;

[Serializable]
[ObfuscateLiterals]
public abstract class AssetLibrary<T> : BaseAssetLibrary where T : Asset
{
	public List<T> list = new List<T>();

	[NonSerialized]
	public Dictionary<string, T> dict = new Dictionary<string, T>();

	protected T t;

	private T[] _array;

	public string file_path;

	private HashSet<string> _not_found = new HashSet<string>();

	public override int total_items => list.Count;

	public virtual T get(string pID)
	{
		if (dict.TryGetValue(pID, out var value))
		{
			return value;
		}
		_not_found.Add(pID);
		return null;
	}

	public T getSimple(string pID)
	{
		if (!has(pID))
		{
			return null;
		}
		if (dict.TryGetValue(pID, out var value))
		{
			return value;
		}
		return null;
	}

	public virtual bool has(string pID)
	{
		return dict.ContainsKey(pID);
	}

	public virtual T add(T pAsset)
	{
		string text = pAsset.id;
		if (dict.ContainsKey(text))
		{
			for (int i = 0; i < list.Count; i++)
			{
				if (!(list[i].id != text))
				{
					list.RemoveAt(i);
					break;
				}
			}
			dict.Remove(text);
			BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: duplicate asset - overwriting...", text);
		}
		t = pAsset;
		t.create();
		t.setHash(BaseAssetLibrary._latest_hash++);
		if (!pAsset.isTemplateAsset())
		{
			list.Add(pAsset);
		}
		t.setIndexID(list.Count);
		dict.Add(text, pAsset);
		return pAsset;
	}

	public virtual T clone(string pNew, string pFrom)
	{
		clone(out var pNew2, dict[pFrom]);
		t = pNew2;
		t.id = pNew;
		add(t);
		return t;
	}

	public virtual void clone(out T pNew, T pFrom)
	{
		pNew = Activator.CreateInstance<T>();
		FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Instance | BindingFlags.Public);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (!fieldInfo.IsNotSerialized)
			{
				object value = fieldInfo.GetValue(pFrom);
				if (value == null || fieldInfo.isString())
				{
					fieldInfo.SetValue(pNew, value);
				}
				else if (fieldInfo.isCloneable())
				{
					ICloneable cloneable = value as ICloneable;
					fieldInfo.SetValue(pNew, cloneable.Clone());
				}
				else if (fieldInfo.isCollection())
				{
					ICollection collection = value as ICollection;
					fieldInfo.SetValue(pNew, Activator.CreateInstance(fieldInfo.FieldType, collection));
				}
				else if (fieldInfo.isEnumerable())
				{
					IEnumerable enumerable = value as IEnumerable;
					fieldInfo.SetValue(pNew, Activator.CreateInstance(fieldInfo.FieldType, enumerable));
				}
				else
				{
					fieldInfo.SetValue(pNew, value);
				}
			}
		}
	}

	internal void loadFromFile<TAssetLib>() where TAssetLib : AssetLibrary<T>
	{
		foreach (T item in JsonUtility.FromJson<TAssetLib>(Resources.Load<TextAsset>(file_path).text).list)
		{
			add(item);
		}
	}

	public T[] getArray()
	{
		if (_array == null)
		{
			_array = list.ToArray();
		}
		return _array;
	}

	public override void editorDiagnostic()
	{
		Type type = typeof(T);
		while (type != null)
		{
			if (!type.IsSerializable)
			{
				BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Asset not marked serializable", type.Name);
			}
			type = type.BaseType;
		}
		FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (fieldInfo.IsAssembly && !fieldInfo.IsNotSerialized)
			{
				BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Asset field is marked <e>internal</e> - set it to <e>public</e> and/or <e>[NonSerialized]</e> instead. Currently it's not being cloned.", fieldInfo.Name);
			}
			if (fieldInfo.IsFamily && !fieldInfo.IsNotSerialized)
			{
				BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Asset field is marked <e>protected</e> - set it to <e>public</e> and/or <e>[NonSerialized]</e> instead. Currently it's not being cloned.", fieldInfo.Name);
			}
			if (fieldInfo.IsPrivate && ((MemberInfo)fieldInfo).GetCustomAttribute<SerializeField>() != null)
			{
				BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Asset field is marked <e>private</e> and has <e>[SerializeField]</e> attribute - it won't be cloned. Set it to <e>public</e> instead", fieldInfo.Name);
			}
		}
		base.editorDiagnostic();
	}

	public override void checkLocale(Asset pAsset, string pLocaleID)
	{
		string text = pLocaleID?.Underscore();
		if (text != pLocaleID)
		{
			BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Translation key is not in lowercase - <e>" + pLocaleID + "</e> should be <e>" + text + "</e>", pAsset.id);
		}
		if (!(pAsset is ILocalizedAsset) && !(pAsset is IMultiLocalesAsset))
		{
			BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Interface missing for <e>" + text + "</e>", pAsset.id);
		}
		if (!string.IsNullOrEmpty(text) && !LocalizedTextManager.stringExists(text))
		{
			BaseAssetLibrary.logAssetError("<e>AssetLibrary<" + typeof(T).Name + "></e>: Missing translation key <e>" + text + "</e>", pAsset.id);
			AssetManager.missing_locale_keys.Add(text);
		}
	}

	public string getEditorPathForSave()
	{
		return Application.dataPath + "/Resources/" + file_path + ".json";
	}

	public void saveToFile(string pPath = "units.json")
	{
		_ = Application.streamingAssetsPath + "/modules/core/" + pPath;
	}

	protected bool checkSpriteExists(string pVariableID, string pPath, Asset pAsset)
	{
		if (!string.IsNullOrEmpty(pPath) && !hasSpriteInResourcesDebug(pPath))
		{
			BaseAssetLibrary.logAssetError(id + ": <e>" + pVariableID + "</e> doesn't exist for <e>" + pAsset.id + "</e> at ", pPath);
			return false;
		}
		return true;
	}

	protected static TA[] a<TA>(params TA[] pArgs)
	{
		return Toolbox.a(pArgs);
	}

	protected static List<TL> l<TL>(params TL[] pArgs)
	{
		return Toolbox.l(pArgs);
	}

	protected static HashSet<TH> h<TH>(params TH[] pArgs)
	{
		return Toolbox.h(pArgs);
	}

	public override IEnumerable<Asset> getList()
	{
		return list;
	}
}
// --- End of File: AssetLibrary.cs ---



// --- Start of File: AssetManager.cs ---
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using ai.behaviours;
using db;

public class AssetManager
{
	public static TileEffectsLibrary tile_tile_effects;

	public static KingdomBannerLibrary kingdom_banners_library;

	public static CultureBannerLibrary culture_banners_library;

	public static ClanBannerLibrary clan_banners_library;

	public static ReligionBannerLibrary religion_banners_library;

	public static LanguageBannerLibrary language_banners_library;

	public static SubspeciesBannerLibrary subspecies_banners_library;

	public static FamilysBannerLibrary family_banners_library;

	public static WorldTimeScaleLibrary time_scales;

	public static OptionsLibrary options_library;

	public static WorldLawLibrary world_laws_library;

	public static WorldLawGroupLibrary world_law_groups;

	public static OnomasticsLibrary onomastics_library;

	public static OnomasticsEvolutionLibrary onomastics_evolution_library;

	public static LinguisticsLibrary linguistics_library;

	public static WordsLibrary words_library;

	public static SentencesLibrary sentences_library;

	public static StoryLibrary story_library;

	public static RarityLibrary rarity_library;

	public static GraphTimeLibrary graph_time_library;

	public static HistoryDataLibrary history_data_library;

	public static HistoryMetaDataLibrary history_meta_data_library;

	public static BaseStatsLibrary base_stats_library;

	public static ChromosomeTypeLibrary chromosome_type_library;

	public static GeneLibrary gene_library;

	public static NameplateLibrary nameplates_library;

	public static MetaTypeLibrary meta_type_library;

	public static MetaCustomizationLibrary meta_customization_library;

	public static MetaRepresentationLibrary meta_representation_library;

	public static DecisionsLibrary decisions_library;

	public static NeuralLayerLibrary neural_layers;

	public static LoyaltyLibrary loyalty_library;

	public static OpinionLibrary opinion_library;

	public static HappinessLibrary happiness_library;

	public static KingdomJobLibrary job_kingdom;

	public static BehaviourTaskKingdomLibrary tasks_kingdom;

	public static WorldLogLibrary world_log_library;

	public static HistoryGroupLibrary history_groups;

	public static CityJobLibrary job_city;

	public static BehaviourTaskCityLibrary tasks_city;

	public static ActorJobLibrary job_actor;

	public static BehaviourTaskActorLibrary tasks_actor;

	public static CitizenJobLibrary citizen_job_library;

	public static CultureTraitLibrary culture_traits;

	public static CultureTraitGroupLibrary culture_trait_groups;

	public static LanguageTraitLibrary language_traits;

	public static LanguageTraitGroupLibrary language_trait_groups;

	public static SubspeciesTraitLibrary subspecies_traits;

	public static SubspeciesTraitGroupLibrary subspecies_trait_groups;

	public static ClanTraitLibrary clan_traits;

	public static ClanTraitGroupLibrary clan_trait_groups;

	public static ReligionTraitLibrary religion_traits;

	public static ReligionTraitGroupLibrary religion_trait_groups;

	public static TraitRainLibrary trait_rains;

	public static CommunicationLibrary communication_library;

	public static CommunicationTopicLibrary communication_topic_library;

	public static BookTypeLibrary book_types;

	public static PersonalityLibrary personalities;

	public static ProfessionLibrary professions;

	public static DropsLibrary drops;

	public static BuildingLibrary buildings;

	public static ActorAssetLibrary actor_library;

	public static ActorTraitLibrary traits;

	public static ActorTraitGroupLibrary trait_groups;

	public static KingdomLibrary kingdoms;

	public static KingdomTraitLibrary kingdoms_traits;

	public static KingdomTraitGroupLibrary kingdoms_traits_groups;

	public static NameGeneratorLibrary name_generator;

	public static NameSetsLibrary name_sets;

	public static DisasterLibrary disasters;

	public static PhenotypeLibrary phenotype_library;

	public static BiomeLibrary biome_library;

	public static ResourceLibrary resources;

	public static ItemLibrary items;

	public static ItemModifierLibrary items_modifiers;

	public static ItemGroupLibrary item_groups;

	public static UnitHandToolLibrary unit_hand_tools;

	public static ProjectileLibrary projectiles;

	public static BuildOrderLibrary city_build_orders;

	public static ArchitectureLibrary architecture_library;

	public static CloudLibrary clouds;

	public static MonthLibrary months;

	public static TileLibrary tiles;

	public static TopTileLibrary top_tiles;

	public static TerraformLibrary terraform;

	public static PowerLibrary powers;

	public static SpellLibrary spells;

	public static StatusLibrary status;

	public static TesterJobLibrary tester_jobs;

	public static TesterBehTaskLibrary tester_tasks;

	public static MusicBoxLibrary music_box;

	public static AchievementLibrary achievements;

	public static AchievementGroupLibrary achievement_groups;

	public static SignalLibrary signals;

	public static MapGenSettingsLibrary map_gen_settings;

	public static MapGenTemplateLibrary map_gen_templates;

	public static QuantumSpriteLibrary quantum_sprites;

	public static WorldBehaviourLibrary world_behaviours;

	public static MapSizeLibrary map_sizes;

	public static WorldAgeLibrary era_library;

	public static EffectsLibrary effects_library;

	public static SimGlobals sim_globals_library;

	public static ColorStyleLibrary color_style_library;

	public static ClanColorsLibrary clan_colors_library;

	public static SubspeciesColorsLibrary subspecies_colors_library;

	public static FamiliesColorsLibrary families_colors_library;

	public static ArmiesColorsLibrary armies_colors_library;

	public static LanguagesColorsLibrary languages_colors_library;

	public static KingdomColorsLibrary kingdom_colors_library;

	public static CultureColorsLibrary culture_colors_library;

	public static ReligionColorsLibrary religion_colors_library;

	public static ArchitectMoodLibrary architect_mood_library;

	public static PlotsLibrary plots_library;

	public static PlotCategoryLibrary plot_category_library;

	public static TooltipLibrary tooltips;

	public static WarTypeLibrary war_types_library;

	public static HotkeyLibrary hotkey_library;

	public static StatisticsLibrary statistics_library;

	public static BrushLibrary brush_library;

	public static DebugToolLibrary debug_tool_library;

	public static CombatActionLibrary combat_action_library;

	public static DynamicSpritesLibrary dynamic_sprites_library;

	public static KnowledgeLibrary knowledge_library;

	public static WindowLibrary window_library;

	public static MetaTextReportLibrary meta_text_report_library;

	public static ListWindowLibrary list_window_library;

	public static PowerTabLibrary power_tab_library;

	public static LocaleGroupLibrary locale_groups_library;

	public static GameLanguageLibrary game_language_library;

	private static AssetManager _instance;

	private readonly List<BaseAssetLibrary> _list = new List<BaseAssetLibrary>();

	private readonly Dictionary<string, BaseAssetLibrary> _dict = new Dictionary<string, BaseAssetLibrary>();

	private string _assetgv;

	public static HashSet<string> missing_locale_keys = new HashSet<string>();

	public static void clear()
	{
		_instance = null;
	}

	public static void initMain()
	{
		if (_instance == null)
		{
			_instance = new AssetManager();
		}
	}

	public static void init()
	{
		_instance.initLibs();
	}

	public AssetManager()
	{
		_assetgv = Config.gv;
		add(game_language_library = new GameLanguageLibrary(), "game_languages");
		add(options_library = new OptionsLibrary(), "options_library");
	}

	private void initLibs()
	{
		add(tile_tile_effects = new TileEffectsLibrary(), "tile_effects");
		add(base_stats_library = new BaseStatsLibrary(), "base_stats_library");
		add(world_log_library = new WorldLogLibrary(), "world_log_library");
		add(history_groups = new HistoryGroupLibrary(), "history_groups");
		add(decisions_library = new DecisionsLibrary(), "decisions_library");
		add(neural_layers = new NeuralLayerLibrary(), "neural_layer_library");
		add(graph_time_library = new GraphTimeLibrary(), "graph_time_library");
		add(history_data_library = new HistoryDataLibrary(), "history_data_library");
		add(history_meta_data_library = new HistoryMetaDataLibrary(), "history_meta_data_library");
		add(world_laws_library = new WorldLawLibrary(), "world_laws_library");
		add(world_law_groups = new WorldLawGroupLibrary(), "world_law_groups");
		add(meta_type_library = new MetaTypeLibrary(), "meta_type_library");
		add(meta_text_report_library = new MetaTextReportLibrary(), "meta_text_report_library");
		add(meta_customization_library = new MetaCustomizationLibrary(), "meta_customization_library");
		add(meta_representation_library = new MetaRepresentationLibrary(), "meta_representation_library");
		add(culture_banners_library = new CultureBannerLibrary(), "culture_banners_library");
		add(kingdom_banners_library = new KingdomBannerLibrary(), "kingdom_banners_library");
		add(clan_banners_library = new ClanBannerLibrary(), "clan_banners_library");
		add(religion_banners_library = new ReligionBannerLibrary(), "religion_banners_library");
		add(language_banners_library = new LanguageBannerLibrary(), "language_banners_library");
		add(subspecies_banners_library = new SubspeciesBannerLibrary(), "subspecies_banners_library");
		add(family_banners_library = new FamilysBannerLibrary(), "family_banners_library");
		add(time_scales = new WorldTimeScaleLibrary(), "world_time_scales_library");
		add(communication_library = new CommunicationLibrary(), "communication_library");
		add(communication_topic_library = new CommunicationTopicLibrary(), "communication_topic_library");
		add(city_build_orders = new BuildOrderLibrary(), "city_build_orders");
		add(architecture_library = new ArchitectureLibrary(), "architecture_library");
		add(book_types = new BookTypeLibrary(), "book_types_library");
		add(nameplates_library = new NameplateLibrary(), "nameplates_library");
		add(combat_action_library = new CombatActionLibrary(), "combat_action_library");
		add(biome_library = new BiomeLibrary(), "biome_library");
		add(phenotype_library = new PhenotypeLibrary(), "phenotype_library");
		add(dynamic_sprites_library = new DynamicSpritesLibrary(), "dynamic_sprites_library");
		add(debug_tool_library = new DebugToolLibrary(), "debug_tool_library");
		add(brush_library = new BrushLibrary(), "brush_library");
		add(chromosome_type_library = new ChromosomeTypeLibrary(), "chromosome_type_library");
		add(gene_library = new GeneLibrary(), "gene_library");
		add(loyalty_library = new LoyaltyLibrary(), "loyalty_library");
		add(opinion_library = new OpinionLibrary(), "opinion_library");
		add(happiness_library = new HappinessLibrary(), "happiness_library");
		add(hotkey_library = new HotkeyLibrary(), "hotkey_library");
		add(tooltips = new TooltipLibrary(), "tooltips");
		add(war_types_library = new WarTypeLibrary(), "war_types_library");
		add(sim_globals_library = new SimGlobals(), "sim_globals_library");
		add(color_style_library = new ColorStyleLibrary(), "color_style_library");
		add(effects_library = new EffectsLibrary(), "effects_library");
		add(kingdom_colors_library = new KingdomColorsLibrary(), "kingdom_colors_library");
		add(clan_colors_library = new ClanColorsLibrary(), "clan_colors_library");
		add(subspecies_colors_library = new SubspeciesColorsLibrary(), "species_colors_library");
		add(languages_colors_library = new LanguagesColorsLibrary(), "language_colors_library");
		add(families_colors_library = new FamiliesColorsLibrary(), "families_colors_library");
		add(armies_colors_library = new ArmiesColorsLibrary(), "armies_colors_library");
		add(culture_colors_library = new CultureColorsLibrary(), "culture_colors_library");
		add(religion_colors_library = new ReligionColorsLibrary(), "religion_colors_library");
		add(months = new MonthLibrary(), "month_library");
		add(era_library = new WorldAgeLibrary(), "era_library");
		add(clouds = new CloudLibrary(), "cloud_library");
		add(map_sizes = new MapSizeLibrary(), "map_sizes");
		add(music_box = new MusicBoxLibrary(), "music_box");
		add(tiles = new TileLibrary(), "tiles");
		add(top_tiles = new TopTileLibrary(), "top_tiles");
		add(culture_traits = new CultureTraitLibrary(), "culture_traits");
		add(culture_trait_groups = new CultureTraitGroupLibrary(), "culture_trait_groups");
		add(language_traits = new LanguageTraitLibrary(), "language_traits");
		add(language_trait_groups = new LanguageTraitGroupLibrary(), "language_trait_groups");
		add(clan_traits = new ClanTraitLibrary(), "clan_traits");
		add(clan_trait_groups = new ClanTraitGroupLibrary(), "clan_trait_groups");
		add(subspecies_traits = new SubspeciesTraitLibrary(), "subspecies_traits");
		add(subspecies_trait_groups = new SubspeciesTraitGroupLibrary(), "subspecies_trait_groups");
		add(religion_traits = new ReligionTraitLibrary(), "religion_traits");
		add(religion_trait_groups = new ReligionTraitGroupLibrary(), "religion_trait_groups");
		add(trait_rains = new TraitRainLibrary(), "trait_rains");
		add(professions = new ProfessionLibrary(), "professions");
		add(quantum_sprites = new QuantumSpriteLibrary(), "quantum_sprites");
		add(world_behaviours = new WorldBehaviourLibrary(), "world_behaviours");
		add(personalities = new PersonalityLibrary(), "personalities");
		add(drops = new DropsLibrary(), "drops");
		add(status = new StatusLibrary(), "status");
		add(spells = new SpellLibrary(), "spells");
		add(citizen_job_library = new CitizenJobLibrary(), "citizen_job_library");
		add(tasks_actor = new BehaviourTaskActorLibrary(), "beh_actor");
		add(tasks_city = new BehaviourTaskCityLibrary(), "beh_city");
		add(tasks_kingdom = new BehaviourTaskKingdomLibrary(), "beh_kingdom");
		add(traits = new ActorTraitLibrary(), "traits");
		add(trait_groups = new ActorTraitGroupLibrary(), "trait_groups");
		add(plots_library = new PlotsLibrary(), "plots");
		add(plot_category_library = new PlotCategoryLibrary(), "plot_group");
		add(kingdoms = new KingdomLibrary(), "kingdoms");
		add(kingdoms_traits_groups = new KingdomTraitGroupLibrary(), "kingdom_trait_group");
		add(kingdoms_traits = new KingdomTraitLibrary(), "kingdom_traits");
		add(actor_library = new ActorAssetLibrary(), "units");
		add(buildings = new BuildingLibrary(), "buildings");
		add(name_generator = new NameGeneratorLibrary(), "name_generator");
		add(name_sets = new NameSetsLibrary(), "name_sets");
		add(disasters = new DisasterLibrary(), "disasters");
		add(job_actor = new ActorJobLibrary(), "job_actor");
		add(job_city = new CityJobLibrary(), "job_city");
		add(job_kingdom = new KingdomJobLibrary(), "job_kingdom");
		add(powers = new PowerLibrary(), "powers");
		add(items = new ItemLibrary(), "items");
		add(items_modifiers = new ItemModifierLibrary(), "items_modifiers");
		add(item_groups = new ItemGroupLibrary(), "item_groups");
		add(unit_hand_tools = new UnitHandToolLibrary(), "tools");
		add(resources = new ResourceLibrary(), "resources");
		add(terraform = new TerraformLibrary(), "terraform");
		add(projectiles = new ProjectileLibrary(), "projectiles");
		add(signals = new SignalLibrary(), "signals");
		add(achievement_groups = new AchievementGroupLibrary(), "achievement_groups");
		add(map_gen_templates = new MapGenTemplateLibrary(), "map_gen_templates");
		add(map_gen_settings = new MapGenSettingsLibrary(), "map_gen_settings");
		add(statistics_library = new StatisticsLibrary(), "statistics_library");
		add(linguistics_library = new LinguisticsLibrary(), "linguistics_library");
		add(words_library = new WordsLibrary(), "words_library");
		add(sentences_library = new SentencesLibrary(), "sentences_library");
		add(story_library = new StoryLibrary(), "story_library");
		add(onomastics_library = new OnomasticsLibrary(), "onomastics_library");
		add(onomastics_evolution_library = new OnomasticsEvolutionLibrary(), "onomastics_evolution_library");
		add(rarity_library = new RarityLibrary(), "rarity_library");
		add(knowledge_library = new KnowledgeLibrary(), "knowledge_library");
		add(window_library = new WindowLibrary(), "window_library");
		add(list_window_library = new ListWindowLibrary(), "list_window_library");
		add(power_tab_library = new PowerTabLibrary(), "power_tab_library");
		add(architect_mood_library = new ArchitectMoodLibrary(), "architect_mood_library");
		add(achievements = new AchievementLibrary(), "achievements");
		if (DebugConfig.isOn(DebugOption.TesterLibs))
		{
			loadAutoTester();
		}
		add(locale_groups_library = new LocaleGroupLibrary(), "locale_groups");
		foreach (BaseAssetLibrary item in _list)
		{
			item.post_init();
		}
		foreach (BaseAssetLibrary item2 in _list)
		{
			item2.linkAssets();
		}
	}

	public static void loadAutoTester()
	{
		if (tester_jobs == null)
		{
			_instance.add(tester_jobs = new TesterJobLibrary(), "tester_jobs");
			_instance.add(tester_tasks = new TesterBehTaskLibrary(), "tester_tasks");
		}
	}

	internal static void generateMissingLocalesFile()
	{
	}

	public void exportAssets()
	{
		if (DebugConfig.isOn(DebugOption.ExportAssetLibraries))
		{
			MiniBench miniBench = new MiniBench("exportAssets", 25L);
			string path = "GenAssets/wbassets";
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			ParallelOptions parallelOptions = new ParallelOptions
			{
				MaxDegreeOfParallelism = 3
			};
			Parallel.ForEach(_list, parallelOptions, delegate(BaseAssetLibrary pLib)
			{
				pLib.exportAssets();
			});
			miniBench.Dispose();
		}
	}

	private void add(BaseAssetLibrary pLibrary, string pId)
	{
		if (_assetgv[0] == '0')
		{
			pLibrary.init();
			_list.Add(pLibrary);
			_dict.Add(pId, pLibrary);
			pLibrary.id = pId;
		}
	}

	public static IEnumerable<BaseAssetLibrary> getList()
	{
		return _instance._list;
	}

	public static bool has(string pLibraryID)
	{
		return _instance._dict.ContainsKey(pLibraryID);
	}

	public static BaseAssetLibrary get(string pLibraryID)
	{
		return _instance._dict[pLibraryID];
	}
}
// --- End of File: AssetManager.cs ---



// --- Start of File: AssetModLoader.cs ---
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public static class AssetModLoader
{
	private static string path_log;

	public static void load()
	{
		path_log = Application.streamingAssetsPath + "/mod_loading_logs.log";
		File.WriteAllText(path_log, "");
		string text = Application.streamingAssetsPath + "/mods/";
		List<string> directories = getDirectories(text);
		log("# HELLO");
		log("# GOTTA LOAD MODS FAST");
		log("# LOADING MODS NOW");
		log("########");
		log("");
		log("# MAIN PATH: " + text);
		log("# TOTAL MODS: " + directories.Count);
		log("");
		for (int i = 0; i < directories.Count; i++)
		{
			string text2 = directories[i];
			log("---------START------------------------------------------------------------------------------------");
			log("## LOADING MOD N " + (i + 1));
			log(text2);
			loadMod(text2);
			log("---------FINISH-----------------------------------------------------------------------------------");
			log("");
			log("");
		}
	}

	private static void loadMod(string pPath)
	{
		string text = pPath.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)[^1];
		log("# CHECKING MOD... " + text);
		foreach (string directory in getDirectories(pPath))
		{
			checkModAssets(directory);
		}
	}

	private static void checkModAssets(string pPath)
	{
		List<string> directories = getDirectories(pPath);
		string[] array = pPath.Split(Path.DirectorySeparatorChar);
		log("");
		string text = array[^1];
		log("## CHECKING MOD FOLDER... " + text);
		log("## SUB FOLDERS FOUND: " + directories.Count);
		log("");
		foreach (string item in directories)
		{
			checkModFolder(item, text);
		}
	}

	private static void checkModFolder(string pPath, string pType)
	{
		List<string> files = getFiles(pPath);
		string[] array = pPath.Split(Path.DirectorySeparatorChar);
		log("");
		log("# CHECKING PATH... " + array[^1]);
		log("FILES: " + files.Count);
		log("");
		foreach (string item in files)
		{
			log(item);
			if (item.Contains("json"))
			{
				loadFileJson(item, pType);
			}
			if (item.Contains("png"))
			{
				loadTexture(item);
			}
		}
	}

	private static void loadTexture(string pPath)
	{
		string text = pPath.Split(Path.DirectorySeparatorChar)[^1];
		log("# LOAD TEXTURE: " + text);
		byte[] pBytes = File.ReadAllBytes(pPath);
		string text2 = "@wb_" + text;
		log("ADDING TEXTURE... " + text2);
		SpriteTextureLoader.addSprite(text2, pBytes);
	}

	private static void loadFileJson(string pPath, string pType)
	{
		string text = pPath.Split(Path.DirectorySeparatorChar)[^1];
		log("# LOAD ASSET: " + text);
		string pData = File.ReadAllText(pPath);
		switch (pType)
		{
		default:
			_ = pType == "traits";
			break;
		case "buildings":
			loadAssetBuilding(pData);
			break;
		case "powers":
			loadAssetPowers(pData);
			break;
		case "kingdoms":
			break;
		}
	}

	private static void loadAssetActor(string pData)
	{
		ActorAsset pAsset = JsonUtility.FromJson<ActorAsset>(pData);
		AssetManager.actor_library.add(pAsset);
	}

	private static void loadAssetBuilding(string pData)
	{
		BuildingAsset pAsset = JsonUtility.FromJson<BuildingAsset>(pData);
		AssetManager.buildings.add(pAsset);
	}

	private static void loadAssetKingdom(string pData)
	{
		KingdomAsset pAsset = JsonUtility.FromJson<KingdomAsset>(pData);
		AssetManager.kingdoms.add(pAsset);
	}

	private static void loadAssetPowers(string pData)
	{
		GodPower pAsset = JsonUtility.FromJson<GodPower>(pData);
		AssetManager.powers.add(pAsset);
	}

	private static void loadAssetTraits(string pData)
	{
		ActorTrait pAsset = JsonUtility.FromJson<ActorTrait>(pData);
		AssetManager.traits.add(pAsset);
	}

	private static void log(string pLog)
	{
		File.AppendAllText(path_log, pLog + "\n");
	}

	private static List<string> getDirectories(string pPath)
	{
		List<string> list = new List<string>();
		string[] directories = Directory.GetDirectories(pPath);
		foreach (string text in directories)
		{
			if (!text.Contains(".meta"))
			{
				list.Add(text);
			}
		}
		return list;
	}

	private static List<string> getFiles(string pPath)
	{
		List<string> list = new List<string>();
		string[] files = Directory.GetFiles(pPath);
		foreach (string text in files)
		{
			if (!text.Contains(".meta"))
			{
				list.Add(text);
			}
		}
		return list;
	}
}
// --- End of File: AssetModLoader.cs ---



// --- Start of File: AssetsDebugManager.cs ---
public class AssetsDebugManager
{
	public static ActorSex actors_sex;

	public static void changeSex()
	{
		if (actors_sex == ActorSex.Female)
		{
			actors_sex = ActorSex.Male;
		}
		else
		{
			actors_sex = ActorSex.Female;
		}
	}

	public static void newKingdomColors()
	{
		foreach (KingdomAsset item in AssetManager.kingdoms.list)
		{
			item.debug_color_asset = AssetManager.kingdom_colors_library.list.GetRandom();
		}
	}

	public static void setRandomKingdomColor(string pKingdomAssetId)
	{
		KingdomAsset kingdomAsset = AssetManager.kingdoms.get(pKingdomAssetId);
		ColorAsset random = AssetManager.kingdom_colors_library.list.GetRandom();
		kingdomAsset.debug_color_asset = random;
	}

	public static void newSkinColors()
	{
		foreach (ActorAsset item in AssetManager.actor_library.list)
		{
			if (item.use_phenotypes)
			{
				setRandomSkinColor(item);
			}
		}
	}

	public static void setRandomSkinColor(ActorAsset pAsset)
	{
		string randomSkinColor = getRandomSkinColor(pAsset);
		pAsset.debug_phenotype_colors = randomSkinColor;
	}

	private static string getRandomSkinColor(ActorAsset pAsset)
	{
		if (pAsset.phenotypes_list == null || pAsset.phenotypes_list.Count == 0)
		{
			return null;
		}
		return pAsset.phenotypes_list.GetRandom();
	}
}
// --- End of File: AssetsDebugManager.cs ---



// --- Start of File: AStarFinder.cs ---
using System;
using System.Collections.Generic;
using C5;

namespace EpPathFinding.cs;

public static class AStarFinder
{
	private static int _last_global_region_id;

	public static bool result_split_path;

	private static IntervalHeap<Node> _open_list = new IntervalHeap<Node>();

	public static void backTracePath(Node pNode, List<WorldTile> pSavePath, bool pEndToStartPath = false)
	{
		pSavePath.Clear();
		pSavePath.Add(pNode.tile);
		while ((object)pNode.parent != null)
		{
			pNode = pNode.parent;
			pSavePath.Add(pNode.tile);
		}
		if (!pEndToStartPath)
		{
			pSavePath.Reverse();
		}
	}

	public static void FindPath(AStarParam pParam, List<WorldTile> pSavePath)
	{
		_open_list.Clear();
		Node node;
		Node node2;
		if (pParam.end_to_start_path)
		{
			node = pParam.EndNode;
			node2 = pParam.StartNode;
		}
		else
		{
			node = pParam.StartNode;
			node2 = pParam.EndNode;
		}
		StaticGrid staticGrid = (StaticGrid)pParam.SearchGrid;
		DiagonalMovement diagonalMovement = pParam.DiagonalMovement;
		float weight = pParam.weight;
		bool boat = pParam.boat;
		node.startToCurNodeLen = 0f;
		node.heuristicStartToEndLen = 0f;
		_open_list.Add(node);
		node.isOpened = true;
		result_split_path = false;
		_last_global_region_id = 0;
		while (((CollectionValueBase<Node>)_open_list).Count != 0 && (pParam.max_open_list == -1 || ((CollectionValueBase<Node>)_open_list).Count <= pParam.max_open_list))
		{
			Node node3 = _open_list.DeleteMin();
			node3.isClosed = true;
			staticGrid.addToClosed(node3);
			if (node3 == node2)
			{
				backTracePath(node2, pSavePath, pParam.end_to_start_path);
				break;
			}
			WorldTile tile = node3.tile;
			if (pParam.use_global_path_lock)
			{
				if (tile.region.region_path_id < _last_global_region_id && tile.region.region_path_id != -1)
				{
					node3.isClosed = true;
					staticGrid.addToClosed(node3);
					continue;
				}
				if (tile.region.region_path_id > _last_global_region_id)
				{
					_last_global_region_id = tile.region.region_path_id;
				}
			}
			WorldTile[] array = ((diagonalMovement == DiagonalMovement.Never) ? tile.neighbours : ((!isObstaclesAround(tile)) ? tile.neighboursAll : tile.neighbours));
			foreach (WorldTile worldTile in array)
			{
				Node node4 = staticGrid.m_nodes[worldTile.x][worldTile.y];
				if (node4.isClosed)
				{
					continue;
				}
				TileTypeBase type = worldTile.Type;
				if (!pParam.block && type.block)
				{
					continue;
				}
				if (pParam.use_global_path_lock)
				{
					if (worldTile.region.region_path_id < _last_global_region_id && worldTile.region.region_path_id != -1)
					{
						node3.isClosed = true;
						staticGrid.addToClosed(node3);
						continue;
					}
					if (worldTile.region.region_path_id > _last_global_region_id)
					{
						_last_global_region_id = worldTile.region.region_path_id;
					}
					if (!worldTile.region.used_by_path_lock)
					{
						node3.isClosed = true;
						staticGrid.addToClosed(node3);
						continue;
					}
				}
				if (boat)
				{
					if (!worldTile.isGoodForBoat())
					{
						continue;
					}
				}
				else
				{
					if (!pParam.lava && type.lava)
					{
						continue;
					}
					if ((!pParam.block || !type.block) && (!pParam.lava || !type.lava))
					{
						if (pParam.ground && pParam.ocean)
						{
							if (!type.ground && !type.ocean)
							{
								continue;
							}
						}
						else if ((pParam.ground && !type.ground) || (pParam.ocean && !type.ocean))
						{
							continue;
						}
					}
				}
				float num = 1f;
				if (pParam.roads && type.road)
				{
					num = 0.01f;
				}
				if (_last_global_region_id >= 4 && staticGrid.closed_list_count > 10)
				{
					result_split_path = true;
					backTracePath(node3, pSavePath, pParam.end_to_start_path);
					return;
				}
				float num2 = node3.startToCurNodeLen + num * ((node4.x - node3.x == 0 || node4.y - node3.y == 0) ? 1f : 1.414f);
				if (node4.isOpened && !(num2 < node4.startToCurNodeLen))
				{
					continue;
				}
				node4.startToCurNodeLen = num2;
				if (!node4.heuristicCurNodeToEndLen.HasValue)
				{
					if (pParam.roads)
					{
						node4.heuristicCurNodeToEndLen = Heuristic.Euclidean(Math.Abs(node4.x - node2.x), Math.Abs(node4.y - node2.y)) * weight;
					}
					else
					{
						node4.heuristicCurNodeToEndLen = (float)(Math.Abs(node4.x - node2.x) + Math.Abs(node4.y - node2.y)) * weight;
					}
				}
				node4.heuristicStartToEndLen = node4.startToCurNodeLen + node4.heuristicCurNodeToEndLen.Value;
				node4.parent = node3;
				if (!node4.isOpened)
				{
					_open_list.Add(node4);
					node4.isOpened = true;
					staticGrid.addToClosed(node4);
				}
			}
		}
	}

	private static bool isObstaclesAround(WorldTile pTile)
	{
		return pTile.hasWallsAround();
	}
}
// --- End of File: AStarFinder.cs ---



// --- Start of File: AStarParam.cs ---
namespace EpPathFinding.cs;

public class AStarParam : ParamBase
{
	internal float weight;

	internal int max_open_list = -1;

	internal bool roads;

	internal bool use_global_path_lock;

	internal bool boat;

	internal bool limit;

	internal bool swamp;

	internal bool ocean;

	internal bool lava;

	internal bool fire;

	internal bool block;

	internal bool ground;

	internal bool end_to_start_path;

	public void resetParam()
	{
		swamp = false;
		roads = false;
		ocean = false;
		lava = false;
		ground = false;
		use_global_path_lock = false;
		boat = false;
		limit = false;
		fire = false;
		end_to_start_path = false;
	}

	internal override void _reset(GridPos iStartPos, GridPos iEndPos, BaseGrid iSearchGrid = null)
	{
	}
}
// --- End of File: AStarParam.cs ---



// --- Start of File: AttackAction.cs ---
using System;

[Serializable]
public delegate bool AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null);
// --- End of File: AttackAction.cs ---



// --- Start of File: AttackData.cs ---
using System;
using UnityEngine;

public readonly struct AttackData
{
	public readonly BaseSimObject initiator;

	public readonly Action kill_action;

	public readonly Kingdom kingdom;

	public readonly WorldTile hit_tile;

	public readonly Vector3 hit_position;

	public readonly Vector3 initiator_position;

	public readonly BaseSimObject target;

	public readonly AttackType attack_type;

	public readonly bool skip_shake;

	public readonly bool metallic_weapon;

	public readonly bool critical;

	public readonly int targets;

	public readonly int critical_damage_multiplier;

	public readonly float area_of_effect;

	public readonly int damage;

	public readonly float damage_range;

	public readonly bool is_projectile;

	public readonly string projectile_id;

	public readonly float knockback;

	public AttackData(BaseSimObject pInitiator, WorldTile pHitTile, Vector3 pHitPosition, Vector3 pInitiatorPosition, BaseSimObject pTarget, Kingdom pKingdom, AttackType pAttackType = AttackType.Other, bool pMetallicWeapon = false, bool pSkipShake = true, bool pProjectile = false, string pProjectileID = "", Action pKillAction = null, float pBonusAreOfEffect = 0f)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		float num = 0f;
		int num2 = 1;
		float num3 = 0.1f;
		int num4 = 1;
		float num5 = 1f;
		float num6 = 1f;
		if (pInitiator != null)
		{
			flag = Randy.randomChance(pInitiator.stats["critical_chance"]);
			num = pInitiator.stats["knockback"];
			num2 = (int)pInitiator.stats["targets"];
			num3 = pInitiator.stats["area_of_effect"];
			num4 = (int)pInitiator.stats["damage"];
			num5 = pInitiator.stats["damage_range"];
			num6 = pInitiator.stats["critical_damage_multiplier"];
		}
		num3 += pBonusAreOfEffect;
		kill_action = pKillAction;
		initiator = pInitiator;
		kingdom = pKingdom;
		hit_tile = pHitTile;
		initiator_position = pInitiatorPosition;
		hit_position = pHitPosition;
		target = pTarget;
		attack_type = pAttackType;
		metallic_weapon = pMetallicWeapon;
		skip_shake = pSkipShake;
		is_projectile = pProjectile;
		projectile_id = pProjectileID;
		targets = num2;
		critical = flag;
		knockback = num;
		area_of_effect = num3;
		damage = num4;
		damage_range = num5;
		critical_damage_multiplier = (int)num6;
	}
}
// --- End of File: AttackData.cs ---



// --- Start of File: AttackDataResult.cs ---
public struct AttackDataResult
{
	public long deflected_by_who_id;

	public ApplyAttackState state;

	public static AttackDataResult Continue => new AttackDataResult(ApplyAttackState.Continue, -1L);

	public static AttackDataResult Miss => new AttackDataResult(ApplyAttackState.Miss, -1L);

	public static AttackDataResult Hit => new AttackDataResult(ApplyAttackState.Hit, -1L);

	public static AttackDataResult Block => new AttackDataResult(ApplyAttackState.Block, -1L);

	public AttackDataResult(ApplyAttackState pState, long pDeflectedByWhoId = -1L)
	{
		state = pState;
		deflected_by_who_id = pDeflectedByWhoId;
	}
}
// --- End of File: AttackDataResult.cs ---



// --- Start of File: AttackType.cs ---
public enum AttackType
{
	Acid,
	Fire,
	Plague,
	Infection,
	Tumor,
	Other,
	Divine,
	AshFever,
	Metamorphosis,
	Starvation,
	Eaten,
	Age,
	Weapon,
	None,
	Poison,
	Gravity,
	Drowning,
	Water,
	Explosion,
	Smile
}
// --- End of File: AttackType.cs ---



// --- Start of File: AugmentationButton.cs ---
using System;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class AugmentationButton<TAugmentation> : MonoBehaviour where TAugmentation : BaseAugmentationAsset
{
	[NonSerialized]
	public TAugmentation augmentation_asset;

	internal Image image;

	internal Image locked_bg;

	private IconOutline _outline;

	private Shadow _shadow;

	private bool _tooltip_enabled = true;

	internal Button button;

	internal bool is_editor_button;

	private AugmentationUnlockedAction _on_augmentation_unlocked;

	private AugmentationButtonClickAction _on_button_clicked;

	protected bool created;

	private bool _selected;

	protected virtual string tooltip_type
	{
		get
		{
			throw new NotImplementedException(((object)this).GetType().Name);
		}
	}

	public bool isSelected()
	{
		return _selected;
	}

	protected virtual void Awake()
	{
		create();
		DraggableLayoutElement draggableLayoutElement = default(DraggableLayoutElement);
		if (((Component)this).TryGetComponent<DraggableLayoutElement>(ref draggableLayoutElement))
		{
			DraggableLayoutElement draggableLayoutElement2 = draggableLayoutElement;
			draggableLayoutElement2.start_being_dragged = (Action<DraggableLayoutElement>)Delegate.Combine(draggableLayoutElement2.start_being_dragged, new Action<DraggableLayoutElement>(onStartDrag));
		}
	}

	protected virtual void onStartDrag(DraggableLayoutElement pOriginalElement)
	{
		AugmentationButton<TAugmentation> component = ((Component)pOriginalElement).GetComponent<AugmentationButton<TAugmentation>>();
		load(component.augmentation_asset);
		is_editor_button = component.is_editor_button;
	}

	protected virtual void create()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		if (!created)
		{
			created = true;
			button = ((Component)this).GetComponent<Button>();
			image = ((Component)((Component)this).transform.Find("TiltEffect/icon")).GetComponent<Image>();
			locked_bg = ((Component)((Component)this).transform.Find("TiltEffect/locked_bg")).GetComponent<Image>();
			((Component)locked_bg).gameObject.SetActive(false);
			initTooltip();
			Transform obj = ((Component)this).transform.FindRecursive("outline");
			_outline = ((obj != null) ? ((Component)obj).GetComponent<IconOutline>() : null);
			_shadow = ((Component)image).GetComponent<Shadow>();
			((UnityEvent)button.onClick).AddListener((UnityAction)delegate
			{
				_on_button_clicked?.Invoke(((Component)this).gameObject);
			});
		}
	}

	public virtual void load(TAugmentation pElement)
	{
		throw new NotImplementedException();
	}

	protected virtual void initTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			tipButton.setHoverAction(showTooltip);
		}
	}

	protected virtual void Update()
	{
		throw new NotImplementedException();
	}

	protected void loadLegendaryOutline()
	{
		((Behaviour)_shadow).enabled = true;
		if (!((Object)(object)_outline == (Object)null))
		{
			if (getRarity() == Rarity.R3_Legendary)
			{
				showOutline(RarityLibrary.legendary.color_container);
			}
			else
			{
				((Component)_outline).gameObject.SetActive(false);
			}
		}
	}

	private void showOutline(ContainerItemColor pContainer)
	{
		if (!((Object)(object)_outline == (Object)null))
		{
			_outline.show(pContainer);
			((Behaviour)_shadow).enabled = false;
		}
	}

	public void showTooltip()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (_tooltip_enabled)
		{
			if (!is_editor_button && !augmentation_asset.unlocked_with_achievement && !isElementUnlocked() && !WorldLawLibrary.world_law_cursed_world.isEnabled() && unlockElement())
			{
				startSignal();
				_on_augmentation_unlocked?.Invoke();
			}
			if (!is_editor_button || InputHelpers.mouseSupported || !Tooltip.isShowingFor(this))
			{
				fillTooltipData(augmentation_asset);
			}
			((Component)this).transform.localScale = new Vector3(1f, 1f, 1f);
			ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
			TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(((Component)this).transform, 0.8f, 0.1f), (Ease)26);
		}
	}

	public void addElementUnlockedAction(AugmentationUnlockedAction pAction)
	{
		_on_augmentation_unlocked = (AugmentationUnlockedAction)Delegate.Combine(_on_augmentation_unlocked, pAction);
	}

	public void removeElementUnlockedAction(AugmentationUnlockedAction pAction)
	{
		_on_augmentation_unlocked = (AugmentationUnlockedAction)Delegate.Remove(_on_augmentation_unlocked, pAction);
	}

	protected virtual void clearActions()
	{
		_on_augmentation_unlocked = null;
		clearClickActions();
	}

	public virtual void updateIconColor(bool pSelected)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		_selected = pSelected;
		if (is_editor_button)
		{
			if (!getElementAsset().isAvailable())
			{
				((Graphic)image).color = Toolbox.color_black;
			}
			else if (pSelected)
			{
				((Graphic)image).color = Toolbox.color_augmentation_selected;
			}
			else
			{
				((Graphic)image).color = Toolbox.color_augmentation_unselected;
			}
		}
	}

	public TAugmentation getElementAsset()
	{
		return augmentation_asset;
	}

	protected bool isElementUnlocked()
	{
		return augmentation_asset.isAvailable();
	}

	protected virtual bool unlockElement()
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	protected virtual void startSignal()
	{
	}

	protected virtual void fillTooltipData(TAugmentation pElement)
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	protected virtual TooltipData tooltipDataBuilder()
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	protected virtual string getElementType()
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	public virtual string getElementId()
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	protected virtual Rarity getRarity()
	{
		throw new NotImplementedException(((object)this).GetType().Name);
	}

	protected virtual void disableTooltip()
	{
		_tooltip_enabled = false;
	}

	public void addClickAction(AugmentationButtonClickAction pAction)
	{
		_on_button_clicked = (AugmentationButtonClickAction)Delegate.Combine(_on_button_clicked, pAction);
	}

	public void removeClickAction(AugmentationButtonClickAction pAction)
	{
		_on_button_clicked = (AugmentationButtonClickAction)Delegate.Remove(_on_button_clicked, pAction);
	}

	private void clearClickActions()
	{
		_on_button_clicked = null;
	}

	private void OnDestroy()
	{
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
	}
}
// --- End of File: AugmentationButton.cs ---



// --- Start of File: AugmentationButtonClickAction.cs ---
using UnityEngine;

public delegate void AugmentationButtonClickAction(GameObject pTraitButton);
// --- End of File: AugmentationButtonClickAction.cs ---



// --- Start of File: AugmentationCategory.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AugmentationCategory<TAugmentation, TAugmentationButton, TAugmentationEditorButton> : MonoBehaviour where TAugmentation : BaseAugmentationAsset where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentationEditorButton : AugmentationEditorButton<TAugmentationButton, TAugmentation>
{
	public Text title;

	public Text counter;

	public RectTransform height;

	public Transform augmentation_buttons_transform;

	public BaseCategoryAsset asset;

	public List<TAugmentationEditorButton> augmentation_buttons = new List<TAugmentationEditorButton>();

	public void clearDebug()
	{
		for (int i = 0; i < augmentation_buttons_transform.childCount; i++)
		{
			Object.Destroy((Object)(object)((Component)augmentation_buttons_transform.GetChild(i)).gameObject);
		}
	}

	public void hideCounter()
	{
		counter.text = "";
		((Component)counter).gameObject.SetActive(false);
	}

	public void updateCounter()
	{
		int num = 0;
		foreach (TAugmentationEditorButton augmentation_button in augmentation_buttons)
		{
			if (augmentation_button.augmentation_button.isSelected())
			{
				num++;
			}
		}
		string arg = augmentation_buttons.Count.ToString();
		counter.text = $"{num}/{arg}";
	}

	protected virtual bool isUnlocked(TAugmentationButton pButton)
	{
		throw new NotImplementedException();
	}

	private void LateUpdate()
	{
		updateValues();
	}

	private void updateValues()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector2 sizeDelta = height.sizeDelta;
		sizeDelta.y = ((Component)augmentation_buttons_transform).GetComponent<RectTransform>().sizeDelta.y + 15f;
		height.sizeDelta = sizeDelta;
	}

	public int countActiveButtons()
	{
		int num = 0;
		foreach (TAugmentationEditorButton augmentation_button in augmentation_buttons)
		{
			if (((Component)augmentation_button).gameObject.activeSelf)
			{
				num++;
			}
		}
		return num;
	}

	public bool hasAugmentation(TAugmentation pTrait)
	{
		foreach (TAugmentationEditorButton augmentation_button in augmentation_buttons)
		{
			if (augmentation_button.augmentation_button.getElementAsset() == pTrait)
			{
				return true;
			}
		}
		return false;
	}
}
// --- End of File: AugmentationCategory.cs ---



// --- Start of File: AugmentationEditorButton.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AugmentationEditorButton<TAugmentationButton, TAugmentation> : MonoBehaviour where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentation : BaseAugmentationAsset
{
	public TAugmentationButton augmentation_button;

	public Image selected_icon;
}
// --- End of File: AugmentationEditorButton.cs ---



// --- Start of File: AugmentationsEditor.cs ---
using System;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using UnityEngine.UI;

public class AugmentationsEditor<TAugmentation, TAugmentationButton, TAugmentationEditorButton, TAugmentationGroupAsset, TAugmentationGroup, TAugmentationWindow, TEditorInterface> : BaseAugmentationsEditor where TAugmentation : BaseAugmentationAsset where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentationEditorButton : AugmentationEditorButton<TAugmentationButton, TAugmentation> where TAugmentationGroupAsset : BaseCategoryAsset where TAugmentationGroup : AugmentationCategory<TAugmentation, TAugmentationButton, TAugmentationEditorButton> where TAugmentationWindow : IAugmentationsWindow<TEditorInterface> where TEditorInterface : IAugmentationsEditor
{
	private const float FOCUS_SCROLL_OFFSET_TOP = -5f;

	private const float FOCUS_SCROLL_OFFSET_BOTTOM = 1f;

	public const float FOCUS_SCROLL_DURATION = 0.3f;

	[SerializeField]
	protected Image art;

	public TAugmentationButton prefab_augmentation;

	public TAugmentationEditorButton prefab_editor_augmentation;

	public TAugmentationGroup prefab_augmentation_group;

	protected readonly Dictionary<string, TAugmentationGroup> dict_groups = new Dictionary<string, TAugmentationGroup>();

	protected readonly List<TAugmentationEditorButton> all_augmentation_buttons = new List<TAugmentationEditorButton>();

	protected TAugmentationWindow augmentation_window;

	protected ObjectPoolGenericMono<TAugmentationButton> selected_editor_buttons;

	[SerializeField]
	private WindowMetaTab _editor_tab;

	protected virtual List<TAugmentationGroupAsset> augmentation_groups_list
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	protected virtual List<TAugmentation> all_augmentations_list
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	protected virtual TAugmentation edited_marker_augmentation => null;

	protected override void create()
	{
		base.create();
		augmentation_window = ((Component)this).GetComponentInParent<TAugmentationWindow>();
		if (rain_editor)
		{
			selected_editor_buttons = new ObjectPoolGenericMono<TAugmentationButton>(prefab_augmentation, ((Component)selected_editor_augmentations_grid).transform);
		}
	}

	protected override void OnEnable()
	{
		if (rain_editor)
		{
			onEnableRain();
		}
		base.OnEnable();
	}

	protected virtual ListPool<TAugmentation> getOrderedAugmentationsList()
	{
		ListPool<TAugmentation> listPool = new ListPool<TAugmentation>(all_augmentations_list);
		listPool.Sort(delegate(TAugmentation pT1, TAugmentation pT2)
		{
			int num = pT2.priority.CompareTo(pT1.priority);
			if (num == 0)
			{
				num = StringComparer.Ordinal.Compare(pT1.id, pT2.id);
			}
			return num;
		});
		return listPool;
	}

	public override void reloadButtons()
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		base.reloadButtons();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		foreach (TAugmentationEditorButton all_augmentation_button in all_augmentation_buttons)
		{
			bool num4 = isAugmentationAvailable(all_augmentation_button.augmentation_button);
			TAugmentation elementAsset = all_augmentation_button.augmentation_button.getElementAsset();
			num3++;
			if (num4)
			{
				num2++;
			}
			((Component)all_augmentation_button.selected_icon).gameObject.SetActive(false);
			if (num4)
			{
				((Graphic)all_augmentation_button.augmentation_button.image).color = Toolbox.color_augmentation_unselected;
			}
			bool can_be_given = elementAsset.can_be_given;
			bool pSelected = false;
			if (!can_be_given)
			{
				bool flag = !rain_editor && hasAugmentation(all_augmentation_button.augmentation_button);
				((Component)all_augmentation_button.selected_icon).gameObject.SetActive(flag);
				((Graphic)all_augmentation_button.selected_icon).color = Toolbox.color_log_warning;
				if (flag)
				{
					num++;
					pSelected = true;
				}
			}
			else if (rain_editor && augmentations_hashset.Contains(all_augmentation_button.augmentation_button.getElementId()))
			{
				Color color = ((rain_editor_state != 0) ? ColorStyleLibrary.m.getSelectorRemoveColor() : ColorStyleLibrary.m.getSelectorColor());
				((Component)all_augmentation_button.selected_icon).gameObject.SetActive(true);
				((Graphic)all_augmentation_button.selected_icon).color = color;
				pSelected = true;
			}
			else if (!rain_editor && hasAugmentation(all_augmentation_button.augmentation_button))
			{
				((Component)all_augmentation_button.selected_icon).gameObject.SetActive(true);
				((Graphic)all_augmentation_button.selected_icon).color = ColorStyleLibrary.m.getSelectorColor();
				pSelected = true;
				num++;
			}
			all_augmentation_button.augmentation_button.updateIconColor(pSelected);
		}
		foreach (TAugmentationGroup value in dict_groups.Values)
		{
			if (value.asset.show_counter)
			{
				value.updateCounter();
			}
			else
			{
				value.hideCounter();
			}
		}
		if (rain_editor)
		{
			text_counter_augmentations.text = num2 + "/" + num3;
		}
		else
		{
			text_counter_augmentations.text = num + "/" + num3;
		}
		startSignal();
	}

	protected override void groupsBuilder()
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		using ListPool<TAugmentation> listPool = getOrderedAugmentationsList();
		foreach (TAugmentationGroupAsset item in augmentation_groups_list)
		{
			TAugmentationGroup val = Object.Instantiate<TAugmentationGroup>(prefab_augmentation_group, augmentation_groups_parent);
			val.asset = item;
			val.clearDebug();
			dict_groups.Add(item.id, val);
			((Component)val.title).GetComponent<LocalizedText>().setKeyAndUpdate(item.getLocaleID());
			((Graphic)val.title).color = item.getColor();
		}
		foreach (ref TAugmentation item2 in listPool)
		{
			TAugmentation current2 = item2;
			TAugmentationGroup pGroup = dict_groups[current2.group_id];
			createButton(current2, pGroup);
		}
	}

	protected override void checkEnabledGroups()
	{
		foreach (TAugmentationGroup value in dict_groups.Values)
		{
			bool active = value.countActiveButtons() > 0;
			((Component)value).gameObject.SetActive(active);
		}
	}

	protected void editorButtonClick(TAugmentationEditorButton pButton)
	{
		if (!InputHelpers.mouseSupported && !Tooltip.isShowingFor(pButton.augmentation_button))
		{
			return;
		}
		if (!Config.hasPremium)
		{
			ScrollWindow.showWindow("premium_menu");
		}
		else if (pButton.augmentation_button.getElementAsset().can_be_given)
		{
			if (rain_editor)
			{
				rainAugmentationClick(pButton);
			}
			else
			{
				metaAugmentationClick(pButton);
			}
			reloadButtons();
		}
	}

	protected virtual void metaAugmentationClick(TAugmentationEditorButton pButton)
	{
		showActiveButtons();
		refreshAugmentationWindow();
	}

	protected virtual void rainAugmentationClick(TAugmentationEditorButton pButton)
	{
		saveRainValues();
		loadEditorSelectedAugmentations();
	}

	protected virtual void validateRainData()
	{
		augmentations_list_link.RemoveAll(delegate(string tId)
		{
			TAugmentation val = all_augmentations_list.Find((TAugmentation tAugmentation) => tAugmentation.id == tId);
			if (val == null)
			{
				return true;
			}
			return !val.isAvailable();
		});
	}

	protected virtual void refreshAugmentationWindow()
	{
		augmentation_window.updateStats();
		augmentation_window.reloadBanner();
	}

	protected void saveRainValues()
	{
		augmentations_list_link.Clear();
		foreach (string item in augmentations_hashset)
		{
			augmentations_list_link.Add(item);
		}
		PlayerConfig.saveData();
	}

	protected virtual void loadEditorSelectedAugmentations()
	{
		selected_editor_buttons.clear();
		foreach (string item in augmentations_hashset)
		{
			if (isAugmentationExists(item))
			{
				TAugmentationButton next = selected_editor_buttons.getNext();
				loadEditorSelectedButton(next, item);
			}
		}
	}

	public void scrollToGroupStarter(GameObject pButton)
	{
		scrollToGroupStarter(pButton, pIgnoreTooltipCheck: false);
	}

	public virtual void scrollToGroupStarter(GameObject pButton, bool pIgnoreTooltipCheck)
	{
		if (!pIgnoreTooltipCheck && !InputHelpers.mouseSupported && !Tooltip.isShowingFor(pButton.GetComponent<TAugmentationButton>()))
		{
			return;
		}
		bool pWithDelay = false;
		if (!((Component)this).gameObject.activeInHierarchy)
		{
			if (!((Object)(object)_editor_tab != (Object)null))
			{
				return;
			}
			_editor_tab.container.showTab(_editor_tab);
			pWithDelay = true;
		}
		((MonoBehaviour)this).StartCoroutine(scrollToGroupStarterRoutine(pButton, pWithDelay));
	}

	private IEnumerator scrollToGroupStarterRoutine(GameObject pButton, bool pWithDelay)
	{
		if (pWithDelay)
		{
			yield return (object)new WaitForSeconds(Config.getScrollToGroupDelay());
		}
		scrollToGroup(pButton);
	}

	private void scrollToGroup(GameObject pButton, float pDuration = 0.3f)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		TAugmentationGroup val = null;
		foreach (TAugmentationGroup value in dict_groups.Values)
		{
			TAugmentationButton component = pButton.GetComponent<TAugmentationButton>();
			if (value.hasAugmentation(component.getElementAsset()))
			{
				val = value;
				break;
			}
		}
		if ((Object)(object)val == (Object)null)
		{
			return;
		}
		Transform transform = ((Component)pButton.GetComponentInParent<HeaderContainer>()).transform;
		Transform obj = ((transform is RectTransform) ? transform : null);
		RectTransform component2 = ((Component)((Component)this).transform.parent).GetComponent<RectTransform>();
		RectTransform component3 = ((Component)((Transform)component2).parent).GetComponent<RectTransform>();
		Transform transform2 = ((Component)this).transform;
		RectTransform val2 = (RectTransform)(object)((transform2 is RectTransform) ? transform2 : null);
		RectTransform component4 = ((Component)val).GetComponent<RectTransform>();
		Rect rect = component3.rect;
		float height = ((Rect)(ref rect)).height;
		rect = ((RectTransform)obj).rect;
		float height2 = ((Rect)(ref rect)).height;
		rect = component2.rect;
		float height3 = ((Rect)(ref rect)).height;
		rect = val2.rect;
		float height4 = ((Rect)(ref rect)).height;
		rect = component4.rect;
		float height5 = ((Rect)(ref rect)).height;
		float num = Mathf.Abs(val2.anchoredPosition.y) - height4 * (1f - val2.pivot.y) - height2;
		float num2 = Mathf.Abs(component4.anchoredPosition.y) - height5 * (1f - component4.pivot.y) + num;
		float num3 = num2 + height5;
		bool flag = num2 < ((Transform)component2).localPosition.y;
		bool flag2 = num3 > ((Transform)component2).localPosition.y + height - height2;
		if (flag || flag2)
		{
			float num4;
			if (flag)
			{
				num4 = num2;
				num4 -= -5f;
			}
			else
			{
				num4 = num3 - height + height2;
				num4 += 1f;
			}
			num4 = Mathf.Clamp(num4, 0f, height3 - height);
			ShortcutExtensions.DOLocalMoveY((Transform)(object)component2, num4, pDuration, false);
		}
	}

	protected virtual bool isAugmentationExists(string pId)
	{
		throw new NotImplementedException();
	}

	protected virtual void loadEditorSelectedButton(TAugmentationButton pButton, string pAugmentationId)
	{
		pButton.removeClickAction(scrollToGroupStarter);
		pButton.addClickAction(scrollToGroupStarter);
	}

	protected virtual void createButton(TAugmentation pElement, TAugmentationGroup pGroup)
	{
		throw new NotImplementedException();
	}

	protected virtual bool hasAugmentation(TAugmentationButton pButton)
	{
		throw new NotImplementedException();
	}

	protected virtual bool addAugmentation(TAugmentationButton pButton)
	{
		throw new NotImplementedException();
	}

	protected virtual bool removeAugmentation(TAugmentationButton pButton)
	{
		throw new NotImplementedException();
	}

	public WindowMetaTab getEditorTab()
	{
		return _editor_tab;
	}

	protected bool isAugmentationAvailable(TAugmentationButton pButton)
	{
		return pButton.getElementAsset().isAvailable();
	}
}
// --- End of File: AugmentationsEditor.cs ---



// --- Start of File: AugmentationUnlockedAction.cs ---
public delegate void AugmentationUnlockedAction();
// --- End of File: AugmentationUnlockedAction.cs ---



// --- Start of File: Auth.cs ---
using System;
using RSG;

public static class Auth
{
	public static UserLoginWindow userLoginWindow;

	public static bool isLoggedIn = false;

	public static string userId;

	public static string userName;

	public static string displayName;

	public static string emailAddress;

	private static bool initialized = false;

	public static bool authLoaded = false;

	public static Promise authLoadedPromise = new Promise();

	public static void initializeAuth()
	{
		if (!initialized)
		{
			initialized = true;
		}
	}

	public static void AuthStateChanged(object sender, EventArgs eventArgs)
	{
	}

	public static void signOut()
	{
	}

	public static bool isValidUsername(string username)
	{
		return false;
	}

	public static bool isValidEmail(string email)
	{
		return false;
	}
}
// --- End of File: Auth.cs ---



// --- Start of File: AuthButton.cs ---
using System.Collections.Generic;
using UnityEngine;

public class AuthButton : MonoBehaviour
{
	private static string windowId;

	private static List<string> worldnetNoSub = new List<string> { "worldnet_main" };

	private void Awake()
	{
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void showWorldNetOwnWorldsWindow()
	{
	}

	public void showWorldNetWorldsListWindow()
	{
	}

	public void showWorldNetMainWindow()
	{
	}

	public void showWorldNetUploadWindow()
	{
	}

	public void showBrowseByTagWindow()
	{
	}

	public void wbbConfirm()
	{
	}

	public void uploadWorldButton()
	{
	}

	public void checkAuthAndOpenWindow()
	{
	}
}
// --- End of File: AuthButton.cs ---



// --- Start of File: AuthorButton.cs ---
using UnityEngine;

public class AuthorButton : MonoBehaviour
{
	public string authorId;

	private void Awake()
	{
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void showWorldNetAuthorListWindow()
	{
	}
}
// --- End of File: AuthorButton.cs ---



// --- Start of File: AutoCivilization.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using ai.behaviours;

public class AutoCivilization
{
	private const int KIDS_AGE = 5;

	private const float KIDS_PERCENT = 0.5f;

	private const int EGGS_AGE = 0;

	private const float EGGS_PERCENT_OF_KIDS = 0.5f;

	private const float WARRIORS_PERCENT_OF_ADULTS = 0.1f;

	private const float ITEMS_HOLDER_PERCENT = 0.6f;

	private const int TICKS_WITHOUT_BUILDING_TO_STOP = 100;

	private const int MAXIMUM_TICKS = 5000;

	private const int UNITS_AMOUNT = 100;

	private const float ELAPSED_PER_TICK = 1.5f;

	private const int ITEM_PRODUCTION_PER_UNIT = 5;

	private const int MAXIMUM_TASK_ACTIONS = 500;

	private const int FRAMES_PER_ROUTINE_UPDATE = 4;

	private List<BehaviourTaskActor> _tasks_building = new List<BehaviourTaskActor>();

	private List<BehaviourTaskActor> _tasks_gathering = new List<BehaviourTaskActor>();

	private List<BehaviourTaskActor> _tasks_farming = new List<BehaviourTaskActor>();

	private BehaviourTaskActor _task_take_items;

	private City _city;

	private Actor _unit;

	private List<Actor> _units_list = new List<Actor>(100);

	private BuildingBiomeFoodProducer _food_producer_bonfire;

	private BuildingBiomeFoodProducer _food_producer_hall;

	private Coroutine _routine;

	private int _action_index;

	public AutoCivilization()
	{
		_tasks_building.Add(AssetManager.tasks_actor.get("try_build_building"));
		_tasks_building.Add(AssetManager.tasks_actor.get("build_building"));
		_tasks_building.Add(AssetManager.tasks_actor.get("build_road"));
		_tasks_building.Add(AssetManager.tasks_actor.get("cleaning"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("chop_trees"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("mine_deposit"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("mine"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("collect_fruits"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("collect_herbs"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("collect_honey"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("manure_cleaning"));
		_tasks_gathering.Add(AssetManager.tasks_actor.get("store_resources"));
		_tasks_farming.Add(AssetManager.tasks_actor.get("farmer_make_field"));
		_tasks_farming.Add(AssetManager.tasks_actor.get("farmer_plant_crops"));
		_tasks_farming.Add(AssetManager.tasks_actor.get("farmer_harvest"));
		_tasks_farming.Add(AssetManager.tasks_actor.get("farmer_fertilize_crops"));
		_task_take_items = AssetManager.tasks_actor.get("try_to_take_city_item");
	}

	public void makeCivilization(Actor pUnit)
	{
		if (!pUnit.isSapient())
		{
			return;
		}
		_unit = pUnit;
		clear();
		if (_unit.buildCityAndStartCivilization())
		{
			Religion religion = World.world.religions.newReligion(_unit, pAddDefaultTraits: true);
			_unit.setReligion(religion);
			_city = _unit.current_tile.zone.city;
			_unit.setCity(_city);
			_unit.createNewWeapon("flame_sword");
			_unit.kingdom.setCapital(_city);
			_units_list.Add(_unit);
			Actor pActor = newUnit(_unit.culture, _unit.language);
			_city.setLeader(pActor, pNew: true);
			spawnUnits(_unit.culture, _unit.language);
			for (int i = 0; i < 50; i++)
			{
				makeBooks(_unit);
			}
			_routine = ((MonoBehaviour)World.world).StartCoroutine(civilizationMakingRoutine());
		}
	}

	private void makeBooks(Actor pActor)
	{
		if (pActor.hasLanguage() && pActor.hasCulture())
		{
			World.world.books.generateNewBook(pActor);
		}
	}

	private Actor newUnit(Culture pCulture, Language pLanguage)
	{
		Actor actor = World.world.units.spawnNewUnit(_unit.asset.id, _city.zones.GetRandom().centerTile, pSpawnSound: true, pMiracleSpawn: true, 3f);
		actor.setCity(_city);
		actor.setSubspecies(_unit.subspecies);
		actor.setCulture(pCulture);
		actor.joinLanguage(pLanguage);
		_units_list.Add(actor);
		return actor;
	}

	private void spawnUnits(Culture pCulture, Language pLanguage)
	{
		for (int i = 0; i < 99; i++)
		{
			newUnit(pCulture, pLanguage).data.age_overgrowth = Randy.randomInt(0, 100);
		}
	}

	private IEnumerator civilizationMakingRoutine()
	{
		int tNoBuiltTicks = 0;
		for (int i = 0; i < 5000; i++)
		{
			Actor random = _units_list.GetRandom();
			claimZone(random);
			gatherResources(random);
			bool flag = buildBuilding(random);
			doFarming(random);
			makeFood(random);
			refertilizeTiles(random.current_zone);
			if (!flag)
			{
				randomTeleport(random);
				tNoBuiltTicks++;
			}
			else
			{
				tNoBuiltTicks = 0;
			}
			if (tNoBuiltTicks > 100)
			{
				break;
			}
			if (i % 4 == 0)
			{
				yield return (object)new WaitForEndOfFrame();
			}
		}
		foreach (Actor item in _units_list)
		{
			craftAndTakeItems(item);
			item.setTask("citizen");
			item.setStatsDirty();
		}
	}

	private void claimZone(Actor pUnit)
	{
		TileZone zoneToClaim = MapBox.instance.city_zone_helper.city_growth.getZoneToClaim(null, _city);
		if (zoneToClaim != null)
		{
			pUnit.setCurrentTilePosition(zoneToClaim.centerTile);
			BehClaimZoneForCityActorBorder.tryClaimZone(pUnit);
		}
	}

	private void gatherResources(Actor pUnit)
	{
		foreach (BehaviourTaskActor item in _tasks_gathering)
		{
			doTask(item, pUnit);
		}
		_city.addResourcesToRandomStockpile("wood", 8);
		_city.addResourcesToRandomStockpile("stone", 8);
		_city.addResourcesToRandomStockpile("common_metals", 4);
		_city.addResourcesToRandomStockpile("gold", 2);
		_city.addResourcesToRandomStockpile("fertilizer");
	}

	private bool buildBuilding(Actor pActor)
	{
		bool result = CityBehBuild.buildTick(_city);
		foreach (BehaviourTaskActor item in _tasks_building)
		{
			doTask(item, pActor);
		}
		World.world.cities.setDirtyBuildings(_city);
		World.world.cities.beginChecksBuildings();
		BuildingZonesSystem.setDirty();
		BuildingZonesSystem.update();
		return result;
	}

	private void doFarming(Actor pUnit)
	{
		foreach (BehaviourTaskActor item in _tasks_farming)
		{
			doTask(item, pUnit);
		}
		foreach (WorldTile calculated_farm_field in _city.calculated_farm_fields)
		{
			Building building = calculated_farm_field.building;
			if (building != null && building.asset.wheat)
			{
				building.component_wheat.update(1.5f);
			}
		}
	}

	private void makeFood(Actor pUnit)
	{
		if (_food_producer_bonfire == null)
		{
			_food_producer_bonfire = _city.getBuildingOfType("type_bonfire")?.component_food_producer;
		}
		if (_food_producer_hall == null)
		{
			_food_producer_hall = _city.getBuildingOfType("type_hall")?.component_food_producer;
		}
		_food_producer_bonfire?.update(1.5f);
		_food_producer_hall?.update(1.5f);
	}

	private void refertilizeTiles(TileZone pTileZone)
	{
		WorldTile[] tiles = pTileZone.tiles;
		foreach (WorldTile pTile in tiles)
		{
			if (Randy.randomChance(0.05f))
			{
				DropsLibrary.action_fertilizer_trees(pTile);
			}
			if (Randy.randomChance(0.05f))
			{
				DropsLibrary.action_fertilizer_plants(pTile);
			}
		}
	}

	private void randomTeleport(Actor pUnit)
	{
		pUnit.setCurrentTilePosition(_city.zones.GetRandom().centerTile);
	}

	private void craftAndTakeItems(Actor pUnit)
	{
		if (Randy.randomChance(0.6f))
		{
			for (int i = 0; i < 5; i++)
			{
				ItemCrafting.tryToCraftRandomArmor(pUnit, _city);
				ItemCrafting.tryToCraftRandomWeapon(pUnit, _city);
			}
			doTask(_task_take_items, pUnit);
		}
	}

	private void doTask(BehaviourTaskActor pTask, Actor pActor)
	{
		_action_index = 0;
		for (int i = 0; i < 500; i++)
		{
			BehResult pResult = pTask.list[_action_index].startExecute(pActor);
			if (!updateTaskIndex(pResult) || _action_index > pTask.list.Count - 1)
			{
				break;
			}
		}
	}

	private bool updateTaskIndex(BehResult pResult)
	{
		switch (pResult)
		{
		case BehResult.Continue:
			_action_index++;
			break;
		case BehResult.StepBack:
			_action_index--;
			if (_action_index < 0)
			{
				_action_index = 0;
			}
			break;
		case BehResult.Stop:
		case BehResult.Skip:
		case BehResult.RestartTask:
		case BehResult.ActiveTaskReturn:
		case BehResult.ImmediateRun:
			return false;
		}
		return true;
	}

	private void clear()
	{
		if (_routine != null)
		{
			((MonoBehaviour)World.world).StopCoroutine(_routine);
		}
		_action_index = 0;
		_food_producer_bonfire = null;
		_food_producer_hall = null;
		_units_list.Clear();
	}
}
// --- End of File: AutoCivilization.cs ---



// --- Start of File: AutoSaveData.cs ---
public class AutoSaveData
{
	public string name;

	public string path;

	public double timestamp;
}
// --- End of File: AutoSaveData.cs ---



// --- Start of File: AutoSaveElement.cs ---
using System;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using Humanizer;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.UI;

public class AutoSaveElement : MonoBehaviour, IPointerMoveHandler, IEventSystemHandler
{
	[Serializable]
	[CompilerGenerated]
	private sealed class _003C_003Ec
	{
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();

		public static UnityAction _003C_003E9__12_0;

		internal void _003CAwake_003Eb__12_0()
		{
			if (InputHelpers.mouseSupported)
			{
				Tooltip.hideTooltip();
			}
		}
	}

	[SerializeField]
	private Image _preview;

	[SerializeField]
	private Text _save_name;

	[SerializeField]
	private Text _save_time_ago;

	[SerializeField]
	private CountUpOnClick _kingdoms;

	[SerializeField]
	private CountUpOnClick _cities;

	[SerializeField]
	private CountUpOnClick _population;

	[SerializeField]
	private CountUpOnClick _mobs;

	[SerializeField]
	private CountUpOnClick _age;

	[SerializeField]
	private Button _button;

	[SerializeField]
	private GameObject _premium_icon;

	private string _world_path;

	private MapMetaData _meta_data;

	private void Awake()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Expected O, but got Unknown
		Button button = _button;
		object obj = _003C_003Ec._003C_003E9__12_0;
		if (obj == null)
		{
			UnityAction val = delegate
			{
				if (InputHelpers.mouseSupported)
				{
					Tooltip.hideTooltip();
				}
			};
			_003C_003Ec._003C_003E9__12_0 = val;
			obj = (object)val;
		}
		button.OnHoverOut((UnityAction)obj);
	}

	public void OnPointerMove(PointerEventData pData)
	{
		if (InputHelpers.mouseSupported && !Tooltip.anyActive())
		{
			tooltipAction();
		}
	}

	private void tooltipAction()
	{
		if (_meta_data != null && Config.tooltips_active)
		{
			_meta_data.temp_date_string = SaveManager.getMapCreationTime(_world_path);
			Tooltip.show(_button, "map_meta", new TooltipData
			{
				map_meta = _meta_data
			});
		}
	}

	public void load(AutoSaveData pData)
	{
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Expected O, but got Unknown
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		_world_path = pData.path;
		string text = SaveManager.generatePngSmallPreviewPath(pData.path);
		if (!string.IsNullOrEmpty(text) && File.Exists(text))
		{
			byte[] array = File.ReadAllBytes(text);
			Texture2D val = new Texture2D(32, 32);
			((Texture)val).anisoLevel = 0;
			((Texture)val).filterMode = (FilterMode)0;
			if (ImageConversion.LoadImage(val, array))
			{
				Sprite sprite = Sprite.Create(val, new Rect(0f, 0f, 32f, 32f), new Vector2(0.5f, 0.5f));
				_preview.sprite = sprite;
			}
		}
		_meta_data = SaveManager.getMetaFor(pData.path);
		_save_name.text = _meta_data.mapStats.name;
		((Graphic)_save_name).color = _meta_data.mapStats.getArchitectMood().getColorText();
		_kingdoms.setValue(_meta_data.kingdoms);
		_cities.setValue(_meta_data.cities);
		_population.setValue(_meta_data.population);
		_mobs.setValue(_meta_data.mobs);
		_age.setValue(Date.getYear(_meta_data.mapStats.world_time));
		string text2 = "";
		string text3 = "";
		try
		{
			DateTime dateTime = Epoch.toDateTime(pData.timestamp);
			CultureInfo culture = LocalizedTextManager.getCulture();
			DateTime dateTime2 = DateTime.UtcNow.AddDays(7.0);
			if (dateTime.Year < 2017)
			{
				text2 = "GREG";
			}
			else if (dateTime > dateTime2)
			{
				text2 = "DREDD";
			}
			else if (LocalizedTextManager.cultureSupported())
			{
				DateTime dateTime3 = dateTime;
				CultureInfo cultureInfo = culture;
				text2 = DateHumanizeExtensions.Humanize(dateTime3, true, (DateTime?)null, cultureInfo);
			}
			else
			{
				string shortDatePattern = culture.DateTimeFormat.ShortDatePattern;
				text2 = dateTime.ToString(shortDatePattern, culture);
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)("failed with " + text3));
			Debug.LogError((object)ex);
		}
		_save_time_ago.text = text2;
		((Object)((Component)this).gameObject).name = "AutoSaveElement_" + pData.timestamp;
	}

	public void clickLoadAutoSave()
	{
		SaveManager.setCurrentPath(_world_path);
		ScrollWindow.showWindow("load_world");
	}

	private void OnDisable()
	{
		_meta_data = null;
		if ((Object)(object)_preview != (Object)null)
		{
			_preview.sprite = null;
		}
	}
}
// --- End of File: AutoSaveElement.cs ---



// --- Start of File: AutoSaveHelper.cs ---
using UnityEngine;

public class AutoSaveHelper : MonoBehaviour
{
	public void openAutoSaveWindow()
	{
		ScrollWindow.showWindow("auto_saves_browse");
	}
}
// --- End of File: AutoSaveHelper.cs ---



// --- Start of File: AutoSaveManager.cs ---
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityPools;

public static class AutoSaveManager
{
	private static float _time = 300f;

	private static float _interval = 300f;

	private static bool lowMemory = false;

	private static int lastClear = 0;

	private static int low_mem_count = 0;

	public static void update()
	{
		if (!lowMemory && Config.autosaves)
		{
			if (_time > 0f)
			{
				_time -= Time.deltaTime;
			}
			else if (ScrollWindow.isWindowActive() || ControllableUnit.isControllingUnit())
			{
				_time += 10f;
			}
			else
			{
				autoSave(pSkipDelete: false, pForce: true);
			}
		}
	}

	public static void autoSave(bool pSkipDelete = false, bool pForce = false)
	{
		if (!pForce && (_time > 240f || Time.realtimeSinceStartup - Config.LAST_LOAD_TIME < 120f))
		{
			return;
		}
		string text = SaveManager.generateAutosavesPath(Math.Truncate(Epoch.Current()).ToString());
		try
		{
			using (getAutoSaves())
			{
				text = SaveManager.generateAutosavesPath(Math.Truncate(Epoch.Current()).ToString());
				SaveManager.saveWorldToDirectory(text, pCompress: false);
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)"error while auto saving");
			Debug.LogError((object)ex);
			SaveManager.deleteSavePath(text);
		}
		try
		{
			if (!pSkipDelete)
			{
				checkClearSaves();
			}
		}
		catch (Exception ex2)
		{
			Debug.Log((object)"Error while clearing saves");
			Debug.LogError((object)ex2);
		}
		resetAutoSaveTimer();
	}

	private static void checkClearSaves()
	{
		using ListPool<AutoSaveData> listPool = getAutoSaves();
		Dictionary<string, ListPool<AutoSaveData>> autoSavesPerMap = getAutoSavesPerMap(listPool);
		foreach (ListPool<AutoSaveData> value in autoSavesPerMap.Values)
		{
			while (value.Count > 5)
			{
				SaveManager.deleteSavePath(value.Pop().path);
			}
			value.Dispose();
		}
		UnsafeCollectionPool<Dictionary<string, ListPool<AutoSaveData>>, KeyValuePair<string, ListPool<AutoSaveData>>>.Release(autoSavesPerMap);
		if (listPool.Count <= 30)
		{
			return;
		}
		using ListPool<AutoSaveData> listPool2 = getAutoSaves();
		if (listPool2.Count > 30)
		{
			for (int i = 30; i < listPool2.Count; i++)
			{
				SaveManager.deleteSavePath(listPool2[i].path);
			}
		}
	}

	public static void resetAutoSaveTimer()
	{
		_time = _interval;
	}

	public static ListPool<AutoSaveData> getAutoSaves()
	{
		string text = SaveManager.generateAutosavesPath();
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		using ListPool<string> listPool = Toolbox.getDirectories(text);
		ListPool<AutoSaveData> listPool2 = new ListPool<AutoSaveData>(listPool.Count);
		foreach (ref string item in listPool)
		{
			string current = item;
			MapMetaData metaFor = SaveManager.getMetaFor(current);
			if (metaFor == null)
			{
				SaveManager.deleteSavePath(current);
				continue;
			}
			listPool2.Add(new AutoSaveData
			{
				name = metaFor.mapStats.name,
				path = current,
				timestamp = metaFor.timestamp
			});
		}
		listPool2.Sort(sorter);
		return listPool2;
	}

	public static Dictionary<string, ListPool<AutoSaveData>> getAutoSavesPerMap(ListPool<AutoSaveData> pDatas)
	{
		Dictionary<string, ListPool<AutoSaveData>> dictionary = UnsafeCollectionPool<Dictionary<string, ListPool<AutoSaveData>>, KeyValuePair<string, ListPool<AutoSaveData>>>.Get();
		for (int i = 0; i < pDatas.Count; i++)
		{
			AutoSaveData autoSaveData = pDatas[i];
			if (!dictionary.ContainsKey(autoSaveData.name))
			{
				dictionary[autoSaveData.name] = new ListPool<AutoSaveData>();
			}
			dictionary[autoSaveData.name].Add(autoSaveData);
		}
		return dictionary;
	}

	public static int sorter(AutoSaveData o1, AutoSaveData o2)
	{
		return o2.timestamp.CompareTo(o1.timestamp);
	}

	internal static void OnLowMemory()
	{
		if (!Config.game_loaded || SmoothLoader.isLoading())
		{
			return;
		}
		low_mem_count++;
		if (low_mem_count < 3)
		{
			return;
		}
		resetAutoSaveTimer();
		int num = (int)Epoch.Current();
		if (!lowMemory || lastClear - num >= 30)
		{
			lastClear = num;
			if (!lowMemory)
			{
				Debug.Log((object)"Running out of memory!");
				WorldTip.showNow("Low on memory(RAM)! Disabling auto-saves", pTranslate: false, "top");
			}
			else
			{
				Debug.Log((object)"Running out of memory!");
				WorldTip.showNow("Your device is low on memory(RAM)", pTranslate: false, "top");
			}
			lowMemory = true;
			Config.forceGC("low memory");
		}
	}
}
// --- End of File: AutoSaveManager.cs ---



// --- Start of File: AutoSavesWindow.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AutoSavesWindow : MonoBehaviour
{
	[SerializeField]
	private AutoSaveElement _element_prefab;

	private List<AutoSaveElement> elements = new List<AutoSaveElement>();

	private Queue<AutoSaveData> _showQueue = new Queue<AutoSaveData>();

	[SerializeField]
	private VerticalLayoutGroup _elements_parent;

	private float _timer;

	private void OnEnable()
	{
		prepareList();
		prepareSaves();
	}

	private void prepareSaves()
	{
		_showQueue.Clear();
		using ListPool<AutoSaveData> listPool = AutoSaveManager.getAutoSaves();
		for (int i = 0; i < listPool.Count; i++)
		{
			AutoSaveData item = listPool[i];
			_showQueue.Enqueue(item);
		}
	}

	private void Update()
	{
		if (_timer > 0f)
		{
			_timer -= Time.deltaTime;
			return;
		}
		_timer = 0.02f;
		showNextItemFromQueue();
	}

	private void showNextItemFromQueue()
	{
		if (_showQueue.Count != 0)
		{
			AutoSaveData pData = _showQueue.Dequeue();
			renderMapElement(pData);
		}
	}

	private void prepareList()
	{
		foreach (AutoSaveElement element in elements)
		{
			Object.Destroy((Object)(object)((Component)element).gameObject);
		}
		elements.Clear();
	}

	private void renderMapElement(AutoSaveData pData)
	{
		AutoSaveElement autoSaveElement = Object.Instantiate<AutoSaveElement>(_element_prefab, ((Component)_elements_parent).transform);
		elements.Add(autoSaveElement);
		autoSaveElement.load(pData);
	}
}
// --- End of File: AutoSavesWindow.cs ---



// --- Start of File: AutoTesterBot.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AutoTesterBot : BaseMapObject
{
	internal string debugString = "";

	internal bool active;

	internal AiSystemTester ai;

	internal float wait;

	internal int beh_year_target;

	internal WorldTile beh_tile_target;

	internal string beh_asset_target;

	internal string active_tester = "";

	private Image _icon;

	public Image icon
	{
		get
		{
			if ((Object)(object)_icon == (Object)null)
			{
				_icon = ((Component)((Component)this).transform.Find("Icon")).GetComponent<Image>();
			}
			return _icon;
		}
	}

	internal void clearWorld()
	{
		beh_tile_target = null;
		beh_asset_target = null;
		beh_year_target = 0;
		ai?.restartJob();
	}

	internal override void create()
	{
		if (ai != null)
		{
			ai.reset();
			ai = null;
		}
		base.create();
		ai = new AiSystemTester(this);
		ai.next_job_delegate = AssetManager.tester_jobs.getNextJob;
		DebugConfig.createTool("Auto Tester", 150, 0);
		startAutoTester();
	}

	internal void create(string pJob)
	{
		if (ai != null)
		{
			ai.reset();
			ai = null;
		}
		base.create();
		active_tester = pJob;
		List<string> tJobs = new List<string> { pJob };
		ai = new AiSystemTester(this);
		ai.next_job_delegate = delegate
		{
			if (tJobs.Count == 0)
			{
				active = false;
				((Component)this).gameObject.SetActive(false);
				return (string)null;
			}
			return tJobs.Pop();
		};
		startAutoTester();
	}

	public override void update(float pElapsed)
	{
		if (active)
		{
			base.update(pElapsed);
			if (wait > 0f)
			{
				wait -= pElapsed;
			}
			else
			{
				ai.update();
			}
		}
	}

	private void updateButton()
	{
		if (active)
		{
			icon.sprite = SpriteTextureLoader.getSprite("ui/Icons/iconPause");
			WorldTip.instance.showToolbarText("Auto tester running");
		}
		else
		{
			icon.sprite = SpriteTextureLoader.getSprite("ui/Icons/iconPlay");
			WorldTip.instance.showToolbarText("Auto tester paused");
		}
	}

	public void startAutoTester()
	{
		active = true;
		updateButton();
	}

	public void stopAutoTester()
	{
		active = false;
		updateButton();
	}

	public void toggleAutoTester()
	{
		if (ai == null)
		{
			create();
		}
		active = !active;
		updateButton();
	}
}
// --- End of File: AutoTesterBot.cs ---



// --- Start of File: AvatarCombineHandItem.cs ---
public class AvatarCombineHandItem
{
	public readonly IHandRenderer hand_renderer;

	public AvatarCombineHandItem(IHandRenderer pHandRenderer)
	{
		hand_renderer = pHandRenderer;
	}
}
// --- End of File: AvatarCombineHandItem.cs ---



// --- Start of File: AvatarEffect.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AvatarEffect : MonoBehaviour
{
	public Image image;

	private RectTransform _rect_transform;

	private Vector3 _initial_position;

	private StatusAsset _asset;

	private Actor _actor;

	private UnitAvatarLoader _avatar;

	private bool _animated;

	private float _time_between_frames;

	private float _elapsed;

	private int _current_frame;

	public void load(StatusAsset pAsset, Actor pActor, UnitAvatarLoader pAvatar)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		_asset = pAsset;
		_actor = pActor;
		_avatar = pAvatar;
		_animated = pAsset.animated;
		_rect_transform = ((Component)this).GetComponent<RectTransform>();
		int pIndex;
		if (!pAsset.animated)
		{
			if (pAsset.random_frame)
			{
				int pMaxExclusive = pAsset.get_sprites_count(pActor, pAsset);
				pIndex = Randy.randomInt(0, pMaxExclusive);
			}
			else
			{
				pIndex = 0;
			}
		}
		else
		{
			_time_between_frames = pAsset.animation_speed + Randy.randomFloat(0f, pAsset.animation_speed_random);
			pIndex = 0;
		}
		((Component)image).transform.localEulerAngles = getSpriteRotation(_current_frame);
		image.sprite = getSprite(pIndex);
	}

	public void update(float pElapsed)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (_animated)
		{
			_elapsed += pElapsed;
			if (!(_elapsed < _time_between_frames))
			{
				_elapsed = 0f;
				int pLength = _asset.get_sprites_count(_actor, _asset);
				_current_frame = Toolbox.loopIndex(_current_frame + 1, pLength);
				Sprite sprite = getSprite(_current_frame);
				((Component)image).transform.localPosition = _initial_position + getSpritePosition(_current_frame);
				((Component)image).transform.localEulerAngles = getSpriteRotation(_current_frame);
				image.sprite = sprite;
			}
		}
	}

	private Sprite getSprite(int pIndex)
	{
		if (_asset.has_override_sprite)
		{
			return _asset.get_override_sprite_ui(this, pIndex);
		}
		return _asset.sprite_list[pIndex];
	}

	private Vector3 getSpritePosition(int pIndex)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (_asset.has_override_sprite)
		{
			return _asset.get_override_sprite_position_ui(this, pIndex);
		}
		return default(Vector3);
	}

	private Vector3 getSpriteRotation(int pIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		if (_asset.has_override_sprite_rotation_z)
		{
			result.z = _asset.get_override_sprite_rotation_z_ui(this, pIndex);
		}
		else
		{
			result.z = _asset.rotation_z;
		}
		return result;
	}

	public void setInitialPosition(Vector2 pPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		_initial_position = Vector2.op_Implicit(pPosition);
	}

	public RectTransform getRectTransform()
	{
		return _rect_transform;
	}

	public UnitAvatarLoader getAvatar()
	{
		return _avatar;
	}

	public StatusAsset getAsset()
	{
		return _asset;
	}
}
// --- End of File: AvatarEffect.cs ---



// --- Start of File: AvatarsCombineDataContainer.cs ---
using System.Collections.Generic;

public class AvatarsCombineDataContainer
{
	private Dictionary<string, AvatarsCombineDataElement> _dict = new Dictionary<string, AvatarsCombineDataElement>();

	private List<AvatarsCombineDataElement> _list = new List<AvatarsCombineDataElement>();

	public void add(string pId, int pAmount)
	{
		AvatarsCombineDataElement avatarsCombineDataElement = new AvatarsCombineDataElement(_dict.Count + 1, pAmount);
		_dict.Add(pId, avatarsCombineDataElement);
		_list.Add(avatarsCombineDataElement);
	}

	public int getListIndex(int pIndex, string pId)
	{
		AvatarsCombineDataElement avatarsCombineDataElement = _dict[pId];
		int num = avatarsCombineDataElement.order_index - 1;
		int num2 = 1;
		for (int i = num + 1; i < _list.Count; i++)
		{
			num2 *= _list[i].total_amount;
		}
		return pIndex / num2 % avatarsCombineDataElement.total_amount;
	}

	public void clear()
	{
		_dict.Clear();
		_list.Clear();
	}

	public int totalCombinations()
	{
		int num = 1;
		for (int i = 0; i < _list.Count; i++)
		{
			num *= _list[i].total_amount;
		}
		return num;
	}
}
// --- End of File: AvatarsCombineDataContainer.cs ---



// --- Start of File: AvatarsCombineDataElement.cs ---
public struct AvatarsCombineDataElement
{
	public readonly int order_index;

	public readonly int total_amount;

	public AvatarsCombineDataElement(int pOrderIndex, int pTotalAmount)
	{
		order_index = pOrderIndex;
		total_amount = pTotalAmount;
	}
}
// --- End of File: AvatarsCombineDataElement.cs ---



// --- Start of File: AvgStats.cs ---
public readonly struct AvgStats
{
	public readonly double avg;

	public readonly int count;

	public readonly string name;

	public AvgStats(double pAvg, int pCount, string pName)
	{
		avg = pAvg;
		count = pCount;
		name = pName;
	}

	public AvgStats add(double pValue)
	{
		double pAvg = (avg * (double)count + pValue) / (double)(count + 1);
		int pCount = count + 1;
		return new AvgStats(pAvg, pCount, name);
	}
}
// --- End of File: AvgStats.cs ---



// --- Start of File: AxonElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AxonElement : MonoBehaviour
{
	public Image image;

	internal NeuronElement neuron_1;

	internal NeuronElement neuron_2;

	internal float mod_light = 1f;

	public bool axon_center;

	public void update()
	{
		mod_light -= Time.deltaTime * 2f;
		mod_light = Mathf.Max(0f, mod_light);
	}

	public void clear()
	{
		axon_center = false;
	}
}
// --- End of File: AxonElement.cs ---



// --- Start of File: BabyHelper.cs ---
using UnityEngine;

public static class BabyHelper
{
	public static Actor debugTryToMakeUnit(Actor pActor)
	{
		WorldTile current_tile = pActor.current_tile;
		Actor actor = null;
		foreach (Actor item in Finder.getUnitsFromChunk(current_tile, 1, 10f))
		{
			if (item != pActor && item.subspecies == pActor.subspecies)
			{
				actor = item;
				break;
			}
		}
		if (actor == null)
		{
			return null;
		}
		return BabyMaker.makeBaby(pActor, actor);
	}

	public static void countBirth(Actor pBaby)
	{
		World.world.game_stats.data.creaturesBorn++;
		World.world.map_stats.creaturesBorn++;
		if (pBaby.hasCity())
		{
			pBaby.city.increaseBirths();
		}
		if (pBaby.hasClan())
		{
			pBaby.clan.increaseBirths();
		}
		if (pBaby.hasFamily())
		{
			pBaby.family.increaseBirths();
		}
		if (pBaby.hasSubspecies())
		{
			pBaby.subspecies.increaseBirths();
		}
		if (pBaby.isKingdomCiv())
		{
			pBaby.kingdom.increaseBirths();
		}
	}

	public static void applyParentsMeta(Actor pParent1, Actor pParent2, Actor pBaby)
	{
		Subspecies babySubspecies = getBabySubspecies(pParent1, pParent2);
		pBaby.setSubspecies(babySubspecies);
		Family family = pParent1.family;
		Clan clan = checkGreatClan(pParent1, pParent2);
		if (clan != null && !clan.isFull())
		{
			pBaby.setClan(clan);
		}
		if (babySubspecies.isSapient())
		{
			if (pParent1.hasCity())
			{
				pBaby.setCity(pParent1.city);
			}
			else if (pParent2 != null && pParent2.hasCity())
			{
				pBaby.setCity(pParent2.city);
			}
		}
		if (family != null)
		{
			pBaby.setFamily(family);
			pBaby.saveOriginFamily(family.data.id);
		}
		using ListPool<Culture> listPool2 = new ListPool<Culture>(2);
		using ListPool<Religion> listPool3 = new ListPool<Religion>(2);
		using ListPool<Language> listPool4 = new ListPool<Language>(2);
		using ListPool<int> listPool = new ListPool<int>(2);
		listPool.Add(pParent1.data.phenotype_index);
		if (pParent1.hasCulture())
		{
			listPool2.Add(pParent1.culture);
		}
		if (pParent1.hasReligion())
		{
			listPool3.Add(pParent1.religion);
		}
		if (pParent1.hasLanguage())
		{
			listPool4.Add(pParent1.language);
		}
		if (pParent2 != null)
		{
			if (pParent2.hasCulture())
			{
				listPool2.Add(pParent2.culture);
			}
			if (pParent2.hasReligion())
			{
				listPool3.Add(pParent2.religion);
			}
			if (pParent2.hasLanguage())
			{
				listPool4.Add(pParent2.language);
			}
			if (pParent2.subspecies == pBaby.subspecies)
			{
				listPool.Add(pParent2.data.phenotype_index);
			}
		}
		if (listPool2.Count > 0 && babySubspecies.has_advanced_memory)
		{
			pBaby.setCulture(listPool2.GetRandom());
		}
		if (listPool3.Count > 0 && babySubspecies.has_advanced_memory)
		{
			pBaby.setReligion(listPool3.GetRandom());
		}
		if (listPool4.Count > 0 && babySubspecies.has_advanced_communication)
		{
			pBaby.joinLanguage(listPool4.GetRandom());
		}
		if (pParent1 != null && pParent1.hasCultureTrait("ancestors_knowledge"))
		{
			string bestAtribute = getBestAtribute(pParent1);
			if (bestAtribute != null)
			{
				pBaby.data[bestAtribute] = (float)(int)pParent1.data[bestAtribute] * 0.5f + 1f;
			}
		}
		if (pParent2 != null && pParent2.hasCultureTrait("ancestors_knowledge"))
		{
			string bestAtribute2 = getBestAtribute(pParent2);
			if (bestAtribute2 != null)
			{
				pBaby.data[bestAtribute2] = (float)(int)pParent2.data[bestAtribute2] * 0.5f + 1f;
			}
		}
		pBaby.data.phenotype_index = listPool.GetRandom();
		pBaby.data.phenotype_shade = Actor.getRandomPhenotypeShade();
		if (babySubspecies.hasTrait("parental_care"))
		{
			pBaby.addStatusEffect("invincible", 90f);
		}
	}

	private static string getBestAtribute(Actor pParent1)
	{
		string result = null;
		int num = 0;
		if (pParent1.data["intelligence"] > (float)num)
		{
			num = (int)pParent1.data["intelligence"];
			result = "intelligence";
		}
		if (pParent1.data["warfare"] > (float)num)
		{
			num = (int)pParent1.data["warfare"];
			result = "warfare";
		}
		if (pParent1.data["diplomacy"] > (float)num)
		{
			num = (int)pParent1.data["diplomacy"];
			result = "diplomacy";
		}
		if (pParent1.data["stewardship"] > (float)num)
		{
			num = (int)pParent1.data["stewardship"];
			result = "stewardship";
		}
		return result;
	}

	private static Clan checkGreatClan(Actor pParent1, Actor pParent2)
	{
		Clan clan = null;
		if (pParent1.isKing())
		{
			clan = pParent1.clan;
		}
		else if (pParent2 != null && pParent2.isKing())
		{
			clan = pParent2.clan;
		}
		if (clan == null)
		{
			if (pParent1.isCityLeader() && pParent2 != null && pParent2.isCityLeader())
			{
				clan = ((!Randy.randomBool()) ? pParent2.clan : pParent1.clan);
			}
			else if (pParent1 != null && pParent1.isCityLeader())
			{
				clan = pParent1.clan;
			}
			else if (pParent2 != null && pParent2.isCityLeader())
			{
				clan = pParent2.clan;
			}
		}
		return clan;
	}

	private static Subspecies getBabySubspecies(Actor pParent1, Actor pParent2)
	{
		Subspecies subspecies = pParent1.subspecies;
		Subspecies subspecies2 = pParent2?.subspecies ?? subspecies;
		if (subspecies.isSapient() && subspecies.isSapient() != subspecies2.isSapient())
		{
			if (subspecies.isSapient())
			{
				return subspecies;
			}
			return subspecies2;
		}
		if (subspecies != subspecies2 && subspecies.getGeneration() != subspecies2.getGeneration())
		{
			if (subspecies.getGeneration() > subspecies2.getGeneration())
			{
				return subspecies;
			}
			return subspecies2;
		}
		if (Randy.randomBool())
		{
			return subspecies;
		}
		return subspecies2;
	}

	public static bool canMakeBabies(Actor pActor)
	{
		if (!pActor.isAdult())
		{
			return false;
		}
		if (!pActor.canProduceBabies())
		{
			return false;
		}
		if (pActor.hasReachedOffspringLimit())
		{
			return false;
		}
		if (!pActor.haveNutritionForNewBaby())
		{
			return false;
		}
		return true;
	}

	public static bool isMetaLimitsReached(Actor pActor)
	{
		if (pActor.subspecies.hasReachedPopulationLimit())
		{
			return true;
		}
		if (pActor.hasCity())
		{
			if (pActor.city.hasReachedWorldLawLimit())
			{
				return true;
			}
			Actor lover = pActor.lover;
			bool num = pActor.isImportantPerson() && !pActor.hasReachedOffspringLimit();
			bool flag = lover != null && lover.isImportantPerson() && !lover.hasReachedOffspringLimit();
			if (num || flag)
			{
				return false;
			}
			if (pActor.subspecies.isReproductionSexual() && pActor.current_children_count == 0)
			{
				return false;
			}
			if (!pActor.city.hasFreeHouseSlots())
			{
				return true;
			}
		}
		return false;
	}

	public static void countMakeChild(Actor pParent1, Actor pParent2)
	{
		if (!pParent1.isRekt())
		{
			pParent1.increaseBirths();
		}
		if (!pParent2.isRekt())
		{
			pParent2.increaseBirths();
		}
	}

	public static void babyMakingStart(Actor pActor)
	{
		pActor.subspecies.all_actions_actor_birth?.Invoke(pActor, pActor.current_tile);
	}

	public static void traitsClone(Actor pActorTarget, Actor pParent1)
	{
		foreach (ActorTrait trait in pParent1.getTraits())
		{
			if (trait.rate_birth != 0 || trait.rate_inherit != 0)
			{
				pActorTarget.addTrait(trait);
			}
		}
	}

	public static void traitsInherit(Actor pActorTarget, Actor pParent1, Actor pParent2)
	{
		using ListPool<ActorTrait> listPool = new ListPool<ActorTrait>(128);
		int pCounter = 0;
		int pCounter2 = 0;
		addTraitsFromParentToList(pParent1, listPool, out pCounter);
		if (pParent2 != null)
		{
			addTraitsFromParentToList(pParent2, listPool, out pCounter2);
		}
		if (listPool.Count != 0)
		{
			int num = (int)((float)(pCounter + pCounter2) * 0.25f);
			num = Mathf.Max(1, num);
			for (int i = 0; i < num; i++)
			{
				ActorTrait random = listPool.GetRandom();
				pActorTarget.addTrait(random.id);
			}
		}
	}

	private static void addTraitsFromParentToList(Actor pActor, ListPool<ActorTrait> pList, out int pCounter)
	{
		int num = 0;
		foreach (ActorTrait trait in pActor.getTraits())
		{
			if (trait.rate_inherit != 0 || trait.rate_birth != 0)
			{
				num++;
				pList.AddTimes(trait.rate_birth, trait);
				pList.AddTimes(trait.rate_inherit, trait);
			}
		}
		pCounter = num;
	}
}
// --- End of File: BabyHelper.cs ---



// --- Start of File: BabyMaker.cs ---
using UnityEngine;

public class BabyMaker
{
	public static void startMiracleBirth(Actor pActor)
	{
		BabyHelper.babyMakingStart(pActor);
		if (pActor.hasSubspeciesTrait("reproduction_strategy_viviparity") && pActor.isSexFemale())
		{
			pActor.addStatusEffect("pregnant", pActor.getMaturationTimeSeconds());
		}
		else
		{
			pActor.birthEvent("miracle_bearer");
			makeBabyFromMiracle(pActor, ActorSex.Male, pAddToFamily: true);
			makeBabyFromMiracle(pActor, ActorSex.Female, pAddToFamily: true);
			if (Randy.randomBool())
			{
				makeBabyFromMiracle(pActor, ActorSex.None, pAddToFamily: true);
			}
		}
		pActor.subspecies.counterReproduction();
	}

	public static void startSoulborneBirth(Actor pActor)
	{
		BabyHelper.babyMakingStart(pActor);
		if (pActor.subspecies.hasTrait("reproduction_strategy_viviparity") && pActor.isSexFemale())
		{
			pActor.addStatusEffect("pregnant", pActor.getMaturationTimeSeconds());
		}
		else
		{
			pActor.birthEvent();
			makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: false, pJoinFamily: true);
		}
		pActor.subspecies.counterReproduction();
	}

	public static void spawnSporesFor(Actor pActor)
	{
		pActor.birthEvent();
		BabyHelper.babyMakingStart(pActor);
		int num = Randy.randomInt(3, 10);
		for (int i = 0; i < num; i++)
		{
			Spores spores = (Spores)EffectsLibrary.spawn("fx_spores", pActor.current_tile);
			if ((Object)(object)spores == (Object)null)
			{
				return;
			}
			spores.prepare();
			spores.setActorParent(pActor);
		}
		pActor.subspecies.counterReproduction();
	}

	public static void spawnBabyFromSpore(Actor pActor, Vector3 pPosition)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		WorldTile tile = World.world.GetTile((int)pPosition.x, (int)pPosition.y);
		if (tile != null)
		{
			makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, tile, pAddToFamily: false, pJoinFamily: true);
		}
	}

	public static void makeBabyFromMiracle(Actor pActor, ActorSex pSex = ActorSex.None, bool pAddToFamily = false)
	{
		makeBaby(pActor, null, pSex, pCloneTraits: false, 0, null, pAddToFamily).addTrait("miracle_born");
	}

	public static Actor makeBabyViaFission(Actor pActor)
	{
		pActor.birthEvent();
		BabyHelper.babyMakingStart(pActor);
		Actor actor = makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: false, pJoinFamily: true);
		int pValue = pActor.getHealth() / 2;
		int pValue2 = pActor.getHappiness() / 2;
		int pVal = pActor.getNutrition() / 2;
		pActor.setHealth(pValue);
		pActor.setStamina(0);
		pActor.setHappiness(pValue2);
		pActor.setNutrition(pVal);
		actor.setHealth(pValue);
		actor.setStamina(0);
		actor.setHappiness(pValue2);
		actor.setNutrition(pVal);
		pActor.subspecies.counterReproduction();
		return actor;
	}

	public static Actor makeBabyViaBudding(Actor pActor)
	{
		pActor.birthEvent();
		BabyHelper.babyMakingStart(pActor);
		return makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: false, pJoinFamily: true);
	}

	public static Actor makeBabyViaVegetative(Actor pActor)
	{
		pActor.birthEvent();
		BabyHelper.babyMakingStart(pActor);
		Actor actor = makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: false, pJoinFamily: true);
		actor.addStatusEffect("uprooting", actor.getMaturationTimeSeconds());
		return actor;
	}

	public static void makeBabyViaParthenogenesis(Actor pActor)
	{
		pActor.birthEvent();
		BabyHelper.babyMakingStart(pActor);
		makeBaby(pActor, null, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: false, pJoinFamily: true);
		pActor.subspecies.counterReproduction();
	}

	public static void makeBabiesViaSexual(Actor pMotherTarget, Actor pParentA, Actor pParentB)
	{
		pParentA.birthEvent();
		pParentB.birthEvent();
		BabyHelper.babyMakingStart(pParentA);
		BabyHelper.babyMakingStart(pParentB);
		newImmediateBabySpawn(pParentA, pParentB);
		int num = (int)pMotherTarget.stats["birth_rate"];
		float num2 = 0.5f;
		for (int i = 0; i < num; i++)
		{
			if (!Randy.randomChance(num2))
			{
				break;
			}
			newImmediateBabySpawn(pParentA, pParentB);
			num2 *= 0.85f;
		}
	}

	public static void makeBabyFromPregnancy(Actor pActor)
	{
		pActor.hasLover();
		Actor lover = pActor.lover;
		pActor.birthEvent();
		makeBaby(pActor, lover, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: true);
		float num = 0.5f;
		int num2 = (int)pActor.stats["birth_rate"];
		for (int i = 0; i < num2; i++)
		{
			if (!Randy.randomChance(num))
			{
				break;
			}
			makeBaby(pActor, lover, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: true);
			num *= 0.85f;
		}
	}

	private static void newImmediateBabySpawn(Actor pParent1, Actor pParent2)
	{
		makeBaby(pParent1, pParent2, ActorSex.None, pCloneTraits: false, 0, null, pAddToFamily: true).justBorn();
	}

	public static Actor makeBaby(Actor pParent1, Actor pParent2, ActorSex pForcedSexType = ActorSex.None, bool pCloneTraits = false, int pMutationRate = 0, WorldTile pTile = null, bool pAddToFamily = false, bool pJoinFamily = false)
	{
		City city = pParent1.city ?? pParent2?.city;
		if (city != null)
		{
			city.status.housing_free--;
		}
		ActorAsset asset = pParent1.asset;
		ActorData actorData = new ActorData();
		actorData.created_time = World.world.getCurWorldTime();
		actorData.id = World.world.map_stats.getNextId("unit");
		actorData.asset_id = asset.id;
		int generation = pParent1.data.generation;
		if (pParent2 != null && pParent2.data.generation > generation)
		{
			generation = pParent2.data.generation;
		}
		actorData.generation = generation + 1;
		using ListPool<WorldTile> listPool = new ListPool<WorldTile>(4);
		WorldTile[] neighboursAll = pParent1.current_tile.neighboursAll;
		foreach (WorldTile worldTile in neighboursAll)
		{
			if (worldTile != pParent1.current_tile && (pParent2 == null || worldTile != pParent2.current_tile) && worldTile.Type.ground)
			{
				listPool.Add(worldTile);
			}
		}
		WorldTile pTile2 = ((pTile != null) ? pTile : ((listPool.Count != 0) ? listPool.GetRandom() : pParent1.current_tile));
		Actor actor = World.world.units.createBabyActorFromData(actorData, pTile2, city);
		actor.setParent1(pParent1);
		if (pParent2 != null)
		{
			actor.setParent2(pParent2);
		}
		if (pAddToFamily && !pParent1.hasFamily())
		{
			World.world.families.newFamily(pParent1, pParent1.current_tile, pParent2);
		}
		else if (pJoinFamily)
		{
			Family family = null;
			family = (pParent1.hasFamily() ? pParent1.family : World.world.families.newFamily(pParent1, pParent1.current_tile, pParent2));
			if (family != null)
			{
				actor.setFamily(family);
			}
		}
		BabyHelper.applyParentsMeta(pParent1, pParent2, actor);
		if (pCloneTraits || pParent1.hasSubspeciesTrait("genetic_mirror"))
		{
			BabyHelper.traitsClone(actor, pParent1);
		}
		else
		{
			foreach (ActorTrait trait in actor.subspecies.getActorBirthTraits().getTraits())
			{
				actor.addTrait(trait);
			}
			BabyHelper.traitsInherit(actor, pParent1, pParent2);
		}
		actor.checkTraitMutationOnBirth();
		actor.setNutrition(SimGlobals.m.nutrition_start_level_baby);
		if (pForcedSexType != ActorSex.None)
		{
			actor.data.sex = pForcedSexType;
		}
		else
		{
			ActorSex actorSex = ActorSex.None;
			if (Randy.randomBool())
			{
				actorSex = (pParent1.hasCity() ? ((pParent1.city.status.females <= pParent1.city.status.males) ? ActorSex.Female : ActorSex.Male) : ((pParent1.subspecies.cached_females <= pParent1.subspecies.cached_males) ? ActorSex.Female : ActorSex.Male));
			}
			if (actorSex != ActorSex.None)
			{
				actor.data.sex = actorSex;
			}
			else
			{
				actor.generateSex();
			}
		}
		actor.checkShouldBeEgg();
		actor.makeStunned(10f);
		actor.applyRandomForce();
		BabyHelper.countBirth(actor);
		BabyHelper.countMakeChild(pParent1, pParent2);
		actor.setStatsDirty();
		actor.event_full_stats = true;
		return actor;
	}
}
// --- End of File: BabyMaker.cs ---



// --- Start of File: BackButtonHider.cs ---
using UnityEngine;

internal class BackButtonHider : MonoBehaviour
{
	private void OnEnable()
	{
		if (WindowHistory.hasHistory())
		{
			((Component)this).gameObject.SetActive(true);
		}
		else
		{
			((Component)this).gameObject.SetActive(false);
		}
	}
}
// --- End of File: BackButtonHider.cs ---



// --- Start of File: BannerAsset.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class BannerAsset : Asset
{
	public List<string> backgrounds;

	public List<string> icons;

	public List<string> frames;
}
// --- End of File: BannerAsset.cs ---



// --- Start of File: BannerBase.cs ---
using System;
using DG.Tweening;
using UnityEngine;

public abstract class BannerBase : MonoBehaviour, IBanner, IBaseMono, IRefreshElement
{
	private Sequence _sequence;

	protected virtual MetaType meta_type
	{
		get
		{
			throw new NotImplementedException(((object)this).GetType().Name);
		}
	}

	public MetaCustomizationAsset meta_asset => AssetManager.meta_customization_library.getAsset(meta_type);

	public MetaTypeAsset meta_type_asset => AssetManager.meta_type_library.getAsset(meta_type);

	internal int option_1
	{
		get
		{
			return meta_asset.option_1_get();
		}
		set
		{
			meta_asset.option_1_set(value);
		}
	}

	internal int option_2
	{
		get
		{
			return meta_asset.option_2_get();
		}
		set
		{
			meta_asset.option_2_set(value);
		}
	}

	internal int color
	{
		get
		{
			return meta_asset.color_get();
		}
		set
		{
			meta_asset.color_set(value);
		}
	}

	public virtual void load(NanoObject pObject)
	{
	}

	public virtual NanoObject GetNanoObject()
	{
		return null;
	}

	public void jump(float pSpeed = 0.1f, bool pSilent = false)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		float y = ((Component)this).transform.localPosition.y;
		TweenExtensions.Kill((Tween)(object)_sequence, false);
		_sequence = DOTween.Sequence();
		TweenSettingsExtensions.Append(_sequence, (Tween)(object)ShortcutExtensions.DOLocalMoveY(((Component)this).transform, y + 5f, pSpeed, false));
		TweenSettingsExtensions.Append(_sequence, (Tween)(object)ShortcutExtensions.DOLocalMoveY(((Component)this).transform, y, pSpeed, false));
		TweenSettingsExtensions.AppendCallback(_sequence, (TweenCallback)delegate
		{
			if (!pSilent)
			{
				SoundBox.click();
			}
		});
	}

	private void OnDisable()
	{
		TweenExtensions.Kill((Tween)(object)_sequence, false);
	}

	public string getName()
	{
		return GetNanoObject().name;
	}

	public virtual void showTooltip()
	{
		throw new NotImplementedException();
	}

	Transform IBaseMono.get_transform()
	{
		return ((Component)this).transform;
	}

	GameObject IBaseMono.get_gameObject()
	{
		return ((Component)this).gameObject;
	}

	T IBaseMono.GetComponent<T>()
	{
		return ((Component)this).GetComponent<T>();
	}
}
// --- End of File: BannerBase.cs ---



// --- Start of File: BannerGeneric.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public abstract class BannerGeneric<TMetaObject, TData> : BannerBase where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
{
	protected TMetaObject meta_object;

	private bool _created;

	protected Image part_background;

	protected Image part_icon;

	protected Image part_frame;

	public bool enable_default_click = true;

	[SerializeField]
	private bool _enable_customize_click;

	public bool enable_tab_show_click;

	protected TData data => meta_object.data;

	protected virtual string tooltip_id
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	private void Start()
	{
		create();
	}

	private void create()
	{
		if (!_created)
		{
			_created = true;
			setupParts();
			setupClick();
			setupTooltip();
		}
	}

	protected virtual void setupClick()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Expected O, but got Unknown
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Expected O, but got Unknown
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Expected O, but got Unknown
		if (!enable_default_click && !_enable_customize_click && !enable_tab_show_click)
		{
			return;
		}
		Button componentInChildren = ((Component)this).GetComponentInChildren<Button>();
		if (!((Object)(object)componentInChildren == (Object)null))
		{
			if (enable_default_click)
			{
				((UnityEvent)componentInChildren.onClick).AddListener(new UnityAction(clickAction));
			}
			else if (_enable_customize_click)
			{
				((UnityEvent)componentInChildren.onClick).AddListener(new UnityAction(clickCustomize));
			}
			else if (enable_tab_show_click)
			{
				((UnityEvent)componentInChildren.onClick).AddListener(new UnityAction(clickShowTab));
			}
		}
	}

	protected virtual void clickAction()
	{
		if (!meta_object.hasDied())
		{
			if (!InputHelpers.mouseSupported)
			{
				switchOnDoubleTap();
			}
			else
			{
				showMetaWindow();
			}
		}
	}

	private void switchOnDoubleTap()
	{
		if (!Tooltip.isShowingFor(this))
		{
			tooltipAction();
		}
		else
		{
			showMetaWindow();
		}
	}

	private void showMetaWindow()
	{
		base.meta_type_asset.set_selected(meta_object);
		string window_name = base.meta_type_asset.window_name;
		if (ScrollWindow.isCurrentWindow(window_name))
		{
			ScrollWindow.get(window_name).showSameWindow();
		}
		else
		{
			ScrollWindow.showWindow(window_name);
		}
	}

	protected virtual void clickCustomize()
	{
		string customize_window_id = base.meta_asset.customize_window_id;
		if (customize_window_id == string.Empty)
		{
			Debug.LogError((object)("var " + customize_window_id + " is not set!"));
		}
		else
		{
			ScrollWindow.showWindow(customize_window_id);
		}
	}

	private void clickShowTab()
	{
		if (HotkeyLibrary.isHoldingControlForSelection())
		{
			clickAction();
			return;
		}
		base.meta_type_asset.selectAndInspect(meta_object);
		Tooltip.blockTooltips(0.5f);
		Tooltip.hideTooltipNow();
	}

	protected virtual void setupParts()
	{
		loadPartBackground();
		loadPartFrame();
		loadPartIcon();
	}

	protected virtual void loadPartFrame()
	{
		Transform obj = ((Component)this).transform.FindRecursive("Frame");
		part_frame = ((obj != null) ? ((Component)obj).GetComponent<Image>() : null);
	}

	protected virtual void loadPartBackground()
	{
		Transform obj = ((Component)this).transform.FindRecursive("Background");
		part_background = ((obj != null) ? ((Component)obj).GetComponent<Image>() : null);
	}

	protected virtual void loadPartIcon()
	{
		Transform obj = ((Component)this).transform.FindRecursive("Icon");
		part_icon = ((obj != null) ? ((Component)obj).GetComponent<Image>() : null);
	}

	protected virtual void setupBanner()
	{
	}

	public override void load(NanoObject pObject)
	{
		setMetaObject(pObject);
		create();
		setupBanner();
	}

	public override NanoObject GetNanoObject()
	{
		return meta_object;
	}

	protected virtual void setupTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (!((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			return;
		}
		tipButton.setHoverAction(delegate
		{
			if (InputHelpers.mouseSupported)
			{
				tooltipAction();
			}
		});
	}

	protected virtual void tooltipAction()
	{
		Tooltip.show(this, tooltip_id, getTooltipData());
	}

	protected virtual TooltipData getTooltipData()
	{
		CustomDataContainer<bool> customDataContainer = new CustomDataContainer<bool>();
		customDataContainer["tab_banner"] = enable_tab_show_click;
		return new TooltipData
		{
			custom_data_bool = customDataContainer
		};
	}

	public override void showTooltip()
	{
		tooltipAction();
	}

	protected void setMetaObject(NanoObject pObject)
	{
		meta_object = (TMetaObject)pObject;
	}

	internal virtual void normalize()
	{
		if (base.meta_asset.option_1_editable)
		{
			int num = base.meta_asset.option_1_count();
			if (base.option_1 < 0)
			{
				base.option_1 += num;
			}
			if (base.option_1 > num - 1)
			{
				base.option_1 -= num;
			}
			base.option_1 = Mathf.Clamp(base.option_1, 0, num - 1);
		}
		if (base.meta_asset.option_2_editable)
		{
			int num2 = base.meta_asset.option_2_count();
			if (base.option_2 < 0)
			{
				base.option_2 += num2;
			}
			if (base.option_2 > num2 - 1)
			{
				base.option_2 -= num2;
			}
			base.option_2 = Mathf.Clamp(base.option_2, 0, num2 - 1);
		}
		if (base.meta_asset.color_editable)
		{
			int num3 = base.meta_asset.color_count();
			if (base.color < 0)
			{
				base.color += num3;
			}
			if (base.color > num3 - 1)
			{
				base.color -= num3;
			}
			base.color = Mathf.Clamp(base.color, 0, num3 - 1);
		}
	}

	internal virtual void updateColor()
	{
		ColorAsset pColor = base.meta_asset.color_library().list[base.color];
		if (meta_object.updateColor(pColor))
		{
			base.meta_asset.on_new_color();
		}
	}
}
// --- End of File: BannerGeneric.cs ---



// --- Start of File: BannersMetaContainer.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

public class BannersMetaContainer<TMetaBanner, TMetaObject, TMetaData> : WindowMetaElementBase where TMetaBanner : BannerGeneric<TMetaObject, TMetaData> where TMetaObject : CoreSystemObject<TMetaData> where TMetaData : BaseSystemData
{
	[SerializeField]
	private TMetaBanner _prefab;

	[SerializeField]
	private Transform _container;

	private StatsWindow _window;

	private ObjectPoolGenericMono<TMetaBanner> _pool_elements;

	protected override void Awake()
	{
		base.Awake();
		_pool_elements = new ObjectPoolGenericMono<TMetaBanner>(_prefab, _container);
	}

	protected override void OnEnable()
	{
	}

	public void update(NanoObject pNano)
	{
		clear();
		_pool_elements.clear();
		showContent(pNano);
	}

	private void showContent(NanoObject pNano)
	{
		using ListPool<TMetaObject> listPool = new ListPool<TMetaObject>(getMetaList(pNano as IMetaObject));
		for (int i = 0; i < listPool.Count; i++)
		{
			TMetaObject val = listPool[i];
			track_objects.Add(val);
			showElement(val);
		}
	}

	private void showElement(TMetaObject pMeta)
	{
		TMetaBanner next = _pool_elements.getNext();
		next.enable_tab_show_click = true;
		next.enable_default_click = false;
		if (!((Component)(object)next).HasComponent<DraggableLayoutElement>())
		{
			((Component)(object)next).AddComponent<DraggableLayoutElement>();
		}
		next.load(pMeta);
	}

	protected virtual IEnumerable<TMetaObject> getMetaList(IMetaObject pMeta)
	{
		throw new NotImplementedException();
	}
}
// --- End of File: BannersMetaContainer.cs ---



// --- Start of File: BaseActionActor.cs ---
public delegate void BaseActionActor(Actor pActor);
// --- End of File: BaseActionActor.cs ---



// --- Start of File: BaseActorComponent.cs ---
using System;
using UnityEngine;

public class BaseActorComponent : MonoBehaviour, IDisposable
{
	internal Actor actor;

	internal virtual void create(Actor pActor)
	{
		actor = pActor;
	}

	public virtual void update(float pElapsed)
	{
	}

	public virtual void Dispose()
	{
		actor = null;
	}
}
// --- End of File: BaseActorComponent.cs ---



// --- Start of File: BaseAnimatedObject.cs ---
using UnityEngine;

public class BaseAnimatedObject : BaseMapObject
{
	internal SpriteAnimation sprite_animation;

	private bool _has_sprite_animation;

	public virtual void Awake()
	{
		sprite_animation = ((Component)this).gameObject.GetComponent<SpriteAnimation>();
		_has_sprite_animation = (Object)(object)sprite_animation != (Object)null;
	}

	internal override void create()
	{
		base.create();
		if (_has_sprite_animation)
		{
			sprite_animation.create();
		}
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		updateSpriteAnimation(pElapsed);
	}

	internal void resetAnim()
	{
		if (_has_sprite_animation)
		{
			sprite_animation.resetAnim();
		}
	}

	internal void updateSpriteAnimation(float pElapsed, bool pForce = false)
	{
		if (_has_sprite_animation)
		{
			sprite_animation.update(pElapsed);
		}
	}

	public override void Dispose()
	{
		sprite_animation = null;
		base.Dispose();
	}
}
// --- End of File: BaseAnimatedObject.cs ---



// --- Start of File: BaseAssetElementPlace.cs ---
using UnityEngine;
using UnityEngine.UI;

public class BaseAssetElementPlace<TAsset, TAssetElement> : MonoBehaviour where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset>
{
	public GameObject game_object_cache;

	public RectTransform rect_transform;

	public LayoutElement layout_element;

	public bool has_element;

	public TAssetElement element;

	public GameObject element_game_object_cache;

	public bool allowed_for_search = true;

	public void clear()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (has_element)
		{
			LayoutElement obj = layout_element;
			Rect rect = element.rect_transform.rect;
			obj.minHeight = ((Rect)(ref rect)).height;
			Object.Destroy((Object)(object)element_game_object_cache);
			element_game_object_cache = null;
			element = null;
			has_element = false;
		}
	}

	public void setData(TAsset pAsset, TAssetElement pPrefab)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (has_element)
		{
			clear();
		}
		layout_element.minHeight = -1f;
		TAssetElement val = Object.Instantiate<TAssetElement>(pPrefab, (Transform)(object)rect_transform);
		val.setData(pAsset);
		((Transform)val.rect_transform).localScale = Vector3.one;
		element = val;
		element_game_object_cache = ((Component)val).gameObject;
		has_element = true;
	}
}
// --- End of File: BaseAssetElementPlace.cs ---



// --- Start of File: BaseAssetLibrary.cs ---
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.UnityConverters.Math;
using UnityEngine;

public abstract class BaseAssetLibrary
{
	private const string ERROR_COLOR_WHITE = "#FFFFFF";

	private const string ERROR_COLOR_RED = "#FF3232";

	private const string ERROR_COLOR_YELLOW = "#FFF832";

	private const string ERROR_COLOR_MAIN = "#D2B7FF";

	[JsonProperty(Order = -1)]
	public string id = "ASSET_LIBRARY";

	protected static int _latest_hash = 1;

	private static JsonSerializer _json_serializer_internal = null;

	private static JsonSerializer _json_serializer
	{
		get
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Expected O, but got Unknown
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Expected O, but got Unknown
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Expected O, but got Unknown
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Expected O, but got Unknown
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Expected O, but got Unknown
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Expected O, but got Unknown
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Expected O, but got Unknown
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Expected O, but got Unknown
			//IL_00cf: Expected O, but got Unknown
			if (_json_serializer_internal == null)
			{
				_json_serializer_internal = JsonSerializer.Create(new JsonSerializerSettings
				{
					DefaultValueHandling = (DefaultValueHandling)1,
					Formatting = (Formatting)1,
					ReferenceLoopHandling = (ReferenceLoopHandling)1,
					Culture = CultureInfo.InvariantCulture,
					ContractResolver = (IContractResolver)(object)new OrderedContractResolver(),
					Converters = { (JsonConverter)(object)new DelegateConverter() },
					Converters = { (JsonConverter)new StringEnumConverter() },
					Converters = { (JsonConverter)new Color32Converter() },
					Converters = { (JsonConverter)new ColorConverter() },
					Converters = { (JsonConverter)new Vector2Converter() },
					Converters = { (JsonConverter)new Vector2IntConverter() },
					Converters = { (JsonConverter)new Vector3Converter() },
					Converters = { (JsonConverter)new Vector3IntConverter() },
					Converters = { (JsonConverter)new Vector4Converter() }
				});
			}
			return _json_serializer_internal;
		}
	}

	public virtual int total_items => 0;

	public virtual void init()
	{
		_ = Application.version;
	}

	public void exportAssets()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Expected O, but got Unknown
		if (id.StartsWith("beh") || id.StartsWith("debug"))
		{
			return;
		}
		string text = "GenAssets/wbassets" + "/" + id + ".json";
		try
		{
			using FileStream stream = new FileStream(text, FileMode.Create, FileAccess.Write, FileShare.None);
			using StreamWriter streamWriter = new StreamWriter(stream)
			{
				NewLine = "\n"
			};
			JsonTextWriter val = new JsonTextWriter((TextWriter)streamWriter)
			{
				Formatting = (Formatting)1,
				Indentation = 4,
				IndentChar = ' '
			};
			try
			{
				_json_serializer.Serialize((JsonWriter)(object)val, (object)this);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to export assets to " + text + ": " + ex.Message));
		}
	}

	public void importAssets()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected O, but got Unknown
		string text = "GenAssets/wbassets" + "/" + id + ".json";
		if (!File.Exists(text))
		{
			Debug.LogError((object)("File not found: " + text));
			return;
		}
		using FileStream stream = new FileStream(text, FileMode.Open, FileAccess.Read, FileShare.Read);
		using StreamReader streamReader = new StreamReader(stream);
		JsonTextReader val = new JsonTextReader((TextReader)streamReader);
		try
		{
			_json_serializer.Populate((JsonReader)(object)val, (object)this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void post_init()
	{
	}

	public virtual void linkAssets()
	{
	}

	public virtual void editorDiagnostic()
	{
		editorDiagnosticLocales();
	}

	public virtual void editorDiagnosticLocales()
	{
	}

	public virtual void checkLocale(Asset pAsset, string pLocaleID)
	{
		if (!string.IsNullOrEmpty(pLocaleID) && !LocalizedTextManager.stringExists(pLocaleID))
		{
			logAssetError("<e>" + pAsset.id + "</e>: Missing translation key", pLocaleID);
			AssetManager.missing_locale_keys.Add(pLocaleID);
		}
	}

	internal bool hasSpriteInResources(string pPath)
	{
		if ((Object)(object)SpriteTextureLoader.getSprite(pPath) == (Object)null)
		{
			return false;
		}
		return true;
	}

	internal bool hasSpriteInResourcesDebug(string pPath)
	{
		string text = Path.Combine(Path.Combine("Assets/Resources", pPath).Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar));
		if (File.Exists(text + ".png"))
		{
			return true;
		}
		if (Directory.Exists(text) && Directory.GetFiles(text, "*.png", SearchOption.TopDirectoryOnly).Length != 0)
		{
			return true;
		}
		return false;
	}

	protected void logErrorOpposites(string pMainTraitID, string pOppositeTraitID)
	{
		Debug.LogError((object)("<color=#FF3232>[" + pMainTraitID + "]</color> has opposite <color=#FFF832>[" + pOppositeTraitID + "]</color>, but <color=#FFF832>[" + pOppositeTraitID + "]</color> doesn't have opposite <color=#FF3232>[" + pMainTraitID + "]</color>"));
	}

	private static string formatLog(string pMessage, string pRightPart = null)
	{
		if (pMessage.Contains("<"))
		{
			pMessage = pMessage.Replace("<e>", "<b><color=#FFFFFF>");
			pMessage = pMessage.Replace("</e>", "</color></b>");
		}
		string text = "<color=#D2B7FF>" + pMessage.Trim() + "</color>";
		if (!string.IsNullOrEmpty(pRightPart))
		{
			text = text + " : <b><color=#FFF832>" + pRightPart.Trim() + "</color></b>";
		}
		return text;
	}

	public static void logAssetLog(string pMessage, string pRightPart = null)
	{
		Debug.Log((object)formatLog(pMessage, pRightPart));
	}

	public static void logAssetError(string pMessage, string pRightPart = null)
	{
		Debug.LogError((object)formatLog(pMessage, pRightPart));
	}

	public virtual IEnumerable<Asset> getList()
	{
		yield break;
	}
}
// --- End of File: BaseAssetLibrary.cs ---



// --- Start of File: BaseAugmentationAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;

[Serializable]
public class BaseAugmentationAsset : BaseUnlockableAsset
{
	[DefaultValue(true)]
	public bool can_be_given = true;

	[DefaultValue(true)]
	public bool can_be_removed = true;

	[DefaultValue(true)]
	public bool show_in_meta_editor = true;

	public WorldActionTrait action_on_object_remove;

	public WorldAction action_special_effect;

	public WorldActionTrait action_on_augmentation_add;

	public WorldActionTrait action_on_augmentation_remove;

	public WorldActionTrait action_on_augmentation_load;

	[DefaultValue(1f)]
	public float special_effect_interval = 1f;

	public AttackAction action_attack_target;

	public string group_id;

	public int priority;

	public string special_locale_id;

	[NonSerialized]
	public CombatActionHolder combat_actions;

	[NonSerialized]
	public List<SpellAsset> spells;

	public List<string> combat_actions_ids;

	[NonSerialized]
	public DecisionAsset[] decisions_assets;

	public List<string> decision_ids;

	public List<string> spells_ids { get; set; }

	public bool hasDecisions()
	{
		return decisions_assets != null;
	}

	public bool hasCombatActions()
	{
		return combat_actions != null;
	}

	public bool hasSpells()
	{
		return spells != null;
	}

	public void addDecision(string pID)
	{
		if (decision_ids == null)
		{
			decision_ids = new List<string>();
		}
		decision_ids.Add(pID);
	}

	public void addSpell(string pSpell)
	{
		if (spells_ids == null)
		{
			spells_ids = new List<string>();
		}
		spells_ids.Add(pSpell);
	}

	public void addCombatAction(string pCombatActionID)
	{
		if (combat_actions_ids == null)
		{
			combat_actions_ids = new List<string>();
		}
		combat_actions_ids.Add(pCombatActionID);
	}

	public void linkCombatActions()
	{
		if (combat_actions_ids != null && combat_actions_ids.Count != 0)
		{
			combat_actions = new CombatActionHolder();
			combat_actions.fillFromIDS(combat_actions_ids);
		}
	}

	public void linkSpells()
	{
		if (spells_ids == null || spells_ids.Count == 0)
		{
			return;
		}
		spells = new List<SpellAsset>();
		foreach (string spells_id in spells_ids)
		{
			SpellAsset spellAsset = AssetManager.spells.get(spells_id);
			if (spellAsset != null)
			{
				spells.Add(spellAsset);
			}
		}
	}

	public virtual BaseCategoryAsset getGroup()
	{
		throw new NotImplementedException();
	}
}
// --- End of File: BaseAugmentationAsset.cs ---



// --- Start of File: BaseAugmentationsEditor.cs ---
using System;
using System.Collections.Generic;
using LayoutGroupExt;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BaseAugmentationsEditor : MonoBehaviour
{
	public Transform augmentation_groups_parent;

	public Text text_counter_augmentations;

	public LocalizedText window_title_text;

	public Image power_icon;

	public Transform powers_icons;

	public GridLayoutGroupExtended selected_editor_augmentations_grid;

	public RainSwitcherButton rain_state_switcher;

	protected List<string> augmentations_list_link;

	protected readonly HashSet<string> augmentations_hashset = new HashSet<string>();

	public bool rain_editor;

	public RainState rain_editor_state;

	private bool _groups_initialized;

	private bool _created;

	private StatsWindow _stats_window;

	protected ToggleRainStateAction rain_state_toggle_action;

	private void Awake()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		create();
		_stats_window = ((Component)this).GetComponentInParent<StatsWindow>();
		RainSwitcherButton rainSwitcherButton = rain_state_switcher;
		if (rainSwitcherButton != null)
		{
			((UnityEvent)rainSwitcherButton.getButton().onClick).AddListener((UnityAction)delegate
			{
				rain_state_toggle_action();
			});
		}
	}

	protected virtual void OnEnable()
	{
		reloadButtons();
		checkEnabledGroups();
		if (!rain_editor)
		{
			_stats_window.updateStats();
		}
	}

	protected virtual void create()
	{
		if (!_created)
		{
			_created = true;
		}
	}

	protected virtual void onEnableRain()
	{
		throw new NotImplementedException();
	}

	public virtual void reloadButtons()
	{
		if (((Component)this).gameObject.activeInHierarchy)
		{
			loadAugmentationGroups();
		}
	}

	protected virtual void showActiveButtons()
	{
		throw new NotImplementedException();
	}

	private void loadAugmentationGroups()
	{
		if (!_groups_initialized)
		{
			_groups_initialized = true;
			groupsBuilder();
		}
	}

	protected virtual void checkEnabledGroups()
	{
		throw new NotImplementedException();
	}

	protected virtual void groupsBuilder()
	{
		throw new NotImplementedException();
	}

	protected virtual void startSignal()
	{
	}

	protected virtual void onNanoWasModified()
	{
		throw new NotImplementedException();
	}

	protected virtual void toggleRainState(ref RainState pState)
	{
		if (pState == RainState.Add)
		{
			pState = RainState.Remove;
			rain_state_switcher.toggleState(pState: true);
		}
		else
		{
			pState = RainState.Add;
			rain_state_switcher.toggleState(pState: false);
		}
		rain_editor_state = pState;
		reloadButtons();
	}
}
// --- End of File: BaseAugmentationsEditor.cs ---



// --- Start of File: BaseBuildingComponent.cs ---
using System;

public class BaseBuildingComponent : IDisposable
{
	internal Building building;

	internal virtual void create(Building pBuilding)
	{
		building = pBuilding;
	}

	public virtual void update(float pElapsed)
	{
	}

	public virtual void Dispose()
	{
		building = null;
	}
}
// --- End of File: BaseBuildingComponent.cs ---



// --- Start of File: BaseCallback.cs ---
public delegate void BaseCallback();
// --- End of File: BaseCallback.cs ---



// --- Start of File: BaseCategoryAsset.cs ---
using System;
using UnityEngine;

[Serializable]
public class BaseCategoryAsset : Asset, ILocalizedAsset
{
	public string name;

	public string color;

	public bool show_counter = true;

	[NonSerialized]
	public Color? _color;

	public virtual string getLocaleID()
	{
		return name;
	}

	public Color getColor()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!_color.HasValue)
		{
			_color = Toolbox.makeColor(color);
		}
		return _color.Value;
	}
}
// --- End of File: BaseCategoryAsset.cs ---



// --- Start of File: BaseCategoryLibrary.cs ---
using System;

[Serializable]
public class BaseCategoryLibrary<T> : AssetLibrary<T> where T : BaseCategoryAsset
{
	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (T item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}
}
// --- End of File: BaseCategoryLibrary.cs ---



// --- Start of File: BaseDebugAnimationElement.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BaseDebugAnimationElement<TAsset> : MonoBehaviour where TAsset : Asset
{
	protected TAsset asset;

	public Button play_pause_button;

	public Image play_pause_icon;

	public Sprite sprite_play;

	public Sprite sprite_pause;

	public Button frame_number_button;

	public Text frame_number_text;

	protected bool is_playing;

	protected virtual void Start()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		((UnityEvent)play_pause_button.onClick).AddListener(new UnityAction(clickToggleState));
		((UnityEvent)frame_number_button.onClick).AddListener(new UnityAction(clickNextFrame));
	}

	public virtual void update()
	{
		throw new NotImplementedException();
	}

	public virtual void setData(TAsset pAsset)
	{
		asset = pAsset;
		clear();
		is_playing = true;
	}

	protected virtual void clear()
	{
		throw new NotImplementedException();
	}

	public virtual void stopAnimations()
	{
		is_playing = false;
		checkButtons();
	}

	public virtual void startAnimations()
	{
		is_playing = true;
		checkButtons();
	}

	private void clickToggleState()
	{
		is_playing = !is_playing;
		if (is_playing)
		{
			startAnimations();
		}
		else
		{
			stopAnimations();
		}
	}

	private void checkButtons()
	{
		if (is_playing)
		{
			play_pause_icon.sprite = sprite_pause;
			((Selectable)frame_number_button).interactable = false;
		}
		else
		{
			play_pause_icon.sprite = sprite_play;
			((Selectable)frame_number_button).interactable = true;
		}
	}

	protected virtual void clickNextFrame()
	{
		throw new NotImplementedException();
	}
}
// --- End of File: BaseDebugAnimationElement.cs ---



// --- Start of File: BaseDebugAssetElement.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BaseDebugAssetElement<TAsset> : MonoBehaviour where TAsset : Asset
{
	public static TAsset selected_asset;

	internal TAsset asset;

	public Sprite no_animation;

	public Button asset_button;

	public Text title;

	public Text stats_description;

	public Text stats_values;

	internal RectTransform rect_transform;

	private void Awake()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		rect_transform = ((Component)this).GetComponent<RectTransform>();
		((UnityEvent)asset_button.onClick).AddListener(new UnityAction(showAssetWindow));
		asset_button.OnHover((UnityAction)delegate
		{
			selected_asset = asset;
		});
	}

	public virtual void setData(TAsset pAsset)
	{
		asset = pAsset;
		title.text = asset.id;
		initAnimations();
		initStats();
	}

	protected virtual void initAnimations()
	{
		throw new NotImplementedException();
	}

	public virtual void update()
	{
		throw new NotImplementedException();
	}

	public virtual void stopAnimations()
	{
		throw new NotImplementedException();
	}

	public virtual void startAnimations()
	{
		throw new NotImplementedException();
	}

	protected virtual void initStats()
	{
		stats_description.text = "";
		stats_values.text = "";
	}

	protected void showStat(string pID, object pValue)
	{
		Text obj = stats_description;
		obj.text = obj.text + LocalizedTextManager.getText(pID) + "\n";
		Text obj2 = stats_values;
		obj2.text = obj2.text + pValue?.ToString() + "\n";
	}

	protected virtual void showAssetWindow()
	{
		selected_asset = asset;
	}
}
// --- End of File: BaseDebugAssetElement.cs ---



// --- Start of File: BaseDebugAssetsComponent.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BaseDebugAssetsComponent<TAsset, TAssetElement, TAssetElementPlace> : MonoBehaviour where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset> where TAssetElementPlace : BaseAssetElementPlace<TAsset, TAssetElement>
{
	public TAssetElementPlace place_prefab;

	public TAssetElement element_prefab;

	public ScrollRect scroll_rect;

	private RectTransform _scroll_rect_transform;

	private Rect _scroll_world_rect;

	public InputField search_input_field;

	public SortingTab sorting_tab;

	protected List<TAsset> list_assets_sorted;

	protected List<TAsset> list_assets_sorting;

	protected List<TAsset> list_assets_sorting_default;

	protected bool default_sort_reversed;

	protected List<TAssetElementPlace> list_places;

	private bool _initialized;

	protected virtual List<TAsset> getAssetsList()
	{
		throw new NotImplementedException();
	}

	protected virtual List<TAsset> getListCivsSort()
	{
		throw new NotImplementedException();
	}

	private void OnEnable()
	{
		refresh();
	}

	private void Start()
	{
		_scroll_rect_transform = ((Component)scroll_rect).GetComponent<RectTransform>();
		((UnityEvent<string>)(object)search_input_field.onValueChanged).AddListener((UnityAction<string>)setDataSearched);
		init();
	}

	protected virtual void init()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		list_assets_sorted = new List<TAsset>(getAssetsList());
		list_assets_sorting = new List<TAsset>(getAssetsList());
		list_assets_sorting_default = new List<TAsset>(getAssetsList());
		foreach (Transform item in ((Component)this).transform)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
		list_places = new List<TAssetElementPlace>();
		foreach (TAsset assets in getAssetsList())
		{
			TAssetElementPlace val = Object.Instantiate<TAssetElementPlace>(place_prefab, ((Component)this).transform);
			list_places.Add(val);
			val.setData(assets, element_prefab);
		}
		sorting_tab.addButton("ui/Icons/iconHumans", "sort_by_civs", setDataResorted, delegate
		{
			list_assets_sorted = getListCivsSort();
		});
		sorting_tab.addButton("ui/Icons/actor_traits/iconClumsy", "default_sort", setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting_default;
			if (sorting_tab.getCurrentButton().getState() == SortButtonState.Down || default_sort_reversed)
			{
				default_sort_reversed = !default_sort_reversed;
				list_assets_sorted.Reverse();
			}
		}).click();
		_initialized = true;
	}

	private void Update()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!_initialized)
		{
			return;
		}
		_scroll_world_rect = _scroll_rect_transform.GetWorldRect();
		foreach (TAssetElementPlace list_place in list_places)
		{
			if (list_place.game_object_cache.activeSelf)
			{
				if ((Object)(object)list_place.element != (Object)null)
				{
					list_place.element.update();
				}
				checkVisible(list_place);
			}
		}
	}

	private void checkVisible(TAssetElementPlace pPlace)
	{
		if (((Component)pPlace).gameObject.activeSelf)
		{
			bool flag = isElementVisible(pPlace);
			if (!flag && pPlace.has_element)
			{
				pPlace.clear();
			}
			else if (flag && !pPlace.has_element)
			{
				TAsset pAsset = list_assets_sorted[((Transform)pPlace.rect_transform).GetSiblingIndex()];
				pPlace.setData(pAsset, element_prefab);
			}
		}
	}

	public void refresh()
	{
		if (_initialized)
		{
			setDataResorted();
		}
	}

	public bool isElementVisible(TAssetElementPlace pPlace)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ((Rect)(ref _scroll_world_rect)).Overlaps(pPlace.rect_transform.GetWorldRect());
	}

	protected void setDataResorted()
	{
		int num = list_assets_sorted.Count - 1;
		for (int i = 0; i < list_places.Count; i++)
		{
			TAssetElementPlace val = list_places[i];
			if (i > num)
			{
				val.game_object_cache.SetActive(false);
				val.allowed_for_search = false;
				continue;
			}
			val.game_object_cache.SetActive(true);
			val.allowed_for_search = true;
			if (isElementVisible(val) && val.has_element)
			{
				TAsset data = list_assets_sorted[i];
				val.element.setData(data);
			}
		}
		setDataSearched(search_input_field.text);
	}

	protected void checkReverseSort()
	{
		if (sorting_tab.getCurrentButton().getState() == SortButtonState.Down)
		{
			list_assets_sorted.Reverse();
		}
	}

	private void setDataSearched(string pValue)
	{
		if (!((Component)this).gameObject.activeSelf)
		{
			return;
		}
		pValue = pValue.ToLower();
		if (string.IsNullOrEmpty(pValue))
		{
			foreach (TAssetElementPlace list_place in list_places)
			{
				if (list_place.allowed_for_search)
				{
					list_place.game_object_cache.SetActive(true);
				}
			}
			return;
		}
		for (int i = 0; i < list_assets_sorted.Count; i++)
		{
			TAssetElementPlace val = list_places[i];
			if (val.allowed_for_search)
			{
				bool active = list_assets_sorted[i].id.ToLower().Contains(pValue);
				val.game_object_cache.SetActive(active);
			}
		}
	}
}
// --- End of File: BaseDebugAssetsComponent.cs ---



// --- Start of File: BaseDebugAssetWindow.cs ---
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

public class BaseDebugAssetWindow<TAsset, TAssetElement> : TabbedWindow where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset>
{
	public static TAssetElement current_element;

	public SpriteElement sprite_element_prefab;

	public TAssetElement asset_debug_element;

	public Transform sprite_elements_parent;

	public SortingTab sorting_tab;

	public FieldInfoList field_infos;

	public PowerButton show_sprites_button;

	public GameObject hidden_sprites_placeholder;

	private List<FieldInfo> _sorted_fields;

	private List<FieldInfo> _sorting_fields;

	private List<FieldInfo> _default_sorting_fields;

	private bool _default_reversed;

	protected TAsset asset;

	private SortButton _default_sort_button;

	private bool _initialized;

	protected override void create()
	{
		base.create();
		asset = BaseDebugAssetElement<TAsset>.selected_asset;
		sorting_tab.addButton("ui/Icons/onomastics/onomastics_vowel_separator", "sort_by_alphabet", setDataResorted, delegate
		{
			_sorted_fields = _sorting_fields;
			_sorted_fields.Sort(sortByName);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/onomastics/onomastics_consonant_separator", "sort_by_type", setDataResorted, delegate
		{
			_sorted_fields = _sorting_fields;
			_sorted_fields.Sort(sortByType);
			checkReverseSort();
		});
		_default_sort_button = sorting_tab.addButton("ui/Icons/actor_traits/iconClumsy", "default_sort", setDataResorted, delegate
		{
			_sorted_fields = _default_sorting_fields;
			if (sorting_tab.getCurrentButton().getState() == SortButtonState.Down || _default_reversed)
			{
				_default_reversed = !_default_reversed;
				_sorted_fields.Reverse();
			}
		});
	}

	private void OnEnable()
	{
		asset = BaseDebugAssetElement<TAsset>.selected_asset;
		current_element = asset_debug_element;
		_initialized = false;
	}

	private void Update()
	{
		load();
		asset_debug_element.update();
	}

	private void load()
	{
		if (!_initialized)
		{
			_initialized = true;
			scroll_window.titleText.text = asset.id;
			asset_debug_element.setData(asset);
			initSprites();
			field_infos.init<TAsset>();
			field_infos.setData(asset);
			_sorted_fields = new List<FieldInfo>(field_infos.field_infos);
			_sorting_fields = new List<FieldInfo>(field_infos.field_infos);
			_default_sorting_fields = new List<FieldInfo>(field_infos.field_infos);
			_default_sort_button.click();
		}
	}

	protected virtual void initSprites()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in sprite_elements_parent)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
	}

	public void clickShowAllSprites()
	{
		GameObject gameObject = ((Component)sprite_elements_parent).gameObject;
		bool flag = !gameObject.activeSelf;
		gameObject.SetActive(flag);
		hidden_sprites_placeholder.SetActive(!flag);
		if (flag)
		{
			show_sprites_button.icon.sprite = SpriteTextureLoader.getSprite("ui/icons/IconOn");
		}
		else
		{
			show_sprites_button.icon.sprite = SpriteTextureLoader.getSprite("ui/icons/IconOff");
		}
	}

	private void setDataResorted()
	{
		field_infos.clear();
		Dictionary<string, FieldInfoListItem> fields_collection_data = field_infos.fields_collection_data;
		fields_collection_data.Clear();
		for (int i = 0; i < _sorted_fields.Count; i++)
		{
			FieldInfoListItem fieldData = field_infos.getFieldData(_sorted_fields[i], asset);
			fields_collection_data.Add(fieldData.field_name, fieldData);
			field_infos.addRow(fieldData.field_name, fieldData.field_value);
		}
		field_infos.setDataSearched(field_infos.search_input_field.text);
	}

	private void checkReverseSort()
	{
		if (sorting_tab.getCurrentButton().getState() == SortButtonState.Down)
		{
			_sorted_fields.Reverse();
		}
	}

	private int sortByName(FieldInfo pObject1, FieldInfo pObject2)
	{
		return string.Compare(pObject1.Name, pObject2.Name, StringComparison.InvariantCulture);
	}

	private int sortByType(FieldInfo pObject1, FieldInfo pObject2)
	{
		return string.Compare(pObject1.FieldType.Name, pObject2.FieldType.Name, StringComparison.InvariantCulture);
	}
}
// --- End of File: BaseDebugAssetWindow.cs ---



// --- Start of File: BaseEffect.cs ---
using FMOD.Studio;
using UnityEngine;

public class BaseEffect : BaseAnimatedObject
{
	private const int MAP_MARGIN_TOP = 25;

	private const int MAP_OFFSET_BOTTOM_MIN = -50;

	private const int MAP_OFFSET_BOTTOM_MAX = 30;

	internal bool active;

	internal int effectIndex;

	public const int STATE_START = 1;

	public const int STATE_ON_DEATH = 2;

	public const int STATE_KILLED = 3;

	protected float scale;

	protected float alpha;

	public WorldTile tile;

	internal BaseEffectController controller;

	internal int state;

	private double _timestamp_spawned;

	internal SpriteRenderer sprite_renderer;

	internal BaseCallback callback;

	internal int callbackOnFrame = -1;

	internal EventInstance fmod_instance;

	internal Actor attachedToActor;

	public double timestamp_spawned => _timestamp_spawned;

	public override void Awake()
	{
		sprite_renderer = ((Component)this).GetComponent<SpriteRenderer>();
		base.Awake();
	}

	public void activate()
	{
		active = true;
		((Component)this).gameObject.SetActive(true);
		state = 1;
		_timestamp_spawned = Time.time;
		clear();
	}

	internal void attachTo(Actor pActor)
	{
		attachedToActor = pActor;
		updateAttached();
	}

	internal void makeParentController()
	{
		((Component)this).transform.SetParent(((Component)controller).transform, true);
	}

	internal virtual void prepare(WorldTile pTile, float pScale = 0.5f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		state = 1;
		((Component)this).transform.localEulerAngles = Vector3.zero;
		Vector2Int pos = pTile.pos;
		float num = (float)((Vector2Int)(ref pos)).x + 0.5f;
		pos = pTile.pos;
		current_position = Vector2.op_Implicit(new Vector3(num, (float)((Vector2Int)(ref pos)).y));
		((Component)this).transform.localPosition = Vector2.op_Implicit(current_position);
		setScale(pScale);
		setAlpha(1f);
		resetAnim();
	}

	public void setScale(float pScale)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		scale = pScale;
		if (scale < 0f)
		{
			scale = 0f;
		}
		((Component)this).transform.localScale = new Vector3(pScale, pScale);
	}

	internal virtual void prepare(Vector2 pVector, float pScale = 1f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		state = 1;
		((Component)this).transform.rotation = Quaternion.identity;
		((Component)this).transform.localPosition = Vector2.op_Implicit(pVector);
		setScale(pScale);
		setAlpha(1f);
		resetAnim();
	}

	protected void setAlpha(float pVal)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		alpha = pVal;
		Color color = sprite_renderer.color;
		color.a = alpha;
		sprite_renderer.color = color;
	}

	internal virtual void prepare()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.position = new Vector3((float)Randy.randomInt(-50, 30), (float)Randy.randomInt(0, MapBox.height + 25));
		state = 1;
		setAlpha(0f);
	}

	internal virtual void spawnOnTile(WorldTile pTile)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		tile = pTile;
		((Component)this).transform.localPosition = new Vector3(pTile.posV3.x, pTile.posV3.y);
	}

	internal void startToDie()
	{
		state = 2;
	}

	public virtual void kill()
	{
		state = 3;
		controller.killObject(this);
	}

	public void deactivate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (((EventInstance)(ref fmod_instance)).isValid())
		{
			((EventInstance)(ref fmod_instance)).stop((STOP_MODE)0);
			((EventInstance)(ref fmod_instance)).release();
		}
		active = false;
		((Component)this).transform.SetParent(((Component)this).transform);
		((Component)this).gameObject.SetActive(false);
		clear();
	}

	public void clear()
	{
		tile = null;
		attachedToActor = null;
		callback = null;
		callbackOnFrame = -1;
	}

	public override void update(float pElapsed)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (controller.asset.draw_light_area)
		{
			Vector2 position = Vector2.op_Implicit(((Component)this).transform.position);
			position.x += controller.asset.draw_light_area_offset_x;
			position.y += controller.asset.draw_light_area_offset_y;
			World.world.stack_effects.light_blobs.Add(new LightBlobData
			{
				position = position,
				radius = controller.asset.draw_light_size
			});
		}
		if (!World.world.isPaused() || !DebugConfig.isOn(DebugOption.PauseEffects))
		{
			if (attachedToActor != null)
			{
				updateAttached();
			}
			base.update(pElapsed);
			if (callbackOnFrame != -1 && sprite_animation.currentFrameIndex == callbackOnFrame)
			{
				callback();
				clear();
			}
		}
	}

	private void updateAttached()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (!attachedToActor.isAlive())
		{
			kill();
			return;
		}
		sprite_renderer.flipX = attachedToActor.a.flip;
		((Component)this).transform.localScale = attachedToActor.current_scale;
		((Component)this).transform.localPosition = attachedToActor.cur_transform_position;
		((Component)this).transform.eulerAngles = attachedToActor.current_rotation;
	}

	public void setCallback(int pFrame, BaseCallback pCallback)
	{
		callbackOnFrame = pFrame;
		callback = pCallback;
	}

	public bool isKilled()
	{
		return state == 3;
	}
}
// --- End of File: BaseEffect.cs ---



// --- Start of File: BaseEffectController.cs ---
using System.Collections.Generic;
using UnityEngine;

public class BaseEffectController : BaseMapObject
{
	public Transform prefab;

	private int _active_index;

	private readonly List<BaseEffect> _list = new List<BaseEffect>();

	private float _timer;

	private float _timer_interval = 1f;

	private bool _object_limit_used;

	private int _object_limit;

	private bool _limit_unload;

	public bool useInterval = true;

	public EffectAsset asset;

	internal override void create()
	{
		base.create();
		_timer_interval = 0.9f;
	}

	public void setLimits(int pLimitObjects, bool pLimitUnload)
	{
		if (pLimitObjects > 0)
		{
			_object_limit_used = true;
		}
		_object_limit = pLimitObjects;
		_limit_unload = pLimitUnload;
	}

	public BaseEffect GetObject()
	{
		BaseEffect baseEffect = null;
		List<BaseEffect> list = _list;
		if (list.Count > _active_index)
		{
			baseEffect = list[_active_index];
		}
		else
		{
			baseEffect = ((Component)Object.Instantiate<Transform>(prefab)).gameObject.GetComponent<BaseEffect>();
			addNewObject(baseEffect);
			if (!baseEffect.created)
			{
				baseEffect.create();
			}
			list.Add(baseEffect);
			baseEffect.effectIndex = list.Count;
		}
		_active_index++;
		baseEffect.activate();
		return baseEffect;
	}

	public int getActiveIndex()
	{
		return _active_index;
	}

	internal void addNewObject(BaseEffect pEffect)
	{
		pEffect.controller = this;
		((Component)pEffect).transform.parent = ((Component)this).transform;
	}

	public void killObject(BaseEffect pObject)
	{
		if (pObject.active)
		{
			makeInactive(pObject);
			List<BaseEffect> list = _list;
			int num = pObject.effectIndex - 1;
			int num2 = _active_index - 1;
			if (num != num2)
			{
				BaseEffect baseEffect = list[num2];
				list[num2] = pObject;
				list[num] = baseEffect;
				pObject.effectIndex = num2 + 1;
				baseEffect.effectIndex = num + 1;
			}
			if (_active_index > 0)
			{
				_active_index--;
			}
		}
	}

	private void makeInactive(BaseEffect pObject)
	{
		pObject.deactivate();
	}

	private void debugString()
	{
		string text = "";
		List<BaseEffect> list = _list;
		for (int i = 0; i < list.Count; i++)
		{
			text = ((!list[i].active) ? (text + "x") : (text + "O"));
		}
		Debug.Log((object)(text + " ::: " + _active_index));
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		updateChildren(pElapsed);
		updateSpawn(pElapsed);
	}

	private void updateSpawn(float pElapsed)
	{
		if (!World.world.isPaused() && useInterval)
		{
			if (_timer > 0f)
			{
				_timer -= pElapsed;
				return;
			}
			_timer = _timer_interval;
			spawn();
		}
	}

	private void updateChildren(float pElapsed)
	{
		List<BaseEffect> list = _list;
		for (int num = _active_index - 1; num >= 0; num--)
		{
			BaseEffect baseEffect = list[num];
			if (baseEffect.created && baseEffect.active)
			{
				baseEffect.update(pElapsed);
			}
		}
	}

	public virtual void spawn()
	{
	}

	public BaseEffect spawnNew()
	{
		if (isLimitReached())
		{
			if (!_limit_unload)
			{
				return null;
			}
			killOldest();
		}
		BaseEffect @object = GetObject();
		if ((Object)(object)@object.sprite_animation != (Object)null)
		{
			@object.sprite_animation.resetAnim();
		}
		return @object;
	}

	private void killOldest()
	{
		if (_list.Count == 0)
		{
			return;
		}
		BaseEffect pObject = _list[0];
		double num = double.MaxValue;
		foreach (BaseEffect item in _list)
		{
			if (item.timestamp_spawned < num)
			{
				pObject = item;
				num = item.timestamp_spawned;
			}
		}
		killObject(pObject);
	}

	internal bool isLimitReached()
	{
		if (_object_limit_used && _active_index >= _object_limit)
		{
			return true;
		}
		return false;
	}

	internal void clear()
	{
		List<BaseEffect> list = _list;
		for (int i = 0; i < list.Count; i++)
		{
			BaseEffect pObject = list[i];
			makeInactive(pObject);
		}
		_active_index = 0;
	}

	public bool isAnyActive()
	{
		return _active_index > 0;
	}

	internal void debug(DebugTool pTool)
	{
		pTool.setText(((Object)this).name, _active_index + "/" + _list.Count, 0f, pShowBar: false, 0L);
	}

	internal List<BaseEffect> getList()
	{
		return _list;
	}
}
// --- End of File: BaseEffectController.cs ---



// --- Start of File: BaseEmptyListMono.cs ---
using UnityEngine;

public class BaseEmptyListMono : MonoBehaviour
{
	internal NanoObject meta_object;

	internal MonoBehaviour element;

	private bool has_element;

	private bool has_object;

	public RectTransform rect_transform;

	internal string debug_original_name;

	public void Awake()
	{
		rect_transform = ((Component)this).GetComponent<RectTransform>();
	}

	public void assignObject(NanoObject pObject)
	{
		meta_object = pObject;
		has_object = true;
	}

	public void assignElement(MonoBehaviour pElement)
	{
		element = pElement;
		has_element = true;
	}

	public bool hasElement()
	{
		return has_element;
	}

	public void clearElement()
	{
		element = null;
		has_element = false;
	}

	public void clearObject()
	{
		meta_object = null;
		has_object = false;
	}

	public bool hasObject()
	{
		return has_object;
	}

	public void debugUpdateName(bool tVisible)
	{
		if (string.IsNullOrEmpty(debug_original_name))
		{
			debug_original_name = ((Object)((Component)this).gameObject).name;
		}
		if (tVisible)
		{
			((Object)((Component)this).gameObject).name = "(v) (" + ((Component)this).gameObject.transform.childCount + ") " + debug_original_name;
		}
		else
		{
			((Object)((Component)this).gameObject).name = "(i) (" + ((Component)this).gameObject.transform.childCount + ") " + debug_original_name;
		}
	}
}
// --- End of File: BaseEmptyListMono.cs ---



// --- Start of File: BaseGrid.cs ---
using System;
using System.Collections.Generic;

namespace EpPathFinding.cs;

public abstract class BaseGrid : IDisposable
{
	public readonly List<Node> closedList = new List<Node>();

	public int closed_list_count;

	public const int CLOSED_LIST_MINIMUM_ELEMENTS = 10;

	protected GridRect m_gridRect;

	public GridRect gridRect => m_gridRect;

	public abstract int width { get; protected set; }

	public abstract int height { get; protected set; }

	public BaseGrid()
	{
		m_gridRect = new GridRect();
	}

	public BaseGrid(BaseGrid b)
	{
		m_gridRect = new GridRect(b.m_gridRect);
		width = b.width;
		height = b.height;
	}

	public abstract Node GetNodeAt(int iX, int iY);

	public abstract bool IsWalkableAt(int iX, int iY);

	public abstract bool SetWalkableAt(int iX, int iY, bool iWalkable, int pCost = 1);

	public abstract Node GetNodeAt(GridPos iPos);

	public abstract bool IsWalkableAt(GridPos iPos);

	public abstract bool SetWalkableAt(GridPos iPos, bool iWalkable);

	public List<Node> GetNeighbors(Node iNode, DiagonalMovement diagonalMovement)
	{
		int x = iNode.x;
		int y = iNode.y;
		List<Node> list = new List<Node>();
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		bool flag6 = false;
		bool flag7 = false;
		bool flag8 = false;
		GridPos gridPos = new GridPos();
		if (IsWalkableAt(gridPos.Set(x, y - 1)))
		{
			list.Add(GetNodeAt(gridPos));
			flag = true;
		}
		if (IsWalkableAt(gridPos.Set(x + 1, y)))
		{
			list.Add(GetNodeAt(gridPos));
			flag3 = true;
		}
		if (IsWalkableAt(gridPos.Set(x, y + 1)))
		{
			list.Add(GetNodeAt(gridPos));
			flag5 = true;
		}
		if (IsWalkableAt(gridPos.Set(x - 1, y)))
		{
			list.Add(GetNodeAt(gridPos));
			flag7 = true;
		}
		switch (diagonalMovement)
		{
		case DiagonalMovement.Always:
			flag2 = true;
			flag4 = true;
			flag6 = true;
			flag8 = true;
			break;
		case DiagonalMovement.IfAtLeastOneWalkable:
			flag2 = flag7 || flag;
			flag4 = flag || flag3;
			flag6 = flag3 || flag5;
			flag8 = flag5 || flag7;
			break;
		case DiagonalMovement.OnlyWhenNoObstacles:
			flag2 = flag7 && flag;
			flag4 = flag && flag3;
			flag6 = flag3 && flag5;
			flag8 = flag5 && flag7;
			break;
		}
		if (flag2 && IsWalkableAt(gridPos.Set(x - 1, y - 1)))
		{
			list.Add(GetNodeAt(gridPos));
		}
		if (flag4 && IsWalkableAt(gridPos.Set(x + 1, y - 1)))
		{
			list.Add(GetNodeAt(gridPos));
		}
		if (flag6 && IsWalkableAt(gridPos.Set(x + 1, y + 1)))
		{
			list.Add(GetNodeAt(gridPos));
		}
		if (flag8 && IsWalkableAt(gridPos.Set(x - 1, y + 1)))
		{
			list.Add(GetNodeAt(gridPos));
		}
		return list;
	}

	public void addToClosed(Node pNode)
	{
		closedList.Add(pNode);
		closed_list_count++;
	}

	public abstract void Reset();

	public abstract BaseGrid Clone();

	public virtual void Dispose()
	{
		foreach (Node closed in closedList)
		{
			closed.Dispose();
		}
		closedList.Clear();
		closed_list_count = 0;
		m_gridRect = null;
	}
}
// --- End of File: BaseGrid.cs ---



// --- Start of File: BaseLibraryWithUnlockables.cs ---
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

[Serializable]
public class BaseLibraryWithUnlockables<T> : AssetLibrary<T>, ILibraryWithUnlockables where T : BaseUnlockableAsset
{
	[JsonIgnore]
	public IEnumerable<BaseUnlockableAsset> elements_list => list;

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (T item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}
}
// --- End of File: BaseLibraryWithUnlockables.cs ---



// --- Start of File: BaseMapObject.cs ---
using UnityEngine;

public class BaseMapObject : BaseWorldObject
{
	public WorldTile current_tile;

	public float position_height;

	public Vector2 current_position;

	public override void Dispose()
	{
		current_tile = null;
		base.Dispose();
	}
}
// --- End of File: BaseMapObject.cs ---



// --- Start of File: BaseMapObjectSimple.cs ---
public class BaseMapObjectSimple
{
	internal bool created;

	public virtual void update(float pElapsed)
	{
	}

	internal virtual void create()
	{
		created = true;
	}
}
// --- End of File: BaseMapObjectSimple.cs ---



// --- Start of File: BaseModule.cs ---
using System.Collections.Generic;

public class BaseModule : BaseMapObject
{
	internal HashSet<WorldTile> hashset;

	protected float timer;

	internal virtual void clear()
	{
	}
}
// --- End of File: BaseModule.cs ---



// --- Start of File: BaseObjectData.cs ---
using System;
using System.ComponentModel;

[Serializable]
public abstract class BaseObjectData : BaseSystemData
{
	[DefaultValue(100)]
	public int health { get; set; } = 100;

}
// --- End of File: BaseObjectData.cs ---



// --- Start of File: BaseSimObject.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class BaseSimObject : NanoObject, IEquatable<BaseSimObject>
{
	public float position_height;

	public WorldTile current_tile;

	public Vector2 current_position;

	public Vector3 current_scale;

	internal Vector3 current_rotation;

	private HashSet<long> _targets_to_ignore;

	[NonSerialized]
	public Kingdom kingdom;

	private bool _stats_dirty;

	internal bool event_full_stats;

	internal readonly BaseStats stats = new BaseStats();

	internal Actor a;

	internal Building b;

	private MapObjectType _object_type;

	private readonly Dictionary<string, Status> _active_status_dict = new Dictionary<string, Status>();

	private bool _has_any_status_cached;

	private bool _has_any_status_to_render;

	internal Vector3 cur_transform_position;

	public TileIsland current_island => current_tile.region.island;

	public TileZone current_zone => current_tile.zone;

	public MapChunk current_chunk => current_tile.chunk;

	public MapRegion current_region => current_tile.region;

	public MapChunk chunk => current_tile.chunk;

	internal virtual void create()
	{
	}

	public int countStatusEffects()
	{
		return _active_status_dict.Count;
	}

	public Dictionary<string, Status>.ValueCollection getStatuses()
	{
		return _active_status_dict.Values;
	}

	public Dictionary<string, Status>.KeyCollection getStatusesIds()
	{
		return _active_status_dict.Keys;
	}

	public IReadOnlyDictionary<string, Status> getStatusesDict()
	{
		return _active_status_dict;
	}

	protected override void setDefaultValues()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		base.setDefaultValues();
		_stats_dirty = true;
		event_full_stats = false;
		current_rotation = default(Vector3);
		position_height = 0f;
		_has_any_status_cached = false;
		_has_any_status_to_render = false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasCity()
	{
		return getCity() != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public virtual City getCity()
	{
		return null;
	}

	internal bool addStatusEffect(string pID, float pOverrideTimer = 0f, bool pColorEffect = true)
	{
		StatusAsset statusAsset = AssetManager.status.get(pID);
		if (statusAsset == null)
		{
			return false;
		}
		return addStatusEffect(statusAsset, pOverrideTimer, pColorEffect);
	}

	internal virtual bool addStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer = 0f, bool pColorEffect = true)
	{
		if (!isAlive())
		{
			return false;
		}
		bool flag = isActor();
		if (flag && a.asset.allowed_status_tiers < pStatusAsset.tier)
		{
			return false;
		}
		bool flag2 = hasAnyStatusEffectRaw();
		if (flag2 && hasStatus(pStatusAsset.id))
		{
			if (!pStatusAsset.allow_timer_reset && pOverrideTimer == 0f)
			{
				return false;
			}
			Status status = _active_status_dict[pStatusAsset.id];
			float num = pStatusAsset.duration;
			if (pOverrideTimer != 0f)
			{
				num = pOverrideTimer;
			}
			if (status.getRemainingTime() < (double)num)
			{
				status.setDuration(num);
			}
			return true;
		}
		if (!canAddStatus(pStatusAsset, flag, pColorEffect))
		{
			return false;
		}
		addNewStatusEffect(pStatusAsset, pOverrideTimer, pColorEffect, flag, flag2);
		return true;
	}

	private bool canAddStatus(StatusAsset pStatusAsset, bool pIsActor, bool pHasAnyStatus)
	{
		if (pIsActor)
		{
			if (pStatusAsset.opposite_traits != null)
			{
				for (int i = 0; i < pStatusAsset.opposite_traits.Length; i++)
				{
					string pTraitID = pStatusAsset.opposite_traits[i];
					if (a.hasTrait(pTraitID))
					{
						return false;
					}
				}
			}
			if (pStatusAsset.opposite_tags != null && a.stats.hasTags() && a.stats.hasTags(pStatusAsset.opposite_tags))
			{
				return false;
			}
		}
		if (pStatusAsset.opposite_status != null && pHasAnyStatus)
		{
			for (int j = 0; j < pStatusAsset.opposite_status.Length; j++)
			{
				string pID = pStatusAsset.opposite_status[j];
				if (hasStatus(pID))
				{
					return false;
				}
			}
		}
		return true;
	}

	private void addNewStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer, bool pColorEffect, bool pIsActor, bool pHasAnyStatus)
	{
		Status value = World.world.statuses.newStatus(this, pStatusAsset, pOverrideTimer);
		setStatsDirty();
		_active_status_dict.Add(pStatusAsset.id, value);
		_has_any_status_cached = true;
		if (pIsActor && pStatusAsset.cancel_actor_job && pColorEffect)
		{
			a.cancelAllBeh();
			a.startColorEffect();
		}
		if (pStatusAsset.remove_status != null && pHasAnyStatus)
		{
			for (int i = 0; i < pStatusAsset.remove_status.Length; i++)
			{
				string pID = pStatusAsset.remove_status[i];
				finishStatusEffect(pID);
			}
		}
		if (pIsActor)
		{
			pStatusAsset.action_on_receive?.Invoke(this);
		}
	}

	internal void finishAllStatusEffects()
	{
		foreach (Status value in _active_status_dict.Values)
		{
			value.finish();
			setStatsDirty();
		}
		_active_status_dict.Clear();
		_has_any_status_cached = false;
		_has_any_status_to_render = false;
	}

	public void finishStatusEffect(string pID)
	{
		if (hasAnyStatusEffect() && _active_status_dict.TryGetValue(pID, out var value))
		{
			value.finish();
			setStatsDirty();
		}
	}

	public virtual void setStatsDirty()
	{
		_stats_dirty = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isActor()
	{
		return _object_type == MapObjectType.Actor;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isBuilding()
	{
		return _object_type == MapObjectType.Building;
	}

	public void setObjectType(MapObjectType pType)
	{
		_object_type = pType;
		if (_object_type == MapObjectType.Actor)
		{
			a = (Actor)this;
		}
		else
		{
			b = (Building)this;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool hasStatus(string pID)
	{
		return _active_status_dict.ContainsKey(pID);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool hasAnyStatusEffect()
	{
		return _has_any_status_cached;
	}

	internal bool hasAnyStatusEffectRaw()
	{
		return _active_status_dict.Count > 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool hasAnyStatusEffectToRender()
	{
		return _has_any_status_to_render;
	}

	public void removeFinishedStatusEffect(Status pStatusData)
	{
		_active_status_dict.Remove(pStatusData.asset.id);
		_has_any_status_cached = hasAnyStatusEffectRaw();
		setStatsDirty();
	}

	internal virtual void updateStats()
	{
		_stats_dirty = false;
		stats_dirty_version++;
		updateCachedStatusEffects();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isStatsDirty()
	{
		return _stats_dirty;
	}

	private void updateCachedStatusEffects()
	{
		_has_any_status_cached = hasAnyStatusEffectRaw();
		_has_any_status_to_render = false;
		if (!_has_any_status_cached)
		{
			return;
		}
		foreach (Status value in _active_status_dict.Values)
		{
			if (!value.is_finished && value.asset.need_visual_render)
			{
				_has_any_status_to_render = true;
				break;
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isInLiquid()
	{
		return current_tile.Type.liquid;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isInWater()
	{
		return current_tile.Type.ocean;
	}

	public bool isTouchingLiquid()
	{
		if (isInLiquid())
		{
			return !isInAir();
		}
		return false;
	}

	internal virtual bool isInAir()
	{
		return false;
	}

	internal virtual bool isFlying()
	{
		return false;
	}

	internal virtual float getHeight()
	{
		return 0f;
	}

	internal virtual void getHit(float pDamage, bool pFlash = true, AttackType pAttackType = AttackType.Other, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
	{
	}

	internal virtual void getHitFullHealth(AttackType pAttackType)
	{
	}

	internal BaseSimObject findEnemyObjectTarget(bool pAttackBuildings)
	{
		EnemyFinderData enemyFinderData = EnemiesFinder.findEnemiesFrom(current_tile, kingdom);
		if (enemyFinderData.isEmpty())
		{
			return null;
		}
		bool flag = true;
		if (enemyFinderData.list.Count > 50)
		{
			flag = Randy.randomChance(0.6f);
		}
		IEnumerable<BaseSimObject> pList;
		if (!flag)
		{
			pList = enemyFinderData.list.LoopRandom();
		}
		else
		{
			IEnumerable<BaseSimObject> list = enemyFinderData.list;
			pList = list;
		}
		return checkObjectList(pList, pAttackBuildings, flag, pIgnoreStunned: false);
	}

	protected BaseSimObject checkObjectList(IEnumerable<BaseSimObject> pList, bool pAttackBuildings, bool pFindClosest, bool pIgnoreStunned, int pMaxDist = int.MaxValue)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		int num = int.MaxValue;
		BaseSimObject result = null;
		long num2 = ((pMaxDist == int.MaxValue) ? pMaxDist : (pMaxDist * pMaxDist + 1));
		bool flag = isActor() && a.hasMeleeAttack();
		WorldTile worldTile = current_tile;
		Vector2Int pos = worldTile.pos;
		foreach (BaseSimObject p in pList)
		{
			if (!p.isAlive() || p == this)
			{
				continue;
			}
			WorldTile worldTile2 = p.current_tile;
			if (pFindClosest)
			{
				num = Toolbox.SquaredDistVec2(worldTile2.pos, pos);
				if (num >= num2)
				{
					continue;
				}
			}
			if ((!pIgnoreStunned || !p.isActor() || !p.a.hasStatusStunned()) && canAttackTarget(p, pCheckForFactions: true, pAttackBuildings) && (!flag || worldTile2.isSameIsland(worldTile) || (!worldTile2.Type.block && worldTile.region.island.isConnectedWith(worldTile2.region.island))) && (!p.isBuilding() || !isKingdomCiv() || !p.b.asset.city_building || p.b.asset.tower || !(p.kingdom.getSpecies() == kingdom.getSpecies())) && !shouldIgnoreTarget(p))
			{
				if (!pFindClosest)
				{
					return p;
				}
				if (num <= 4)
				{
					return p;
				}
				result = p;
				num2 = num;
			}
		}
		return result;
	}

	internal void ignoreTarget(BaseSimObject pTarget)
	{
		if (_targets_to_ignore == null)
		{
			_targets_to_ignore = new HashSet<long>();
		}
		_targets_to_ignore.Add(pTarget.getID());
	}

	internal bool shouldIgnoreTarget(BaseSimObject pTarget)
	{
		return _targets_to_ignore?.Contains(pTarget.getID()) ?? false;
	}

	internal void clearIgnoreTargets()
	{
		_targets_to_ignore?.Clear();
	}

	internal int countTargetsToIgnore()
	{
		return _targets_to_ignore?.Count ?? 0;
	}

	internal bool canAttackTarget(BaseSimObject pTarget, bool pCheckForFactions = true, bool pAttackBuildings = true)
	{
		if (!isAlive())
		{
			return false;
		}
		if (!pTarget.isAlive())
		{
			return false;
		}
		bool flag = isActor();
		if (pTarget.isBuilding() && !pAttackBuildings)
		{
			if (!flag || !a.asset.unit_zombie)
			{
				return false;
			}
			if (!pTarget.kingdom.asset.brain)
			{
				return false;
			}
		}
		string species;
		WeaponType weaponType;
		if (flag)
		{
			if (a.asset.skip_fight_logic)
			{
				return false;
			}
			species = a.asset.id;
			weaponType = a._attack_asset.attack_type;
		}
		else
		{
			species = b.kingdom.getSpecies();
			weaponType = WeaponType.Range;
		}
		if (pTarget.isActor())
		{
			Actor actor = pTarget.a;
			if (!actor.asset.can_be_killed_by_stuff)
			{
				return false;
			}
			if (actor.isInsideSomething())
			{
				return false;
			}
			if (actor.isFlying() && weaponType == WeaponType.Melee)
			{
				return false;
			}
			if (actor.ai.action != null && actor.ai.action.special_prevent_can_be_attacked)
			{
				return false;
			}
			if (actor.isInMagnet())
			{
				return false;
			}
			if (pCheckForFactions && areFoes(pTarget) && actor.isKingdomCiv() && isKingdomCiv() && !hasStatusTantrum() && !actor.hasStatusTantrum())
			{
				bool flag2 = (flag && a.hasXenophobic()) || actor.hasXenophobic();
				bool flag3 = (flag && a.hasXenophiles()) || actor.hasXenophiles();
				bool flag4 = flag && a.culture == actor.culture;
				bool flag5 = species == actor.asset.id;
				bool flag6 = ((flag5 || flag3) && !flag2) || (flag4 && flag5);
				if (!WorldLawLibrary.world_law_angry_civilians.isEnabled())
				{
					if (actor.profession_asset.is_civilian && flag6)
					{
						return false;
					}
					if (flag && a.profession_asset.is_civilian && flag6)
					{
						return false;
					}
				}
			}
			if (pCheckForFactions && flag && a.hasCannibalism() && a.isSameSpecies(actor))
			{
				Family family = a.family;
				Family family2 = actor.family;
				if (family2 == null || family == null)
				{
					return false;
				}
				if (a.hasFamily())
				{
					if (family2 == family)
					{
						return false;
					}
					if (!family2.areMostUnitsHungry() && !family.areMostUnitsHungry())
					{
						return false;
					}
				}
			}
		}
		else
		{
			Building building = pTarget.b;
			if (isKingdomCiv() && building.asset.city_building && building.asset.tower && !building.isCiv() && flag && a.profession_asset.is_civilian && !WorldLawLibrary.world_law_angry_civilians.isEnabled() && building.kingdom.getSpecies() == kingdom.getSpecies())
			{
				return false;
			}
		}
		if (flag)
		{
			ActorAsset asset = a.asset;
			if (!a.isWaterCreature() || !a.hasRangeAttack())
			{
				if (a.isWaterCreature() && !asset.force_land_creature)
				{
					if (!pTarget.isInLiquid())
					{
						return false;
					}
					if (!pTarget.current_tile.isSameIsland(current_tile))
					{
						return false;
					}
				}
				else if (weaponType == WeaponType.Melee && pTarget.isInLiquid() && !a.isWaterCreature())
				{
					return false;
				}
			}
		}
		return true;
	}

	public bool areFoes(BaseSimObject pTarget)
	{
		return kingdom.isEnemy(pTarget.kingdom);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void setHealth(int pValue, bool pClamp = true)
	{
		BaseObjectData data = getData();
		if (pClamp)
		{
			pValue = Mathf.Clamp(pValue, 1, getMaxHealth());
		}
		data.health = pValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void setMaxHealth()
	{
		setHealth(getMaxHealth());
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void changeHealth(int pValue)
	{
		BaseObjectData data = getData();
		int num = data.health + pValue;
		data.health = Mathf.Clamp(num, 0, getMaxHealth());
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getHealth()
	{
		return getData().health;
	}

	public int getMaxHealthPercent(float pPercent)
	{
		int num = (int)((float)getMaxHealth() * pPercent);
		return Mathf.Max(1, num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasHealth()
	{
		return getHealth() > 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(BaseSimObject pObject)
	{
		return _hashcode == pObject.GetHashCode();
	}

	public int getMaxHealth()
	{
		return (int)stats["health"];
	}

	public override void Dispose()
	{
		current_tile = null;
		kingdom = null;
		stats.reset();
		clearIgnoreTargets();
		_targets_to_ignore = null;
		disposeStatusEffects();
		current_tile = null;
		base.Dispose();
	}

	private void disposeStatusEffects()
	{
		foreach (Status value in _active_status_dict.Values)
		{
			value.finish();
		}
		_active_status_dict.Clear();
		_has_any_status_cached = false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isKingdomCiv()
	{
		return kingdom.isCiv();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isKingdomMob()
	{
		return kingdom.isMobs();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasKingdom()
	{
		return kingdom != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public virtual BaseObjectData getData()
	{
		return null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public sealed override long getID()
	{
		return getData().id;
	}

	public override double getFoundedTimestamp()
	{
		return getData().created_time;
	}

	public virtual bool hasStatusTantrum()
	{
		return false;
	}

	public bool isSameIsland(WorldTile pTile)
	{
		return current_tile.isSameIsland(pTile);
	}

	public bool isSameIslandAs(BaseSimObject pTarget)
	{
		return current_tile.isSameIsland(pTarget.current_tile);
	}
}
// --- End of File: BaseSimObject.cs ---



// --- Start of File: BaseStatAsset.cs ---
using System;
using System.ComponentModel;

[Serializable]
public class BaseStatAsset : Asset, ILocalizedAsset
{
	public bool hidden;

	public string icon;

	public bool normalize;

	public float normalize_min;

	[DefaultValue(2.1474836E+09f)]
	public float normalize_max = 2.1474836E+09f;

	public bool used_only_for_civs;

	public bool actor_data_attribute;

	public bool show_as_percents;

	[DefaultValue(1f)]
	public float tooltip_multiply_for_visual_number = 1f;

	public bool multiplier;

	public string main_stat_to_multiply;

	public int sort_rank;

	public bool ignore;

	public string translation_key;

	public string getLocaleID()
	{
		return translation_key ?? id;
	}
}
// --- End of File: BaseStatAsset.cs ---



// --- Start of File: BaseStats.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using UnityEngine;

[Serializable]
public class BaseStats : ICloneable
{
	[JsonProperty]
	private List<BaseStatsContainer> _stats_list = new List<BaseStatsContainer>();

	private Dictionary<string, BaseStatsContainer> _stats_dict = new Dictionary<string, BaseStatsContainer>();

	private List<BaseStatsContainer> _multipliers_list;

	[JsonProperty]
	private HashSet<string> _tags;

	public float this[string pKey]
	{
		get
		{
			return get(pKey);
		}
		set
		{
			set(pKey, value);
		}
	}

	private void set(string pID, float pAmount)
	{
		BaseStatAsset baseStatAsset = AssetManager.base_stats_library.get(pID);
		if (baseStatAsset.ignore)
		{
			return;
		}
		BaseStatsContainer value2;
		if (pAmount == 0f && !baseStatAsset.normalize)
		{
			if (_stats_dict.TryGetValue(pID, out var value))
			{
				if (baseStatAsset.multiplier)
				{
					_multipliers_list?.Remove(value);
				}
				_stats_list.Remove(value);
				_stats_dict.Remove(pID);
			}
		}
		else if (!_stats_dict.TryGetValue(pID, out value2))
		{
			value2 = new BaseStatsContainer();
			value2.value = pAmount;
			value2.id = pID;
			_stats_dict[pID] = value2;
			_stats_list.Add(value2);
			if (baseStatAsset.multiplier)
			{
				if (_multipliers_list == null)
				{
					_multipliers_list = new List<BaseStatsContainer>();
				}
				_multipliers_list.Add(value2);
			}
		}
		else
		{
			_stats_dict[pID].value = pAmount;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public List<BaseStatsContainer> getList()
	{
		return _stats_list;
	}

	public void checkStatName(string pID)
	{
		if (Config.game_loaded && AssetManager.base_stats_library.get(pID) == null)
		{
			Debug.LogError((object)("base_stats_library.get() - no asset with id: " + pID));
			Debug.LogError((object)"Only call stats with S.id, never with pure strings to avoid typos");
		}
	}

	public float get(string pID)
	{
		if (_stats_dict.TryGetValue(pID, out var value))
		{
			return value.value;
		}
		return 0f;
	}

	public bool hasStat(string pID)
	{
		return _stats_dict.ContainsKey(pID);
	}

	public BaseStatsContainer getContainer(string pID)
	{
		BaseStatsContainer value = null;
		_stats_dict.TryGetValue(pID, out value);
		return value;
	}

	internal void mergeStats(BaseStats pStats, float pMultiplier = 1f)
	{
		for (int i = 0; i < pStats._stats_list.Count; i++)
		{
			BaseStatsContainer baseStatsContainer = pStats._stats_list[i];
			this[baseStatsContainer.id] += baseStatsContainer.value * pMultiplier;
		}
		if (pStats._tags != null)
		{
			if (_tags == null)
			{
				_tags = new HashSet<string>(pStats._tags);
			}
			else
			{
				_tags.UnionWith(pStats._tags);
			}
		}
	}

	public void checkMultipliers()
	{
		if (_multipliers_list == null)
		{
			return;
		}
		for (int i = 0; i < _multipliers_list.Count; i++)
		{
			BaseStatsContainer baseStatsContainer = _multipliers_list[i];
			BaseStatAsset asset = baseStatsContainer.asset;
			BaseStatsContainer container = getContainer(asset.main_stat_to_multiply);
			if (container != null)
			{
				container.value += container.value * baseStatsContainer.value;
			}
		}
	}

	public bool hasTag(string pTag)
	{
		return _tags?.Contains(pTag) ?? false;
	}

	public bool hasTags(string[] pTags)
	{
		return _tags?.Overlaps(pTags) ?? false;
	}

	public void normalize()
	{
		for (int i = 0; i < _stats_list.Count; i++)
		{
			_stats_list[i].normalize();
		}
	}

	internal void clear()
	{
		_multipliers_list?.Clear();
		_stats_list.Clear();
		_stats_dict.Clear();
		_tags?.Clear();
	}

	public void reset()
	{
		clear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void addTag(string pTag)
	{
		if (_tags == null)
		{
			_tags = new HashSet<string>();
		}
		_tags.Add(pTag);
	}

	public bool hasTags()
	{
		HashSet<string> tags = _tags;
		if (tags == null)
		{
			return false;
		}
		return tags.Count > 0;
	}

	public bool hasStats()
	{
		List<BaseStatsContainer> stats_list = _stats_list;
		if (stats_list == null)
		{
			return false;
		}
		return stats_list.Count > 0;
	}

	public bool ShouldSerialize_tags()
	{
		return hasTags();
	}

	public bool ShouldSerialize_stats_list()
	{
		return hasStats();
	}

	public void addCombatAction(string pCombatAction)
	{
	}

	public object Clone()
	{
		BaseStats baseStats = new BaseStats();
		baseStats.mergeStats(this);
		return baseStats;
	}
}
// --- End of File: BaseStats.cs ---



// --- Start of File: BaseStatsContainer.cs ---
using Newtonsoft.Json;
using UnityEngine;

public class BaseStatsContainer
{
	public string id;

	public float value;

	[JsonIgnore]
	public BaseStatAsset asset => AssetManager.base_stats_library.get(id);

	public void normalize()
	{
		BaseStatAsset baseStatAsset = asset;
		if (baseStatAsset.normalize)
		{
			value = Mathf.Clamp(value, baseStatAsset.normalize_min, baseStatAsset.normalize_max);
		}
	}
}
// --- End of File: BaseStatsContainer.cs ---



// --- Start of File: BaseStatsExtension.cs ---
public static class BaseStatsExtension
{
	public static bool isEmpty(this BaseStats pBaseStats)
	{
		if (pBaseStats == null)
		{
			return true;
		}
		if (!pBaseStats.hasTags())
		{
			return !pBaseStats.hasStats();
		}
		return false;
	}
}
// --- End of File: BaseStatsExtension.cs ---



// --- Start of File: BaseStatsHelper.cs ---
using System.Collections.Generic;
using UnityEngine.UI;

public static class BaseStatsHelper
{
	public delegate KeyValueField KeyValueFieldGetter(string pID);

	public static BaseStats _base_stats_tooltip_helper = new BaseStats();

	private static List<BaseStatsContainer> _stats_container_positive = new List<BaseStatsContainer>();

	private static List<BaseStatsContainer> _stats_container_negative = new List<BaseStatsContainer>();

	public static BaseStats getTotalStatsFrom(BaseStats pBaseStats, BaseStats pBaseStatsMeta)
	{
		_base_stats_tooltip_helper.clear();
		_base_stats_tooltip_helper.mergeStats(pBaseStats);
		_base_stats_tooltip_helper.mergeStats(pBaseStatsMeta);
		return _base_stats_tooltip_helper;
	}

	public static void showItemMods(Text pTextFieldDescription, Text pTextFieldValues, Item pItem)
	{
		using ListPool<TooltipModContainerInfo> listPool = getItemModsBase(pItem);
		foreach (ref TooltipModContainerInfo item in listPool)
		{
			TooltipModContainerInfo current = item;
			addStatValues(pTextFieldDescription, pTextFieldValues, Toolbox.coloredText("+" + LocalizedTextManager.getText(current.asset.getLocaleID()), "#45FFFE"), Toolbox.coloredText(current.string_pluses, "#45FFFE"));
			addLineBreak(pTextFieldDescription, pTextFieldValues);
		}
	}

	public static void showItemModsRows(KeyValueFieldGetter pFieldsFabric, Item pItem)
	{
		using ListPool<TooltipModContainerInfo> listPool = getItemModsBase(pItem);
		foreach (ref TooltipModContainerInfo item in listPool)
		{
			TooltipModContainerInfo current = item;
			string text = Toolbox.coloredText("+" + LocalizedTextManager.getText(current.asset.getLocaleID()), "#45FFFE");
			string text2 = Toolbox.coloredText(current.string_pluses, "#45FFFE");
			KeyValueField keyValueField = pFieldsFabric(current.asset.getLocaleID());
			keyValueField.name_text.text = text;
			keyValueField.value.text = text2;
		}
	}

	private static ListPool<TooltipModContainerInfo> getItemModsBase(Item pItem)
	{
		ListPool<TooltipModContainerInfo> listPool = new ListPool<TooltipModContainerInfo>(pItem.data.modifiers.Count);
		foreach (ref string modifier in pItem.data.modifiers)
		{
			string current = modifier;
			ItemModAsset itemModAsset = AssetManager.items_modifiers.get(current);
			string text = "";
			for (int i = 0; i < itemModAsset.mod_rank; i++)
			{
				text += "+";
			}
			listPool.Add(new TooltipModContainerInfo(itemModAsset, itemModAsset.mod_rank, text));
		}
		listPool.Sort(sortByPluses);
		return listPool;
	}

	private static void addStatValues(Text pStatsField, Text pValuesField, string pStats, string pValues)
	{
		pStatsField.text += pStats;
		pValuesField.text += pValues;
	}

	private static void addLineBreak(Text pStatsField, Text pValuesField)
	{
		pStatsField.text += "\n";
		pValuesField.text += "\n";
	}

	private static int sortByPluses(TooltipModContainerInfo pContainer1, TooltipModContainerInfo pContainer2)
	{
		return pContainer2.pluses.CompareTo(pContainer1.pluses);
	}

	public static void showBaseStats(Text pStatsField, Text pValuesField, BaseStats pBaseStats, bool pAddPlus = true)
	{
		calcBaseStatsBase(pBaseStats);
		foreach (BaseStatsContainer item in _stats_container_positive)
		{
			showBaseStatLine(pStatsField, pValuesField, item, pAddColor: true, pAddPlus);
		}
		foreach (BaseStatsContainer item2 in _stats_container_negative)
		{
			showBaseStatLine(pStatsField, pValuesField, item2, pAddColor: true, pAddPlus);
		}
	}

	public static void showBaseStatsRows(KeyValueFieldGetter pFieldsFabric, BaseStats pBaseStats, bool pAddPlus = true)
	{
		calcBaseStatsBase(pBaseStats);
		foreach (BaseStatsContainer item in _stats_container_positive)
		{
			showBaseStatRow(pFieldsFabric, item, pAddColor: true, pAddPlus);
		}
		foreach (BaseStatsContainer item2 in _stats_container_negative)
		{
			showBaseStatRow(pFieldsFabric, item2, pAddColor: true, pAddPlus);
		}
	}

	private static void calcBaseStatsBase(BaseStats pBaseStats)
	{
		_stats_container_positive.Clear();
		_stats_container_negative.Clear();
		foreach (BaseStatsContainer item in pBaseStats.getList())
		{
			if (!item.asset.hidden || DebugConfig.isOn(DebugOption.ShowHiddenStats))
			{
				queueStatContainer(item);
			}
		}
		_stats_container_positive.Sort(sortByRank);
	}

	private static int sortByRank(BaseStatsContainer pContainerA, BaseStatsContainer pContainerB)
	{
		BaseStatAsset asset = pContainerA.asset;
		return pContainerB.asset.sort_rank.CompareTo(asset.sort_rank);
	}

	private static void queueStatContainer(BaseStatsContainer pContainer)
	{
		if (pContainer.value > 0f)
		{
			_stats_container_positive.Add(pContainer);
		}
		if (pContainer.value < 0f)
		{
			_stats_container_negative.Add(pContainer);
		}
	}

	private static void showBaseStatLine(Text pStatsField, Text pValuesField, BaseStatsContainer pContainer, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	{
		calcBaseStatLineBase(pContainer, out var tId, out var tValue, out var tAsset);
		if (!tAsset.hidden)
		{
			addItemText(pStatsField, pValuesField, tId, tValue, tAsset.show_as_percents, pAddColor, pAddPlus, pMainColor, pForceZero);
			return;
		}
		if (pStatsField.text.Length > 0)
		{
			addLineBreak(pStatsField, pValuesField);
		}
		string pText = tId;
		string text = tValue.ToText();
		if (tAsset.show_as_percents)
		{
			text += " %";
		}
		pValuesField.text += Toolbox.coloredText(text, ColorStyleLibrary.m.color_text_grey);
		pStatsField.text += Toolbox.coloredText(pText, ColorStyleLibrary.m.color_text_grey);
	}

	private static void showBaseStatRow(KeyValueFieldGetter pFieldsFabric, BaseStatsContainer pContainer, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	{
		calcBaseStatLineBase(pContainer, out var tId, out var tValue, out var tAsset);
		addItemTextRow(pFieldsFabric(tId), tId, tValue, tAsset.show_as_percents, pAddColor, pAddPlus, pMainColor, pForceZero);
	}

	private static void calcBaseStatLineBase(BaseStatsContainer pContainer, out string tId, out float tValue, out BaseStatAsset tAsset)
	{
		tAsset = pContainer.asset;
		tId = tAsset.getLocaleID();
		tValue = pContainer.value;
		if (tAsset.tooltip_multiply_for_visual_number != 1f)
		{
			tValue *= tAsset.tooltip_multiply_for_visual_number;
		}
		if (tAsset.hidden && DebugConfig.isOn(DebugOption.ShowHiddenStats))
		{
			tId = "[HIDDEN] " + tId;
		}
	}

	private static void addItemText(Text pStatsField, Text pValuesField, string pID, float pValue, bool pPercent = false, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	{
		addItemTextBase(pValue, out var pValString, pPercent, pForceZero);
		if (!pAddColor)
		{
			addLineText(pStatsField, pValuesField, pID, pValString, null, pPercent);
		}
		else if (pValue > 0f)
		{
			if (pAddPlus)
			{
				pValString = "+" + pValString;
			}
			addLineText(pStatsField, pValuesField, pID, pValString, pMainColor, pPercent);
		}
		else
		{
			addLineText(pStatsField, pValuesField, pID, pValString, "#FB2C21", pPercent);
		}
	}

	private static void addItemTextRow(KeyValueField pField, string pID, float pValue, bool pPercent = false, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	{
		addItemTextBase(pValue, out var pValString, pPercent, pForceZero);
		if (!pAddColor)
		{
			addRowText(pField, pID, pValString, null, pPercent);
		}
		else if (pValue > 0f)
		{
			if (pAddPlus)
			{
				pValString = "+" + pValString;
			}
			addRowText(pField, pID, pValString, pMainColor, pPercent);
		}
		else
		{
			addRowText(pField, pID, pValString, "#FB2C21", pPercent);
		}
	}

	private static void addItemTextBase(float pValue, out string pValString, bool pPercent = false, bool pForceZero = false)
	{
		pValString = pValue.ToText();
		if ((pValue != 0f || pForceZero) && pPercent)
		{
			pValString += "%";
		}
	}

	private static void addLineIntText(Text pStatsField, Text pValuesField, string pID, int pValue, string pColor = null)
	{
		addLineText(pStatsField, pValuesField, pID, pValue.ToText(), pColor);
	}

	private static void addLineText(Text pStatsField, Text pValuesField, string pID, string pValue, string pColor = null, bool pPercent = false)
	{
		if (pStatsField.text.Length > 0)
		{
			addLineBreak(pStatsField, pValuesField);
		}
		if (pValue.Length > 21)
		{
			pValue = pValue.Substring(0, 20) + "...";
		}
		string text = LocalizedTextManager.getText(pID);
		if (pPercent)
		{
			text += " %";
		}
		if (!string.IsNullOrEmpty(pColor))
		{
			pStatsField.text += text;
			pValuesField.text += Toolbox.coloredText(pValue, pColor);
		}
		else
		{
			pStatsField.text += text;
			pValuesField.text += pValue;
		}
	}

	private static void addRowText(KeyValueField pField, string pID, string pValue, string pColor = null, bool pPercent = false)
	{
		if (pValue.Length > 21)
		{
			pValue = pValue.Substring(0, 20) + "...";
		}
		string text;
		if (pID.Contains("[HIDDEN]"))
		{
			text = pID;
			pColor = ColorStyleLibrary.m.color_text_grey;
		}
		else
		{
			text = LocalizedTextManager.getText(pID);
		}
		if (pPercent)
		{
			text += " %";
		}
		if (!string.IsNullOrEmpty(pColor))
		{
			pField.name_text.text = Toolbox.coloredText(text, pColor);
			pField.value.text = Toolbox.coloredText(pValue, pColor);
		}
		else
		{
			pField.name_text.text = text;
			pField.value.text = pValue;
		}
	}
}
// --- End of File: BaseStatsHelper.cs ---



// --- Start of File: BaseStatsLibrary.cs ---
public class BaseStatsLibrary : AssetLibrary<BaseStatAsset>
{
	public override void init()
	{
		base.init();
		add(new BaseStatAsset
		{
			id = "personality_aggression",
			hidden = true,
			normalize = true,
			normalize_min = 0f,
			normalize_max = 1f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "personality_administration",
			hidden = true,
			normalize = true,
			normalize_min = 0f,
			normalize_max = 1f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "personality_diplomatic",
			hidden = true,
			normalize = true,
			normalize_min = 0f,
			normalize_max = 1f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "personality_rationality",
			hidden = true,
			normalize = true,
			normalize_min = 0f,
			normalize_max = 1f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "diplomacy",
			actor_data_attribute = true,
			normalize = true,
			normalize_max = 999f,
			used_only_for_civs = true,
			sort_rank = 900
		});
		add(new BaseStatAsset
		{
			id = "warfare",
			actor_data_attribute = true,
			normalize = true,
			normalize_max = 999f,
			used_only_for_civs = true,
			sort_rank = 900
		});
		add(new BaseStatAsset
		{
			id = "stewardship",
			actor_data_attribute = true,
			normalize = true,
			normalize_max = 999f,
			used_only_for_civs = true,
			sort_rank = 900
		});
		add(new BaseStatAsset
		{
			id = "intelligence",
			actor_data_attribute = true,
			normalize = true,
			normalize_max = 999f,
			used_only_for_civs = true,
			sort_rank = 900
		});
		add(new BaseStatAsset
		{
			id = "lifespan",
			sort_rank = 997,
			normalize = true,
			normalize_min = 1f
		});
		add(new BaseStatAsset
		{
			id = "mutation",
			sort_rank = 996
		});
		add(new BaseStatAsset
		{
			id = "offspring",
			normalize = true,
			normalize_min = 0f,
			normalize_max = 1000f
		});
		add(new BaseStatAsset
		{
			id = "multiplier_offspring",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "offspring",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "offspring"
		});
		add(new BaseStatAsset
		{
			id = "army",
			normalize = true,
			normalize_min = 0.1f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "cities",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "range"
		});
		add(new BaseStatAsset
		{
			id = "bonus_towers",
			normalize = true,
			normalize_max = 2f,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "damage",
			normalize = true,
			normalize_min = 1f,
			sort_rank = 999
		});
		add(new BaseStatAsset
		{
			id = "speed",
			normalize = true,
			normalize_min = 1f,
			sort_rank = 998
		});
		add(new BaseStatAsset
		{
			id = "health",
			normalize = true,
			normalize_min = 1f,
			sort_rank = 1000
		});
		add(new BaseStatAsset
		{
			id = "armor",
			normalize = true,
			normalize_min = 0f,
			normalize_max = 99f
		});
		add(new BaseStatAsset
		{
			id = "stamina",
			normalize = true,
			normalize_min = 1f,
			sort_rank = 1000
		});
		add(new BaseStatAsset
		{
			id = "mana",
			normalize = true,
			normalize_min = 0f,
			sort_rank = 1000
		});
		add(new BaseStatAsset
		{
			id = "accuracy",
			normalize_min = 1f,
			normalize_max = 10f,
			normalize = true
		});
		add(new BaseStatAsset
		{
			id = "targets",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "projectiles",
			normalize = true,
			normalize_min = 1f,
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "experience"
		});
		add(new BaseStatAsset
		{
			id = "happiness",
			normalize = true,
			normalize_min = 0f
		});
		add(new BaseStatAsset
		{
			id = "critical_chance",
			normalize = true,
			normalize_min = 0f,
			show_as_percents = true,
			tooltip_multiply_for_visual_number = 100f
		});
		add(new BaseStatAsset
		{
			id = "critical_damage_multiplier",
			show_as_percents = true,
			tooltip_multiply_for_visual_number = 100f
		});
		add(new BaseStatAsset
		{
			id = "size",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "area_of_effect",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "attack_speed",
			normalize = true,
			normalize_min = 0.5f,
			normalize_max = 10f
		});
		add(new BaseStatAsset
		{
			id = "throwing_range",
			normalize = true,
			normalize_min = 1f,
			normalize_max = 100f
		});
		add(new BaseStatAsset
		{
			id = "construction_speed",
			normalize = true,
			normalize_min = 1f,
			normalize_max = 100f
		});
		add(new BaseStatAsset
		{
			id = "loyalty_traits",
			translation_key = "loyalty",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "birth_rate",
			translation_key = "birth_rate"
		});
		add(new BaseStatAsset
		{
			id = "maturation",
			translation_key = "maturation"
		});
		add(new BaseStatAsset
		{
			id = "age_adult",
			translation_key = "age_adult",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "age_breeding",
			translation_key = "age_breeding",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "max_nutrition",
			translation_key = "max_nutrition"
		});
		add(new BaseStatAsset
		{
			id = "metabolic_rate",
			translation_key = "metabolic_rate",
			normalize_min = 1f,
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "loyalty_mood",
			translation_key = "loyalty",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "opinion",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "skill_combat",
			show_as_percents = true,
			tooltip_multiply_for_visual_number = 100f
		});
		add(new BaseStatAsset
		{
			id = "skill_spell",
			show_as_percents = true,
			tooltip_multiply_for_visual_number = 100f
		});
		add(new BaseStatAsset
		{
			id = "knockback"
		});
		add(new BaseStatAsset
		{
			id = "recoil"
		});
		add(new BaseStatAsset
		{
			id = "mass"
		});
		add(new BaseStatAsset
		{
			id = "mass_2"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_mass",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "mass_2",
			hidden = true
		});
		add(new BaseStatAsset
		{
			id = "limit_population"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_health",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "health",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "health"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_lifespan",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "lifespan",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "lifespan"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_stamina",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "stamina",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "stamina"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_mana",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "mana",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "mana"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_damage",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "damage",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "damage"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_crit",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "critical_chance",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "critical_chance_multiplier"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_diplomacy",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "diplomacy",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "diplomacy",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "multiplier_speed",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "speed",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "speed"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_attack_speed",
			show_as_percents = true,
			multiplier = true,
			main_stat_to_multiply = "attack_speed",
			tooltip_multiply_for_visual_number = 100f,
			translation_key = "attack_speed"
		});
		add(new BaseStatAsset
		{
			id = "scale",
			show_as_percents = true,
			tooltip_multiply_for_visual_number = 1000f,
			translation_key = "size"
		});
		add(new BaseStatAsset
		{
			id = "multiplier_supply_timer",
			hidden = true,
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "limit_clan_members",
			used_only_for_civs = true
		});
		add(new BaseStatAsset
		{
			id = "status_chance"
		});
		add(new BaseStatAsset
		{
			id = "damage_range",
			hidden = true,
			normalize = true,
			normalize_min = 0.1f
		});
	}

	public override void editorDiagnosticLocales()
	{
		foreach (BaseStatAsset item in list)
		{
			if (!item.hidden)
			{
				checkLocale(item, item.getLocaleID());
			}
		}
		base.editorDiagnosticLocales();
	}
}
// --- End of File: BaseStatsLibrary.cs ---



// --- Start of File: BaseSystemData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using Newtonsoft.Json;
using SQLite;
using UnityEngine.Scripting;
using UnityPools;

[Serializable]
public abstract class BaseSystemData : IDisposable
{
	[DefaultValue(null)]
	public List<NameEntry> past_names;

	[DefaultValue(null)]
	public CustomDataContainer<int> custom_data_int;

	[DefaultValue(null)]
	public CustomDataContainer<long> custom_data_long;

	[DefaultValue(null)]
	public CustomDataContainer<float> custom_data_float;

	[DefaultValue(null)]
	public CustomDataContainer<bool> custom_data_bool;

	[DefaultValue(null)]
	public CustomDataContainer<string> custom_data_string;

	[DefaultValue(null)]
	public HashSet<string> custom_data_flags;

	[JsonIgnore]
	public bool from_db;

	[PrimaryKey]
	[NotNull]
	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(-1L)]
	public long id { get; set; } = -1L;


	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string name { get; set; }

	public bool custom_name { get; set; }

	[DefaultValue(-1L)]
	public long name_culture_id { get; set; } = -1L;


	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[DefaultValue(0.0)]
	public double created_time { get; set; }

	[DefaultValue(0.0)]
	public double died_time { get; set; }

	[DefaultValue(false)]
	public bool favorite { get; set; }

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	[Preserve]
	[DefaultValue(1)]
	[Obsolete("Use created_time instead")]
	public int age
	{
		set
		{
			if (value >= 1 && !(created_time > 0.0))
			{
				created_time = (float)(-1 * value) * 60f;
			}
		}
	}

	[JsonIgnore]
	[Ignore]
	public float this[string pKey]
	{
		get
		{
			get(pKey, out var pResult, 0f);
			return pResult;
		}
		set
		{
			set(pKey, value);
		}
	}

	[JsonIgnore]
	public string obsidian_name_id => name + "(" + id + ")";

	public void cloneCustomDataFrom(BaseSystemData pTarget)
	{
		if (pTarget.custom_data_int != null)
		{
			foreach (KeyValuePair<string, int> item in pTarget.custom_data_int.dict)
			{
				set(item.Key, item.Value);
			}
		}
		if (pTarget.custom_data_long != null)
		{
			foreach (KeyValuePair<string, long> item2 in pTarget.custom_data_long.dict)
			{
				set(item2.Key, item2.Value);
			}
		}
		if (pTarget.custom_data_float != null)
		{
			foreach (KeyValuePair<string, float> item3 in pTarget.custom_data_float.dict)
			{
				set(item3.Key, item3.Value);
			}
		}
		if (pTarget.custom_data_bool != null)
		{
			foreach (KeyValuePair<string, bool> item4 in pTarget.custom_data_bool.dict)
			{
				set(item4.Key, item4.Value);
			}
		}
		if (pTarget.custom_data_string != null)
		{
			foreach (KeyValuePair<string, string> item5 in pTarget.custom_data_string.dict)
			{
				set(item5.Key, item5.Value);
			}
		}
		if (pTarget.custom_data_flags == null)
		{
			return;
		}
		foreach (string custom_data_flag in pTarget.custom_data_flags)
		{
			addFlag(custom_data_flag);
		}
	}

	public Dictionary<string, string> debug()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		if (custom_data_int != null)
		{
			foreach (KeyValuePair<string, int> item in custom_data_int.dict)
			{
				dictionary.Add(item.Key, item.Value.ToString());
			}
		}
		if (custom_data_long != null)
		{
			foreach (KeyValuePair<string, long> item2 in custom_data_long.dict)
			{
				dictionary.Add(item2.Key, item2.Value.ToString());
			}
		}
		if (custom_data_float != null)
		{
			foreach (KeyValuePair<string, float> item3 in custom_data_float.dict)
			{
				dictionary.Add(item3.Key, item3.Value.ToString(CultureInfo.InvariantCulture));
			}
		}
		if (custom_data_bool != null)
		{
			foreach (KeyValuePair<string, bool> item4 in custom_data_bool.dict)
			{
				dictionary.Add(item4.Key, item4.Value.ToString());
			}
		}
		if (custom_data_string != null)
		{
			foreach (KeyValuePair<string, string> item5 in custom_data_string.dict)
			{
				dictionary.Add(item5.Key, item5.Value);
			}
		}
		if (custom_data_flags != null)
		{
			foreach (string custom_data_flag in custom_data_flags)
			{
				dictionary.Add("Flag", custom_data_flag);
			}
		}
		return dictionary;
	}

	public void save()
	{
		checkInt();
		checkLong();
		checkFloat();
		checkBool();
		checkString();
		checkFlags();
	}

	public void checkInt()
	{
		CustomDataContainer<int> customDataContainer = custom_data_int;
		if (customDataContainer != null && customDataContainer.dict.Count == 0)
		{
			custom_data_int.Dispose();
			custom_data_int = null;
		}
	}

	public void checkLong()
	{
		CustomDataContainer<long> customDataContainer = custom_data_long;
		if (customDataContainer != null && customDataContainer.dict.Count == 0)
		{
			custom_data_long.Dispose();
			custom_data_long = null;
		}
	}

	public void checkFloat()
	{
		CustomDataContainer<float> customDataContainer = custom_data_float;
		if (customDataContainer != null && customDataContainer.dict.Count == 0)
		{
			custom_data_float.Dispose();
			custom_data_float = null;
		}
	}

	public void checkBool()
	{
		CustomDataContainer<bool> customDataContainer = custom_data_bool;
		if (customDataContainer != null && customDataContainer.dict.Count == 0)
		{
			custom_data_bool.Dispose();
			custom_data_bool = null;
		}
	}

	public void checkString()
	{
		CustomDataContainer<string> customDataContainer = custom_data_string;
		if (customDataContainer != null && customDataContainer.dict.Count == 0)
		{
			custom_data_string.Dispose();
			custom_data_string = null;
		}
	}

	public void checkFlags()
	{
		if (custom_data_flags != null && custom_data_flags.Count == 0)
		{
			UnsafeCollectionPool<HashSet<string>, string>.Release(custom_data_flags);
			custom_data_flags = null;
		}
	}

	public void load()
	{
	}

	public void get(string pKey, out int pResult, int pDefault = 0)
	{
		if (custom_data_int == null || !custom_data_int.TryGetValue(pKey, out pResult))
		{
			pResult = pDefault;
		}
	}

	public void get(string pKey, out long pResult, long pDefault = 0L)
	{
		if (custom_data_long == null || !custom_data_long.TryGetValue(pKey, out pResult))
		{
			pResult = pDefault;
		}
	}

	public void get(string pKey, out float pResult, float pDefault = 0f)
	{
		if (custom_data_float == null || !custom_data_float.TryGetValue(pKey, out pResult))
		{
			pResult = pDefault;
		}
	}

	public void get(string pKey, out string pResult, string pDefault = null)
	{
		if (custom_data_string == null || !custom_data_string.TryGetValue(pKey, out pResult))
		{
			pResult = pDefault;
		}
	}

	public void get(string pKey, out bool pResult, bool pDefault = false)
	{
		if (custom_data_bool == null || !custom_data_bool.TryGetValue(pKey, out pResult))
		{
			pResult = pDefault;
		}
	}

	public int set(string pKey, int pData)
	{
		if (custom_data_int == null)
		{
			custom_data_int = new CustomDataContainer<int>();
		}
		custom_data_int[pKey] = pData;
		return pData;
	}

	public long set(string pKey, long pData)
	{
		if (custom_data_long == null)
		{
			custom_data_long = new CustomDataContainer<long>();
		}
		custom_data_long[pKey] = pData;
		return pData;
	}

	public float set(string pKey, float pData)
	{
		if (custom_data_float == null)
		{
			custom_data_float = new CustomDataContainer<float>();
		}
		custom_data_float[pKey] = pData;
		return pData;
	}

	public string set(string pKey, string pData)
	{
		if (custom_data_string == null)
		{
			custom_data_string = new CustomDataContainer<string>();
		}
		custom_data_string[pKey] = pData;
		return pData;
	}

	public bool set(string pKey, bool pData)
	{
		if (custom_data_bool == null)
		{
			custom_data_bool = new CustomDataContainer<bool>();
		}
		custom_data_bool[pKey] = pData;
		return pData;
	}

	public void change(string pKey, int pValue, int pMin = 0, int pMax = 1000)
	{
		get(pKey, out var pResult, 0);
		pResult += pValue;
		if (pResult < pMin)
		{
			pResult = pMin;
		}
		if (pResult > pMax)
		{
			pResult = pMax;
		}
		set(pKey, pResult);
	}

	public void removeInt(string pKey)
	{
		if (custom_data_int != null)
		{
			custom_data_int.Remove(pKey);
			checkInt();
		}
	}

	public void removeLong(string pKey)
	{
		if (custom_data_long != null)
		{
			custom_data_long.Remove(pKey);
			checkLong();
		}
	}

	public void removeFloat(string pKey)
	{
		if (custom_data_float != null)
		{
			custom_data_float.Remove(pKey);
			checkFloat();
		}
	}

	public void removeString(string pKey)
	{
		if (custom_data_string != null)
		{
			custom_data_string.Remove(pKey);
			checkString();
		}
	}

	public void removeBool(string pKey)
	{
		if (custom_data_bool != null)
		{
			custom_data_bool.Remove(pKey);
			checkBool();
		}
	}

	public bool addFlag(string pID)
	{
		if (custom_data_flags == null)
		{
			custom_data_flags = UnsafeCollectionPool<HashSet<string>, string>.Get();
		}
		return custom_data_flags.Add(pID);
	}

	public bool hasFlag(string pID)
	{
		return custom_data_flags?.Contains(pID) ?? false;
	}

	public void removeFlag(string pID)
	{
		if (custom_data_flags != null)
		{
			custom_data_flags.Remove(pID);
			checkFlags();
		}
	}

	public virtual void Dispose()
	{
		custom_data_int?.Dispose();
		custom_data_long?.Dispose();
		custom_data_float?.Dispose();
		custom_data_bool?.Dispose();
		custom_data_string?.Dispose();
		custom_data_int = null;
		custom_data_long = null;
		custom_data_float = null;
		custom_data_bool = null;
		custom_data_string = null;
		custom_data_flags?.Clear();
		checkFlags();
		past_names?.Clear();
		past_names = null;
	}
}
// --- End of File: BaseSystemData.cs ---



// --- Start of File: BaseSystemManager.cs ---
using System;

public abstract class BaseSystemManager
{
	protected static int _latest_hash = 1;

	internal static bool anything_changed = false;

	public virtual int Count
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	public virtual void ClearAllDisposed()
	{
	}

	public virtual void parallelDirtyUnitsCheck()
	{
	}

	public virtual void checkLists()
	{
	}

	public virtual void clear()
	{
		ClearAllDisposed();
		anything_changed = false;
	}

	public virtual void checkDeadObjects()
	{
	}

	public virtual bool isUnitsDirty()
	{
		return false;
	}

	public virtual bool isLocked()
	{
		return isUnitsDirty();
	}

	public virtual void startCollectHistoryData()
	{
	}

	public virtual void clearLastYearStats()
	{
	}

	public virtual void showDebugTool(DebugTool pTool)
	{
	}

	public virtual bool hasAny()
	{
		return Count > 0;
	}

	public virtual string debugShort()
	{
		return $"[c:{Count}]";
	}
}
// --- End of File: BaseSystemManager.cs ---



// --- Start of File: BaseTrait.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;

[Serializable]
public class BaseTrait<TTrait> : BaseAugmentationAsset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset where TTrait : BaseTrait<TTrait>
{
	public float value;

	public WorldAction action_death;

	public WorldAction action_growth;

	public WorldAction action_birth;

	public GetHitAction action_get_hit;

	[DefaultValue(true)]
	public bool spawn_random_trait_allowed = true;

	[DefaultValue(5)]
	public int spawn_random_rate = 5;

	public bool special_icon_logic;

	public BaseStats base_stats_meta;

	public List<string> opposite_list;

	[NonSerialized]
	public HashSet<TTrait> opposite_traits;

	public string[] traits_to_remove_ids;

	[NonSerialized]
	public TTrait[] traits_to_remove;

	[DefaultValue("")]
	public string special_locale_description = string.Empty;

	[DefaultValue("")]
	public string special_locale_description_2 = string.Empty;

	[DefaultValue(true)]
	public bool has_localized_id = true;

	[DefaultValue(true)]
	public bool has_description_1 = true;

	[DefaultValue(true)]
	public bool has_description_2 = true;

	[DefaultValue(Rarity.R1_Rare)]
	public Rarity rarity = Rarity.R1_Rare;

	[DefaultValue(true)]
	public bool can_be_in_book = true;

	[DefaultValue("")]
	public string plot_id = string.Empty;

	[JsonIgnore]
	public List<ActorAsset> default_for_actor_assets;

	[JsonIgnore]
	public virtual string typed_id
	{
		get
		{
			throw new NotImplementedException(GetType().Name);
		}
	}

	[JsonIgnore]
	public PlotAsset plot_asset => AssetManager.plots_library.get(plot_id);

	public bool hasPlotAsset()
	{
		return !string.IsNullOrEmpty(plot_id);
	}

	public string getId()
	{
		return id;
	}

	public WorldAction getSpecialEffect()
	{
		return action_special_effect;
	}

	public float getSpecialEffectInterval()
	{
		return special_effect_interval;
	}

	public void addOpposite(string pID)
	{
		if (opposite_list == null)
		{
			opposite_list = new List<string>();
		}
		opposite_list.Add(pID);
	}

	public void addOpposites(IEnumerable<string> pListIDS)
	{
		if (opposite_list == null)
		{
			opposite_list = new List<string>(pListIDS);
		}
		else
		{
			opposite_list.AddRange(pListIDS);
		}
	}

	public void removeOpposite(string pID)
	{
		opposite_list.Remove(pID);
	}

	public override string getLocaleID()
	{
		if (!has_localized_id)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(special_locale_id))
		{
			return special_locale_id;
		}
		return typed_id + "_" + id;
	}

	public string getDescriptionID()
	{
		if (!has_description_1)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(special_locale_description))
		{
			return special_locale_description;
		}
		return typed_id + "_" + id + "_info";
	}

	public string getDescriptionID2()
	{
		if (!has_description_2)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(special_locale_description_2))
		{
			return special_locale_description_2;
		}
		return typed_id + "_" + id + "_info_2";
	}

	public string getTranslatedName()
	{
		return LocalizedTextManager.getText(getLocaleID());
	}

	public string getTranslatedDescription()
	{
		string descriptionID = getDescriptionID();
		if (LocalizedTextManager.stringExists(descriptionID))
		{
			return LocalizedTextManager.getText(descriptionID);
		}
		return null;
	}

	public string getTranslatedDescription2()
	{
		string descriptionID = getDescriptionID2();
		if (LocalizedTextManager.stringExists(descriptionID))
		{
			return LocalizedTextManager.getText(descriptionID);
		}
		return null;
	}

	protected override bool isDebugUnlockedAll()
	{
		return DebugConfig.isOn(DebugOption.UnlockAllTraits);
	}

	protected virtual IEnumerable<ITraitsOwner<TTrait>> getRelatedMetaList()
	{
		throw new NotImplementedException(GetType().Name);
	}

	private ListPool<ITraitsOwner<TTrait>> getOwnersList()
	{
		ListPool<ITraitsOwner<TTrait>> listPool = new ListPool<ITraitsOwner<TTrait>>();
		TTrait pTraitId = (TTrait)this;
		foreach (ITraitsOwner<TTrait> relatedMeta in getRelatedMetaList())
		{
			if (relatedMeta.hasTrait(pTraitId))
			{
				listPool.Add(relatedMeta);
			}
		}
		return listPool;
	}

	private (int pTotal, int pCivs, int pMobs) countTraitOwnersByCategories()
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		TTrait pTraitId = (TTrait)this;
		foreach (ITraitsOwner<TTrait> relatedMeta in getRelatedMetaList())
		{
			if (relatedMeta.hasTrait(pTraitId))
			{
				num++;
				if (isSapient(relatedMeta))
				{
					num2++;
				}
				else
				{
					num3++;
				}
			}
		}
		return (pTotal: num, pCivs: num2, pMobs: num3);
	}

	public virtual string getCountRows()
	{
		using ListPool<ITraitsOwner<TTrait>> listPool = getOwnersList();
		int num = 0;
		foreach (ref ITraitsOwner<TTrait> item in listPool)
		{
			ITraitsOwner<TTrait> current = item;
			num += ((IMetaObject)current).countUnits();
		}
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append(LocalizedTextManager.getText(typed_id + "_amount_text").Replace("$amount$", getColoredNumber(listPool.Count.ToString())));
		stringBuilderPool.AppendLine();
		stringBuilderPool.Append(LocalizedTextManager.getText("population_amount").Replace("$amount$", getColoredNumber(num.ToString())));
		return stringBuilderPool.ToString();
	}

	private string getColoredNumber(string pText)
	{
		return Toolbox.coloredString(pText, "#F3961F");
	}

	protected string getCountRowsByCategories()
	{
		(int, int, int) tuple = countTraitOwnersByCategories();
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append(LocalizedTextManager.getText("trait_owners_civs").Replace("$amount$", getColoredNumber(tuple.Item2.ToString())));
		stringBuilderPool.AppendLine();
		stringBuilderPool.Append(LocalizedTextManager.getText("trait_owners_mobs").Replace("$amount$", getColoredNumber(tuple.Item3.ToString())));
		return stringBuilderPool.ToString();
	}

	protected virtual bool isSapient(ITraitsOwner<TTrait> pObject)
	{
		throw new NotImplementedException(GetType().Name);
	}

	public bool ShouldSerializebase_stats_meta()
	{
		return !base_stats_meta.isEmpty();
	}

	public void setTraitInfoToGrinMark()
	{
		path_icon = "ui/Icons/subspecies_traits/subspecies_trait_grin_mark";
		special_locale_id = "subspecies_trait_grin_mark";
		special_locale_description = "subspecies_trait_grin_mark_info";
		special_locale_description_2 = "subspecies_trait_grin_mark_info_2";
		show_for_unlockables_ui = false;
		action_on_augmentation_add = (WorldActionTrait)Delegate.Combine(action_on_augmentation_add, new WorldActionTrait(WorldBehaviourActions.addForGrinReaper));
		action_on_augmentation_load = (WorldActionTrait)Delegate.Combine(action_on_augmentation_load, new WorldActionTrait(WorldBehaviourActions.addForGrinReaper));
		action_on_augmentation_remove = (WorldActionTrait)Delegate.Combine(action_on_augmentation_remove, new WorldActionTrait(WorldBehaviourActions.removeUsedForGrinReaper));
		action_on_object_remove = (WorldActionTrait)Delegate.Combine(action_on_object_remove, new WorldActionTrait(WorldBehaviourActions.removeUsedForGrinReaper));
	}
}
// --- End of File: BaseTrait.cs ---



// --- Start of File: BaseTraitGroupAsset.cs ---
using System;

[Serializable]
public class BaseTraitGroupAsset : BaseCategoryAsset
{
}
// --- End of File: BaseTraitGroupAsset.cs ---



// --- Start of File: BaseTraitLibrary.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class BaseTraitLibrary<T> : BaseLibraryWithUnlockables<T> where T : BaseTrait<T>
{
	protected List<T> _pot_allowed_to_be_given_randomly = new List<T>();

	protected virtual string icon_path
	{
		get
		{
			throw new NotImplementedException(GetType().Name);
		}
	}

	public override void post_init()
	{
		base.post_init();
		list.Sort((T pT1, T pT2) => StringComparer.Ordinal.Compare(pT2.id, pT1.id));
		autoSetRarity();
		checkIcons();
	}

	protected virtual void autoSetRarity()
	{
		foreach (T item in list)
		{
			if (item.unlocked_with_achievement)
			{
				item.rarity = Rarity.R3_Legendary;
				continue;
			}
			bool num = item.action_death != null || item.action_special_effect != null || item.action_get_hit != null || item.action_birth != null || item.action_attack_target != null || item.action_on_augmentation_add != null || item.action_on_augmentation_remove != null || item.action_on_augmentation_load != null;
			bool flag = item.decision_ids != null;
			bool flag2 = item.spells_ids != null;
			bool flag3 = item.combat_actions_ids != null;
			bool flag4 = item.base_stats.hasTags();
			bool flag5 = !string.IsNullOrEmpty(item.plot_id);
			int num2 = 0;
			if (num)
			{
				num2++;
			}
			if (flag)
			{
				num2++;
			}
			if (flag2)
			{
				num2++;
			}
			if (flag3)
			{
				num2++;
			}
			if (flag4)
			{
				num2++;
			}
			if (flag5)
			{
				num2++;
			}
			if (num2 > 0)
			{
				if (num2 == 1)
				{
					item.rarity = Rarity.R1_Rare;
				}
				else
				{
					item.rarity = Rarity.R2_Epic;
				}
				item.needs_to_be_explored = true;
			}
			else if (item.rarity == Rarity.R0_Normal)
			{
				item.needs_to_be_explored = false;
			}
		}
	}

	public override void linkAssets()
	{
		base.linkAssets();
		fillOppositeHashsetsWithAssets();
		linkDecisions();
		linkCombatActions();
		linkSpells();
		linkActorAssets();
		foreach (T item in list)
		{
			if (item.spawn_random_trait_allowed)
			{
				_pot_allowed_to_be_given_randomly.AddTimes(item.spawn_random_rate, item);
			}
		}
	}

	private void linkCombatActions()
	{
		foreach (T item in list)
		{
			item.linkCombatActions();
		}
	}

	private void linkSpells()
	{
		foreach (T item in list)
		{
			item.linkSpells();
		}
	}

	private void linkDecisions()
	{
		foreach (T item in list)
		{
			if (item.decision_ids != null)
			{
				item.decisions_assets = new DecisionAsset[item.decision_ids.Count];
				for (int i = 0; i < item.decision_ids.Count; i++)
				{
					string pID = item.decision_ids[i];
					DecisionAsset decisionAsset = AssetManager.decisions_library.get(pID);
					item.decisions_assets[i] = decisionAsset;
				}
			}
		}
	}

	private void linkActorAssets()
	{
		foreach (ActorAsset item in AssetManager.actor_library.list)
		{
			List<string> defaultTraitsForMeta = getDefaultTraitsForMeta(item);
			if (defaultTraitsForMeta == null)
			{
				continue;
			}
			foreach (string item2 in defaultTraitsForMeta)
			{
				T val = get(item2);
				if (val.default_for_actor_assets == null)
				{
					val.default_for_actor_assets = new List<ActorAsset>();
				}
				val.default_for_actor_assets.Add(item);
			}
		}
	}

	public override void editorDiagnostic()
	{
		checkOppositeErrors();
		foreach (T item in list)
		{
			if (string.IsNullOrEmpty(item.group_id))
			{
				BaseAssetLibrary.logAssetError("Group id not assigned", item.id);
			}
			if (!item.special_icon_logic && (Object)(object)SpriteTextureLoader.getSprite(item.path_icon) == (Object)null)
			{
				BaseAssetLibrary.logAssetError("Missing icon file", item.path_icon);
			}
		}
		base.editorDiagnostic();
	}

	public override void editorDiagnosticLocales()
	{
		foreach (T item in list)
		{
			checkLocale(item, item.getLocaleID());
			checkLocale(item, item.getDescriptionID());
			checkLocale(item, item.getDescriptionID2());
		}
	}

	private void checkOppositeErrors()
	{
		foreach (T item in list)
		{
			HashSet<T> opposite_traits = item.opposite_traits;
			if (opposite_traits == null)
			{
				continue;
			}
			foreach (T item2 in opposite_traits)
			{
				HashSet<T> opposite_traits2 = item2.opposite_traits;
				if (opposite_traits2 == null || !opposite_traits2.Contains(item))
				{
					logErrorOpposites(item.id, item2.id);
				}
			}
		}
	}

	private void fillOppositeHashsetsWithAssets()
	{
		foreach (T item2 in list)
		{
			if (item2.opposite_list == null || item2.opposite_list.Count <= 0)
			{
				continue;
			}
			item2.opposite_traits = new HashSet<T>(item2.opposite_list.Count);
			foreach (string item3 in item2.opposite_list)
			{
				T item = get(item3);
				item2.opposite_traits.Add(item);
			}
		}
		foreach (T item4 in list)
		{
			if (item4.traits_to_remove_ids != null)
			{
				int num = item4.traits_to_remove_ids.Length;
				item4.traits_to_remove = new T[num];
				for (int i = 0; i < num; i++)
				{
					string pID = item4.traits_to_remove_ids[i];
					T val = get(pID);
					item4.traits_to_remove[i] = val;
				}
			}
		}
	}

	private void checkIcons()
	{
		foreach (T item in list)
		{
			if (string.IsNullOrEmpty(item.path_icon))
			{
				item.path_icon = icon_path + item.getLocaleID();
			}
		}
	}

	public override T add(T pAsset)
	{
		T val = base.add(pAsset);
		if (val.base_stats == null)
		{
			val.base_stats = new BaseStats();
		}
		if (val.base_stats_meta == null)
		{
			val.base_stats_meta = new BaseStats();
		}
		return val;
	}

	public string addToGameplayReportShort(string pWhatFor)
	{
		string empty = string.Empty;
		empty = empty + pWhatFor + "\n";
		foreach (T item in list)
		{
			string text = item.id;
			if (!(text == "Phenotype"))
			{
				string translatedDescription = item.getTranslatedDescription();
				string text2 = "\n" + text;
				if (!string.IsNullOrEmpty(translatedDescription))
				{
					text2 = text2 + ": " + translatedDescription;
				}
				empty += text2;
			}
		}
		return empty + "\n\n";
	}

	public string addToGameplayReport(string pWhatFor)
	{
		string empty = string.Empty;
		empty = empty + pWhatFor + "\n";
		foreach (T item in list)
		{
			string translatedName = item.getTranslatedName();
			if (!(translatedName == "Phenotype"))
			{
				string translatedDescription = item.getTranslatedDescription();
				string translatedDescription2 = item.getTranslatedDescription2();
				string text = "\n" + translatedName;
				text += "\n";
				if (!string.IsNullOrEmpty(translatedDescription))
				{
					text = text + "1: " + translatedDescription;
				}
				if (!string.IsNullOrEmpty(translatedDescription2))
				{
					text = text + "\n2: " + translatedDescription2;
				}
				empty += text;
			}
		}
		return empty + "\n\n";
	}

	public T getRandomSpawnTrait()
	{
		return _pot_allowed_to_be_given_randomly.GetRandom();
	}

	protected virtual List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	{
		throw new NotImplementedException();
	}
}
// --- End of File: BaseTraitLibrary.cs ---



// --- Start of File: BaseUnlockableAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

[Serializable]
public class BaseUnlockableAsset : Asset, ILocalizedAsset
{
	public string path_icon;

	[DefaultValue(true)]
	public bool show_for_unlockables_ui = true;

	[DefaultValue(null)]
	public BaseStats base_stats;

	public bool unlocked_with_achievement;

	[DefaultValue(true)]
	public bool needs_to_be_explored = true;

	public string achievement_id;

	[DefaultValue(true)]
	public bool show_in_knowledge_window = true;

	[NonSerialized]
	protected Sprite cached_sprite;

	[DefaultValue(true)]
	public bool has_locales = true;

	protected GameProgressData _progress_data => GameProgress.instance?.data;

	protected virtual HashSet<string> progress_elements
	{
		get
		{
			throw new NotImplementedException(GetType().Name);
		}
	}

	public void setUnlockedWithAchievement(string pAchievementID)
	{
		unlocked_with_achievement = true;
		achievement_id = pAchievementID;
	}

	public virtual bool unlock(bool pSaveData = true)
	{
		if (progress_elements == null)
		{
			return false;
		}
		if (isAvailable())
		{
			return false;
		}
		bool flag = false;
		if (this is ActorAsset actorAsset)
		{
			string pID = (string.IsNullOrEmpty(actorAsset.base_asset_id) ? id : actorAsset.base_asset_id);
			flag = AssetManager.actor_library.get(pID).isAvailable();
		}
		progress_elements.Add(id);
		if (pSaveData)
		{
			GameProgress.saveData();
		}
		if (!unlocked_with_achievement && has_locales && !flag)
		{
			WorldTip.showNowTop("new_knowledge_gain".Localize().Replace("$knowledge$", getLocaleID().Localize()), pTranslate: false);
		}
		return true;
	}

	public bool isUnlocked()
	{
		if (isDebugUnlockedAll())
		{
			return true;
		}
		if (isCheatEnabled())
		{
			return true;
		}
		return progress_elements.Contains(id);
	}

	public bool isAvailable()
	{
		if (isDebugUnlockedAll())
		{
			return true;
		}
		if (isCheatEnabled())
		{
			return true;
		}
		if (unlocked_with_achievement)
		{
			return GameProgress.isAchievementUnlocked(achievement_id);
		}
		if (!needs_to_be_explored)
		{
			return true;
		}
		return isUnlocked();
	}

	public bool isUnlockedByPlayer()
	{
		if (unlocked_with_achievement)
		{
			return GameProgress.isAchievementUnlocked(achievement_id);
		}
		if (!needs_to_be_explored)
		{
			return true;
		}
		return progress_elements.Contains(id);
	}

	protected virtual bool isDebugUnlockedAll()
	{
		throw new NotImplementedException(GetType().Name);
	}

	public bool isCheatEnabled()
	{
		return WorldLawLibrary.world_law_cursed_world.isEnabled();
	}

	public bool ShouldSerializebase_stats()
	{
		return !base_stats.isEmpty();
	}

	public virtual string getLocaleID()
	{
		if (!has_locales)
		{
			return null;
		}
		return id;
	}

	public string getAchievementLocaleID()
	{
		return getAchievement()?.getLocaleID();
	}

	public Achievement getAchievement()
	{
		if (!unlocked_with_achievement)
		{
			return null;
		}
		return AssetManager.achievements.get(achievement_id);
	}

	public virtual Sprite getSprite()
	{
		if (cached_sprite == null)
		{
			cached_sprite = SpriteTextureLoader.getSprite(path_icon);
		}
		return cached_sprite;
	}
}
// --- End of File: BaseUnlockableAsset.cs ---



// --- Start of File: BaseWorldAgeElement.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BaseWorldAgeElement : MonoBehaviour
{
	[SerializeField]
	protected Button button;

	[SerializeField]
	protected TipButton _tip_button;

	[SerializeField]
	protected Image _icon;

	protected WorldAgeAsset asset;

	protected WorldAgeElementAction click_callback;

	private void Awake()
	{
		prepare();
	}

	protected virtual void prepare()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
		{
			click_callback?.Invoke(this);
		});
	}

	public WorldAgeAsset getAsset()
	{
		return asset;
	}

	public virtual void setAge(WorldAgeAsset pAsset)
	{
		asset = pAsset;
		_icon.sprite = asset.getSprite();
		_tip_button.type = "world_age";
		_tip_button.textOnClick = pAsset.id;
	}

	public void setIconActiveColor(bool pState)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float num = ((!pState) ? 0.55f : 1f);
		Color color = default(Color);
		((Color)(ref color))._002Ector(num, num, num);
		((Graphic)_icon).color = color;
	}

	public void addClickCallback(WorldAgeElementAction pAction)
	{
		click_callback = (WorldAgeElementAction)Delegate.Combine(click_callback, pAction);
	}

	public void removeClickCallback(WorldAgeElementAction pAction)
	{
		click_callback = (WorldAgeElementAction)Delegate.Remove(click_callback, pAction);
	}

	public WorldAgeElementAction getClickCallback()
	{
		return click_callback;
	}

	public void clearClickCallbacks()
	{
		click_callback = null;
	}

	public Button getButton()
	{
		return button;
	}
}
// --- End of File: BaseWorldAgeElement.cs ---



// --- Start of File: BaseWorldObject.cs ---
using System;
using UnityEngine;

public class BaseWorldObject : MonoBehaviour, IDisposable
{
	internal bool created;

	internal Transform m_transform;

	private void Start()
	{
		if (!created)
		{
			create();
		}
	}

	public virtual void update(float pElapsed)
	{
	}

	internal virtual void create()
	{
		created = true;
		m_transform = ((Component)this).gameObject.transform;
	}

	public virtual void Dispose()
	{
		m_transform = null;
	}
}
// --- End of File: BaseWorldObject.cs ---



// --- Start of File: Batch.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class Batch<T>
{
	internal ObjectContainer<T> main;

	internal bool free_slots;

	private List<ObjectContainer<T>> containers = new List<ObjectContainer<T>>();

	internal List<Job<T>> jobs_pre = new List<Job<T>>();

	internal List<Job<T>> jobs_post = new List<Job<T>>();

	internal List<Job<T>> jobs_parallel = new List<Job<T>>();

	protected List<T> _list;

	protected T[] _array;

	protected int _count;

	protected float _elapsed;

	protected ObjectContainer<T> _cur_container;

	internal JobUpdater clearParallelResults;

	internal JobUpdater applyParallelResults;

	public int batch_id;

	public Batch()
	{
		createJobs();
		createHelpers();
	}

	public void updateJobsPre(float pElapsed)
	{
		_elapsed = pElapsed;
		List<Job<T>> list = jobs_pre;
		int count = list.Count;
		for (int i = 0; i < count; i++)
		{
			Job<T> job = list[i];
			_cur_container = job.container;
			if (job.current_skips > 0)
			{
				job.current_skips--;
			}
			else
			{
				runUpdater(job);
			}
		}
	}

	public void updateJobsParallel(float pElapsed)
	{
		List<Job<T>> list = jobs_parallel;
		int count = list.Count;
		for (int i = 0; i < count; i++)
		{
			Job<T> job = list[i];
			_cur_container = job.container;
			job.job_updater();
		}
	}

	public void updateJobsPost(float pElapsed)
	{
		_elapsed = pElapsed;
		List<Job<T>> list = jobs_post;
		int count = list.Count;
		for (int i = 0; i < count; i++)
		{
			Job<T> job = list[i];
			_cur_container = job.container;
			if (job.current_skips > 0)
			{
				job.current_skips--;
			}
			else
			{
				runUpdater(job);
			}
		}
	}

	private void runUpdater(Job<T> pObj)
	{
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		pObj.job_updater();
		if (pObj.random_tick_skips > 0)
		{
			pObj.current_skips = Randy.randomInt(0, pObj.random_tick_skips);
		}
		double num = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
		pObj.time_benchmark += num;
		pObj.counter += _cur_container.Count;
	}

	internal virtual void prepare()
	{
		for (int i = 0; i < containers.Count; i++)
		{
			containers[i].doChecks();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected void createJob(out ObjectContainer<T> pContainer, JobUpdater pJobUpdater, JobType pType, string pID, int pRandomTickSkips = 0)
	{
		pContainer = new ObjectContainer<T>();
		pContainer.prepareArray(JobConst.MAX_ELEMENTS);
		containers.Add(pContainer);
		if (pJobUpdater != null)
		{
			addJob(pContainer, pJobUpdater, pType, pID, pRandomTickSkips);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected void addJob(ObjectContainer<T> pContainer, JobUpdater pJobUpdater, JobType pType, string pID, int pRandomTickSkips = 0)
	{
		switch (pType)
		{
		case JobType.Pre:
			putJob(pContainer, pJobUpdater, jobs_pre, pID, pRandomTickSkips);
			break;
		case JobType.Parallel:
			putJob(pContainer, pJobUpdater, jobs_parallel, pID, pRandomTickSkips);
			break;
		case JobType.Post:
			putJob(pContainer, pJobUpdater, jobs_post, pID, pRandomTickSkips);
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void putJob(ObjectContainer<T> pContainer, JobUpdater pJobUpdater, List<Job<T>> pListJobs, string pID, int pRandomTickSkips = 0)
	{
		pListJobs.Add(new Job<T>
		{
			container = pContainer,
			job_updater = pJobUpdater,
			id = pID,
			random_tick_skips = pRandomTickSkips
		});
	}

	internal virtual void clear()
	{
		for (int i = 0; i < containers.Count; i++)
		{
			containers[i].Clear();
		}
		if (_array != null)
		{
			Array.Clear(_array, 0, _array.Length);
		}
	}

	internal virtual void remove(T pObject)
	{
		for (int i = 0; i < containers.Count; i++)
		{
			containers[i].Remove(pObject);
		}
	}

	internal virtual void add(T pObject)
	{
		main.Add(pObject);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected bool check(ObjectContainer<T> pContainer)
	{
		if (pContainer.Count > 0 || pContainer.isDirtyContainer())
		{
			pContainer.checkAddRemove();
			_array = pContainer.getFastSimpleArray();
			_count = pContainer.Count;
			return true;
		}
		return false;
	}

	protected virtual void createJobs()
	{
	}

	protected virtual void createHelpers()
	{
	}

	public virtual void clearHelperLists()
	{
	}

	public void debug(DebugTool pTool)
	{
		pTool.setText("total", main.Count, 0f, pShowBar: false, 0L);
	}
}
// --- End of File: Batch.cs ---



// --- Start of File: BatchActors.cs ---
using System;
using System.Collections.Generic;
using Unity.Mathematics;

public class BatchActors : Batch<Actor>
{
	public ObjectContainer<Actor> c_main;

	public ObjectContainer<Actor> c_check_attack_target;

	public ObjectContainer<Actor> c_update_movement;

	public ObjectContainer<Actor> c_main_tile_action;

	public ObjectContainer<Actor> c_shake;

	public ObjectContainer<Actor> c_stats_dirty;

	public ObjectContainer<Actor> c_action_landed;

	public ObjectContainer<Actor> c_make_decision;

	public ObjectContainer<Actor> c_sprite_animations;

	public ObjectContainer<Actor> c_update_children;

	public ObjectContainer<Actor> c_check_enemy_target;

	public ObjectContainer<Actor> c_augmentation_effects;

	public ObjectContainer<Actor> c_events_become_adult;

	public ObjectContainer<Actor> c_events_hatched;

	public ObjectContainer<Actor> c_hovering;

	public ObjectContainer<Actor> c_pollinating;

	public ObjectContainer<Actor> c_check_deaths;

	internal List<Actor> l_parallel_update_sprites = new List<Actor>();

	public Random rnd = new Random(10u);

	protected override void createJobs()
	{
		addJob(null, prepare, JobType.Parallel, "prepare");
		createJob(out c_main, updateParallelChecks, JobType.Parallel, "update_timers");
		addJob(c_main, updateVisibility, JobType.Parallel, "update_visibility");
		createJob(out c_stats_dirty, updateStats, JobType.Parallel, "update_stats");
		createJob(out c_events_become_adult, updateEventsBecomeAdult, JobType.Post, "update_events_become_adult");
		createJob(out c_events_hatched, updateEventsEggHatched, JobType.Post, "update_events_hatched");
		createJob(out c_action_landed, updateActionLanded, JobType.Post, "update_action_landed");
		addJob(c_main, updateNutritionDecay, JobType.Post, "update_hunger");
		addJob(c_main, u1_checkInside, JobType.Post, "u1_checkInside");
		createJob(out c_update_children, u2_updateChildren, JobType.Post, "u2_updateChildren");
		createJob(out c_sprite_animations, u3_spriteAnimation, JobType.Post, "u3_spriteAnimation");
		addJob(c_main, u4_deadCheck, JobType.Post, "u4_deadCheck");
		createJob(out c_main_tile_action, u5_curTileAction, JobType.Post, "u5_curTileAction");
		addJob(c_main, u6_checkFrozen, JobType.Post, "u6_checkFrozen");
		createJob(out c_augmentation_effects, u7_checkAugmentationEffects, JobType.Post, "u7_checkAugmentationEffects", 20);
		addJob(c_main, u8_checkUpdateTimers, JobType.Post, "u8_checkUpdateTimers");
		addJob(c_main, b1_checkUnderForce, JobType.Post, "b1_checkUnderForce");
		createJob(out c_check_attack_target, b2_checkCurrentEnemyTarget, JobType.Post, "b2_checkCurrentEnemyTarget");
		addJob(c_main, b3_findEnemyTarget, JobType.Post, "b3_findEnemyTarget", 5);
		addJob(c_main, b4_checkTaskVerifier, JobType.Post, "b4_checkTaskVerifier");
		addJob(c_main, b5_checkPathMovement, JobType.Post, "b5_checkPathMovement");
		createJob(out c_make_decision, b6_0_updateDecision, JobType.Post, "b6_0_update_decision");
		addJob(c_main, b55_updateNaturalDeaths, JobType.Post, "b55_update_natural_death", 20);
		addJob(c_main, b6_updateAI, JobType.Post, "b6_update_ai");
		createJob(out c_update_movement, u10_checkSmoothMovement, JobType.Post, "u10_checkSmoothMovement");
		createJob(out c_shake, updateShake, JobType.Post, "update_shake");
		createJob(out c_hovering, updateHovering, JobType.Post, "update_hovering");
		createJob(out c_pollinating, updatePollinating, JobType.Post, "update_pollinating");
		createJob(out c_check_deaths, updateDeathCheck, JobType.Post, "update_death");
		main = c_main;
		clearParallelResults = (JobUpdater)Delegate.Combine(clearParallelResults, new JobUpdater(clearParallelSprites));
	}

	private void updateParallelChecks()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateParallelChecks(_elapsed);
			}
		}
	}

	private void updateVisibility()
	{
		if (!check(_cur_container))
		{
			return;
		}
		bool flag = MapBox.isRenderGameplay();
		Actor[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Actor actor = array[i];
			if (!actor.asset.has_sprite_renderer)
			{
				continue;
			}
			if (actor.isInMagnet() || actor.isInsideSomething())
			{
				actor.is_visible = false;
			}
			else if (flag)
			{
				if (actor.current_tile.zone.visible)
				{
					actor.is_visible = true;
				}
				else
				{
					actor.is_visible = false;
				}
			}
			else if (actor.asset.visible_on_minimap)
			{
				actor.is_visible = true;
			}
			else
			{
				actor.is_visible = false;
			}
		}
	}

	private void updateNutritionDecay()
	{
		if (World.world.timer_nutrition_decay > 0f || World.world.isPaused() || !check(_cur_container))
		{
			return;
		}
		bool pDoStarvationDamage = false;
		if (WorldLawLibrary.world_law_hunger.isEnabled())
		{
			pDoStarvationDamage = true;
		}
		Actor[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Actor actor = array[i];
			if (actor.needsFood() && !actor.isEgg() && (!actor.hasSubspecies() || !actor.subspecies.has_trait_energy_preserver || !actor.hasStatus("sleeping")))
			{
				actor.updateNutritionDecay(pDoStarvationDamage);
			}
		}
	}

	private void updateEventsBecomeAdult()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].eventBecomeAdult();
			}
		}
	}

	private void updateEventsEggHatched()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].eventHatchFromEgg();
			}
		}
	}

	private void updateActionLanded()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].actionLanded();
			}
		}
	}

	private void updateStats()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateStats();
			}
		}
	}

	private void u1_checkInside()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u1_checkInside(_elapsed);
			}
		}
	}

	private void u2_updateChildren()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u2_updateChildren(_elapsed);
			}
		}
	}

	private void u3_spriteAnimation()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u3_spriteAnimation(_elapsed);
			}
		}
	}

	private void u4_deadCheck()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u4_deadCheck(_elapsed);
			}
		}
	}

	private void u5_curTileAction()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u5_curTileAction();
			}
		}
	}

	private void u5_checkTileDeath()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].checkDieOnGroundBoat();
			}
		}
	}

	private void u6_checkFrozen()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u6_checkFrozen(_elapsed);
			}
		}
	}

	private void u7_checkAugmentationEffects()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u7_checkAugmentationEffects();
			}
		}
	}

	private void u8_checkUpdateTimers()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u8_checkUpdateTimers(_elapsed);
			}
		}
	}

	private void b1_checkUnderForce()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b1_checkUnderForce(_elapsed);
			}
		}
	}

	private void b2_checkCurrentEnemyTarget()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b2_checkCurrentEnemyTarget(_elapsed);
			}
		}
	}

	private void b3_findEnemyTarget()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b3_findEnemyTarget(_elapsed);
			}
		}
	}

	private void b4_checkTaskVerifier()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b4_checkTaskVerifier(_elapsed);
			}
		}
	}

	private void b5_checkPathMovement()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b5_checkPathMovement(_elapsed);
			}
		}
	}

	private void b6_0_updateDecision()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b6_0_updateDecision(_elapsed);
			}
			_cur_container.Clear();
		}
	}

	private void b55_updateNaturalDeaths()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b55_updateNaturalDeaths(_elapsed);
			}
		}
	}

	private void b6_updateAI()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].b6_updateAI(_elapsed);
			}
		}
	}

	private void u10_checkSmoothMovement()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].u10_checkSmoothMovement(_elapsed);
			}
		}
	}

	private void updateShake()
	{
		if (check(_cur_container))
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateShake(_elapsed);
			}
			_cur_container.checkAddRemove();
		}
	}

	private void updateHovering()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateHover(_elapsed);
			}
		}
	}

	private void updatePollinating()
	{
		if (check(_cur_container) && !World.world.isPaused())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updatePollinate(_elapsed);
			}
		}
	}

	private void updateDeathCheck()
	{
		if (check(_cur_container) && !World.world.isWindowOnScreen())
		{
			Actor[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].checkDeath();
			}
			_cur_container.Clear();
		}
	}

	internal override void clear()
	{
		base.clear();
		clearParallelResults?.Invoke();
	}

	private void clearParallelSprites()
	{
		l_parallel_update_sprites.Clear();
	}

	internal override void add(Actor pActor)
	{
		base.add(pActor);
		pActor.batch = this;
	}

	internal override void remove(Actor pObject)
	{
		base.remove(pObject);
		pObject.batch = null;
	}
}
// --- End of File: BatchActors.cs ---



// --- Start of File: BatchBuildings.cs ---
using System;
using System.Collections.Generic;
using Unity.Mathematics;

public class BatchBuildings : Batch<Building>
{
	public ObjectContainer<Building> c_main;

	public ObjectContainer<Building> c_scale;

	public ObjectContainer<Building> c_angle;

	public ObjectContainer<Building> c_components;

	public ObjectContainer<Building> c_spread_trees;

	public ObjectContainer<Building> c_spread_plants;

	public ObjectContainer<Building> c_spread_fungi;

	public ObjectContainer<Building> c_poop;

	public ObjectContainer<Building> c_resource_shaker;

	public ObjectContainer<Building> c_shake;

	public ObjectContainer<Building> c_position_dirty;

	public ObjectContainer<Building> c_tiles_dirty;

	public ObjectContainer<Building> c_stats_dirty;

	public ObjectContainer<Building> c_auto_remove;

	public Random rnd = new Random(10u);

	private float _timer_spread_trees;

	private float _timer_spread_plants;

	private float _timer_poop_flora;

	private float _timer_spread_fungi;

	public List<Action> actions_to_run = new List<Action>();

	protected override void createJobs()
	{
		addJob(null, prepare, JobType.Parallel, "prepare");
		createJob(out c_scale, updateScale, JobType.Parallel, "update_scale");
		createJob(out c_angle, updateAngle, JobType.Parallel, "update_angle");
		createJob(out c_resource_shaker, updateResourceShaker, JobType.Parallel, "update_resource_shaker");
		createJob(out c_stats_dirty, updateStatsDirty, JobType.Parallel, "update_dirty_stats");
		createJob(out c_shake, updateShake, JobType.Parallel, "update_shake");
		createJob(out c_main, updateVisibility, JobType.Parallel, "update_visibility");
		createJob(out c_tiles_dirty, updateTilesDirty, JobType.Post, "update_dirty_tiles");
		createJob(out c_auto_remove, updateAutoRemove, JobType.Post, "update_auto_remove");
		createJob(out c_components, updateComponents, JobType.Post, "update_components");
		createJob(out c_spread_trees, updateSpreadTrees, JobType.Post, "update_spread_trees");
		createJob(out c_spread_plants, updateSpreadPlants, JobType.Post, "update_spread_plants");
		createJob(out c_spread_fungi, updateSpreadFungi, JobType.Post, "update_spread_fungi");
		createJob(out c_poop, updatePoopTurningIntoFlora, JobType.Post, "update_poop_turning_into_flora");
		createJob(out c_position_dirty, updatePositionsDirty, JobType.Post, "update_dirty_positions");
		main = c_main;
		applyParallelResults = (JobUpdater)Delegate.Combine(applyParallelResults, new JobUpdater(applyTweenActions));
	}

	public void applyTweenActions()
	{
		if (actions_to_run.Count != 0)
		{
			for (int i = 0; i < actions_to_run.Count; i++)
			{
				actions_to_run[i]();
			}
			actions_to_run.Clear();
		}
	}

	internal override void clear()
	{
		base.clear();
		clearParallelResults?.Invoke();
		actions_to_run.Clear();
	}

	private void updateScale()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateScale();
			}
		}
	}

	private void updateAngle()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateAngle(_elapsed);
			}
		}
	}

	private void updateVisibility()
	{
		if (!check(_cur_container))
		{
			return;
		}
		bool flag = MapBox.isRenderGameplay();
		bool flag2 = World.world.quality_changer.shouldRenderBuildings();
		if (!DebugConfig.isOn(DebugOption.ScaleEffectEnabled) && flag2 && !flag)
		{
			flag2 = false;
		}
		Building[] array = _array;
		int count = _count;
		if (flag)
		{
			for (int i = 0; i < count; i++)
			{
				Building obj = array[i];
				obj.is_visible = obj.current_tile.zone.visible;
			}
		}
		else
		{
			for (int j = 0; j < count; j++)
			{
				array[j].is_visible = flag2;
			}
		}
	}

	private void updateTilesDirty()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].checkDirtyTiles();
			}
		}
	}

	private void updateAutoRemove()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateAutoRemove(_elapsed);
			}
		}
	}

	private void updateStatsDirty()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateStats();
			}
		}
	}

	private void updateComponents()
	{
		if (!check(_cur_container) || World.world.isPaused())
		{
			return;
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable())
			{
				building.updateComponents(_elapsed);
			}
		}
	}

	private void updateSpreadTrees()
	{
		if (!check(_cur_container) || World.world.isPaused() || !WorldLawLibrary.world_law_spread_trees.isEnabled())
		{
			return;
		}
		if (_timer_spread_trees >= 0f)
		{
			_timer_spread_trees -= _elapsed;
			if (_timer_spread_trees > 0f)
			{
				return;
			}
			_timer_spread_trees = WorldLawLibrary.getIntervalSpreadTrees();
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable())
			{
				building.checkVegetationSpread(_elapsed);
			}
		}
	}

	private void updateSpreadPlants()
	{
		if (!check(_cur_container) || World.world.isPaused() || !WorldLawLibrary.world_law_spread_plants.isEnabled())
		{
			return;
		}
		if (_timer_spread_plants >= 0f)
		{
			_timer_spread_plants -= _elapsed;
			if (_timer_spread_plants > 0f)
			{
				return;
			}
			_timer_spread_plants = WorldLawLibrary.getIntervalSpreadPlants();
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable())
			{
				building.checkVegetationSpread(_elapsed);
			}
		}
	}

	private void updatePoopTurningIntoFlora()
	{
		if (!check(_cur_container) || World.world.isPaused())
		{
			return;
		}
		if (_timer_poop_flora >= 0f)
		{
			_timer_poop_flora -= _elapsed;
			if (_timer_poop_flora > 0f)
			{
				return;
			}
			_timer_poop_flora = 5f;
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable() && !(building.getExistenceMonths() < (float)SimGlobals.m.months_till_pool_turns_into_flora) && !Randy.randomChance(0.7f))
			{
				WorldTile current_tile = building.current_tile;
				BiomeAsset biome_asset = current_tile.Type.biome_asset;
				if (biome_asset != null && biome_asset.grow_type_selector_plants != null)
				{
					building.startDestroyBuilding();
					BuildingActions.tryGrowVegetationRandom(current_tile, VegetationType.Plants, pOnStart: false, pCheckLimit: false, pCheckRandom: false);
				}
			}
		}
	}

	private void updateSpreadFungi()
	{
		if (!check(_cur_container) || World.world.isPaused() || !WorldLawLibrary.world_law_spread_fungi.isEnabled())
		{
			return;
		}
		if (_timer_spread_fungi >= 0f)
		{
			_timer_spread_fungi -= _elapsed;
			if (_timer_spread_fungi > 0f)
			{
				return;
			}
			_timer_spread_fungi = WorldLawLibrary.getIntervalSpreadFungi();
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable())
			{
				building.checkVegetationSpread(_elapsed);
			}
		}
	}

	private void updateResourceShaker()
	{
		if (!check(_cur_container) || World.world.isPaused())
		{
			return;
		}
		Building[] array = _array;
		int count = _count;
		for (int i = 0; i < count; i++)
		{
			Building building = array[i];
			if (building.isUsable())
			{
				building.updateTimerShakeResources(_elapsed);
			}
		}
	}

	private void updateShake()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updateShake(_elapsed);
			}
		}
	}

	private void updatePositionsDirty()
	{
		if (check(_cur_container))
		{
			Building[] array = _array;
			int count = _count;
			for (int i = 0; i < count; i++)
			{
				array[i].updatePosition();
			}
		}
	}

	internal override void add(Building pBuilding)
	{
		base.add(pBuilding);
		pBuilding.batch = this;
	}

	internal override void remove(Building pObject)
	{
		base.remove(pObject);
		pObject.batch = null;
	}
}
// --- End of File: BatchBuildings.cs ---



// --- Start of File: BattleContainer.cs ---
public class BattleContainer
{
	public float timer = 1f;

	public float timeout = 1f;

	public float timer_animation = 0.05f;

	public int frame;

	private int _deaths_civs;

	private int _deaths_mobs;

	public WorldTile tile;

	public int getDeathsTotal()
	{
		return _deaths_civs + _deaths_mobs;
	}

	public void increaseDeaths(Actor pActor)
	{
		if (pActor.isSapient())
		{
			_deaths_civs++;
		}
		else
		{
			_deaths_mobs++;
		}
	}

	public bool isRendered()
	{
		if (_deaths_civs <= 3)
		{
			return _deaths_mobs > 6;
		}
		return true;
	}
}
// --- End of File: BattleContainer.cs ---



// --- Start of File: BattleKeeperManager.cs ---
using System.Collections.Generic;
using UnityEngine;

public static class BattleKeeperManager
{
	private const int MAX_FRAMES = 8;

	private static HashSet<BattleContainer> _hashset;

	private static readonly List<BattleContainer> _to_remove = new List<BattleContainer>();

	public static void clear()
	{
		if (_hashset == null)
		{
			_hashset = new HashSet<BattleContainer>();
		}
		_hashset.Clear();
		_to_remove.Clear();
	}

	public static HashSet<BattleContainer> get()
	{
		return _hashset;
	}

	public static void update(float pElapsed)
	{
		if (_hashset.Count == 0)
		{
			return;
		}
		foreach (BattleContainer item in _hashset)
		{
			if (item.timer > 1f)
			{
				item.timer -= pElapsed;
				item.timer = Mathf.Clamp(item.timer, 1f, item.timer);
			}
			if (item.isRendered())
			{
				if (item.timer_animation > 0f)
				{
					item.timer_animation -= pElapsed;
				}
				else
				{
					item.timer_animation = 0.04f;
					item.frame++;
					if (item.frame >= 8)
					{
						item.frame = 7;
					}
				}
			}
			if (item.timeout > 0f)
			{
				item.timeout -= pElapsed;
				continue;
			}
			item.timer -= pElapsed;
			if (item.timer <= 0f)
			{
				_to_remove.Add(item);
			}
		}
		if (_to_remove.Count <= 0)
		{
			return;
		}
		foreach (BattleContainer item2 in _to_remove)
		{
			_hashset.Remove(item2);
		}
		_to_remove.Clear();
	}

	public static void addUnitKilled(Actor pActor)
	{
		BattleContainer battleContainer = null;
		foreach (BattleContainer item in _hashset)
		{
			if ((float)Toolbox.SquaredDistTile(item.tile, pActor.current_tile) < 1600f)
			{
				battleContainer = item;
				break;
			}
		}
		if (battleContainer != null || pActor.isSapient())
		{
			if (battleContainer == null)
			{
				battleContainer = new BattleContainer();
				battleContainer.tile = pActor.current_tile;
				_hashset.Add(battleContainer);
			}
			battleContainer.increaseDeaths(pActor);
			if (battleContainer.tile != pActor.current_tile && ((float)Toolbox.SquaredDistTile(battleContainer.tile, pActor.current_tile) < 25f || battleContainer.getDeathsTotal() < 3))
			{
				battleContainer.tile = pActor.current_tile;
			}
			battleContainer.timer = 1.2f;
			battleContainer.timeout = 1f;
			if (battleContainer.frame >= 7)
			{
				battleContainer.frame = 0;
			}
		}
	}
}
// --- End of File: BattleKeeperManager.cs ---



// --- Start of File: Beehive.cs ---
public class Beehive : BaseBuildingComponent
{
	public int honey;

	public void addHoney()
	{
		if (honey < 10)
		{
			honey++;
			if (honey == 10)
			{
				building.setHaveResourcesToCollect(pValue: true);
			}
		}
	}
}
// --- End of File: Beehive.cs ---



// --- Start of File: BehActive.cs ---
namespace ai.behaviours;

public class BehActive : BehaviourActionActor
{
}
// --- End of File: BehActive.cs ---



// --- Start of File: BehActiveCrabDangerCheck.cs ---
namespace ai.behaviours;

public class BehActiveCrabDangerCheck : BehActive
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isHungry())
		{
			return BehResult.Continue;
		}
		if (Toolbox.hasDifferentSpeciesInChunkAround(pActor.current_tile, pActor.asset.id))
		{
			pActor.cancelAllBeh();
			pActor.ai.setJob("crab_burrow");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehActiveCrabDangerCheck.cs ---



// --- Start of File: BehActorAddExperience.cs ---
namespace ai.behaviours;

public class BehActorAddExperience : BehaviourActionActor
{
	private int _min;

	private int _max;

	public BehActorAddExperience(int pMin, int pMax)
	{
		_min = pMin;
		_max = pMax;
	}

	public override BehResult execute(Actor pActor)
	{
		int pValue = Randy.randomInt(_min, _max + 1);
		pActor.addExperience(pValue);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorAddExperience.cs ---



// --- Start of File: BehActorAddStatus.cs ---
namespace ai.behaviours;

public class BehActorAddStatus : BehaviourActionActor
{
	private string _status_id;

	private float _override_timer;

	private bool _effect_on;

	private bool _add_action_timer;

	public BehActorAddStatus(string pStatusID, float pOverrideTimer = -1f, bool pEffectOn = true, bool pAddActionTimer = false)
	{
		_status_id = pStatusID;
		_override_timer = pOverrideTimer;
		_effect_on = pEffectOn;
		_add_action_timer = pAddActionTimer;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.addStatusEffect(_status_id, _override_timer, _effect_on);
		if (_add_action_timer)
		{
			pActor.makeWait(_override_timer);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehActorAddStatus.cs ---



// --- Start of File: BehActorBuildingTarget.cs ---
using ai.behaviours;

public class BehActorBuildingTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_building_target = true;
	}
}
// --- End of File: BehActorBuildingTarget.cs ---



// --- Start of File: BehActorChangeHappiness.cs ---
using ai.behaviours;

public class BehActorChangeHappiness : BehaviourActionActor
{
	private string _happiness_id;

	public BehActorChangeHappiness(string pID)
	{
		_happiness_id = pID;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.changeHappiness(_happiness_id);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorChangeHappiness.cs ---



// --- Start of File: BehActorCheckBool.cs ---
namespace ai.behaviours;

public class BehActorCheckBool : BehaviourActionActor
{
	private string actionIfBool;

	private string boolCheck;

	public BehActorCheckBool(string pBool, string pActionIfHit)
	{
		actionIfBool = pActionIfHit;
		boolCheck = pBool;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get(boolCheck, out var pResult, pDefault: false);
		if (pResult)
		{
			pActor.data.removeBool(boolCheck);
			return forceTask(pActor, actionIfBool);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehActorCheckBool.cs ---



// --- Start of File: BehActorCheckZoneTarget.cs ---
using ai.behaviours;

public class BehActorCheckZoneTarget : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		TileZone zoneToClaim = BehaviourActionBase<Actor>.world.city_zone_helper.city_growth.getZoneToClaim(pActor, pActor.city);
		if (zoneToClaim == null)
		{
			return BehResult.Stop;
		}
		if (zoneToClaim.city == city)
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		if (zoneToClaim.centerTile.isSameIsland(pActor.current_tile))
		{
			worldTile = zoneToClaim.centerTile;
		}
		else
		{
			foreach (WorldTile item in zoneToClaim.tiles.LoopRandom())
			{
				if (item.isSameIsland(pActor.current_tile))
				{
					worldTile = item;
					break;
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehActorCheckZoneTarget.cs ---



// --- Start of File: BehActorGiveTax.cs ---
using ai.behaviours;

public class BehActorGiveTax : BehCitizenActionCity
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isKing())
		{
			pActor.takeAllOwnLoot();
			return BehResult.Continue;
		}
		if (!pActor.city.hasLeader())
		{
			pActor.takeAllOwnLoot();
			return BehResult.Continue;
		}
		Actor leader = pActor.city.leader;
		if (pActor.isCityLeader())
		{
			if (!pActor.kingdom.hasKing())
			{
				pActor.takeAllOwnLoot();
			}
			else
			{
				payTributeToKing(pActor, pActor.kingdom.king, pActor.kingdom.getTaxRateTribute());
			}
		}
		else
		{
			payTaxToLeader(pActor, leader, pActor.kingdom.getTaxRateLocal());
		}
		return BehResult.Continue;
	}

	private void payTributeToKing(Actor pActor, Actor pKing, float pTaxRate)
	{
		if (pActor.loot > 0)
		{
			int loot = pActor.loot;
			int num = (int)((float)loot * pTaxRate);
			int num2 = loot - num;
			int num3 = (int)((float)num2 * 0.5f);
			num2 -= num3;
			pActor.city.addResourcesToRandomStockpile("gold", num3);
			pActor.addMoney(num2);
			pKing.addLoot(num);
			pActor.paidTax(pTaxRate, "fx_money_paid_tribute");
		}
	}

	private void payTaxToLeader(Actor pActor, Actor pTarget, float pTaxRate)
	{
		if (pActor.loot > 0)
		{
			int loot = pActor.loot;
			int num = (int)((float)loot * pTaxRate);
			int pValue = loot - num;
			pActor.addMoney(pValue);
			pTarget.addLoot(num);
			pActor.paidTax(pTaxRate, "fx_money_paid_tax");
		}
	}
}
// --- End of File: BehActorGiveTax.cs ---



// --- Start of File: BehActorRandomJump.cs ---
using UnityEngine;
using ai.behaviours;

public class BehActorRandomJump : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		float num = Randy.randomFloat(1f, 5f);
		float pForceHeight = Randy.randomFloat(1f, 2f);
		Vector2 current_position = pActor.current_position;
		float degrees = Randy.randomFloat(-180f, 180f);
		Vector2 val = current_position + Toolbox.rotateVector(current_position, degrees) * num;
		pActor.calculateForce(current_position.x, current_position.y, val.x, val.y, num, pForceHeight);
		pActor.punchTargetAnimation(Vector2.op_Implicit(current_position), pFlip: false, pReverse: false, -60f);
		if (pActor.is_visible)
		{
			Vector2 current_position2 = pActor.current_position;
			BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_dodge", current_position2, pActor.actor_scale);
			if ((Object)(object)baseEffect != (Object)null)
			{
				((Component)baseEffect).transform.rotation = Toolbox.getEulerAngle(current_position, val);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehActorRandomJump.cs ---



// --- Start of File: BehActorRemoveStatus.cs ---
namespace ai.behaviours;

public class BehActorRemoveStatus : BehaviourActionActor
{
	private string status;

	public BehActorRemoveStatus(string pStatus)
	{
		status = pStatus;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.finishStatusEffect(status);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorRemoveStatus.cs ---



// --- Start of File: BehActorReverseFlip.cs ---
using ai.behaviours;

public class BehActorReverseFlip : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.setFlip(!pActor.flip);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorReverseFlip.cs ---



// --- Start of File: BehActorSetBool.cs ---
namespace ai.behaviours;

public class BehActorSetBool : BehaviourActionActor
{
	private string boolName;

	private bool boolValue;

	public BehActorSetBool(string pBoolName, bool pBoolValue)
	{
		boolName = pBoolName;
		boolValue = pBoolValue;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.set(boolName, boolValue);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorSetBool.cs ---



// --- Start of File: BehActorSetFlip.cs ---
namespace ai.behaviours;

public class BehActorSetFlip : BehaviourActionActor
{
	private bool flip;

	public BehActorSetFlip(bool pFlip)
	{
		flip = pFlip;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.setFlip(flip);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorSetFlip.cs ---



// --- Start of File: BehActorSetFlying.cs ---
namespace ai.behaviours;

public class BehActorSetFlying : BehaviourActionActor
{
	private bool _flying;

	public BehActorSetFlying(bool pFlying)
	{
		_flying = pFlying;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.setFlying(_flying);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorSetFlying.cs ---



// --- Start of File: BehActorSetInt.cs ---
namespace ai.behaviours;

public class BehActorSetInt : BehaviourActionActor
{
	private string intName;

	private int intValue;

	public BehActorSetInt(string pIntName, int pIntValue)
	{
		intName = pIntName;
		intValue = pIntValue;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.set(intName, intValue);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorSetInt.cs ---



// --- Start of File: BehActorTryToAddRandomCombatSkill.cs ---
namespace ai.behaviours;

public class BehActorTryToAddRandomCombatSkill : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!Randy.randomChance(0.15f))
		{
			return BehResult.Stop;
		}
		ActorTrait random = AssetManager.traits.pot_traits_combat.GetRandom();
		pActor.addTrait(random);
		return BehResult.Continue;
	}
}
// --- End of File: BehActorTryToAddRandomCombatSkill.cs ---



// --- Start of File: BehActorTryToTakeItemFromCity.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehActorTryToTakeItemFromCity : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		foreach (List<long> allEquipmentList in city.data.equipment.getAllEquipmentLists())
		{
			City.giveItem(pActor, allEquipmentList, city);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehActorTryToTakeItemFromCity.cs ---



// --- Start of File: BehActorUsableBuildingTarget.cs ---
public class BehActorUsableBuildingTarget : BehActorBuildingTarget
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
	}
}
// --- End of File: BehActorUsableBuildingTarget.cs ---



// --- Start of File: BehAddAggroForBehTarget.cs ---
using ai.behaviours;

public class BehAddAggroForBehTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.addAggro(pActor.beh_actor_target.a);
		return BehResult.Continue;
	}
}
// --- End of File: BehAddAggroForBehTarget.cs ---



// --- Start of File: BehAddHappiness.cs ---
using ai.behaviours;

public class BehAddHappiness : BehaviourActionActor
{
	private string _happiness_id;

	public BehAddHappiness(string pHappinessID)
	{
		_happiness_id = pHappinessID;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.a.changeHappiness(_happiness_id);
		return BehResult.Continue;
	}
}
// --- End of File: BehAddHappiness.cs ---



// --- Start of File: BehAffectDreams.cs ---
using ai.behaviours;

public class BehAffectDreams : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Actor randomDreamingActor = getRandomDreamingActor(pActor);
		if (randomDreamingActor == null)
		{
			return BehResult.Stop;
		}
		randomDreamingActor.tryToConvertActorToMetaFromActor(pActor);
		return BehResult.Continue;
	}

	private Actor getRandomDreamingActor(Actor pActor)
	{
		BehaviourActionBase<Actor>.world.units.checkSleepingUnits();
		if (BehaviourActionBase<Actor>.world.units.cached_sleeping_units.Count == 0)
		{
			return null;
		}
		foreach (Actor item in BehaviourActionBase<Actor>.world.units.cached_sleeping_units.LoopRandom())
		{
			if (item.isAlive() && item.hasSubspecies() && item.hasStatus("sleeping") && (item.subspecies.has_advanced_memory || item.subspecies.has_advanced_communication))
			{
				return item;
			}
		}
		return null;
	}
}
// --- End of File: BehAffectDreams.cs ---



// --- Start of File: BehAngleAnimation.cs ---
namespace ai.behaviours;

public class BehAngleAnimation : BehaviourActionActor
{
	private AngleAnimationTarget _target;

	private float _timer_action;

	private float _angle;

	private string _sound_event_id;

	private bool _check_flip;

	public BehAngleAnimation(AngleAnimationTarget pTarget, string pSound = null, float pTimerAction = 0f, float pAngle = 40f, bool pCheckFlip = true, bool pLandIfHovering = false)
	{
		_sound_event_id = pSound;
		_angle = pAngle;
		_target = pTarget;
		_timer_action = pTimerAction;
		_check_flip = pCheckFlip;
		land_if_hovering = pLandIfHovering;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		switch (_target)
		{
		case AngleAnimationTarget.Tile:
			null_check_tile_target = true;
			break;
		case AngleAnimationTarget.Building:
			null_check_building_target = true;
			check_building_target_non_usable = true;
			break;
		case AngleAnimationTarget.Ruin:
			null_check_building_target = true;
			break;
		case AngleAnimationTarget.Actor:
			null_check_actor_target = true;
			break;
		}
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		WorldTile worldTile = pActor.current_tile;
		switch (_target)
		{
		case AngleAnimationTarget.Tile:
			worldTile = pActor.beh_tile_target;
			break;
		case AngleAnimationTarget.Building:
			worldTile = pActor.beh_building_target.current_tile;
			pActor.beh_building_target.startShake(0.3f);
			break;
		case AngleAnimationTarget.Actor:
			if (pActor.beh_actor_target.a.isInsideSomething())
			{
				return BehResult.Stop;
			}
			worldTile = pActor.beh_actor_target.current_tile;
			break;
		}
		pActor.punchTargetAnimation(worldTile.posV3, _check_flip, pReverse: false, _angle);
		if (!string.IsNullOrEmpty(_sound_event_id))
		{
			MusicBox.playSound(_sound_event_id, worldTile, pGameViewOnly: true);
		}
		pActor.timer_action = _timer_action;
		return BehResult.Continue;
	}
}
// --- End of File: BehAngleAnimation.cs ---



// --- Start of File: BehAnimalBreedingTime.cs ---
namespace ai.behaviours;

public class BehAnimalBreedingTime : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Toolbox.DistTile(pActor.current_tile, pActor.beh_actor_target.current_tile) > 1f)
		{
			return BehResult.Stop;
		}
		pActor.beh_actor_target.a.startShake();
		pActor.startShake();
		pActor.beh_actor_target.a.timer_action = 2f;
		EffectsLibrary.spawnAt("fx_hearts", pActor.current_position, 0.15f);
		return BehResult.Continue;
	}
}
// --- End of File: BehAnimalBreedingTime.cs ---



// --- Start of File: BehAnimalCheckHungry.cs ---
namespace ai.behaviours;

public class BehAnimalCheckHungry : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.isHungry())
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehAnimalCheckHungry.cs ---



// --- Start of File: BehAnimalFindTile.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehAnimalFindTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (Randy.randomChance(0.8f))
		{
			using IEnumerator<Actor> enumerator = Finder.findSpeciesAroundTileChunk(pActor.current_tile, "druid").GetEnumerator();
			if (enumerator.MoveNext())
			{
				Actor current = enumerator.Current;
				pActor.beh_tile_target = current.current_tile.region.getRandomTile();
				return BehResult.Continue;
			}
		}
		MapRegion mapRegion = pActor.current_tile.region;
		if (mapRegion.neighbours.Count > 0 && Randy.randomBool())
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.getRandomTile();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehAnimalFindTile.cs ---



// --- Start of File: BehAntSetup.cs ---
namespace ai.behaviours;

public class BehAntSetup : BehaviourActionActor
{
	private static string[] _ant_tile_types = new string[8] { "deep_ocean", "close_ocean", "shallow_waters", "sand", "soil_low", "soil_high", "hills", "mountains" };

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("tile_type1", out var pResult, null);
		if (string.IsNullOrEmpty(pResult))
		{
			pResult = getRandomTileType(pActor.current_tile?.Type?.id);
			string randomTileType = getRandomTileType(pResult);
			pActor.data.set("tile_type1", pResult);
			pActor.data.set("tile_type2", randomTileType);
		}
		return BehResult.Continue;
	}

	public static string getRandomTileType(string pExclude = null)
	{
		string random = _ant_tile_types.GetRandom();
		while (random == pExclude)
		{
			random = _ant_tile_types.GetRandom();
		}
		return random;
	}
}
// --- End of File: BehAntSetup.cs ---



// --- Start of File: BehAntSwitchGround.cs ---
namespace ai.behaviours;

public class BehAntSwitchGround : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("ant_steps", out var pResult, 0);
		pActor.data.get("direction", out var pResult2, 0);
		pActor.data.get("tile_type1", out var pResult3, null);
		pActor.data.get("tile_type2", out var pResult4, null);
		if (pActor.beh_tile_target.Type.IsType(pResult4))
		{
			Ant.antUseOnTile(pActor.beh_tile_target, pResult3);
			if (pResult++ > 3)
			{
				pResult2++;
				if (pResult2 > Toolbox.directions.Length - 1)
				{
					pResult2 = 0;
				}
				pResult = 0;
			}
		}
		else
		{
			Ant.antUseOnTile(pActor.beh_tile_target, pResult4);
			if (pResult++ > 3)
			{
				pResult2--;
				if (pResult2 < 0)
				{
					pResult2 = Toolbox.directions.Length - 1;
				}
				pResult = 0;
			}
		}
		pActor.data.set("ant_steps", pResult);
		pActor.data.set("direction", pResult2);
		return BehResult.Continue;
	}
}
// --- End of File: BehAntSwitchGround.cs ---



// --- Start of File: BehAttackActorHuntingTarget.cs ---
namespace ai.behaviours;

public class BehAttackActorHuntingTarget : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		BaseSimObject beh_actor_target = pActor.beh_actor_target;
		if (pActor.isInWaterAndCantAttack())
		{
			return BehResult.Stop;
		}
		if (beh_actor_target == null || !beh_actor_target.isAlive())
		{
			pActor.makeWait(0.5f);
			return BehResult.Continue;
		}
		if (pActor.isInAttackRange(beh_actor_target))
		{
			bool num = pActor.tryToAttack(beh_actor_target);
			if (num && pActor.hasRangeAttack())
			{
				pActor.makeWait(0.5f);
			}
			if (num && !beh_actor_target.isAlive())
			{
				return BehResult.Continue;
			}
			if (beh_actor_target.isAlive())
			{
				return BehResult.RepeatStep;
			}
			return BehResult.Continue;
		}
		return BehResult.StepBack;
	}
}
// --- End of File: BehAttackActorHuntingTarget.cs ---



// --- Start of File: BehaviourActionActor.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehaviourActionActor : BehaviourActionBase<Actor>
{
	public bool null_check_city;

	public bool null_check_kingdom;

	public bool null_check_tile_target;

	public bool null_check_building_target;

	public bool null_check_actor_target;

	public bool check_building_target_non_usable;

	public bool land_if_hovering;

	internal bool special_prevent_can_be_attacked;

	internal string force_animation_id = string.Empty;

	internal bool force_animation;

	internal bool socialize;

	protected static List<Actor> temp_actors = new List<Actor>();

	protected static List<WorldTile> possible_moves = new List<WorldTile>();

	public bool calibrate_target_position;

	public float check_actor_target_position_distance;

	public BehResult forceTask(Actor pActor, string pTask, bool pClean = true, bool pForceAction = false)
	{
		pActor.setTask(pTask, pClean, pCleanJob: false, pForceAction);
		return BehResult.Skip;
	}

	public BehResult forceTaskImmediate(Actor pActor, string pTask, bool pClean = true, bool pForceAction = false)
	{
		pActor.setTask(pTask, pClean, pCleanJob: false, pForceAction);
		return BehResult.ImmediateRun;
	}

	public override bool errorsFound(Actor pObject)
	{
		if (pObject.current_tile.region == null)
		{
			return true;
		}
		if (pObject.current_tile.region.island == null)
		{
			return true;
		}
		if (null_check_city)
		{
			if (pObject.city == null)
			{
				return true;
			}
			if (!pObject.city.isAlive())
			{
				return true;
			}
		}
		if (null_check_actor_target)
		{
			if (pObject.beh_actor_target == null)
			{
				return true;
			}
			if (!pObject.beh_actor_target.isAlive())
			{
				return true;
			}
		}
		if (null_check_tile_target && pObject.beh_tile_target == null)
		{
			return true;
		}
		if (check_building_target_non_usable)
		{
			if (pObject.beh_building_target == null)
			{
				return true;
			}
			if (!pObject.beh_building_target.isUsable())
			{
				return true;
			}
		}
		else if (null_check_building_target)
		{
			if (pObject.beh_building_target == null)
			{
				return true;
			}
			if (!pObject.beh_building_target.isAlive())
			{
				return true;
			}
		}
		return base.errorsFound(pObject);
	}

	public static void clear()
	{
		temp_actors.Clear();
		possible_moves.Clear();
	}
}
// --- End of File: BehaviourActionActor.cs ---



// --- Start of File: BehaviourActionBase.cs ---
using ai.behaviours;

public class BehaviourActionBase<T> : BehaviourElementAI
{
	public bool uses_kingdoms;

	public bool uses_cities;

	public bool uses_books;

	public bool uses_religions;

	public bool uses_languages;

	public bool uses_cultures;

	public bool uses_clans;

	public bool uses_plots;

	public bool uses_families;

	protected bool _has_error_check;

	protected static MapBox world => MapBox.instance;

	public override void create()
	{
		base.create();
		setupErrorChecks();
	}

	public virtual void prepare(T pObject)
	{
	}

	public virtual BehResult startExecute(T pObject)
	{
		if (_has_error_check)
		{
			if (shouldRetry(pObject))
			{
				return BehResult.RepeatStep;
			}
			if (errorsFound(pObject))
			{
				return BehResult.Stop;
			}
		}
		prepare(pObject);
		return execute(pObject);
	}

	public virtual BehResult execute(T pObject)
	{
		return BehResult.Continue;
	}

	protected virtual void setupErrorChecks()
	{
		setHasErrorCheck();
	}

	private void setHasErrorCheck()
	{
		_has_error_check = true;
	}

	public virtual bool errorsFound(T pObject)
	{
		return false;
	}

	public virtual bool shouldRetry(T pObject)
	{
		if (uses_cities && world.cities.isLocked())
		{
			return true;
		}
		if (uses_kingdoms && world.kingdoms.isLocked())
		{
			return true;
		}
		if (uses_books && world.books.isLocked())
		{
			return true;
		}
		if (uses_religions && world.religions.isLocked())
		{
			return true;
		}
		if (uses_languages && world.languages.isLocked())
		{
			return true;
		}
		if (uses_cultures && world.cultures.isLocked())
		{
			return true;
		}
		if (uses_clans && world.clans.isLocked())
		{
			return true;
		}
		if (uses_plots && world.plots.isLocked())
		{
			return true;
		}
		if (uses_families && world.families.isLocked())
		{
			return true;
		}
		return false;
	}
}
// --- End of File: BehaviourActionBase.cs ---



// --- Start of File: BehaviourActionCity.cs ---
public class BehaviourActionCity : BehaviourActionBase<City>
{
	public override bool errorsFound(City pCity)
	{
		if (!pCity.hasZones() || pCity.getPopulationPeople() == 0)
		{
			return true;
		}
		return base.errorsFound(pCity);
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_kingdoms = true;
		uses_cities = true;
	}
}
// --- End of File: BehaviourActionCity.cs ---



// --- Start of File: BehaviourActionKingdom.cs ---
public class BehaviourActionKingdom : BehaviourActionBase<Kingdom>
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_kingdoms = true;
		uses_cities = true;
	}
}
// --- End of File: BehaviourActionKingdom.cs ---



// --- Start of File: BehaviourActionTester.cs ---
public class BehaviourActionTester : BehaviourActionBase<AutoTesterBot>
{
	public bool null_check_tile_target;

	public override bool errorsFound(AutoTesterBot pObject)
	{
		if (null_check_tile_target && pObject.beh_tile_target == null)
		{
			return true;
		}
		return base.errorsFound(pObject);
	}
}
// --- End of File: BehaviourActionTester.cs ---



// --- Start of File: BehaviourActorCondition.cs ---
public class BehaviourActorCondition : BehaviourBaseCondition<Actor>
{
	public override bool check(Actor pActor)
	{
		return base.check(pActor);
	}
}
// --- End of File: BehaviourActorCondition.cs ---



// --- Start of File: BehaviourBaseCondition.cs ---
public abstract class BehaviourBaseCondition<T>
{
	public virtual bool check(T pObject)
	{
		return true;
	}
}
// --- End of File: BehaviourBaseCondition.cs ---



// --- Start of File: BehaviourCityCondition.cs ---
public class BehaviourCityCondition : BehaviourBaseCondition<City>
{
	public override bool check(City pCity)
	{
		return base.check(pCity);
	}
}
// --- End of File: BehaviourCityCondition.cs ---



// --- Start of File: BehaviourElementAI.cs ---
using System;

[Serializable]
public class BehaviourElementAI : Asset
{
	[NonSerialized]
	internal RateCounter rate_counter_calls;

	[NonSerialized]
	internal RateCounter rate_counter_performance;

	public override void create()
	{
		base.create();
		rate_counter_calls = new RateCounter("calls", 1);
		rate_counter_performance = new RateCounter("performance", 1);
	}
}
// --- End of File: BehaviourElementAI.cs ---



// --- Start of File: BehaviourKingdomCondition.cs ---
public class BehaviourKingdomCondition : BehaviourBaseCondition<Kingdom>
{
	public override bool check(Kingdom pKingdom)
	{
		return base.check(pKingdom);
	}
}
// --- End of File: BehaviourKingdomCondition.cs ---



// --- Start of File: BehaviourTaskActor.cs ---
using System;
using UnityEngine;

namespace ai.behaviours;

[Serializable]
public class BehaviourTaskActor : BehaviourTaskBase<BehaviourActionActor>
{
	public bool move_from_block;

	public bool ignore_fight_check;

	public bool in_combat;

	public string force_hand_tool = string.Empty;

	public bool flag_boat_related;

	public bool diet;

	public bool cancellable_by_reproduction;

	public bool cancellable_by_socialize;

	public bool is_fireman;

	public string path_icon = "ui/Icons/iconWarning";

	public bool show_icon;

	public float speed_multiplier = 1f;

	[NonSerialized]
	public UnitHandToolAsset cached_hand_tool_asset;

	private Sprite _cached_sprite;

	protected override string locale_key_prefix => "task_unit";

	public Sprite getSprite()
	{
		if ((Object)(object)_cached_sprite == (Object)null)
		{
			_cached_sprite = SpriteTextureLoader.getSprite(path_icon);
			if ((Object)(object)_cached_sprite == (Object)null)
			{
				Debug.LogError((object)("No sprite found for " + path_icon));
			}
		}
		return _cached_sprite;
	}

	public void setIcon(string pPath)
	{
		path_icon = pPath;
		show_icon = true;
	}
}
// --- End of File: BehaviourTaskActor.cs ---



// --- Start of File: BehaviourTaskActorLibrary.cs ---
namespace ai.behaviours;

public class BehaviourTaskActorLibrary : AssetLibrary<BehaviourTaskActor>
{
	public override void init()
	{
		base.init();
		initTasksMobs();
		initTasksSocializing();
		initTasksSubspeciesTraits();
		initTasksReproductionSexual();
		initTasksReproductionAsexual();
		initTasksChildren();
		initTasksStatusRelated();
		initTasksKings();
		initTasksLeaders();
		initTasksWarriors();
		initTasksSleep();
		initTasksPoop();
		initTasksThinkingReflectionHappiness();
		initTasksClanLeader();
		initTasksBoats();
		initTasksDragons();
		initTasksFingers();
		initTasksUFOs();
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "nothing",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_nothing"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "fighting",
			in_combat = true,
			locale_key = "task_unit_fight"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconWar");
		t.addBeh(new BehFightCheckEnemyIsOk());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: true, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "move_from_block",
			move_from_block = true,
			ignore_fight_check = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehMoveAwayFromBlock());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "swim_to_island",
			ignore_fight_check = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconTileShallowWater");
		t.addBeh(new BehGoToStablePlace());
		t.addBeh(new BehGoOrSwimToTileTarget());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "move_to_water",
			ignore_fight_check = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconTileShallowWater");
		t.addBeh(new BehGoToStablePlace());
		t.addBeh(new BehGoOrSwimToTileTarget());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "check_if_stuck_on_small_land",
			ignore_fight_check = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconTileSoil");
		t.addBeh(new BehCheckIfOnSmallLand());
		t.addBeh(new BehWalkIntoWaterCorner());
		t.addBeh(new BehGoOrSwimToTileTarget());
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "pollinate",
			locale_key = "task_unit_pollinate"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconBee");
		t.addBeh(new BehBeeCheckHome());
		t.addBeh(new BehFindBuilding("type_flower", pOnlyNonTargeted: true, pOnlyWithResources: false));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 3f, pLand: true));
		t.addBeh(new BehPollinate());
		t.addBeh(new BehBeeCheckReturnHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehBeeReturnHome());
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "bee_find_hive",
			locale_key = "task_unit_bee_find_hive"
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconBeehive");
		t.addBeh(new BehBeeCheckNoHome());
		t.addBeh(new BehFindBuilding("type_hive", pOnlyNonTargeted: false, pOnlyWithResources: false));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehBeeJoinHive());
		t.addBeh(new BehBeeReturnHome());
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "bee_create_hive",
			locale_key = "task_unit_bee_create_hive"
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/iconBeehive");
		t.addBeh(new BehBeeCheckNoHome());
		t.addBeh(new BehFindTile(TileFinderType.Biome));
		t.addBeh(new BehGoToTileTarget());
		for (int i = 0; i < 5; i++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, null, 0.5f, 40f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehBeeCreateHive());
		t.addBeh(new BehBeeJoinHive());
		t.addBeh(new BehBeeReturnHome());
		BehaviourTaskActor obj10 = new BehaviourTaskActor
		{
			id = "random_move",
			locale_key = "task_unit_move"
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		BehaviourTaskActor obj11 = new BehaviourTaskActor
		{
			id = "random_fun_move",
			locale_key = "task_unit_move"
		};
		pAsset = obj11;
		t = obj11;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		for (int j = 0; j < 6; j++)
		{
			t.addBeh(new BehFindRandomNeighbourTile());
			t.addBeh(new BehGoToTileTarget());
			t.addBeh(new BehRandomWait(0f, 0.01f));
		}
		BehaviourTaskActor obj12 = new BehaviourTaskActor
		{
			id = "run_away",
			speed_multiplier = 2f,
			ignore_fight_check = true,
			locale_key = "task_unit_flee"
		};
		pAsset = obj12;
		t = obj12;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconAgile");
		t.addBeh(new BehFindRandomFarTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		BehaviourTaskActor obj13 = new BehaviourTaskActor
		{
			id = "run_away_from_carnivore",
			speed_multiplier = 2f,
			ignore_fight_check = true,
			locale_key = "task_unit_flee"
		};
		pAsset = obj13;
		t = obj13;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconAgile");
		t.addBeh(new BehFindRandomFarTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		BehaviourTaskActor obj14 = new BehaviourTaskActor
		{
			id = "print_start"
		};
		pAsset = obj14;
		t = obj14;
		add(pAsset);
		t.setIcon("ui/Icons/iconPrinterStar");
		t.addBeh(new BehPrinterSetup());
		BehaviourTaskActor obj15 = new BehaviourTaskActor
		{
			id = "print_step"
		};
		pAsset = obj15;
		t = obj15;
		add(pAsset);
		t.setIcon("ui/Icons/iconPrinterStar");
		t.addBeh(new BehPrinterStep());
		BehaviourTaskActor obj16 = new BehaviourTaskActor
		{
			id = "worm_move"
		};
		pAsset = obj16;
		t = obj16;
		add(pAsset);
		t.setIcon("ui/Icons/iconWorm");
		t.addBeh(new BehFindRandomTile8Directions());
		t.addBeh(new BehWormDive());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehWormDig());
		BehaviourTaskActor obj17 = new BehaviourTaskActor
		{
			id = "sandspider_move"
		};
		pAsset = obj17;
		t = obj17;
		add(pAsset);
		t.setIcon("ui/Icons/iconSandSpider");
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehSandspiderCheckSand());
		t.addBeh(new BehSandspiderCheckDie());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehSandspiderBuildSand());
		BehaviourTaskActor obj18 = new BehaviourTaskActor
		{
			id = "ant_black_island"
		};
		pAsset = obj18;
		t = obj18;
		add(pAsset);
		t.setIcon("ui/Icons/iconAntBlack");
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehBlackAntBuildIsland());
		BehaviourTaskActor obj19 = new BehaviourTaskActor
		{
			id = "ant_black_sand"
		};
		pAsset = obj19;
		t = obj19;
		add(pAsset);
		t.setIcon("ui/Icons/iconAntBlack");
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehBlackAntBuildSand());
		BehaviourTaskActor obj20 = new BehaviourTaskActor
		{
			id = "ant_red_move"
		};
		pAsset = obj20;
		t = obj20;
		add(pAsset);
		t.setIcon("ui/Icons/iconAntRed");
		t.addBeh(new BehAntSetup());
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehAntSwitchGround());
		BehaviourTaskActor obj21 = new BehaviourTaskActor
		{
			id = "ant_blue_move"
		};
		pAsset = obj21;
		t = obj21;
		add(pAsset);
		t.setIcon("ui/Icons/iconAntBlue");
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehBlueAntSwitchGround());
		BehaviourTaskActor obj22 = new BehaviourTaskActor
		{
			id = "ant_green_move"
		};
		pAsset = obj22;
		t = obj22;
		add(pAsset);
		t.setIcon("ui/Icons/iconAntGreen");
		t.addBeh(new BehFindRandomTile4Directions());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		t.addBeh(new BehGreenAntSwitchGround());
		BehaviourTaskActor obj23 = new BehaviourTaskActor
		{
			id = "random_wait_short_1",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_wait"
		};
		pAsset = obj23;
		t = obj23;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		t.addBeh(new BehRandomWait(0.1f));
		BehaviourTaskActor obj24 = new BehaviourTaskActor
		{
			id = "investigate_curiosity",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj24;
		t = obj24;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_inquisitive_nature");
		t.addBeh(new BehCheckCuriosityTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 3f));
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehRandomWait(1f, 3f));
		t.addBeh(new BehFindRandomNeighbourTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 3f));
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj25 = new BehaviourTaskActor
		{
			id = "random_animal_move",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj25;
		t = obj25;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehAnimalFindTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 6f));
		BehaviourTaskActor obj26 = new BehaviourTaskActor
		{
			id = "random_move_towards_civ_building",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj26;
		t = obj26;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehFindRandomCivBuildingTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 4f));
		BehaviourTaskActor obj27 = new BehaviourTaskActor
		{
			id = "stay_in_random_house",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_nothing"
		};
		pAsset = obj27;
		t = obj27;
		add(pAsset);
		t.setIcon("ui/Icons/iconBuildings");
		t.addBeh(new BehCityActorFindBuilding("random_house_building"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(10f, 60f));
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj28 = new BehaviourTaskActor
		{
			id = "stay_in_own_home",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_nothing"
		};
		pAsset = obj28;
		t = obj28;
		add(pAsset);
		t.setIcon("ui/Icons/iconHoused");
		t.addBeh(new BehBuildingTargetHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(10f, 60f));
		t.addBeh(new BehRestoreStats(0.1f, 0.2f));
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj29 = new BehaviourTaskActor
		{
			id = "generate_loot",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_nothing"
		};
		pAsset = obj29;
		t = obj29;
		add(pAsset);
		t.setIcon("ui/Icons/iconMoney");
		t.addBeh(new BehBuildingTargetHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(2f, 6f));
		t.addBeh(new BehGenerateLootFromHouse());
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj30 = new BehaviourTaskActor
		{
			id = "random_swim",
			locale_key = "task_unit_move"
		};
		pAsset = obj30;
		t = obj30;
		add(pAsset);
		t.setIcon("ui/Icons/iconTileShallowWater");
		t.addBeh(new BehRandomSwim());
		t.addBeh(new BehRandomWait(0f, 2f));
		BehaviourTaskActor obj31 = new BehaviourTaskActor
		{
			id = "make_decision"
		};
		pAsset = obj31;
		t = obj31;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconStupid");
		t.addBeh(new BehMakeDecision());
		BehaviourTaskActor obj32 = new BehaviourTaskActor
		{
			id = "try_new_plot",
			locale_key = "task_unit_plot"
		};
		pAsset = obj32;
		t = obj32;
		add(pAsset);
		t.setIcon("ui/Icons/iconPlot");
		t.addBeh(new BehTryNewPlot());
		BehaviourTaskActor obj33 = new BehaviourTaskActor
		{
			id = "check_plot",
			locale_key = "task_unit_plot"
		};
		pAsset = obj33;
		t = obj33;
		add(pAsset);
		t.setIcon("ui/Icons/iconPlot");
		t.addBeh(new BehCheckPlot());
		BehaviourTaskActor obj34 = new BehaviourTaskActor
		{
			id = "progress_plot",
			force_hand_tool = "coffee_cup",
			locale_key = "task_unit_plot"
		};
		pAsset = obj34;
		t = obj34;
		add(pAsset);
		t.setIcon("ui/Icons/iconPlot");
		t.addBeh(new BehCheckPlotIsOk());
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehWait(2f));
		t.addBeh(new BehCheckPlotProgress());
		t.addBeh(new BehSpawnPlotProgressEffect());
		t.addBeh(new BehCheckNeeds(0));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj35 = new BehaviourTaskActor
		{
			id = "try_to_eat_city_food",
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj35;
		t = obj35;
		add(pAsset);
		t.setIcon("ui/Icons/iconHunger");
		t.addBeh(new BehCheckHasMoneyForCityFood());
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0.1f));
		for (int k = 0; k < 3; k++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 0.2f));
		}
		t.addBeh(new BehTryToEatCityFood());
		for (int l = 0; l < 3; l++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 0.2f));
		}
		t.addBeh(new BehRandomWait(1f, 5f));
		BehaviourTaskActor obj36 = new BehaviourTaskActor
		{
			id = "find_house"
		};
		pAsset = obj36;
		t = obj36;
		add(pAsset);
		t.setIcon("ui/Icons/iconBuildings");
		t.addBeh(new BehFindHouse());
		BehaviourTaskActor obj37 = new BehaviourTaskActor
		{
			id = "random_move_near_house",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj37;
		t = obj37;
		add(pAsset);
		t.setIcon("ui/Icons/iconLivingHouse");
		t.addBeh(new BehFindRandomFrontTileNearHouse());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 6f));
		BehaviourTaskActor obj38 = new BehaviourTaskActor
		{
			id = "end_job"
		};
		pAsset = obj38;
		t = obj38;
		add(pAsset);
		t.setIcon("ui/Icons/iconClose");
		t.addBeh(new BehEndJob());
		BehaviourTaskActor obj39 = new BehaviourTaskActor
		{
			id = "check_end_job"
		};
		pAsset = obj39;
		t = obj39;
		add(pAsset);
		t.setIcon("ui/Icons/iconClose");
		t.addBeh(new BehCheckEndCityActorJob());
		BehaviourTaskActor obj40 = new BehaviourTaskActor
		{
			id = "check_city_destroyed"
		};
		pAsset = obj40;
		t = obj40;
		add(pAsset);
		t.setIcon("ui/Icons/iconWar");
		t.addBeh(new BehCheckCityDestroyed());
		BehaviourTaskActor obj41 = new BehaviourTaskActor
		{
			id = "build_civ_city_here"
		};
		pAsset = obj41;
		t = obj41;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCheckBuildCity());
		t.addBeh(new BehEndJob());
		BehaviourTaskActor obj42 = new BehaviourTaskActor
		{
			id = "try_to_start_new_civilization"
		};
		pAsset = obj42;
		t = obj42;
		add(pAsset);
		t.setIcon("ui/Icons/iconKingdom");
		t.addBeh(new BehCheckEnemyNotNear());
		t.addBeh(new BehCheckStartCivilization());
		BehaviourTaskActor obj43 = new BehaviourTaskActor
		{
			id = "check_join_city"
		};
		pAsset = obj43;
		t = obj43;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehJoinCity());
		t.addBeh(new BehEndJob());
		BehaviourTaskActor obj44 = new BehaviourTaskActor
		{
			id = "check_join_empty_nearby_city"
		};
		pAsset = obj44;
		t = obj44;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehFindNearbyPotentialCivCityToJoin());
		BehaviourTaskActor obj45 = new BehaviourTaskActor
		{
			id = "try_to_read",
			force_hand_tool = "book",
			cancellable_by_reproduction = true,
			cancellable_by_socialize = true,
			locale_key = "task_unit_read"
		};
		pAsset = obj45;
		t = obj45;
		add(pAsset);
		t.setIcon("ui/Icons/iconBooks");
		t.addBeh(new BehTryToRead());
		for (int m = 0; m < 7; m++)
		{
			t.addBeh(new BehFindRandomNeighbourTile());
			t.addBeh(new BehGoToTileTarget());
			t.addBeh(new BehSpawnHmmEffect());
			for (int n = 0; n < 5; n++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 1f, 6f));
			}
			t.addBeh(new BehActorReverseFlip());
			for (int num = 0; num < 5; num++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 1f, 6f));
			}
		}
		t.addBeh(new BehFinishReading());
		BehaviourTaskActor obj46 = new BehaviourTaskActor
		{
			id = "citizen"
		};
		pAsset = obj46;
		t = obj46;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehRandomWait(1f, 5f));
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		BehaviourTaskActor obj47 = new BehaviourTaskActor
		{
			id = "try_to_take_city_item"
		};
		pAsset = obj47;
		t = obj47;
		add(pAsset);
		t.setIcon("ui/Icons/items/icon_sword_wood");
		t.addBeh(new BehActorTryToTakeItemFromCity());
		BehaviourTaskActor obj48 = new BehaviourTaskActor
		{
			id = "city_idle_walking",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_walk"
		};
		pAsset = obj48;
		t = obj48;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCityActorGetRandomIdleTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 6f));
		BehaviourTaskActor obj49 = new BehaviourTaskActor
		{
			id = "city_walking_to_danger_zone",
			locale_key = "task_unit_investigate"
		};
		pAsset = obj49;
		t = obj49;
		add(pAsset);
		t.setIcon("ui/Icons/iconWar");
		t.addBeh(new BehCityActorGetRandomDangerZone());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 6f));
		BehaviourTaskActor obj50 = new BehaviourTaskActor
		{
			id = "find_city_job"
		};
		pAsset = obj50;
		t = obj50;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCityActorFindNewJob());
		BehaviourTaskActor obj51 = new BehaviourTaskActor
		{
			id = "give_tax"
		};
		pAsset = obj51;
		t = obj51;
		add(pAsset);
		t.setIcon("ui/Icons/iconTax");
		t.addBeh(new BehActorGiveTax());
		BehaviourTaskActor obj52 = new BehaviourTaskActor
		{
			id = "do_hunting",
			cancellable_by_reproduction = true,
			in_combat = true,
			ignore_fight_check = true,
			locale_key = "task_unit_hunt"
		};
		pAsset = obj52;
		t = obj52;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobHunter");
		t.addBeh(new BehFindTargetForHunter());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehAttackActorHuntingTarget());
		addActionsForDeliverResources(t);
		BehaviourTaskActor obj53 = new BehaviourTaskActor
		{
			id = "make_items"
		};
		pAsset = obj53;
		t = obj53;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobBlacksmith");
		t.addBeh(new BehBuildingTargetHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(10f, 15f));
		t.addBeh(new BehMakeItem());
		t.addBeh(new BehActorTryToTakeItemFromCity());
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj54 = new BehaviourTaskActor
		{
			id = "cleaning",
			force_hand_tool = "hammer",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_cleaning_ruins"
		};
		pAsset = obj54;
		t = obj54;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobCleaner");
		t.addBeh(new BehCityActorFindBuilding("ruins"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0.3f, 0.3f));
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num2 = 0; num2 < 3; num2++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Ruin, "event:/SFX/CIVILIZATIONS/CleanRuins", 1f, 40f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Ruin, "event:/SFX/CIVILIZATIONS/CleanRuins", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
		t.addBeh(new BehRemoveRuins());
		addActionsForDeliverResources(t);
		BehaviourTaskActor obj55 = new BehaviourTaskActor
		{
			id = "manure_cleaning",
			force_hand_tool = "basket",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_cleaning_poop"
		};
		pAsset = obj55;
		t = obj55;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobCleaner");
		t.addBeh(new BehCityActorFindBuilding("type_poop"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num3 = 0; num3 < 5; num3++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/CollectHerbs"));
		}
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		t.addBeh(new BehCheckNeeds(6));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj56 = new BehaviourTaskActor
		{
			id = "put_out_fire",
			force_hand_tool = "bucket",
			locale_key = "task_unit_extinguish",
			is_fireman = true
		};
		pAsset = obj56;
		t = obj56;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFireman");
		t.addBeh(new BehCityActorFindFireZone());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehCityActorFindClosestFire());
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0f, -20f, pCheckFlip: false));
		t.addBeh(new BehRandomWait(0.1f, 0.5f));
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile));
		t.addBeh(new BehCityActorRemoveFire());
		t.addBeh(new BehRandomWait(0.4f, 1.2f));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj57 = new BehaviourTaskActor
		{
			id = "try_build_building",
			force_hand_tool = "hammer",
			locale_key = "task_unit_build"
		};
		pAsset = obj57;
		t = obj57;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobBuilder");
		t.addBeh(new BehCityActorFindBuilding("new_building"));
		t.addBeh(new BehSetNextTask("build_building", pClean: false, pForce: true));
		BehaviourTaskActor obj58 = new BehaviourTaskActor
		{
			id = "build_building",
			force_hand_tool = "hammer",
			locale_key = "task_unit_build"
		};
		pAsset = obj58;
		t = obj58;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobBuilder");
		t.addBeh(new BehCheckStillUnderConstruction());
		t.addBeh(new BehFindConstructionTile());
		t.addBeh(new BehGoToTileTarget());
		for (int num4 = 0; num4 < 5; num4++)
		{
			t.addBeh(new BehCheckStillUnderConstruction());
			t.addBeh(new BehLookAtBuildingTarget());
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, "event:/SFX/BUILDINGS/onstructionBuildingGeneric", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
			t.addBeh(new BehBuildTarget());
		}
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj59 = new BehaviourTaskActor
		{
			id = "build_road",
			force_hand_tool = "hammer",
			locale_key = "task_unit_build"
		};
		pAsset = obj59;
		t = obj59;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobRoadBuilder");
		t.addBeh(new BehFindTile(TileFinderType.NewRoad)
		{
			null_check_city = true
		});
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0.2f));
		for (int num5 = 0; num5 < 3; num5++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, "event:/SFX/CIVILIZATIONS/BuildRoad", 1f, 40f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, "event:/SFX/CIVILIZATIONS/BuildRoad", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
		t.addBeh(new BehCityActorCreateRoad());
		t.addBeh(new BehRandomWait(1f, 2f));
		t.addBeh(new BehCheckNeeds(10));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj60 = new BehaviourTaskActor
		{
			id = "collect_fruits",
			force_hand_tool = "basket",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_collect_food"
		};
		pAsset = obj60;
		t = obj60;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobGathererBushes");
		t.addBeh(new BehCityActorFindBuilding("type_fruits"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num6 = 0; num6 < 4; num6++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/CollectFruits"));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/CollectFruits"));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		t.addBeh(new BehCheckNeeds(5));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj61 = new BehaviourTaskActor
		{
			id = "collect_honey",
			force_hand_tool = "basket",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_collect_honey"
		};
		pAsset = obj61;
		t = obj61;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobGathererHoney");
		t.addBeh(new BehCityActorFindBuilding("type_hive"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num7 = 0; num7 < 4; num7++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, null));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, null));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		t.addBeh(new BehCheckNeeds(3));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj62 = new BehaviourTaskActor
		{
			id = "claim_land",
			force_hand_tool = "flag",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_claim_land"
		};
		pAsset = obj62;
		t = obj62;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenLandClaimer");
		t.addBeh(new BehActorCheckZoneTarget());
		t.addBeh(new BehGoToTileTarget());
		for (int num8 = 0; num8 < 21; num8++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.5f, 0.5f));
			t.addBeh(new BehSpawnCityBorderEffect());
		}
		t.addBeh(new BehClaimZoneForCityActorBorder());
		t.addBeh(new BehSpawnCityBorderEffect(5));
		t.addBeh(new BehEndJob());
		BehaviourTaskActor obj63 = new BehaviourTaskActor
		{
			id = "collect_herbs",
			force_hand_tool = "basket",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_collect_herbs"
		};
		pAsset = obj63;
		t = obj63;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobGathererHerbs");
		t.addBeh(new BehCityActorFindBuilding("type_vegetation"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num9 = 0; num9 < 4; num9++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/CollectHerbs"));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/CollectHerbs"));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		t.addBeh(new BehCheckNeeds(4));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj64 = new BehaviourTaskActor
		{
			id = "chop_trees",
			force_hand_tool = "axe",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_chop"
		};
		pAsset = obj64;
		t = obj64;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobWoodcutter");
		t.addBeh(new BehCityActorFindBuilding("type_tree"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num10 = 0; num10 < 7; num10++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/ChopTree"));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/ChopTree"));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		BehaviourTaskActor obj65 = new BehaviourTaskActor
		{
			id = "mine_deposit",
			force_hand_tool = "pickaxe",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_mine"
		};
		pAsset = obj65;
		t = obj65;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobMinerDeposit");
		t.addBeh(new BehCityActorFindBuilding("type_mineral"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int num11 = 0; num11 < 6; num11++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/MiningMineral"));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/MiningMineral"));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t);
		t.addBeh(new BehCheckNeeds(3));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj66 = new BehaviourTaskActor
		{
			id = "farmer_make_field",
			force_hand_tool = "hoe",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_farm"
		};
		pAsset = obj66;
		t = obj66;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFarmer");
		t.addBeh(new BehFindTileForFarm());
		t.addBeh(new BehGoToTileTarget());
		for (int num12 = 0; num12 < 6; num12++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, "event:/SFX/CIVILIZATIONS/MakeFarmField", 1f, 40f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehMakeFarm());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj67 = new BehaviourTaskActor
		{
			id = "farmer_plant_crops",
			force_hand_tool = "hoe",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_farm"
		};
		pAsset = obj67;
		t = obj67;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFarmer");
		t.addBeh(new BehFindFarmField());
		t.addBeh(new BehGoToTileTarget());
		for (int num13 = 0; num13 < 4; num13++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, "event:/SFX/CIVILIZATIONS/PlantCrops", 1f, 40f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehPlantCrops());
		t.addBeh(new BehRandomWait(1f, 2f));
		t.addBeh(new BehCheckNeeds(6));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj68 = new BehaviourTaskActor
		{
			id = "farmer_harvest",
			force_hand_tool = "hoe",
			locale_key = "task_unit_farm"
		};
		pAsset = obj68;
		t = obj68;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFarmer");
		t.addBeh(new BehFindWheat());
		t.addBeh(new BehGoToBuildingTarget());
		for (int num14 = 0; num14 < 3; num14++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/CIVILIZATIONS/HarvestCrops"));
		}
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/HarvestCrops"));
		t.addBeh(new BehExtractResourcesFromBuilding());
		addActionsForDeliverResources(t, pWheatStorage: true);
		t.addBeh(new BehCheckNeeds(6));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj69 = new BehaviourTaskActor
		{
			id = "farmer_fertilize_crops",
			force_hand_tool = "bucket",
			cancellable_by_reproduction = true,
			locale_key = "task_unit_farm"
		};
		pAsset = obj69;
		t = obj69;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFarmer");
		t.addBeh(new BehCityActorFindStorage());
		t.addBeh(new BehGoToBuildingTarget());
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, null, 1f, 40f, pCheckFlip: true, pLandIfHovering: true));
		t.addBeh(new BehCityActorGetResourceFromStorage("fertilizer", 5));
		for (int num15 = 0; num15 < 5; num15++)
		{
			t.addBeh(new BehCityActorFindUngrownCrop());
			t.addBeh(new BehGoToBuildingTarget());
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, null, 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
			t.addBeh(new BehThrowResourceAnimation("fertilizer"));
			t.addBeh(new BehWait());
			t.addBeh(new BehCityActorFertilizeCrop());
		}
		addActionsForDeliverResources(t);
		t.addBeh(new BehRandomWait(1f, 2f));
		t.addBeh(new BehCheckNeeds(6));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj70 = new BehaviourTaskActor
		{
			id = "farmer_random_move",
			force_hand_tool = "hoe",
			locale_key = "task_unit_farm"
		};
		pAsset = obj70;
		t = obj70;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobFarmer");
		t.addBeh(new BehFindRandomFarmTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj71 = new BehaviourTaskActor
		{
			id = "store_resources",
			locale_key = "task_unit_store_resources"
		};
		pAsset = obj71;
		t = obj71;
		add(pAsset);
		t.setIcon("ui/Icons/iconCityInventory");
		addActionsForDeliverResources(t);
		BehaviourTaskActor obj72 = new BehaviourTaskActor
		{
			id = "mine",
			force_hand_tool = "pickaxe",
			locale_key = "task_unit_mine"
		};
		pAsset = obj72;
		t = obj72;
		add(pAsset);
		t.setIcon("ui/Icons/citizen_jobs/iconCitizenJobMiner");
		t.addBeh(new BehCityActorFindBuilding("type_mine"));
		t.addBeh(new BehGoToBuildingTarget());
		t.addBeh(new BehStayInBuildingTarget(10f, 15f));
		t.addBeh(new BehGetResourcesFromMine());
		t.addBeh(new BehExitBuilding());
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 2f));
		t.addBeh(new BehCheckNeeds(3));
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj73 = new BehaviourTaskActor
		{
			id = "try_to_return_to_home_city",
			flag_boat_related = true
		};
		pAsset = obj73;
		t = obj73;
		add(pAsset);
		t.setIcon("ui/Icons/iconHoused");
		t.addBeh(new BehTaxiCheck());
		t.addBeh(new BehRandomWait(1f));
		t.addBeh(new BehTaxiFindShipTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehTaxiEmbark());
		BehaviourTaskActor obj74 = new BehaviourTaskActor
		{
			id = "force_into_a_boat",
			flag_boat_related = true
		};
		pAsset = obj74;
		t = obj74;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehTaxiFindShipTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehTaxiEmbark());
		BehaviourTaskActor obj75 = new BehaviourTaskActor
		{
			id = "embark_into_boat",
			flag_boat_related = true
		};
		pAsset = obj75;
		t = obj75;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehTaxiEmbark());
		BehaviourTaskActor obj76 = new BehaviourTaskActor
		{
			id = "sit_inside_boat",
			flag_boat_related = true
		};
		pAsset = obj76;
		t = obj76;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehTaxiSitInside());
		t.addBeh(new BehTaxiSitInside());
		t.addBeh(new BehTaxiSitInside());
		BehaviourTaskActor obj77 = new BehaviourTaskActor
		{
			id = "wait",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_wait"
		};
		pAsset = obj77;
		t = obj77;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		t.addBeh(new BehRandomWait(0.5f, 1.3f));
		BehaviourTaskActor obj78 = new BehaviourTaskActor
		{
			id = "wait5",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_wait"
		};
		pAsset = obj78;
		t = obj78;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		t.addBeh(new BehRandomWait(1f, 5f));
		BehaviourTaskActor obj79 = new BehaviourTaskActor
		{
			id = "wait10",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_wait"
		};
		pAsset = obj79;
		t = obj79;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		t.addBeh(new BehRandomWait(1f, 10f));
		BehaviourTaskActor obj80 = new BehaviourTaskActor
		{
			id = "replenish_energy",
			cancellable_by_socialize = false,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_replenish_energy"
		};
		pAsset = obj80;
		t = obj80;
		add(pAsset);
		t.setIcon("ui/Icons/iconStamina");
		t.addBeh(new BehFindBuilding("type_well", pOnlyNonTargeted: false, pOnlyWithResources: false));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num16 = 0; num16 < 5; num16++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, null, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehReplenishEnergy());
		BehaviourTaskActor obj81 = new BehaviourTaskActor
		{
			id = "repair_equipment",
			cancellable_by_socialize = false,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_repair_equipment"
		};
		pAsset = obj81;
		t = obj81;
		add(pAsset);
		t.setIcon("ui/Icons/iconReforge");
		t.addBeh(new BehCheckCanRepairEquipment());
		t.addBeh(new BehFindBuilding("type_barracks", pOnlyNonTargeted: false, pOnlyWithResources: false));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num17 = 0; num17 < 5; num17++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, null, 1f, 20f));
		}
		t.addBeh(new BehRepairEquipment());
	}

	private void initTasksThinkingReflectionHappiness()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "try_to_steal_money"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconThief");
		t.addBeh(new BehFindTargetToStealFrom());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.NearbyTileClosest, pPathOnWater: false, pCheckCanAttackTarget: false, pCalibrateTargetPosition: true));
		for (int i = 0; i < 2; i++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Actor, null, 0.3f, 30f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehStealFromTarget());
		t.addBeh(new BehSetNextTask("run_away"));
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "reflection"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconBre");
		t.addBeh(new BehReflection());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "madness_random_emotion"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconMadness");
		t.addBeh(new BehMadnessRandomEmotion());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "happy_laughing"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconLaughing");
		t.addBeh(new BehTryFindTargetWithStatusNearby("laughing", "crying", "swearing", "singing"));
		t.addBeh(new BehGoToTileTarget());
		for (int j = 0; j < 4; j++)
		{
			t.addBeh(new BehActorAddStatus("laughing", 2f, pEffectOn: false));
			for (int k = 0; k < 3; k++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0.2f, -20f, pCheckFlip: false));
			}
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehWait(0.3f));
		}
		t.addBeh(new BehAddHappiness("just_laughed"));
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "singing"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconSinging");
		t.addBeh(new BehTryFindTargetWithStatusNearby("laughing", "crying", "swearing", "singing"));
		t.addBeh(new BehGoToTileTarget());
		for (int l = 0; l < 5; l++)
		{
			t.addBeh(new BehJumpingAnimation(0f, 5f));
			t.addBeh(new BehActorAddStatus("singing", 3f, pEffectOn: false));
			for (int m = 0; m < 3; m++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0.4f, -30f, pCheckFlip: false));
				t.addBeh(new BehActorReverseFlip());
				t.addBeh(new BehWait(0.1f));
			}
		}
		t.addBeh(new BehAddHappiness("just_sang"));
		t.addBeh(new BehFinishSinging());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "swearing"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconSwearing");
		t.addBeh(new BehTryFindTargetWithStatusNearby("laughing", "crying", "swearing", "singing"));
		t.addBeh(new BehGoToTileTarget());
		for (int n = 0; n < 4; n++)
		{
			t.addBeh(new BehActorAddStatus("swearing", 2f, pEffectOn: false));
			for (int num = 0; num < 3; num++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0.2f, -20f, pCheckFlip: false));
			}
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehWait(0.3f));
		}
		t.addBeh(new BehAddHappiness("just_swore"));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "crying"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconCrying");
		t.addBeh(new BehTryFindTargetWithStatusNearby("laughing", "crying", "swearing", "singing"));
		t.addBeh(new BehGoToTileTarget());
		for (int num2 = 0; num2 < 4; num2++)
		{
			t.addBeh(new BehActorAddStatus("crying", 2f, pEffectOn: false));
			for (int num3 = 0; num3 < 3; num3++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0.2f, -20f, pCheckFlip: false));
			}
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehWait(0.3f));
		}
		t.addBeh(new BehAddHappiness("just_cried"));
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "possessed_following"
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconPossessed");
		t.addBeh(new BehTryFindTargetWithStatusNearby("possessed"));
		t.addBeh(new BehCopyAggro());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehFindRandomNeighbourTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0.5f, 2f));
		t.addBeh(new BehRandomSocializeTopic(1.5f, 3f, 0.1f));
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "start_tantrum"
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/iconTantrum");
		for (int num4 = 0; num4 < 6; num4++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.1f, 0.1f));
		}
		t.addBeh(new BehActorAddStatus("tantrum", 60f));
		BehaviourTaskActor obj10 = new BehaviourTaskActor
		{
			id = "do_tantrum"
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.setIcon("ui/Icons/iconTantrum");
		t.addBeh(new BehFindTantrumTarget());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.RaycastWithAttackRange, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehAddAggroForBehTarget());
		BehaviourTaskActor obj11 = new BehaviourTaskActor
		{
			id = "punch_a_tree"
		};
		pAsset = obj11;
		t = obj11;
		add(pAsset);
		t.setIcon("ui/Icons/iconRage");
		t.addBeh(new BehFindBuilding("type_tree", pOnlyNonTargeted: true, pOnlyWithResources: false));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num5 = 0; num5 < 2; num5++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/HIT/HitWood"));
		}
		t.addBeh(new BehGetDamaged(1, AttackType.Gravity));
		t.addBeh(new BehActorAddStatus("crying", 5f, pEffectOn: false, pAddActionTimer: true));
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj12 = new BehaviourTaskActor
		{
			id = "punch_a_building"
		};
		pAsset = obj12;
		t = obj12;
		add(pAsset);
		t.setIcon("ui/Icons/iconRage");
		t.addBeh(new BehFindBuilding("type_house", pOnlyNonTargeted: false, pOnlyWithResources: false));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num6 = 0; num6 < 2; num6++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/HIT/HitGeneric"));
		}
		t.addBeh(new BehGetDamaged(1, AttackType.Gravity));
		t.addBeh(new BehActorAddStatus("crying", 5f, pEffectOn: false, pAddActionTimer: true));
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj13 = new BehaviourTaskActor
		{
			id = "start_fire"
		};
		pAsset = obj13;
		t = obj13;
		add(pAsset);
		t.setIcon("ui/Icons/iconFire");
		t.addBeh(new BehWait());
	}

	private void initTasksClanLeader()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "kill_unruly_clan_members"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/clan_traits/clan_trait_deathbound");
		t.addBeh(new BehClanChiefCheckMembersToKill());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "banish_unruly_clan_members"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/clan_traits/clan_trait_blood_pact");
		t.addBeh(new BehClanChiefCheckMembersToBanish());
	}

	private void initTasksPoop()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "try_to_poop"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconPoop");
		t.addBeh(new BehDecideWhereToPoop());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "try_to_launch_fireworks"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconFireworks");
		t.addBeh(new BehTryFindTargetWithStatusNearby("laughing", "crying", "swearing", "singing"));
		t.addBeh(new BehGoToTileTarget());
		for (int i = 0; i < 1; i++)
		{
			t.addBeh(new BehActorAddStatus("laughing", 2f, pEffectOn: false));
			for (int j = 0; j < 3; j++)
			{
				t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Nothing, null, 0.2f, -20f, pCheckFlip: false, pLandIfHovering: true));
			}
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehWait(0.3f));
		}
		t.addBeh(new BehLaunchFireworks());
		t.addBeh(new BehAddHappiness("just_laughed"));
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "poop_inside"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconPoop");
		t.addBeh(new BehBuildingTargetHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(10f, 60f));
		t.addBeh(new BehPoopInside());
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "poop_outside"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconPoop");
		t.addBeh(new BehFindTile(TileFinderType.FreeTile));
		t.addBeh(new BehGoToTileTarget());
		for (int k = 0; k < 4; k++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.5f, 0.5f));
		}
		t.addBeh(new BehPoopOutside());
	}

	private void initTasksSleep()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "decide_where_to_sleep"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconSleep");
		t.addBeh(new BehDecideWhereToSleep());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "sleep_inside"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconHoused");
		t.addBeh(new BehBuildingTargetHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget());
		t.addBeh(new BehTrySleep());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "sleep_outside"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconHomeless");
		t.addBeh(new BehFindTile(TileFinderType.FreeTile));
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0f, 2f));
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehRandomWait(0f, 2f));
		t.addBeh(new BehFindRandomNeighbourTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0f, 2f));
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehRandomWait(0f, 2f));
		t.addBeh(new BehTrySleep(pSleepOutside: true));
	}

	private void initTasksKings()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "king_check_new_city_foundation"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehKingCheckNewCityFoundation());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "king_change_kingdom_language"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconLanguage");
		t.addBeh(new BehChangeKingdomLanguage());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "king_change_kingdom_culture"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconCulture");
		t.addBeh(new BehChangeKingdomCulture());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "king_change_kingdom_religion"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconReligion");
		t.addBeh(new BehChangeKingdomReligion());
	}

	private void initTasksWarriors()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "warrior_random_move",
			locale_key = "task_unit_move"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "warrior_army_captain_idle_walking_city",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_walk"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCityActorGetRandomBorderTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 6f));
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "warrior_army_captain_waiting",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_walk"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCityActorGetRandomBorderTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(10f, 20f));
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "check_warrior_limit"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconWar");
		t.addBeh(new BehCheckCityActorWarriorLimit());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "warrior_try_join_army_group"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconWar");
		t.addBeh(new BehCheckCityActorArmyGroup());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "warrior_army_leader_move_random",
			speed_multiplier = 0.8f
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(10f, 20f));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "warrior_army_leader_move_to_attack_target",
			speed_multiplier = 0.8f,
			cancellable_by_socialize = false,
			cancellable_by_reproduction = false
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowAttackTarget");
		t.addTaskVerifier(new BehVerifierAttackZone());
		t.addBeh(new BehCityActorCheckAttack());
		t.addBeh(new BehGoToTileTarget
		{
			limit_pathfinding_regions = 6
		});
		t.addBeh(new BehWarriorCaptainWait());
		t.addBeh(new BehRestartTask());
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "warrior_army_follow_leader",
			speed_multiplier = 1.3f,
			cancellable_by_socialize = false,
			cancellable_by_reproduction = false
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconLoyalty");
		t.addBeh(new BehFindTileNearbyGroupLeader());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "check_warrior_transport",
			flag_boat_related = true,
			cancellable_by_socialize = false,
			cancellable_by_reproduction = false
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehCityActorWarriorTaxiCheck());
		t.addBeh(new BehRandomWait(1f, 5f));
		t.addBeh(new BehTaxiFindShipTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehTaxiEmbark());
		BehaviourTaskActor obj10 = new BehaviourTaskActor
		{
			id = "warrior_train_with_dummy"
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.setIcon("ui/Icons/iconWarfare");
		t.addBeh(new BehCityActorFindBuilding("type_training_dummies"));
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehLookAtBuildingTarget());
		for (int i = 0; i < 10; i++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, "event:/SFX/BUILDINGS/DestroyBuildingWood", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
			t.addBeh(new BehActorAddExperience(0, 2));
			t.addBeh(new BehRandomWait(0f, 2f));
			t.addBeh(new BehDealDamageToTargetBuilding(0.05f, 0.15f));
		}
		t.addBeh(new BehActorTryToAddRandomCombatSkill());
		t.addBeh(new BehRandomWait(3f, 6f));
	}

	private void initTasksLeaders()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "leader_change_city_language"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconLanguage");
		t.addBeh(new BehChangeCityActorLanguage());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "leader_change_city_culture"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconCulture");
		t.addBeh(new BehChangeCityActorCulture());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "leader_change_city_religion"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconReligion");
		t.addBeh(new BehChangeCityActorReligion());
	}

	private void initTasksStatusRelated()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "strange_urge_finish",
			locale_key = "task_strange_urge_finish"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconStrangeUrge");
		for (int i = 0; i < 6; i++)
		{
			t.addBeh(new BehFindRandomNeighbourTile());
			t.addBeh(new BehGoToTileTarget());
			t.addBeh(new BehRandomWait(0.5f, 5f));
		}
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "status_confused",
			locale_key = "task_unit_confused"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconConfused");
		for (int j = 0; j < 6; j++)
		{
			t.addBeh(new BehFindRandomNeighbourTile());
			t.addBeh(new BehGoToTileTarget());
			t.addBeh(new BehRandomWait(0f, 0.01f));
		}
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "status_soul_harvested",
			locale_key = "status_title_soul_harvested"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconSoulHarvested");
		t.addBeh(new BehStartShake());
		for (int k = 0; k < 12; k++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.1f, 0.1f));
		}
		t.addBeh(new BehCheckSoulBorneReproduction());
	}

	private void initTasksMobs()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "diet_tiles",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_geophagy");
		t.addBeh(new BehFindTileForEating());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true,
			walk_on_blocks = true
		});
		for (int i = 0; i < 10; i++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehConsumeTargetTile());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "diet_wood",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_xylophagy");
		t.addBeh(new BehFindBuilding("type_tree", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int j = 0; j < 4; j++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "diet_minerals",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_lithotroph");
		t.addBeh(new BehFindBuilding("type_mineral", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int k = 0; k < 4; k++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "diet_fruits",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_frugivore");
		t.addBeh(new BehFindBuilding("type_fruits", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int l = 0; l < 4; l++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "diet_vegetation",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_folivore");
		t.addBeh(new BehFindBuilding("type_vegetation", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int m = 0; m < 4; m++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "diet_flowers",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_florivore");
		t.addBeh(new BehFindBuilding("type_flower", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int n = 0; n < 4; n++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "diet_nectar",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_florivore");
		t.addBeh(new BehFindBuilding("type_flower", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num = 0; num < 4; num++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehNectarNectarFromFlower());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "diet_crops",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_granivore");
		t.addBeh(new BehFindBuilding("type_crops", pOnlyNonTargeted: false, pOnlyWithResources: true));
		t.addBeh(new BehGoToBuildingTarget());
		for (int num2 = 0; num2 < 4; num2++)
		{
			t.addBeh(new BehResourceGatheringAnimation(1f, "event:/SFX/NATURE/AnimalEatPlant"));
		}
		t.addBeh(new BehConsumeTargetBuilding());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "diet_grass",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_graminivore");
		t.addBeh(new BehFindTile(TileFinderType.Grass));
		t.addBeh(new BehGoToTileTarget());
		for (int num3 = 0; num3 < 4; num3++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehConsumeGrass());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj10 = new BehaviourTaskActor
		{
			id = "diet_meat",
			cancellable_by_reproduction = true,
			ignore_fight_check = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_carnivore");
		t.addBeh(new BehFindMeatSource());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehConsumeActorTarget());
		BehaviourTaskActor obj11 = new BehaviourTaskActor
		{
			id = "diet_blood",
			cancellable_by_reproduction = true,
			ignore_fight_check = true,
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj11;
		t = obj11;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_hematophagy");
		t.addBeh(new BehFindMeatSource(MeatTargetType.Meat, pCheckForFactions: false));
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehConsumeActorsBloodTarget());
		BehaviourTaskActor obj12 = new BehaviourTaskActor
		{
			id = "diet_meat_insect",
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj12;
		t = obj12;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_insectivore");
		t.addBeh(new BehFindMeatInsectSource());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehConsumeActorTarget());
		BehaviourTaskActor obj13 = new BehaviourTaskActor
		{
			id = "diet_same_species",
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj13;
		t = obj13;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_cannibalism");
		t.addBeh(new BehFindMeatSameSpeciesSource(pCheckForFactions: false));
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameTile, pPathOnWater: false, pCheckCanAttackTarget: true, pCalibrateTargetPosition: true));
		t.addBeh(new BehConsumeActorTarget());
		BehaviourTaskActor obj14 = new BehaviourTaskActor
		{
			id = "diet_algae",
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj14;
		t = obj14;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_algivore");
		t.addBeh(new BehFindTile(TileFinderType.Water));
		t.addBeh(new BehGoOrSwimToTileTarget());
		for (int num4 = 0; num4 < 4; num4++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehReplenishNutrition());
		BehaviourTaskActor obj15 = new BehaviourTaskActor
		{
			id = "diet_fish",
			locale_key = "task_unit_eat",
			diet = true
		};
		pAsset = obj15;
		t = obj15;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_diet_piscivore");
		t.addBeh(new BehFindTile(TileFinderType.Water));
		t.addBeh(new BehGoOrSwimToTileTarget());
		for (int num5 = 0; num5 < 4; num5++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehReplenishNutrition());
		BehaviourTaskActor obj16 = new BehaviourTaskActor
		{
			id = "family_alpha_move",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj16;
		t = obj16;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconStrong");
		t.addBeh(new BehFamilyAlphaMove());
		t.addBeh(new BehGoToTileTarget());
		BehaviourTaskActor obj17 = new BehaviourTaskActor
		{
			id = "family_group_follow",
			cancellable_by_socialize = true,
			cancellable_by_reproduction = true,
			locale_key = "task_unit_follow_family"
		};
		pAsset = obj17;
		t = obj17;
		add(pAsset);
		t.setIcon("ui/Icons/iconFamiliesZones");
		t.addBeh(new BehFamilyFollowAlpha());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameRegion));
		BehaviourTaskActor obj18 = new BehaviourTaskActor
		{
			id = "family_check_existence"
		};
		pAsset = obj18;
		t = obj18;
		add(pAsset);
		t.setIcon("ui/Icons/iconFamiliesZones");
		t.addBeh(new BehFamilyCheckMembers());
		BehaviourTaskActor obj19 = new BehaviourTaskActor
		{
			id = "family_group_leave"
		};
		pAsset = obj19;
		t = obj19;
		add(pAsset);
		t.setIcon("ui/Icons/iconFamiliesZones");
		t.addBeh(new BehFamilyGroupLeave());
		BehaviourTaskActor obj20 = new BehaviourTaskActor
		{
			id = "family_group_join_or_new_herd"
		};
		pAsset = obj20;
		t = obj20;
		add(pAsset);
		t.setIcon("ui/Icons/iconFamiliesZones");
		t.addBeh(new BehFamilyGroupJoin());
		t.addBeh(new BehFamilyGroupNew());
		BehaviourTaskActor obj21 = new BehaviourTaskActor
		{
			id = "attack_golden_brain"
		};
		pAsset = obj21;
		t = obj21;
		add(pAsset);
		t.setIcon("ui/Icons/iconGoldBrain");
		t.addBeh(new BehFindGoldenBrain());
		t.addBeh(new BehGoToBuildingTarget());
		BehaviourTaskActor obj22 = new BehaviourTaskActor
		{
			id = "follow_desire_target",
			locale_key = "task_unit_weird_desire"
		};
		pAsset = obj22;
		t = obj22;
		add(pAsset);
		t.setIcon("ui/Icons/iconGoldBrain");
		t.addBeh(new BehFindDesireWaypoint());
		t.addBeh(new BehGoToBuildingTarget());
		BehaviourTaskActor obj23 = new BehaviourTaskActor
		{
			id = "crab_eat",
			diet = true
		};
		pAsset = obj23;
		t = obj23;
		add(pAsset);
		t.setIcon("ui/Icons/iconCrab");
		t.addBeh(new BehAnimalCheckHungry());
		t.addBeh(new BehRandomWait(2f, 5f));
		t.addBeh(new BehFindTileBeach());
		t.addBeh(new BehGoOrSwimToTileTarget());
		for (int num6 = 0; num6 < 4; num6++)
		{
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, string.Empty, 1f, 20f, pCheckFlip: true, pLandIfHovering: true));
		}
		t.addBeh(new BehReplenishNutrition());
		BehaviourTaskActor obj24 = new BehaviourTaskActor
		{
			id = "crab_danger_check"
		};
		pAsset = obj24;
		t = obj24;
		add(pAsset);
		t.setIcon("ui/Icons/iconBloodRain");
		t.addBeh(new BehCheckIfOnGround());
		t.addBeh(new BehActiveCrabDangerCheck());
		BehaviourTaskActor obj25 = new BehaviourTaskActor
		{
			id = "crab_burrow"
		};
		pAsset = obj25;
		t = obj25;
		add(pAsset);
		t.setIcon("ui/Icons/iconCrab");
		t.addBeh(new BehCheckIfOnGround());
		t.addBeh(new BehFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehCrabBurrow());
		BehaviourTaskActor obj26 = new BehaviourTaskActor
		{
			id = "make_skeleton"
		};
		pAsset = obj26;
		t = obj26;
		add(pAsset);
		t.setIcon("ui/Icons/iconSkeleton");
		t.addBeh(new BehMagicMakeSkeleton());
		t.addBeh(new BehRandomWait(3f, 3f));
		BehaviourTaskActor obj27 = new BehaviourTaskActor
		{
			id = "skeleton_move",
			locale_key = "task_unit_move"
		};
		pAsset = obj27;
		t = obj27;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehSkeletonFindTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 6f));
		BehaviourTaskActor obj28 = new BehaviourTaskActor
		{
			id = "spawn_fertilizer"
		};
		pAsset = obj28;
		t = obj28;
		add(pAsset);
		t.setIcon("ui/Icons/iconFertilizerPlants");
		t.addBeh(new BehSpawnTreeFertilizer());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj29 = new BehaviourTaskActor
		{
			id = "check_cure"
		};
		pAsset = obj29;
		t = obj29;
		add(pAsset);
		t.setIcon("ui/Icons/iconHealth");
		t.addBeh(new BehCheckCure());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj30 = new BehaviourTaskActor
		{
			id = "burn_tumors"
		};
		pAsset = obj30;
		t = obj30;
		add(pAsset);
		t.setIcon("ui/Icons/iconFire");
		t.addBeh(new BehBurnTumorTiles());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj31 = new BehaviourTaskActor
		{
			id = "check_heal"
		};
		pAsset = obj31;
		t = obj31;
		add(pAsset);
		t.setIcon("ui/Icons/iconHealth");
		t.addBeh(new BehHeal());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj32 = new BehaviourTaskActor
		{
			id = "random_teleport"
		};
		pAsset = obj32;
		t = obj32;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconMageSlayer");
		t.addBeh(new BehRandomTeleport());
		t.addBeh(new BehRandomWait(0.5f));
		BehaviourTaskActor obj33 = new BehaviourTaskActor
		{
			id = "teleport_back_home"
		};
		pAsset = obj33;
		t = obj33;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconMageSlayer");
		t.addBeh(new BehTeleportHome());
		t.addBeh(new BehRandomWait(0.5f));
		BehaviourTaskActor obj34 = new BehaviourTaskActor
		{
			id = "run_to_water_when_on_fire",
			locale_key = "task_unit_run_to_water"
		};
		pAsset = obj34;
		t = obj34;
		add(pAsset);
		t.setIcon("ui/Icons/iconFire");
		t.addBeh(new BehShortRandomMove());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehShortRandomMove());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehShortRandomMove());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehFindTileWhenOnFire());
		t.addBeh(new BehGoOrSwimToTileTarget());
		BehaviourTaskActor obj35 = new BehaviourTaskActor
		{
			id = "short_move",
			cancellable_by_socialize = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj35;
		t = obj35;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehShortRandomMove());
		t.addBeh(new BehGoToTileTarget());
	}

	private void initTasksFingers()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "godfinger_find_target"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		t.addBeh(new BehFingerFindTarget());
		t.addBeh(new BehFingerGoTowardsTileTarget(5));
		t.addBeh(new BehFingerSetFlying(pFlying: true, 2f));
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehSetNextTask("godfinger_draw"));
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "godfinger_draw"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerCheckCanDraw());
		t.addBeh(new BehFingerSetFlying(pFlying: false));
		t.addBeh(new BehFingerFindCloseTile());
		t.addBeh(new BehFingerWaitForFlying());
		t.addBeh(new BehFingerDrawToTileTarget());
		t.addBeh(new BehSetNextTask("godfinger_find_target"));
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "godfinger_move"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		t.addBeh(new BehRandomWait(0.1f, 0.4f));
		t.addBeh(new BehFingerFindRandomTile());
		t.addBeh(new BehFingerGoTowardsTileTarget());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "godfinger_random_fun_move"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		for (int i = 0; i < 6; i++)
		{
			t.addBeh(new BehFingerFindRandomTile(5));
			t.addBeh(new BehFingerGoTowardsTileTarget(5));
			t.addBeh(new BehRandomWait(0f, 0.01f));
		}
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "godfinger_circle_move"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		t.addBeh(new BehRandomWait(0.1f, 0.4f));
		t.addBeh(new BehFingerGoToCircleTarget(25, 75));
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "godfinger_circle_move_small"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		t.addBeh(new BehRandomWait(0.1f, 0.4f));
		t.addBeh(new BehFingerGoToCircleTarget(5, 15));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "godfinger_circle_move_big"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconGodFinger");
		t.addBeh(new BehFingerSetFlying(pFlying: true));
		t.addBeh(new BehRandomWait(0.1f, 0.4f));
		t.addBeh(new BehFingerGoToCircleTarget(75, 150));
	}

	private void initTasksDragons()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "dragon_fly",
			locale_key = "task_unit_dragon_fly"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconDragon");
		t.addBeh(new BehDragonSetAnimation(DragonState.Fly, pLooped: true, pForceRestart: false));
		t.addBeh(new BehActorSetFlying(pFlying: true));
		t.addBeh(new BehDragonSleepy());
		t.addBeh(new BehDragonCheckAttackTargetAlive());
		t.addBeh(new BehDragonZombieFindGoldenBrain());
		t.addBeh(new BehDragonCheckAttackTile());
		t.addBeh(new BehDragonCheckAttackCity());
		t.addBeh(new BehDragonFindRandomTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRepeatTaskChance(0.7f));
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "dragon_sleep",
			locale_key = "task_unit_dragon_sleep"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconSleep");
		t.addBeh(new BehDragonSetAnimation(DragonState.SleepStart, pLooped: false));
		t.addBeh(new BehActorSetFlip(pFlip: false));
		t.addBeh(new BehActorSetFlying(pFlying: false));
		t.addBeh(new BehDragonFinishAnimation());
		t.addBeh(new BehDragonSetAnimation(DragonState.SleepLoop));
		t.addBeh(new BehDragonSleep());
		t.addBeh(new BehDragonFinishAnimation());
		t.addBeh(new BehSetNextTask("dragon_wakeup"));
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "dragon_wakeup",
			locale_key = "task_unit_dragon_sleep"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconDragon");
		t.addBeh(new BehDragonSetAnimation(DragonState.SleepUp, pLooped: false));
		t.addBeh(new BehActorSetFlip(pFlip: false));
		t.addBeh(new BehDragonFinishAnimation());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "dragon_slide",
			locale_key = "task_unit_dragon_attack"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconFire");
		t.addBeh(new BehDragonSetAnimation(DragonState.Slide, pLooped: false));
		t.addBeh(new BehActorSetFlying(pFlying: true));
		t.addBeh(new BehDragonSleepy());
		t.addBeh(new BehActorAddStatus("invincible", 2f));
		t.addBeh(new BehActorSetBool("justSlid", pBoolValue: true));
		t.addBeh(new BehDragonSlide());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "dragon_land",
			locale_key = "task_unit_dragon_land"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconDragon");
		t.addBeh(new BehDragonSetAnimation(DragonState.Landing, pLooped: false));
		t.addBeh(new BehDragonSleepy());
		t.addBeh(new BehDragonCheckAttackTargetAlive());
		t.addBeh(new BehDragonCheckOverTargetCity());
		t.addBeh(new BehDragonFinishAnimation());
		t.addBeh(new BehActorSetFlying(pFlying: false));
		t.addBeh(new BehDragonCantLand("dragon_up"));
		t.addBeh(new BehDragonLanded());
		t.addBeh(new BehDragonCheckOverTargetActor());
		t.addBeh(new BehDragonCheckOverTargetCity());
		t.addBeh(new BehActorSetInt("justLanded", 2));
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "dragon_land_attack",
			locale_key = "task_unit_dragon_attack"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconFire");
		t.addBeh(new BehDragonSetAnimation(DragonState.LandAttack, pLooped: false));
		t.addBeh(new BehDragonSleepy());
		t.addBeh(new BehActorSetFlying(pFlying: false));
		t.addBeh(new BehDragonLandAttack());
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "dragon_up",
			locale_key = "task_unit_dragon_fly"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconDragon");
		t.addBeh(new BehDragonSetAnimation(DragonState.Up, pLooped: false));
		t.addBeh(new BehDragonFlyUp());
		t.addBeh(new BehDragonSleepy());
		t.addBeh(new BehActorSetFlying(pFlying: true));
		t.addBeh(new BehDragonFinishAnimation());
		t.addBeh(new BehActorSetBool("justUp", pBoolValue: true));
		t.addBeh(new BehActorCheckBool("justGotHit", "dragon_fly"));
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "dragon_idle",
			locale_key = "task_unit_dragon_normal"
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconDragon");
		t.addBeh(new BehDragonSetAnimation(DragonState.Idle));
		t.addBeh(new BehActorSetFlying(pFlying: false));
		t.addBeh(new BehDragonIdle());
		t.addBeh(new BehDragonFinishAnimation());
	}

	private void initTasksUFOs()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "ufo_idle"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconUFO");
		t.addBeh(new BehSetActorSpeed(20f));
		t.addBeh(new BehUFOBeam());
		t.addBeh(new BehUFOCheckExplore());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "ufo_hit"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconUFO");
		t.addBeh(new BehUFOSelectTarget());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "ufo_flee"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/actor_traits/iconAgile");
		t.addBeh(new BehSetActorSpeed(100f));
		t.addBeh(new BehUFOBeam());
		t.addBeh(new BehGetRandomZoneTile());
		t.addBeh(new BehGoToTileTarget());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "ufo_fly"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconUFO");
		t.addBeh(new BehSetActorSpeed(20f));
		t.addBeh(new BehUFOBeam());
		t.addBeh(new BehUFOFindTarget());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehUFOCheckAttackCity());
		t.addBeh(new BehUFOExplore());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "ufo_explore"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconInspectZoneToggle");
		t.addBeh(new BehSetActorSpeed(10f));
		t.addBeh(new BehUFOBeam());
		t.addBeh(new BehGetRandomZoneTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehUFOCheckExplore());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "ufo_chase"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconUFO");
		t.addBeh(new BehSetActorSpeed(50f));
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehSetNextTask("ufo_attack"));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "ufo_attack"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowAttackTarget");
		t.addBeh(new BehUFOBeam(pEnabled: true));
	}

	private void initTasksBoats()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "boat_check_existence"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehBoatCheckExistence());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "boat_check_limits",
			locale_key = "task_unit_move"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehBoatCheckLimit());
		t.addBeh(new BehBoatCheckHomeDocks());
		t.addBeh(new BehBoatSetHomeDockTarget());
		t.addBeh(new BehBoatFindTileInDock());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0f, 3f));
		t.addBeh(new BehStayInBuildingTarget(2f, 4f));
		t.addBeh(new BehBoatRemoveIfLimit());
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "boat_idle",
			locale_key = "task_unit_nothing"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconClock");
		t.addBeh(new BehBoatDamageCheck());
		t.addBeh(new BehBoatFindOceanNeutralTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 10f));
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "boat_danger_check",
			locale_key = "task_unit_flee"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehCheckIfInLiquid());
		t.addBeh(new BehBoatDangerCheck());
		t.addBeh(new BehBoatFindWaterTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(3f, 10f));
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "boat_transport_check"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehRandomWait());
		t.addBeh(new BehBoatTransportCheck());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "boat_transport_check_taxi"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconBoat");
		t.addBeh(new BehBoatFindRequest());
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "boat_transport_go_load",
			locale_key = "task_unit_boat_load_units"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconCityInventory");
		t.addBeh(new BehBoatTransportFindTilePickUp());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		t.addBeh(new BehBoatTransportDoLoading());
		t.addBeh(new BehSetNextTask("boat_transport_go_unload", pClean: false));
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "boat_transport_go_unload",
			locale_key = "task_unit_boat_unload_units"
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconCityInventory");
		t.addBeh(new BehRandomWait());
		t.addBeh(new BehBoatTransportFindTileUnload());
		t.addBeh(new BehGoToTileTarget
		{
			walk_on_water = true
		});
		t.addBeh(new BehRandomWait());
		t.addBeh(new BehBoatTransportUnloadUnits());
		t.addBeh(new BehRandomWait(3f, 10f));
		t.addBeh(new BehEndJob());
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "boat_trading",
			locale_key = "task_unit_boat_trade"
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/iconMoney");
		t.addBeh(new BehBoatCheckHomeDocks());
		t.addBeh(new BehBoatFindTargetForTrade());
		t.addBeh(new BehBoatFindTileInDock());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehStayInBuildingTarget(2f, 5f));
		t.addBeh(new BehBoatMakeTrade());
		t.addBeh(new BehExitBuilding());
		t.addBeh(new BehSetNextTask("boat_return_to_dock"));
		BehaviourTaskActor obj10 = new BehaviourTaskActor
		{
			id = "boat_fishing",
			locale_key = "task_unit_boat_catch_fish"
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.setIcon("ui/Icons/iconResFish");
		t.addBeh(new BehBoatCheckHomeDocks());
		t.addBeh(new BehBoatFindWaterTile());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait());
		t.addBeh(new BehBoatFishing());
		t.addBeh(new BehRandomWait(5f, 10f));
		t.addBeh(new BehBoatCollectFish());
		t.addBeh(new BehRandomWait(1f, 2f));
		t.addBeh(new BehBoatCheckFishingRepeat());
		BehaviourTaskActor obj11 = new BehaviourTaskActor
		{
			id = "boat_return_to_dock",
			locale_key = "task_unit_return_to_dock"
		};
		pAsset = obj11;
		t = obj11;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowDestination");
		t.addBeh(new BehBoatCheckHomeDocks());
		t.addBeh(new BehBoatSetHomeDockTarget());
		t.addBeh(new BehBoatFindTileInDock());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehRandomWait(0f, 3f));
		t.addBeh(new BehStayInBuildingTarget(2f, 4f));
		t.addBeh(new BehUnloadResources());
		t.addBeh(new BehRepairInDock());
		t.addBeh(new BehExitBuilding());
		t.addBeh(new BehEndJob());
	}

	private void initTasksReproductionAsexual()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "asexual_reproduction_budding",
			locale_key = "task_unit_reproduce"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_budding");
		for (int i = 0; i < 4; i++)
		{
			t.addBeh(new BehStartShake(0.1f, 0.1f));
			t.addBeh(new BehActorReverseFlip());
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehCheckBuddingReproduction());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "asexual_reproduction_divine",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_divine");
		for (int j = 0; j < 4; j++)
		{
			t.addBeh(new BehStartShake(0.1f, 0.1f));
			t.addBeh(new BehActorReverseFlip());
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehCheckDivineReproduction());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "asexual_reproduction_spores",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_spores");
		t.addBeh(new BehStartShake());
		for (int k = 0; k < 4; k++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.1f, 0.1f));
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehCheckSporeReproduction());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "asexual_reproduction_fission",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_fission");
		for (int l = 0; l < 4; l++)
		{
			t.addBeh(new BehStartShake(0.1f, 0.1f));
			t.addBeh(new BehActorReverseFlip());
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehCheckFissionReproduction());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "asexual_reproduction_vegetative",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_vegetative");
		for (int m = 0; m < 4; m++)
		{
			t.addBeh(new BehStartShake(0.1f, 0.1f));
			t.addBeh(new BehActorReverseFlip());
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehFindTile(TileFinderType.Dirt));
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehCheckVegetativeReproduction());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "asexual_reproduction_parthenogenesis",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_reproduction_parthenogenesis");
		for (int n = 0; n < 4; n++)
		{
			t.addBeh(new BehStartShake(0.1f, 0.1f));
			t.addBeh(new BehActorReverseFlip());
		}
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehCheckParthenogenesisReproduction());
	}

	private void initTasksReproductionSexual()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "check_lover_city"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconCity");
		t.addBeh(new BehCheckSameCityActorLover());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "find_lover"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconArrowLover");
		t.addBeh(new BehFindLover());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_try",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		t.addBeh(new BehCheckReproductionBasics());
		t.addBeh(new BehSexualReproductionTry());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_check_outside",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		t.addBeh(new BehCheckSexualReproductionOutside());
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_inside",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		t.addBeh(new BehCheckSexualReproductionCiv());
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_outside",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		t.addBeh(new BehGoToActorTarget());
		t.addBeh(new BehRandomWait(0.5f));
		t.addBeh(new BehAnimalBreedingTime());
		t.addBeh(new BehRandomWait(0.5f));
		t.addBeh(new BehAnimalBreedingTime());
		t.addBeh(new BehRandomWait(0.5f));
		t.addBeh(new BehAnimalBreedingTime());
		t.addBeh(new BehRandomWait(0.5f));
		t.addBeh(new BehCheckForBabiesFromSexualReproduction());
		t.addBeh(new BehRandomWait(1f, 3f));
		BehaviourTaskActor obj7 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_civ_go",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		t.addBeh(new BehBuildingTargetLoverHome());
		t.addBeh(new BehGetTargetBuildingMainTile());
		t.addBeh(new BehGoToTileTarget());
		for (int i = 0; i < 6; i++)
		{
			t.addBeh(new BehRandomWait(1f, 2f));
			t.addBeh(new BehCheckForLover());
			t.addBeh(new BehRandomWait(1f, 2f));
		}
		BehaviourTaskActor obj8 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_civ_action",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		for (int j = 0; j < 5; j++)
		{
			t.addBeh(new BehStayInBuildingTarget(1f, 2f));
			t.addBeh(new BehShakeBuilding());
			t.addBeh(new BehSpawnHeartsFromBuilding());
		}
		t.addBeh(new BehCheckForBabiesFromSexualReproduction());
		t.addBeh(new BehExitBuilding());
		BehaviourTaskActor obj9 = new BehaviourTaskActor
		{
			id = "sexual_reproduction_civ_wait",
			locale_key = "task_unit_reproduce"
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.setIcon("ui/Icons/iconLovers");
		for (int k = 0; k < 5; k++)
		{
			t.addBeh(new BehStayInBuildingTarget(1f, 2f));
		}
		t.addBeh(new BehExitBuilding());
	}

	private void initTasksChildren()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "child_random_flips",
			cancellable_by_socialize = true,
			locale_key = "task_unit_play"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/iconChildren");
		for (int i = 0; i < 4; i++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.2f, 0.2f));
		}
		t.addBeh(new BehActorChangeHappiness("just_played"));
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "child_play_at_one_spot",
			cancellable_by_socialize = true,
			locale_key = "task_unit_play"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/iconChildren");
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehJumpingAnimation(1.5f, 1.5f));
		t.addBeh(new BehActorReverseFlip());
		t.addBeh(new BehActorChangeHappiness("just_played"));
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "child_random_jump",
			cancellable_by_socialize = true,
			locale_key = "task_unit_play"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/iconChildren");
		for (int j = 0; j < 2; j++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(1.5f, 1.5f));
		}
		t.addBeh(new BehActorRandomJump());
		t.addBeh(new BehRandomWait(1f, 3f));
		t.addBeh(new BehActorChangeHappiness("just_played"));
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "child_follow_parent",
			cancellable_by_socialize = true,
			locale_key = "task_unit_move"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/iconAdults");
		t.addBeh(new BehChildFindRandomFamilyParent());
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.SameRegion));
		t.addBeh(new BehRepeatTaskChance(0.1f));
	}

	private void initTasksSubspeciesTraits()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "try_affect_dreams"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/subspecies_traits/subspecies_trait_dreamweavers");
		t.addBeh(new BehFindTile(TileFinderType.FreeTile));
		t.addBeh(new BehGoToTileTarget());
		for (int i = 0; i < 4; i++)
		{
			t.addBeh(new BehActorReverseFlip());
			t.addBeh(new BehJumpingAnimation(0.5f, 0.5f));
		}
		t.addBeh(new BehAffectDreams());
	}

	private void initTasksSocializing()
	{
		BehaviourTaskActor obj = new BehaviourTaskActor
		{
			id = "socialize_initial_check",
			locale_key = "task_unit_socialize"
		};
		BehaviourTaskActor pAsset = obj;
		t = obj;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehSocializeStartCheck());
		BehaviourTaskActor obj2 = new BehaviourTaskActor
		{
			id = "socialize_try_to_start_near_bonfire",
			locale_key = "task_unit_socialize"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehCityActorFindBuilding("type_bonfire"));
		t.addBeh(new BehFindRandomTileNearBuildingTarget());
		t.addBeh(new BehGoToTileTarget());
		t.addBeh(new BehTryToSocialize());
		BehaviourTaskActor obj3 = new BehaviourTaskActor
		{
			id = "socialize_try_to_start_immediate",
			locale_key = "task_unit_socialize"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehTryToSocialize());
		BehaviourTaskActor obj4 = new BehaviourTaskActor
		{
			id = "socialize_go_to_target",
			locale_key = "task_unit_socialize"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehGoToActorTarget(GoToActorTargetType.NearbyTileClosest, pPathOnWater: false, pCheckCanAttackTarget: false, pCalibrateTargetPosition: true));
		t.addBeh(new BehCheckNearActorTarget());
		t.addBeh(new BehSetNextTask("socialize_do_talk", pClean: false));
		BehaviourTaskActor obj5 = new BehaviourTaskActor
		{
			id = "socialize_do_talk",
			locale_key = "task_unit_socialize"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehDoTalk());
		t.addBeh(new BehFinishTalk());
		t.addBeh(new BehRandomWait(1f, 2f));
		BehaviourTaskActor obj6 = new BehaviourTaskActor
		{
			id = "socialize_receiving",
			locale_key = "task_unit_socialize"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.setIcon("ui/Icons/culture_traits/culture_trait_gossip_lovers");
		t.addBeh(new BehSocializeTalk());
	}

	private void addActionsForDeliverResources(BehaviourTaskActor pTask, bool pWheatStorage = false)
	{
		pTask.addBeh(new BehCheckHasResources());
		pTask.addBeh(new BehRandomWait(0.7f, 1.2f));
		if (pWheatStorage)
		{
			pTask.addBeh(new BehCityActorFindStorageWheat());
		}
		else
		{
			pTask.addBeh(new BehCityActorFindStorage());
		}
		pTask.addBeh(new BehFindRaycastTileForBuildingTarget());
		pTask.addBeh(new BehGoToTileTarget());
		pTask.addBeh(new BehLookAtBuildingTarget());
		pTask.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, string.Empty, 0.1f, 20f));
		pTask.addBeh(new BehThrowResources());
		pTask.addBeh(new BehRandomWait(0f, 0.2f));
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (BehaviourTaskActor item in list)
		{
			string force_hand_tool = item.force_hand_tool;
			if (!string.IsNullOrEmpty(force_hand_tool))
			{
				item.cached_hand_tool_asset = AssetManager.unit_hand_tools.get(force_hand_tool);
			}
		}
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (BehaviourTaskActor item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}
}
// --- End of File: BehaviourTaskActorLibrary.cs ---



// --- Start of File: BehaviourTaskBase.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;

[Serializable]
public class BehaviourTaskBase<T> : BehaviourElementAI, ILocalizedAsset where T : BehaviourElementAI
{
	[DefaultValue(1f)]
	public float single_interval = 1f;

	public float single_interval_random;

	public List<T> list = new List<T>();

	public T task_verifier;

	public bool has_verifier;

	[DefaultValue("")]
	public string locale_key = string.Empty;

	public bool debug_flag;

	[DefaultValue(true)]
	protected virtual bool has_locales => true;

	protected virtual string locale_key_prefix
	{
		get
		{
			throw new NotImplementedException(GetType().Name);
		}
	}

	public BehaviourTaskBase()
	{
		create();
	}

	public T get(int pIndex)
	{
		return list[pIndex];
	}

	public string getLocaleID()
	{
		if (!has_locales)
		{
			return null;
		}
		if (string.IsNullOrEmpty(locale_key))
		{
			return locale_key_prefix + "_" + id;
		}
		return locale_key;
	}

	public string getLocalizedText()
	{
		if (!has_locales)
		{
			return "???";
		}
		return getLocaleID().Localize();
	}

	public void addRepeatActions(int pIndexAmount, int pHowManyTimes)
	{
		List<T> list = new List<T>();
		int count = this.list.Count;
		for (int i = 0; i < pHowManyTimes; i++)
		{
			for (int j = 0; j < pIndexAmount; j++)
			{
				int index = count - (pIndexAmount - j);
				T item = this.list[index];
				list.Add(item);
			}
		}
		this.list.AddRange(list);
	}

	public void addBeh(T pAction)
	{
		pAction.id = pAction.GetType().ToString();
		pAction.id = pAction.id.Replace("ai.behaviours.", "");
		list.Add(pAction);
		pAction.create();
	}

	public void addTaskVerifier(T pAction)
	{
		task_verifier = pAction;
		has_verifier = true;
	}
}
// --- End of File: BehaviourTaskBase.cs ---



// --- Start of File: BehaviourTaskCity.cs ---
using System;

[Serializable]
public class BehaviourTaskCity : BehaviourTaskBase<BehaviourActionCity>
{
	protected override string locale_key_prefix => "task_city";

	protected override bool has_locales => false;

	public void executeAllActionsForCity(City pCity)
	{
		for (int i = 0; i < list.Count; i++)
		{
			list[i].startExecute(pCity);
		}
	}
}
// --- End of File: BehaviourTaskCity.cs ---



// --- Start of File: BehaviourTaskCityLibrary.cs ---
namespace ai.behaviours;

public class BehaviourTaskCityLibrary : AssetLibrary<BehaviourTaskCity>
{
	public override void init()
	{
		base.init();
		BehaviourTaskCity obj = new BehaviourTaskCity
		{
			id = "nothing"
		};
		BehaviourTaskCity pAsset = obj;
		t = obj;
		add(pAsset);
		BehaviourTaskCity obj2 = new BehaviourTaskCity
		{
			id = "wait1"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.addBeh(new CityBehRandomWait());
		BehaviourTaskCity obj3 = new BehaviourTaskCity
		{
			id = "wait5"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.addBeh(new CityBehRandomWait(5f, 5f));
		BehaviourTaskCity obj4 = new BehaviourTaskCity
		{
			id = "random_wait_test"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.addBeh(new CityBehRandomWait(5f, 10f));
		t.addBeh(new CityBehRandomWait(5f, 10f));
		t.addBeh(new CityBehRandomWait(5f, 10f));
		BehaviourTaskCity obj5 = new BehaviourTaskCity
		{
			id = "do_checks"
		};
		pAsset = obj5;
		t = obj5;
		add(pAsset);
		t.addBeh(new CityBehCheckLeader());
		t.addBeh(new CityBehRandomWait(0.1f));
		t.addBeh(new CityBehCheckAttackZone());
		t.addBeh(new CityBehRandomWait(0.1f));
		t.addBeh(new CityBehCheckCitizenTasks());
		t.addBeh(new CityBehRandomWait(0.1f));
		BehaviourTaskCity obj6 = new BehaviourTaskCity
		{
			id = "do_initial_load_check"
		};
		pAsset = obj6;
		t = obj6;
		add(pAsset);
		t.addBeh(new CityBehCheckCitizenTasks());
		t.addBeh(new CityBehCheckLoyalty());
		BehaviourTaskCity obj7 = new BehaviourTaskCity
		{
			id = "check_farms"
		};
		pAsset = obj7;
		t = obj7;
		add(pAsset);
		t.addBeh(new CityBehCheckFarms());
		BehaviourTaskCity obj8 = new BehaviourTaskCity
		{
			id = "check_loyalty",
			single_interval = 2f
		};
		pAsset = obj8;
		t = obj8;
		add(pAsset);
		t.addBeh(new CityBehCheckLoyalty());
		BehaviourTaskCity obj9 = new BehaviourTaskCity
		{
			id = "check_destruction",
			single_interval = 2f
		};
		pAsset = obj9;
		t = obj9;
		add(pAsset);
		t.addBeh(new CityBehCheckDestruction());
		BehaviourTaskCity obj10 = new BehaviourTaskCity
		{
			id = "produce_boat"
		};
		pAsset = obj10;
		t = obj10;
		add(pAsset);
		t.addBeh(new CityBehProduceBoat());
		BehaviourTaskCity obj11 = new BehaviourTaskCity
		{
			id = "border_shrink"
		};
		pAsset = obj11;
		t = obj11;
		add(pAsset);
		t.addBeh(new CityBehBorderShrink());
		BehaviourTaskCity obj12 = new BehaviourTaskCity
		{
			id = "build",
			single_interval = 0f
		};
		pAsset = obj12;
		t = obj12;
		add(pAsset);
		t.addBeh(new CityBehBuild());
		BehaviourTaskCity obj13 = new BehaviourTaskCity
		{
			id = "supply_kingdom_cities"
		};
		pAsset = obj13;
		t = obj13;
		add(pAsset);
		t.addBeh(new CityBehSupplyKingdomCities());
		BehaviourTaskCity obj14 = new BehaviourTaskCity
		{
			id = "produce_resources"
		};
		pAsset = obj14;
		t = obj14;
		add(pAsset);
		t.addBeh(new CityBehProduceResources());
		BehaviourTaskCity obj15 = new BehaviourTaskCity
		{
			id = "check_army"
		};
		pAsset = obj15;
		t = obj15;
		add(pAsset);
		t.addBeh(new CityBehCheckArmy());
	}

	public override void editorDiagnosticLocales()
	{
	}
}
// --- End of File: BehaviourTaskCityLibrary.cs ---



// --- Start of File: BehaviourTaskKingdom.cs ---
using System;

[Serializable]
public class BehaviourTaskKingdom : BehaviourTaskBase<BehaviourActionKingdom>
{
	protected override string locale_key_prefix => "task_kingdom";

	protected override bool has_locales => false;
}
// --- End of File: BehaviourTaskKingdom.cs ---



// --- Start of File: BehaviourTaskKingdomLibrary.cs ---
namespace ai.behaviours;

public class BehaviourTaskKingdomLibrary : AssetLibrary<BehaviourTaskKingdom>
{
	public override void init()
	{
		base.init();
		BehaviourTaskKingdom obj = new BehaviourTaskKingdom
		{
			id = "nothing"
		};
		BehaviourTaskKingdom pAsset = obj;
		t = obj;
		add(pAsset);
		BehaviourTaskKingdom obj2 = new BehaviourTaskKingdom
		{
			id = "wait1"
		};
		pAsset = obj2;
		t = obj2;
		add(pAsset);
		t.addBeh(new KingdomBehRandomWait());
		BehaviourTaskKingdom obj3 = new BehaviourTaskKingdom
		{
			id = "wait_random"
		};
		pAsset = obj3;
		t = obj3;
		add(pAsset);
		t.addBeh(new KingdomBehRandomWait(0f, 5f));
		BehaviourTaskKingdom obj4 = new BehaviourTaskKingdom
		{
			id = "do_checks"
		};
		pAsset = obj4;
		t = obj4;
		add(pAsset);
		t.addBeh(new KingdomBehCheckCapital());
		t.addBeh(new KingdomBehCheckKing());
		t.addBeh(new KingdomBehRandomWait());
	}

	public override void editorDiagnosticLocales()
	{
	}
}
// --- End of File: BehaviourTaskKingdomLibrary.cs ---



// --- Start of File: BehaviourTaskTester.cs ---
using System;

[Serializable]
public class BehaviourTaskTester : BehaviourTaskBase<BehaviourActionTester>
{
	protected override bool has_locales => false;

	protected override string locale_key_prefix => "task_tester";
}
// --- End of File: BehaviourTaskTester.cs ---



// --- Start of File: BehaviourTesterCondition.cs ---
public class BehaviourTesterCondition : BehaviourBaseCondition<AutoTesterBot>
{
}
// --- End of File: BehaviourTesterCondition.cs ---



// --- Start of File: BehBeeCheckHome.cs ---
namespace ai.behaviours;

public class BehBeeCheckHome : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.asset.id != "bee")
		{
			return BehResult.Continue;
		}
		if (pActor.getHomeBuilding() != null)
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehBeeCheckHome.cs ---



// --- Start of File: BehBeeCheckNoHome.cs ---
namespace ai.behaviours;

public class BehBeeCheckNoHome : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.getHomeBuilding() == null)
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehBeeCheckNoHome.cs ---



// --- Start of File: BehBeeCheckReturnHome.cs ---
namespace ai.behaviours;

public class BehBeeCheckReturnHome : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = homeBuilding;
		return BehResult.Continue;
	}
}
// --- End of File: BehBeeCheckReturnHome.cs ---



// --- Start of File: BehBeeCreateHive.cs ---
namespace ai.behaviours;

public class BehBeeCreateHive : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (isAnotherBeehiveNearby(pActor))
		{
			return BehResult.Stop;
		}
		Building beh_building_target = BehaviourActionBase<Actor>.world.buildings.addBuilding("beehive", pActor.beh_tile_target, pCheckForBuild: true);
		pActor.beh_building_target = beh_building_target;
		return BehResult.Continue;
	}

	public static bool isAnotherBeehiveNearby(Actor pActor)
	{
		foreach (Building item in Finder.getBuildingsFromChunk(pActor.current_tile, 2))
		{
			if (item.asset.id == "beehive")
			{
				return true;
			}
		}
		return false;
	}
}
// --- End of File: BehBeeCreateHive.cs ---



// --- Start of File: BehBeeJoinHive.cs ---
namespace ai.behaviours;

public class BehBeeJoinHive : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_building_target = true;
		check_building_target_non_usable = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Building beh_building_target = pActor.beh_building_target;
		pActor.setHomeBuilding(beh_building_target);
		return BehResult.Continue;
	}
}
// --- End of File: BehBeeJoinHive.cs ---



// --- Start of File: BehBeeReturnHome.cs ---
namespace ai.behaviours;

public class BehBeeReturnHome : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding.isRekt())
		{
			return BehResult.Stop;
		}
		if (Toolbox.DistTile(pActor.current_tile, homeBuilding.current_tile) > 3f)
		{
			return BehResult.Stop;
		}
		if (pActor.data.pollen == 3 && pActor.current_tile.building == homeBuilding)
		{
			pActor.data.pollen = 0;
			if (pActor.isKingdomCiv())
			{
				pActor.addToInventory("honey", 1);
			}
			else
			{
				homeBuilding.component_beehive.addHoney();
			}
			pActor.timer_action = 3f;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBeeReturnHome.cs ---



// --- Start of File: BehBlackAntBuildIsland.cs ---
namespace ai.behaviours;

public class BehBlackAntBuildIsland : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("ant_steps", out var pResult, 0);
		pActor.data.get("direction", out var pResult2, 0);
		if (pActor.beh_tile_target.Type.liquid)
		{
			pResult = 20;
		}
		if (pResult > 0)
		{
			string pType;
			if (!pActor.beh_tile_target.Type.IsType("mountains"))
			{
				pType = "mountains";
				pResult2++;
				if (pResult2 > Toolbox.directions.Length - 1)
				{
					pResult2 = 0;
				}
			}
			else
			{
				pType = "hills";
				pResult2--;
				if (pResult2 < 0)
				{
					pResult2 = Toolbox.directions.Length - 1;
				}
			}
			Ant.antUseOnTile(pActor.beh_tile_target, pType);
			pResult--;
		}
		if (pResult == 0)
		{
			pActor.data.set("ant_steps", 40);
			pActor.data.set("direction", getRandomDirection());
			pActor.setTask("ant_black_sand");
			return BehResult.Stop;
		}
		pActor.data.set("ant_steps", pResult);
		pActor.data.set("direction", pResult2);
		return BehResult.Continue;
	}

	private static int getRandomDirection()
	{
		ActorDirection random = Randy.getRandom(Toolbox.directions);
		return Toolbox.directions.IndexOf(random);
	}
}
// --- End of File: BehBlackAntBuildIsland.cs ---



// --- Start of File: BehBlackAntBuildSand.cs ---
namespace ai.behaviours;

public class BehBlackAntBuildSand : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("ant_steps", out var pResult, 0);
		pActor.data.get("direction", out var pResult2, 0);
		if (pResult > 0)
		{
			pResult--;
			if (!pActor.beh_tile_target.Type.IsType("mountains") && !pActor.beh_tile_target.Type.IsType("hills"))
			{
				Ant.antUseOnTile(pActor.beh_tile_target, "sand");
			}
			pResult2 = getRandomDirection();
		}
		pActor.data.set("ant_steps", pResult);
		pActor.data.set("direction", pResult2);
		if (pResult == 0)
		{
			pActor.setTask("ant_black_island");
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}

	private static int getRandomDirection()
	{
		ActorDirection random = Randy.getRandom(Toolbox.directions);
		return Toolbox.directions.IndexOf(random);
	}
}
// --- End of File: BehBlackAntBuildSand.cs ---



// --- Start of File: BehBlueAntSwitchGround.cs ---
namespace ai.behaviours;

public class BehBlueAntSwitchGround : BehaviourActionActor
{
	private const string tileType1 = "sand";

	private const string tileType2 = "shallow_waters";

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("direction", out var pResult, 0);
		if (pActor.beh_tile_target.Type.liquid)
		{
			pResult++;
			if (pResult > Toolbox.directions.Length - 1)
			{
				pResult = 0;
			}
			Ant.antUseOnTile(pActor.beh_tile_target, "sand");
		}
		else
		{
			pResult--;
			if (pResult < 0)
			{
				pResult = Toolbox.directions.Length - 1;
			}
			Ant.antUseOnTile(pActor.beh_tile_target, "shallow_waters");
		}
		pActor.data.set("direction", pResult);
		return BehResult.Continue;
	}
}
// --- End of File: BehBlueAntSwitchGround.cs ---



// --- Start of File: BehBoat.cs ---
namespace ai.behaviours;

public class BehBoat : BehaviourActionActor
{
	internal Boat boat;

	internal void checkHomeDocks(Actor pActor)
	{
		ActorTool.checkHomeDocks(pActor);
	}

	public override void prepare(Actor pActor)
	{
		base.prepare(pActor);
		boat = pActor.getSimpleComponent<Boat>();
	}

	public override BehResult execute(Actor pActor)
	{
		return BehResult.Continue;
	}
}
// --- End of File: BehBoat.cs ---



// --- Start of File: BehBoatCheckExistence.cs ---
using ai.behaviours;

public class BehBoatCheckExistence : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.actor.getHomeBuilding() == null)
		{
			pActor.data.get("existence_check", out var pResult, 0);
			if (pResult == 0)
			{
				pActor.data.set("existence_check", (int)BehaviourActionBase<Actor>.world.getCurWorldTime());
			}
			else if (Date.getMonthsSince(pResult) > 2)
			{
				pActor.getHitFullHealth(AttackType.Explosion);
			}
		}
		else
		{
			pActor.data.removeInt("existence_check");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatCheckExistence.cs ---



// --- Start of File: BehBoatCheckFishingRepeat.cs ---
namespace ai.behaviours;

public class BehBoatCheckFishingRepeat : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.inventory.getResource("fish") <= 10)
		{
			return BehResult.RestartTask;
		}
		return forceTask(pActor, "boat_return_to_dock");
	}
}
// --- End of File: BehBoatCheckFishingRepeat.cs ---



// --- Start of File: BehBoatCheckHomeDocks.cs ---
namespace ai.behaviours;

public class BehBoatCheckHomeDocks : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		checkHomeDocks(pActor);
		if (boat.actor.getHomeBuilding() == null)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatCheckHomeDocks.cs ---



// --- Start of File: BehBoatCheckLimit.cs ---
namespace ai.behaviours;

public class BehBoatCheckLimit : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.getSimpleComponent<Boat>().isHomeDockFull())
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehBoatCheckLimit.cs ---



// --- Start of File: BehBoatCollectFish.cs ---
namespace ai.behaviours;

public class BehBoatCollectFish : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.addToInventory("fish", 1);
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatCollectFish.cs ---



// --- Start of File: BehBoatDamageCheck.cs ---
namespace ai.behaviours;

public class BehBoatDamageCheck : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.getHealthRatio() < 0.8f)
		{
			checkHomeDocks(pActor);
			if (boat.actor.getHomeBuilding() != null)
			{
				pActor.cancelAllBeh();
				return forceTask(pActor, "boat_return_to_dock");
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatDamageCheck.cs ---



// --- Start of File: BehBoatDangerCheck.cs ---
namespace ai.behaviours;

public class BehBoatDangerCheck : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.attackedBy != null)
		{
			if (pActor.getHealthRatio() < 0.25f)
			{
				checkHomeDocks(pActor);
				if (boat.actor.getHomeBuilding() != null)
				{
					pActor.cancelAllBeh();
					return forceTask(pActor, "boat_return_to_dock");
				}
			}
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehBoatDangerCheck.cs ---



// --- Start of File: BehBoatFindOceanNeutralTile.cs ---
namespace ai.behaviours;

public class BehBoatFindOceanNeutralTile : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		checkHomeDocks(pActor);
		Building homeBuilding = boat.actor.getHomeBuilding();
		if (homeBuilding != null)
		{
			if (pActor.getSimpleComponent<Boat>().isNearDock())
			{
				return BehResult.Stop;
			}
			WorldTile oceanTileInSameOcean = homeBuilding.component_docks.getOceanTileInSameOcean(pActor.current_tile);
			if (oceanTileInSameOcean != null)
			{
				pActor.beh_tile_target = oceanTileInSameOcean;
				return BehResult.Continue;
			}
		}
		WorldTile randomTileForBoat = ActorTool.getRandomTileForBoat(pActor);
		if (randomTileForBoat == null)
		{
			return BehResult.Stop;
		}
		if (randomTileForBoat.zone.city != null && randomTileForBoat.zone.city.kingdom.isEnemy(pActor.kingdom))
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = randomTileForBoat;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatFindOceanNeutralTile.cs ---



// --- Start of File: BehBoatFindRequest.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehBoatFindRequest : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.taxi_request != null && !boat.taxi_request.isAlreadyUsedByBoat(pActor))
		{
			boat.taxi_request.cancel();
			boat.taxi_request = null;
		}
		boat.taxi_request = TaxiManager.getNewRequestForBoat(pActor);
		if (boat.taxi_request == null)
		{
			return BehResult.Stop;
		}
		boat.taxi_request.assign(boat);
		return forceTask(pActor, "boat_transport_go_load");
	}
}
// --- End of File: BehBoatFindRequest.cs ---



// --- Start of File: BehBoatFindTargetForTrade.cs ---
namespace ai.behaviours;

public class BehBoatFindTargetForTrade : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		Docks dockTradeTarget = ActorTool.getDockTradeTarget(pActor);
		if (dockTradeTarget != null)
		{
			pActor.beh_building_target = dockTradeTarget.building;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehBoatFindTargetForTrade.cs ---



// --- Start of File: BehBoatFindTileInDock.cs ---
namespace ai.behaviours;

public class BehBoatFindTileInDock : BehBoat
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.beh_building_target.isCiv())
		{
			return BehResult.Stop;
		}
		WorldTile oceanTileInSameOcean = pActor.beh_building_target.component_docks.getOceanTileInSameOcean(pActor.current_tile);
		if (oceanTileInSameOcean == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = oceanTileInSameOcean;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatFindTileInDock.cs ---



// --- Start of File: BehBoatFindWaterTile.cs ---
namespace ai.behaviours;

public class BehBoatFindWaterTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		WorldTile randomTileForBoat = ActorTool.getRandomTileForBoat(pActor);
		pActor.beh_tile_target = randomTileForBoat;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatFindWaterTile.cs ---



// --- Start of File: BehBoatFishing.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehBoatFishing : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		spawnFishnet(pActor);
		return BehResult.Continue;
	}

	public void spawnFishnet(Actor pActor)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (MapBox.isRenderGameplay())
		{
			Vector2 val = Randy.randomPointOnCircle(3f, 4f);
			WorldTile worldTile = null;
			MapBox mapBox = BehaviourActionBase<Actor>.world;
			Vector2Int pos = pActor.current_tile.pos;
			int pX = ((Vector2Int)(ref pos)).x + (int)val.x;
			pos = pActor.current_tile.pos;
			worldTile = mapBox.GetTile(pX, ((Vector2Int)(ref pos)).y + (int)val.y);
			if (worldTile != null && worldTile.Type.ocean)
			{
				EffectsLibrary.spawnAtTile("fx_fishnet", worldTile, pActor.asset.base_stats["scale"]);
			}
		}
	}
}
// --- End of File: BehBoatFishing.cs ---



// --- Start of File: BehBoatMakeTrade.cs ---
namespace ai.behaviours;

public class BehBoatMakeTrade : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.addToInventory("gold", 5);
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatMakeTrade.cs ---



// --- Start of File: BehBoatRemoveIfLimit.cs ---
namespace ai.behaviours;

public class BehBoatRemoveIfLimit : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.isHomeDockOverfilled())
		{
			boat.destroyBecauseOverfilled();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatRemoveIfLimit.cs ---



// --- Start of File: BehBoatSetHomeDockTarget.cs ---
namespace ai.behaviours;

public class BehBoatSetHomeDockTarget : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		checkHomeDocks(pActor);
		Building homeBuilding = boat.actor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = homeBuilding;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatSetHomeDockTarget.cs ---



// --- Start of File: BehBoatTransportCheck.cs ---
namespace ai.behaviours;

public class BehBoatTransportCheck : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		checkHomeDocks(pActor);
		if (boat.hasPassengers())
		{
			WorldTile worldTile = null;
			if (boat.countPassengers() > 5 && pActor != null && pActor.city?.hasAttackZoneOrder() == true)
			{
				worldTile = pActor.city.target_attack_zone.centerTile;
			}
			if (worldTile == null)
			{
				worldTile = pActor?.city?.getTile();
			}
			if (worldTile != null)
			{
				boat.taxi_target = worldTile;
				pActor.beh_tile_target = worldTile;
				return forceTask(pActor, "boat_transport_go_unload", pClean: false);
			}
			return BehResult.Stop;
		}
		return forceTask(pActor, "boat_transport_check_taxi");
	}
}
// --- End of File: BehBoatTransportCheck.cs ---



// --- Start of File: BehBoatTransportDoLoading.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehBoatTransportDoLoading : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		TaxiRequest taxi_request = boat.taxi_request;
		if (taxi_request == null)
		{
			boat.cancelWork(pActor);
			return BehResult.Stop;
		}
		bool flag = true;
		if (boat.passengerWaitCounter > 4 || boat.countPassengers() >= 100)
		{
			flag = false;
		}
		else if (taxi_request.everyoneEmbarked())
		{
			flag = false;
		}
		if (flag)
		{
			foreach (Actor actor in taxi_request.getActors())
			{
				if (!actor.is_inside_boat && !actor.isFighting() && (!actor.hasTask() || !actor.ai.task.flag_boat_related))
				{
					actor.stopSleeping();
					actor.cancelAllBeh();
					actor.setTask("force_into_a_boat");
				}
			}
			taxi_request.setState(TaxiRequestState.Loading);
			pActor.timer_action = 12f;
			boat.passengerWaitCounter++;
			return BehResult.RepeatStep;
		}
		if (!boat.hasPassengers())
		{
			boat.cancelWork(pActor);
			return BehResult.Stop;
		}
		taxi_request.setState(TaxiRequestState.Transporting);
		taxi_request.cancelForLatePassengers();
		boat.taxi_target = taxi_request.getTileTarget();
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatTransportDoLoading.cs ---



// --- Start of File: BehBoatTransportFindTilePickUp.cs ---
using tools;

namespace ai.behaviours;

public class BehBoatTransportFindTilePickUp : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.taxi_request == null || !boat.taxi_request.isStillLegit())
		{
			boat.cancelWork(pActor);
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		boat.pickup_near_dock = false;
		ActorTool.checkHomeDocks(pActor);
		Building homeBuilding = boat.actor.getHomeBuilding();
		if (homeBuilding != null)
		{
			WorldTile oceanTileInSameOcean = homeBuilding.component_docks.getOceanTileInSameOcean(pActor.current_tile);
			if (oceanTileInSameOcean != null && oceanTileInSameOcean.isSameIsland(boat.taxi_request.getTileStart()))
			{
				boat.pickup_near_dock = true;
				if (boat.isNearDock())
				{
					boat.passengerWaitCounter = 0;
					pActor.beh_tile_target = pActor.current_tile;
					return BehResult.Continue;
				}
				pActor.beh_tile_target = oceanTileInSameOcean;
				return BehResult.Continue;
			}
		}
		worldTile = OceanHelper.findTileForBoat(pActor.current_tile, boat.taxi_request.getTileStart());
		if (worldTile == null)
		{
			boat.cancelWork(pActor);
			return BehResult.Stop;
		}
		boat.passengerWaitCounter = 0;
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatTransportFindTilePickUp.cs ---



// --- Start of File: BehBoatTransportFindTileUnload.cs ---
using tools;

namespace ai.behaviours;

public class BehBoatTransportFindTileUnload : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.taxi_target == null)
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = OceanHelper.findTileForBoat(pActor.current_tile, boat.taxi_target);
		if (worldTile == null)
		{
			boat.cancelWork(pActor);
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatTransportFindTileUnload.cs ---



// --- Start of File: BehBoatTransportUnloadUnits.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehBoatTransportUnloadUnits : BehBoat
{
	public override BehResult execute(Actor pActor)
	{
		if (boat.taxi_target == null)
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = PathfinderTools.raycastTileForUnitLandingFromOcean(pActor.current_tile, boat.taxi_target);
		if (worldTile.Type.ocean)
		{
			WorldTile[] neighboursAll = worldTile.neighboursAll;
			foreach (WorldTile worldTile2 in neighboursAll)
			{
				if (worldTile2.Type.ground)
				{
					worldTile = worldTile2;
					break;
				}
			}
		}
		boat.unloadPassengers(worldTile);
		if (boat.taxi_request != null)
		{
			TaxiManager.finish(boat.taxi_request);
			boat.taxi_request = null;
			boat.cancelWork(pActor);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBoatTransportUnloadUnits.cs ---



// --- Start of File: BehBuildingTargetHome.cs ---
namespace ai.behaviours;

public class BehBuildingTargetHome : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = homeBuilding;
		return BehResult.Continue;
	}
}
// --- End of File: BehBuildingTargetHome.cs ---



// --- Start of File: BehBuildingTargetLoverHome.cs ---
namespace ai.behaviours;

public class BehBuildingTargetLoverHome : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasLover())
		{
			return BehResult.Stop;
		}
		Building loverHomeBuilding = getLoverHomeBuilding(pActor, pActor.lover);
		if (loverHomeBuilding == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = loverHomeBuilding;
		return BehResult.Continue;
	}

	private Building getLoverHomeBuilding(Actor pActor1, Actor pActor2)
	{
		if (pActor1.hasHouse() && pActor2.hasHouse())
		{
			if (pActor1.isSexMale())
			{
				return pActor1.getHomeBuilding();
			}
			return pActor2.getHomeBuilding();
		}
		if (pActor1.hasHouse())
		{
			return pActor1.getHomeBuilding();
		}
		if (pActor2.hasHouse())
		{
			return pActor2.getHomeBuilding();
		}
		return null;
	}
}
// --- End of File: BehBuildingTargetLoverHome.cs ---



// --- Start of File: BehBuildTarget.cs ---
namespace ai.behaviours;

public class BehBuildTarget : BehActorUsableBuildingTarget
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
		null_check_city = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.beh_building_target.isUnderConstruction())
		{
			return BehResult.Stop;
		}
		if (pActor.beh_building_target.updateBuild(pActor.getConstructionSpeed()))
		{
			pActor.addLoot(SimGlobals.m.coins_for_building);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehBuildTarget.cs ---



// --- Start of File: BehBurnTumorTiles.cs ---
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace ai.behaviours;

public class BehBurnTumorTiles : BehaviourActionActor
{
	private static List<WorldTile> tiles = new List<WorldTile>();

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.current_tile.Type.ground)
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		List<WorldTile> list = tiles;
		checkRegion(pActor.current_tile.region, list);
		if (list.Count != 0)
		{
			worldTile = list.GetRandom();
		}
		else
		{
			List<MapRegion> neighbours = pActor.current_tile.region.neighbours;
			for (int i = 0; i < neighbours.Count; i++)
			{
				checkRegion(neighbours[i], list);
				if (list.Count != 0)
				{
					worldTile = list.GetRandom();
					break;
				}
			}
		}
		list.Clear();
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		AssetManager.spells.get("cast_fire").action?.Invoke(pActor, null, worldTile);
		pActor.doCastAnimation();
		return BehResult.Continue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void checkRegion(MapRegion pRegion, List<WorldTile> pTiles)
	{
		List<WorldTile> list = pRegion.tiles;
		for (int i = 0; i < list.Count; i++)
		{
			WorldTile worldTile = list[i];
			if (worldTile.Type.creep)
			{
				pTiles.Add(worldTile);
			}
		}
	}
}
// --- End of File: BehBurnTumorTiles.cs ---



// --- Start of File: BehChangeCityActorCulture.cs ---
using ai.behaviours;

public class BehChangeCityActorCulture : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasCulture())
		{
			pActor.city.setCulture(pActor.culture);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeCityActorCulture.cs ---



// --- Start of File: BehChangeCityActorLanguage.cs ---
using ai.behaviours;

public class BehChangeCityActorLanguage : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasLanguage())
		{
			pActor.city.setLanguage(pActor.language);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeCityActorLanguage.cs ---



// --- Start of File: BehChangeCityActorReligion.cs ---
using ai.behaviours;

public class BehChangeCityActorReligion : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasReligion())
		{
			pActor.city.setReligion(pActor.religion);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeCityActorReligion.cs ---



// --- Start of File: BehChangeKingdomCulture.cs ---
using ai.behaviours;

public class BehChangeKingdomCulture : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasCulture())
		{
			pActor.kingdom.setCulture(pActor.culture);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeKingdomCulture.cs ---



// --- Start of File: BehChangeKingdomLanguage.cs ---
using ai.behaviours;

public class BehChangeKingdomLanguage : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasLanguage())
		{
			pActor.kingdom.setLanguage(pActor.language);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeKingdomLanguage.cs ---



// --- Start of File: BehChangeKingdomReligion.cs ---
using ai.behaviours;

public class BehChangeKingdomReligion : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasReligion())
		{
			pActor.kingdom.setReligion(pActor.religion);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehChangeKingdomReligion.cs ---



// --- Start of File: BehCheckBuddingReproduction.cs ---
using ai.behaviours;

public class BehCheckBuddingReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasStatus("budding"))
		{
			return BehResult.Stop;
		}
		pActor.addStatusEffect("budding", pActor.getMaturationTimeSeconds());
		pActor.subspecies.counterReproduction();
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckBuddingReproduction.cs ---



// --- Start of File: BehCheckBuildCity.cs ---
namespace ai.behaviours;

public class BehCheckBuildCity : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.current_tile.zone.hasCity())
		{
			return BehResult.Stop;
		}
		if (!WorldLawLibrary.world_law_kingdom_expansion.isEnabled())
		{
			return BehResult.Stop;
		}
		if (!pActor.current_tile.zone.isGoodForNewCity(pActor))
		{
			return BehResult.Stop;
		}
		City pCity = BehaviourActionBase<Actor>.world.cities.buildNewCity(pActor, pActor.current_zone);
		pActor.joinCity(pCity);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckBuildCity.cs ---



// --- Start of File: BehCheckCanRepairEquipment.cs ---
using ai.behaviours;

public class BehCheckCanRepairEquipment : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasEquipment())
		{
			return BehResult.Stop;
		}
		bool flag = false;
		foreach (ActorEquipmentSlot item in pActor.equipment)
		{
			if (item.getItem().needRepair())
			{
				int num = (int)((float)item.getItem().getAsset().cost_gold * SimGlobals.m.item_repair_cost_multiplier);
				if (pActor.money >= num)
				{
					flag = true;
				}
			}
		}
		if (!flag)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCanRepairEquipment.cs ---



// --- Start of File: BehCheckCityActorArmyGroup.cs ---
namespace ai.behaviours;

public class BehCheckCityActorArmyGroup : BehCitizenActionCity
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.isKingdomCiv())
		{
			pActor.stopBeingWarrior();
			return BehResult.Stop;
		}
		if (pActor.city.hasArmy())
		{
			Army army = pActor.city.army;
			if (army.isGroupInCityAndHaveLeader())
			{
				pActor.setArmy(army);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCityActorArmyGroup.cs ---



// --- Start of File: BehCheckCityActorWarriorLimit.cs ---
namespace ai.behaviours;

public class BehCheckCityActorWarriorLimit : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		if (!pActor.inOwnCityBorders())
		{
			return BehResult.Stop;
		}
		city.checkIfWarriorStillOk(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCityActorWarriorLimit.cs ---



// --- Start of File: BehCheckCityDestroyed.cs ---
namespace ai.behaviours;

public class BehCheckCityDestroyed : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.city == null)
		{
			if (pActor.profession_asset.cancel_when_no_city)
			{
				pActor.stopBeingWarrior();
			}
			pActor.endJob();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCityDestroyed.cs ---



// --- Start of File: BehCheckCure.cs ---
namespace ai.behaviours;

public class BehCheckCure : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.current_tile.Type.ground)
		{
			return BehResult.Stop;
		}
		Actor actor = null;
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, 1))
		{
			if (ActorTool.canBeCuredFromTraitsOrStatus(item))
			{
				actor = item;
				break;
			}
		}
		if (actor == null)
		{
			return BehResult.Stop;
		}
		AssetManager.spells.get("cast_cure").action?.Invoke(pActor, actor, actor.current_tile);
		pActor.doCastAnimation();
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCure.cs ---



// --- Start of File: BehCheckCuriosityTile.cs ---
using ai.behaviours;

public class BehCheckCuriosityTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.scheduled_tile_target == null)
		{
			return BehResult.Stop;
		}
		WorldTile scheduled_tile_target = pActor.scheduled_tile_target;
		pActor.scheduled_tile_target = null;
		float num = 0.6f;
		if (pActor.hasSubspecies() && pActor.subspecies.has_trait_curious)
		{
			num += 0.3f;
		}
		if (!Randy.randomChance(num))
		{
			return BehResult.Stop;
		}
		WorldTile walkableTileAround = scheduled_tile_target.getWalkableTileAround(pActor.current_tile);
		if (walkableTileAround == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = walkableTileAround;
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckCuriosityTile.cs ---



// --- Start of File: BehCheckDivineReproduction.cs ---
using ai.behaviours;

public class BehCheckDivineReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasTrait("miracle_bearer"))
		{
			return BehResult.Stop;
		}
		BabyMaker.startMiracleBirth(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckDivineReproduction.cs ---



// --- Start of File: BehCheckEndCityActorJob.cs ---
namespace ai.behaviours;

public class BehCheckEndCityActorJob : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		CitizenJobAsset citizen_job = pActor.a.citizen_job;
		int num = pActor.city.jobs.countOccupied(citizen_job);
		int num2 = pActor.city.jobs.countCurrentJobs(citizen_job);
		if (num > num2)
		{
			pActor.endJob();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckEndCityActorJob.cs ---



// --- Start of File: BehCheckEnemyNotNear.cs ---
using ai.behaviours;

public class BehCheckEnemyNotNear : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (Finder.isEnemyNearOnSameIsland(pActor))
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckEnemyNotNear.cs ---



// --- Start of File: BehCheckFissionReproduction.cs ---
using ai.behaviours;

public class BehCheckFissionReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		BabyMaker.makeBabyViaFission(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckFissionReproduction.cs ---



// --- Start of File: BehCheckForBabiesFromSexualReproduction.cs ---
namespace ai.behaviours;

public class BehCheckForBabiesFromSexualReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasLover())
		{
			return BehResult.Stop;
		}
		pActor.addAfterglowStatus();
		pActor.lover.addAfterglowStatus();
		pActor.changeHappiness("just_kissed");
		pActor.lover.changeHappiness("just_kissed");
		if (BabyHelper.isMetaLimitsReached(pActor))
		{
			return BehResult.Stop;
		}
		pActor.subspecies.counter_reproduction_acts?.registerEvent();
		checkForBabies(pActor, pActor.lover);
		return BehResult.Continue;
	}

	private void checkForBabies(Actor pParentA, Actor pParentB)
	{
		checkFamily(pParentA, pParentB);
		Subspecies subspecies = pParentA.subspecies;
		Actor actor = null;
		ReproductiveStrategy reproductionStrategy = subspecies.getReproductionStrategy();
		if (subspecies.hasTraitReproductionSexual())
		{
			if (pParentA.isSexFemale())
			{
				actor = pParentA;
			}
			else if (pParentB.isSexFemale())
			{
				actor = pParentB;
			}
		}
		else if (subspecies.hasTraitReproductionSexualHermaphroditic())
		{
			actor = ((!Randy.randomBool()) ? pParentB : pParentA);
		}
		if (actor != null && BabyHelper.canMakeBabies(actor) && (!actor.isSexMale() || !actor.subspecies.hasTraitReproductionSexual()))
		{
			float maturationTimeSeconds = pParentA.getMaturationTimeSeconds();
			switch (reproductionStrategy)
			{
			case ReproductiveStrategy.Egg:
			case ReproductiveStrategy.SpawnUnitImmediate:
				BabyMaker.makeBabiesViaSexual(actor, pParentA, pParentB);
				actor.subspecies.counterReproduction();
				break;
			case ReproductiveStrategy.Pregnancy:
				BabyHelper.babyMakingStart(actor);
				actor.addStatusEffect("pregnant", maturationTimeSeconds);
				actor.subspecies.counterReproduction();
				break;
			}
		}
	}

	private void checkFamily(Actor pActor, Actor pLover)
	{
		bool flag = false;
		if (pActor.hasFamily())
		{
			if (pActor.family != pActor.lover.family)
			{
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			BehaviourActionBase<Actor>.world.families.newFamily(pActor, pActor.current_tile, pLover);
		}
	}
}
// --- End of File: BehCheckForBabiesFromSexualReproduction.cs ---



// --- Start of File: BehCheckForLover.cs ---
namespace ai.behaviours;

public class BehCheckForLover : BehCitizenActionCity
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasLover())
		{
			return BehResult.Stop;
		}
		Actor lover = pActor.lover;
		if (lover.isTask("sexual_reproduction_civ_go") && lover.beh_building_target == pActor.beh_building_target && lover.ai.action_index > 3)
		{
			pActor.stayInBuilding(pActor.beh_building_target);
			lover.stayInBuilding(lover.beh_building_target);
			lover.setTask("sexual_reproduction_civ_wait", pClean: false, pCleanJob: false, pForceAction: true);
			return forceTask(pActor, "sexual_reproduction_civ_action", pClean: false, pForceAction: true);
		}
		if (!lover.isTask("sexual_reproduction_civ_go"))
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckForLover.cs ---



// --- Start of File: BehCheckHasMoneyForCityFood.cs ---
using ai.behaviours;

public class BehCheckHasMoneyForCityFood : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.canGetFoodFromCity())
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckHasMoneyForCityFood.cs ---



// --- Start of File: BehCheckHasResources.cs ---
using ai.behaviours;

public class BehCheckHasResources : BehaviourActionActor
{
	public override BehResult execute(Actor pObject)
	{
		if (pObject.isCarryingResources())
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCheckHasResources.cs ---



// --- Start of File: BehCheckIfInLiquid.cs ---
namespace ai.behaviours;

public class BehCheckIfInLiquid : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isInLiquid())
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCheckIfInLiquid.cs ---



// --- Start of File: BehCheckIfOnGround.cs ---
namespace ai.behaviours;

public class BehCheckIfOnGround : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isInLiquid())
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckIfOnGround.cs ---



// --- Start of File: BehCheckIfOnSmallLand.cs ---
namespace ai.behaviours;

public class BehCheckIfOnSmallLand : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.current_tile.region.island.isGoodIslandForActor(pActor))
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckIfOnSmallLand.cs ---



// --- Start of File: BehCheckNearActorTarget.cs ---
namespace ai.behaviours;

public class BehCheckNearActorTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Actor a = pActor.beh_actor_target.a;
		if (!pActor.canTalkWith(a))
		{
			return BehResult.Stop;
		}
		if (Toolbox.SquaredDistVec2Float(pActor.current_position, a.current_position) < 4f)
		{
			return BehResult.Continue;
		}
		return BehResult.RestartTask;
	}
}
// --- End of File: BehCheckNearActorTarget.cs ---



// --- Start of File: BehCheckNeeds.cs ---
namespace ai.behaviours;

public class BehCheckNeeds : BehCityActor
{
	private int _max_restarts;

	public BehCheckNeeds(int pRestarts)
	{
		_max_restarts = pRestarts;
	}

	public override BehResult execute(Actor pActor)
	{
		if (_max_restarts > 0 && pActor.ai.restarts >= _max_restarts)
		{
			return BehResult.Stop;
		}
		if (pActor.isStarving() && pActor.city.hasAnyFood())
		{
			pActor.endJob();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckNeeds.cs ---



// --- Start of File: BehCheckParthenogenesisReproduction.cs ---
using ai.behaviours;

public class BehCheckParthenogenesisReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		switch (pActor.subspecies.getReproductionStrategy())
		{
		case ReproductiveStrategy.Egg:
		case ReproductiveStrategy.SpawnUnitImmediate:
			BabyMaker.makeBabyViaParthenogenesis(pActor);
			break;
		case ReproductiveStrategy.Pregnancy:
		{
			BabyHelper.babyMakingStart(pActor);
			float maturationTimeSeconds = pActor.getMaturationTimeSeconds();
			pActor.addStatusEffect("pregnant_parthenogenesis", maturationTimeSeconds);
			pActor.subspecies.counterReproduction();
			break;
		}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckParthenogenesisReproduction.cs ---



// --- Start of File: BehCheckPlot.cs ---
using ai.behaviours;

public class BehCheckPlot : BehCheckPlotBase
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasPlot())
		{
			return BehResult.Stop;
		}
		if (!isBasePlotCheckOk(pActor))
		{
			pActor.leavePlot();
			return BehResult.Stop;
		}
		return forceTask(pActor, "progress_plot");
	}
}
// --- End of File: BehCheckPlot.cs ---



// --- Start of File: BehCheckPlotBase.cs ---
using ai.behaviours;

public class BehCheckPlotBase : BehaviourActionActor
{
	public override bool shouldRetry(Actor pActor)
	{
		if (base.shouldRetry(pActor))
		{
			return true;
		}
		if (pActor.hasPlot())
		{
			PlotRetryAction plot_retry_action = pActor.plot.getAsset().getPlotGroup().plot_retry_action;
			if (plot_retry_action != null && plot_retry_action())
			{
				return true;
			}
		}
		return false;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_plots = true;
		uses_clans = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasClan())
		{
			return BehResult.Stop;
		}
		if (!pActor.plot.isActive())
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}

	protected bool isBasePlotCheckOk(Actor pActor)
	{
		if (!pActor.hasPlot())
		{
			return false;
		}
		if (!pActor.isKingdomCiv())
		{
			return false;
		}
		Plot plot = pActor.plot;
		if (!plot.isActive())
		{
			return false;
		}
		PlotAsset asset = plot.getAsset();
		if (!asset.isAllowedByWorldLaws())
		{
			return false;
		}
		PlotCheckerDelegate check_should_continue = asset.check_should_continue;
		if (check_should_continue != null && !check_should_continue(pActor))
		{
			return false;
		}
		return true;
	}
}
// --- End of File: BehCheckPlotBase.cs ---



// --- Start of File: BehCheckPlotIsOk.cs ---
using ai.behaviours;

public class BehCheckPlotIsOk : BehCheckPlotBase
{
	public override BehResult execute(Actor pActor)
	{
		if (!isBasePlotCheckOk(pActor))
		{
			pActor.leavePlot();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckPlotIsOk.cs ---



// --- Start of File: BehCheckPlotProgress.cs ---
using ai.behaviours;

public class BehCheckPlotProgress : BehCheckPlotBase
{
	public override BehResult execute(Actor pActor)
	{
		if (!isBasePlotCheckOk(pActor))
		{
			pActor.leavePlot();
			return BehResult.Stop;
		}
		Plot plot = pActor.plot;
		plot.updateProgressTarget(pActor, pActor.stats["intelligence"]);
		if (!plot.isActive())
		{
			pActor.leavePlot();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckPlotProgress.cs ---



// --- Start of File: BehCheckReproductionBasics.cs ---
using ai.behaviours;

public class BehCheckReproductionBasics : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isSapient())
		{
			if (!WorldLawLibrary.world_law_civ_babies.isEnabled())
			{
				return BehResult.Stop;
			}
		}
		else if (!WorldLawLibrary.world_law_animals_babies.isEnabled())
		{
			return BehResult.Stop;
		}
		pActor.subspecies.counter_reproduction_basics_1?.registerEvent();
		if (!pActor.canBreed())
		{
			return BehResult.Stop;
		}
		pActor.subspecies.counter_reproduction_basics_2?.registerEvent();
		if (!BabyHelper.canMakeBabies(pActor))
		{
			return BehResult.Stop;
		}
		if (BabyHelper.isMetaLimitsReached(pActor))
		{
			return BehResult.Stop;
		}
		pActor.subspecies.counter_reproduction_basics_3?.registerEvent();
		if (!pActor.isImportantPerson() && !pActor.isPlacePrivateForBreeding())
		{
			return BehResult.Stop;
		}
		pActor.subspecies.counter_reproduction_basics_4?.registerEvent();
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckReproductionBasics.cs ---



// --- Start of File: BehCheckSameCityActorLover.cs ---
namespace ai.behaviours;

public class BehCheckSameCityActorLover : BehCitizenActionCity
{
	public override bool errorsFound(Actor pObject)
	{
		if (base.errorsFound(pObject))
		{
			return true;
		}
		if (!pObject.hasLover())
		{
			return true;
		}
		if (pObject.lover.isRekt())
		{
			return true;
		}
		if (pObject.lover.city.isRekt())
		{
			return true;
		}
		return false;
	}

	public override BehResult execute(Actor pActor)
	{
		City city = pActor.lover.city;
		pActor.clearHomeBuilding();
		pActor.stopBeingWarrior();
		pActor.joinCity(city);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckSameCityActorLover.cs ---



// --- Start of File: BehCheckSexualReproductionCiv.cs ---
namespace ai.behaviours;

public class BehCheckSexualReproductionCiv : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isKingdomCiv())
		{
			if (!pActor.hasHouse())
			{
				return BehResult.Stop;
			}
			if (!pActor.hasLover())
			{
				return BehResult.Stop;
			}
		}
		Actor lover = pActor.lover;
		if (!lover.canCurrentTaskBeCancelledByReproduction())
		{
			return BehResult.Stop;
		}
		lover.setTask("sexual_reproduction_civ_go", pClean: true, pCleanJob: true);
		lover.timer_action = 0f;
		return forceTask(pActor, "sexual_reproduction_civ_go");
	}
}
// --- End of File: BehCheckSexualReproductionCiv.cs ---



// --- Start of File: BehCheckSexualReproductionOutside.cs ---
namespace ai.behaviours;

public class BehCheckSexualReproductionOutside : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.canBreed())
		{
			return BehResult.Stop;
		}
		if (!pActor.hasLover())
		{
			return BehResult.Stop;
		}
		Actor lover = pActor.lover;
		if (!lover.canBreed())
		{
			return BehResult.Stop;
		}
		if (!lover.canCurrentTaskBeCancelledByReproduction())
		{
			return BehResult.Stop;
		}
		if (tryStartBreeding(pActor, lover))
		{
			return BehResult.RepeatStep;
		}
		pActor.addAfterglowStatus();
		return BehResult.Stop;
	}

	internal bool tryStartBreeding(Actor pActor, Actor pLover)
	{
		pActor.setTask("sexual_reproduction_outside", pClean: true, pCleanJob: true);
		pActor.beh_actor_target = pLover;
		pLover.makeWait();
		return true;
	}
}
// --- End of File: BehCheckSexualReproductionOutside.cs ---



// --- Start of File: BehCheckSoulBorneReproduction.cs ---
using ai.behaviours;

public class BehCheckSoulBorneReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasStatus("soul_harvested"))
		{
			return BehResult.Stop;
		}
		if (pActor.hasStatus("pregnant"))
		{
			return BehResult.Stop;
		}
		if (BabyHelper.isMetaLimitsReached(pActor))
		{
			return BehResult.Stop;
		}
		pActor.finishStatusEffect("soul_harvested");
		BabyMaker.startSoulborneBirth(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckSoulBorneReproduction.cs ---



// --- Start of File: BehCheckSporeReproduction.cs ---
using ai.behaviours;

public class BehCheckSporeReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		BabyMaker.spawnSporesFor(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckSporeReproduction.cs ---



// --- Start of File: BehCheckStartCivilization.cs ---
using ai.behaviours;

public class BehCheckStartCivilization : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.buildCityAndStartCivilization();
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckStartCivilization.cs ---



// --- Start of File: BehCheckStillUnderConstruction.cs ---
namespace ai.behaviours;

public class BehCheckStillUnderConstruction : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_city = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.beh_building_target.isUnderConstruction())
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckStillUnderConstruction.cs ---



// --- Start of File: BehCheckVegetativeReproduction.cs ---
using ai.behaviours;

public class BehCheckVegetativeReproduction : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasStatus("taking_roots"))
		{
			return BehResult.Stop;
		}
		pActor.addStatusEffect("taking_roots", pActor.getMaturationTimeSeconds());
		pActor.subspecies.counterReproduction();
		return BehResult.Continue;
	}
}
// --- End of File: BehCheckVegetativeReproduction.cs ---



// --- Start of File: BehChildFindRandomFamilyParent.cs ---
using ai.behaviours;

public class BehChildFindRandomFamilyParent : BehaviourActionActor
{
	public override BehResult execute(Actor pBabyActor)
	{
		if (!pBabyActor.family.hasFounders())
		{
			return BehResult.Stop;
		}
		Actor randomFounder = pBabyActor.family.getRandomFounder();
		if (pBabyActor.inOwnCityBorders() && !randomFounder.inOwnCityBorders())
		{
			return BehResult.Stop;
		}
		pBabyActor.beh_actor_target = randomFounder;
		return BehResult.Continue;
	}
}
// --- End of File: BehChildFindRandomFamilyParent.cs ---



// --- Start of File: BehCitizenActionCity.cs ---
namespace ai.behaviours;

public class BehCitizenActionCity : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_cities = true;
	}
}
// --- End of File: BehCitizenActionCity.cs ---



// --- Start of File: BehCityActor.cs ---
namespace ai.behaviours;

public class BehCityActor : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_city = true;
	}
}
// --- End of File: BehCityActor.cs ---



// --- Start of File: BehCityActorCheckAttack.cs ---
namespace ai.behaviours;

public class BehCityActorCheckAttack : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		TileZone target_attack_zone = pActor.city.target_attack_zone;
		City city = pActor.city.target_attack_zone.city;
		if (!isAttackingZoneAvailable(pActor, target_attack_zone, city))
		{
			return BehResult.Stop;
		}
		if (pActor.current_tile.zone.city != target_attack_zone.city)
		{
			pActor.beh_tile_target = target_attack_zone.tiles.GetRandom();
			return BehResult.Continue;
		}
		Building buildingOfType = city.getBuildingOfType("type_watch_tower", pCountOnlyFinished: false, pRandom: false, pOnlyFreeTile: false, pActor.current_island);
		if (buildingOfType != null)
		{
			pActor.beh_tile_target = buildingOfType.current_tile.region.tiles.GetRandom();
			return BehResult.Continue;
		}
		TileZone[] neighbours_all = pActor.current_tile.zone.neighbours_all;
		foreach (TileZone tileZone in neighbours_all)
		{
			if (tileZone.city == city)
			{
				WorldTile random = tileZone.tiles.GetRandom();
				if (random.isSameIsland(pActor.current_tile))
				{
					pActor.beh_tile_target = random;
					return BehResult.Continue;
				}
			}
		}
		foreach (TileZone zone in city.zones)
		{
			WorldTile random2 = zone.tiles.GetRandom();
			if (random2.isSameIsland(pActor.current_tile))
			{
				pActor.beh_tile_target = random2;
				return BehResult.Continue;
			}
		}
		return BehResult.Stop;
	}

	private bool isAttackingZoneAvailable(Actor pActor, TileZone pAttackZone, City pAttackCity)
	{
		if (pActor.army.isGroupInCityAndHaveLeader() && !pActor.city.isOkToSendArmy())
		{
			return false;
		}
		if (pAttackCity == null)
		{
			return false;
		}
		if (pAttackZone == null)
		{
			return false;
		}
		if (!pAttackZone.centerTile.isSameIsland(pActor.current_tile))
		{
			return false;
		}
		return true;
	}
}
// --- End of File: BehCityActorCheckAttack.cs ---



// --- Start of File: BehCityActorCreateRoad.cs ---
namespace ai.behaviours;

public class BehCityActorCreateRoad : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		MapAction.createRoadTile(pActor.beh_tile_target);
		pActor.addLoot(SimGlobals.m.coins_for_road);
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorCreateRoad.cs ---



// --- Start of File: BehCityActorFertilizeCrop.cs ---
namespace ai.behaviours;

public class BehCityActorFertilizeCrop : BehActorUsableBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		Building beh_building_target = pActor.beh_building_target;
		if (beh_building_target.component_wheat.isMaxLevel())
		{
			return BehResult.Stop;
		}
		if (pActor.inventory.getResource("fertilizer") == 0)
		{
			return BehResult.Stop;
		}
		pActor.takeFromInventory("fertilizer", 1);
		beh_building_target.component_wheat.growFull();
		pActor.addLoot(SimGlobals.m.coins_for_fertilize);
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorFertilizeCrop.cs ---



// --- Start of File: BehCityActorFindBuilding.cs ---
namespace ai.behaviours;

public class BehCityActorFindBuilding : BehCityActor
{
	private string _type;

	private string[] _types;

	private bool _only_free_tile;

	public BehCityActorFindBuilding(string pType, bool pFreeTile = true)
	{
		_type = pType;
		_only_free_tile = pFreeTile;
		if (pType.Contains(","))
		{
			_types = pType.Split(',');
		}
	}

	public override BehResult execute(Actor pActor)
	{
		if (_types != null)
		{
			_type = _types.GetRandom();
		}
		pActor.beh_building_target = ActorTool.findNewBuildingTarget(pActor, _type);
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorFindBuilding.cs ---



// --- Start of File: BehCityActorFindClosestFire.cs ---
using System.Collections.Generic;
using UnityEngine;

namespace ai.behaviours;

public class BehCityActorFindClosestFire : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		WorldTile current_tile = pActor.current_tile;
		WorldTile closestTileOnFireFromZones = getClosestTileOnFireFromZones(pActor);
		if (closestTileOnFireFromZones == null)
		{
			return BehResult.Stop;
		}
		if (pActor.is_visible)
		{
			pActor.spawnSlashYell(Vector2Int.op_Implicit(closestTileOnFireFromZones.pos));
		}
		WorldTile worldTile = raycastTileForUnitToFightFire(current_tile, closestTileOnFireFromZones);
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}

	private static WorldTile getClosestTileOnFireFromZones(Actor pActor)
	{
		WorldTile current_tile = pActor.current_tile;
		TileZone current_zone = pActor.current_zone;
		WorldTile closestTileOnFire = getClosestTileOnFire(current_zone.tiles, current_tile);
		if (closestTileOnFire == null)
		{
			foreach (TileZone item in current_zone.neighbours_all.LoopRandom())
			{
				if (item.isZoneOnFire())
				{
					closestTileOnFire = getClosestTileOnFire(item.tiles, current_tile);
					if (closestTileOnFire != null)
					{
						return closestTileOnFire;
					}
				}
			}
		}
		return closestTileOnFire;
	}

	private static WorldTile getClosestTileOnFire(WorldTile[] pArray, WorldTile pTarget)
	{
		WorldTile result = null;
		int num = pArray.Length;
		int num2 = int.MaxValue;
		for (int i = 0; i < num; i++)
		{
			WorldTile worldTile = pArray[i];
			int num3 = Toolbox.SquaredDist(pTarget.x, pTarget.y, worldTile.x, worldTile.y);
			if (num3 < num2 && worldTile.isOnFire())
			{
				num2 = num3;
				result = worldTile;
			}
		}
		return result;
	}

	public static WorldTile raycastTileForUnitToFightFire(WorldTile pActorTile, WorldTile pTargetFire)
	{
		if (pActorTile == pTargetFire)
		{
			return pActorTile;
		}
		List<WorldTile> list = PathfinderTools.raycast(pTargetFire, pActorTile);
		WorldTile result = null;
		float num = float.MaxValue;
		for (int i = 0; i < list.Count; i++)
		{
			WorldTile worldTile = list[i];
			float num2 = Toolbox.SquaredDist(worldTile.x, worldTile.y, pTargetFire.x, pTargetFire.y);
			if (!(num2 < 4f) && !(num2 >= num))
			{
				num = num2;
				result = worldTile;
			}
		}
		list.Clear();
		return result;
	}
}
// --- End of File: BehCityActorFindClosestFire.cs ---



// --- Start of File: BehCityActorFindFireZone.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehCityActorFindFireZone : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasStatus("burning"))
		{
			return BehResult.Stop;
		}
		TileZone cityZoneNearFire = getCityZoneNearFire(pActor);
		if (cityZoneNearFire == null)
		{
			return BehResult.Stop;
		}
		WorldTile closestTileNotOnFire = getClosestTileNotOnFire(cityZoneNearFire.tiles, pActor.current_tile);
		if (closestTileNotOnFire == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = closestTileNotOnFire;
		return BehResult.Continue;
	}

	private static TileZone getCityZoneNearFire(Actor pActor)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		using ListPool<TileZone> listPool = new ListPool<TileZone>(pActor.city.zones);
		int num = int.MaxValue;
		TileZone result = null;
		foreach (TileZone neighbour_zone in pActor.city.neighbour_zones)
		{
			if (!neighbour_zone.hasCity())
			{
				listPool.Add(neighbour_zone);
			}
		}
		Vector2Int pos = pActor.current_tile.pos;
		for (int i = 0; i < listPool.Count; i++)
		{
			TileZone tileZone = listPool[i];
			if (tileZone.isZoneOnFire())
			{
				Vector2Int pos2 = tileZone.centerTile.pos;
				int num2 = Toolbox.SquaredDist(((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, ((Vector2Int)(ref pos2)).x, ((Vector2Int)(ref pos2)).y);
				if (num2 < num)
				{
					result = tileZone;
					num = num2;
				}
			}
		}
		listPool.Clear();
		return result;
	}

	public static WorldTile getClosestTileNotOnFire(WorldTile[] pArray, WorldTile pTarget)
	{
		WorldTile result = null;
		int num = pArray.Length;
		int num2 = int.MaxValue;
		for (int i = 0; i < num; i++)
		{
			WorldTile worldTile = pArray[i];
			int num3 = Toolbox.SquaredDist(pTarget.x, pTarget.y, worldTile.x, worldTile.y);
			if (num3 < num2 && !worldTile.hasBuilding() && !worldTile.isOnFire())
			{
				num2 = num3;
				result = worldTile;
			}
		}
		return result;
	}
}
// --- End of File: BehCityActorFindFireZone.cs ---



// --- Start of File: BehCityActorFindNewJob.cs ---
namespace ai.behaviours;

public class BehCityActorFindNewJob : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.city.setCitizenJob(pActor);
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorFindNewJob.cs ---



// --- Start of File: BehCityActorFindStorage.cs ---
namespace ai.behaviours;

public class BehCityActorFindStorage : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		Building storageNear = pActor.city.getStorageNear(pActor.current_tile);
		if (storageNear != null)
		{
			pActor.beh_building_target = storageNear;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCityActorFindStorage.cs ---



// --- Start of File: BehCityActorFindStorageWheat.cs ---
namespace ai.behaviours;

public class BehCityActorFindStorageWheat : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		Building buildingOfType = pActor.city.getBuildingOfType("type_windmill", pCountOnlyFinished: true, pRandom: false, pOnlyFreeTile: false, pActor.current_island);
		if (buildingOfType != null)
		{
			pActor.beh_building_target = buildingOfType;
			return BehResult.Continue;
		}
		Building storageNear = pActor.city.getStorageNear(pActor.current_tile, pOnlyFood: true);
		if (storageNear != null)
		{
			pActor.beh_building_target = storageNear;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCityActorFindStorageWheat.cs ---



// --- Start of File: BehCityActorFindUngrownCrop.cs ---
namespace ai.behaviours;

public class BehCityActorFindUngrownCrop : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		using ListPool<Building> listPool = new ListPool<Building>();
		foreach (WorldTile calculated_crop in city.calculated_crops)
		{
			Building building = calculated_crop.building;
			if (!building.isRekt() && building.asset.wheat && !building.component_wheat.isMaxLevel())
			{
				listPool.Add(building);
			}
		}
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = listPool.GetRandom();
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorFindUngrownCrop.cs ---



// --- Start of File: BehCityActorGetRandomBorderTile.cs ---
using ai.behaviours;

public class BehCityActorGetRandomBorderTile : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.city.hasZones())
		{
			return BehResult.Stop;
		}
		if (pActor.city.border_zones.Count == 0)
		{
			return BehResult.Stop;
		}
		WorldTile random = pActor.city.border_zones.GetRandom().tiles.GetRandom();
		if (!random.Type.ground)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = random;
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorGetRandomBorderTile.cs ---



// --- Start of File: BehCityActorGetRandomDangerZone.cs ---
namespace ai.behaviours;

public class BehCityActorGetRandomDangerZone : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		if (!city.hasZones())
		{
			return BehResult.Stop;
		}
		if (!city.isInDanger())
		{
			return BehResult.Stop;
		}
		if (Randy.randomChance(0.2f))
		{
			foreach (TileZone danger_zone in city.danger_zones)
			{
				WorldTile random = danger_zone.tiles.GetRandom();
				if (random.isSameIsland(pActor.current_tile))
				{
					pActor.beh_tile_target = random;
					return BehResult.Continue;
				}
			}
		}
		int num = int.MaxValue;
		WorldTile worldTile = null;
		foreach (TileZone danger_zone2 in city.danger_zones)
		{
			WorldTile centerTile = danger_zone2.centerTile;
			int num2 = Toolbox.SquaredDistTile(pActor.current_tile, centerTile);
			if (num2 <= num && centerTile.isSameIsland(pActor.current_tile) && (num2 != num || !Randy.randomBool()))
			{
				num = num2;
				worldTile = centerTile;
			}
		}
		if (worldTile != null)
		{
			pActor.beh_tile_target = worldTile;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCityActorGetRandomDangerZone.cs ---



// --- Start of File: BehCityActorGetRandomIdleTile.cs ---
namespace ai.behaviours;

public class BehCityActorGetRandomIdleTile : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.city.hasZones())
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = tryToGetBonfireTile(pActor);
		if (worldTile == null)
		{
			worldTile = getRandomCityZoneTile(pActor);
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}

	private WorldTile getRandomCityZoneTile(Actor pActor)
	{
		WorldTile worldTile = null;
		if (!pActor.current_tile.isSameCityHere(pActor.city) || Randy.randomChance(0.2f))
		{
			worldTile = pActor.city.zones.GetRandom().tiles.GetRandom();
			if (!worldTile.isSameIsland(pActor.current_tile))
			{
				return null;
			}
		}
		else
		{
			worldTile = pActor.current_tile.region.tiles.GetRandom();
		}
		return worldTile;
	}

	private WorldTile tryToGetBonfireTile(Actor pActor)
	{
		Building buildingOfType = pActor.city.getBuildingOfType("type_bonfire", pCountOnlyFinished: true, pRandom: true, pOnlyFreeTile: false, pActor.current_island);
		if (buildingOfType == null)
		{
			return null;
		}
		WorldTile random = buildingOfType.tiles.GetRandom();
		if (Randy.randomChance(0.3f))
		{
			MapRegion mapRegion = buildingOfType.current_tile.region;
			if (mapRegion.neighbours.Count > 0 && Randy.randomChance(0.3f))
			{
				mapRegion = mapRegion.neighbours.GetRandom();
			}
			random = mapRegion.tiles.GetRandom();
		}
		return random;
	}
}
// --- End of File: BehCityActorGetRandomIdleTile.cs ---



// --- Start of File: BehCityActorGetRandomZoneTile.cs ---
namespace ai.behaviours;

public class BehCityActorGetRandomZoneTile : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.city.hasZones())
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		if (pActor.current_tile.zone.city != pActor.city || Randy.randomChance(0.2f))
		{
			worldTile = pActor.city.zones.GetRandom().getRandomTile();
			if (!worldTile.isSameIsland(pActor.current_tile))
			{
				return BehResult.Stop;
			}
		}
		else
		{
			worldTile = pActor.current_tile.region.tiles.GetRandom();
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorGetRandomZoneTile.cs ---



// --- Start of File: BehCityActorGetResourceFromStorage.cs ---
namespace ai.behaviours;

public class BehCityActorGetResourceFromStorage : BehCityActor
{
	private string _resource_id;

	private int _amount;

	public BehCityActorGetResourceFromStorage(string pResourceId, int pAmount)
	{
		_resource_id = pResourceId;
		_amount = pAmount;
	}

	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		if (!city.hasStorages())
		{
			return BehResult.Stop;
		}
		if (city.getResourcesAmount(_resource_id) < _amount)
		{
			return BehResult.Stop;
		}
		city.takeResource(_resource_id, _amount);
		pActor.addToInventory(_resource_id, _amount);
		return BehResult.Continue;
	}
}
// --- End of File: BehCityActorGetResourceFromStorage.cs ---



// --- Start of File: BehCityActorRemoveFire.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehCityActorRemoveFire : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		foreach (WorldTile item in pActor.current_tile.getTilesAround(3))
		{
			if (item != null)
			{
				putOutFireForTile(item);
			}
		}
		return BehResult.Continue;
	}

	private void putOutFireForTile(WorldTile pTile, bool pForceEffect = false)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (pTile.isOnFire())
		{
			pTile.stopFire();
			flag = true;
		}
		if (flag || pForceEffect)
		{
			EffectsLibrary.spawnAt("fx_water_splash", Vector2Int.op_Implicit(pTile.pos), 0.1f);
		}
		if (pTile.hasBuilding())
		{
			pTile.building.stopFire();
		}
	}
}
// --- End of File: BehCityActorRemoveFire.cs ---



// --- Start of File: BehCityActorWarriorTaxiCheck.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehCityActorWarriorTaxiCheck : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.current_tile.hasCity() && pActor.current_tile.zone_city.kingdom.isEnemy(pActor.kingdom))
		{
			return BehResult.Stop;
		}
		if (pActor.city.hasAttackZoneOrder() && !pActor.city.target_attack_zone.centerTile.isSameIsland(pActor.current_tile))
		{
			TaxiManager.newRequest(pActor, pActor.city.target_attack_zone.centerTile);
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehCityActorWarriorTaxiCheck.cs ---



// --- Start of File: BehClaimZoneForCityActorBorder.cs ---
using ai.behaviours;

public class BehClaimZoneForCityActorBorder : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		return tryClaimZone(pActor);
	}

	public static BehResult tryClaimZone(Actor pActor)
	{
		TileZone zone = pActor.current_tile.zone;
		City city = pActor.city;
		WorldTile tile = city.getTile();
		if (tile == null)
		{
			return BehResult.Stop;
		}
		if (!city.isZoneToClaimStillGood(pActor, zone, tile))
		{
			return BehResult.Stop;
		}
		bool flag = pActor.hasCultureTrait("expansionists") || DebugConfig.isOn(DebugOption.CityFastZonesGrowth);
		bool num = zone.city != null && zone.city != city;
		city.addZone(zone);
		if (num)
		{
			flag = false;
		}
		if (flag)
		{
			TileZone[] neighbours_all = zone.neighbours_all;
			foreach (TileZone tileZone in neighbours_all)
			{
				if (!tileZone.hasCity() && tileZone.centerTile.isSameIsland(tile) && city.isZoneToClaimStillGood(pActor, tileZone, tile))
				{
					city.addZone(tileZone);
				}
			}
		}
		pActor.addLoot(SimGlobals.m.coins_for_zone);
		return BehResult.Continue;
	}
}
// --- End of File: BehClaimZoneForCityActorBorder.cs ---



// --- Start of File: BehClanChiefCheckMembersToBanish.cs ---
using ai.behaviours;

public class BehClanChiefCheckMembersToBanish : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Clan clan = pActor.clan;
		for (int i = 0; i < clan.units.Count; i++)
		{
			Actor actor = clan.units[i];
			if (actor != pActor && pActor.areFoes(actor))
			{
				actor.setClan(null);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehClanChiefCheckMembersToBanish.cs ---



// --- Start of File: BehClanChiefCheckMembersToKill.cs ---
using ai.behaviours;

public class BehClanChiefCheckMembersToKill : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Clan clan = pActor.clan;
		for (int i = 0; i < clan.units.Count; i++)
		{
			Actor actor = clan.units[i];
			if (actor != pActor && pActor.areFoes(actor))
			{
				actor.getHitFullHealth(AttackType.Divine);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehClanChiefCheckMembersToKill.cs ---



// --- Start of File: BehConsumeActorsBloodTarget.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehConsumeActorsBloodTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Actor a = pActor.beh_actor_target.a;
		if (Toolbox.DistTile(pActor.current_tile, a.current_tile) > 1f)
		{
			return BehResult.StepBack;
		}
		consume(pActor, a);
		if (a.hasHealth())
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}

	private void consume(Actor pMain, Actor pTarget)
	{
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		pMain.timer_action = 0.3f;
		if (pMain.current_position.x > pTarget.current_position.x)
		{
			if (pTarget.target_angle.z > -45f)
			{
				pTarget.target_angle.z -= BehaviourActionBase<Actor>.world.elapsed * 100f;
				if (pTarget.target_angle.z < -90f)
				{
					pTarget.target_angle.z = -90f;
				}
				pTarget.rotation_cooldown = 1f;
			}
		}
		else if (pTarget.target_angle.z < 45f)
		{
			pTarget.target_angle.z += BehaviourActionBase<Actor>.world.elapsed * 100f;
			pTarget.rotation_cooldown = 1f;
		}
		if (pMain.target_angle.z == 0f)
		{
			pMain.punchTargetAnimation(Vector2.op_Implicit(pTarget.current_position), pFlip: false, pReverse: false, -40f);
			int num = (int)((float)pTarget.getMaxHealth() * 0.05f) + 1;
			pTarget.getHit(num, pFlash: true, AttackType.Eaten, pMain, pSkipIfShake: false);
			pTarget.startShake(0.2f);
			if (pTarget.hasHealth())
			{
				pMain.addNutritionFromEating(10);
			}
			else
			{
				pMain.addNutritionFromEating(100, pSetMaxNutrition: true, pSetJustAte: true);
				pMain.countConsumed();
			}
		}
		pTarget.cancelAllBeh();
	}
}
// --- End of File: BehConsumeActorsBloodTarget.cs ---



// --- Start of File: BehConsumeActorTarget.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehConsumeActorTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Actor a = pActor.beh_actor_target.a;
		if (Toolbox.DistTile(pActor.current_tile, a.current_tile) > 1f)
		{
			return BehResult.StepBack;
		}
		consume(pActor, a);
		if (a.hasHealth())
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}

	private void consume(Actor pMain, Actor pTarget)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		pMain.timer_action = 0.3f;
		if (pMain.current_position.x > pTarget.current_position.x)
		{
			if (pTarget.target_angle.z > -45f)
			{
				pTarget.target_angle.z -= BehaviourActionBase<Actor>.world.elapsed * 100f;
				if (pTarget.target_angle.z < -90f)
				{
					pTarget.target_angle.z = -90f;
				}
				pTarget.rotation_cooldown = 1f;
			}
		}
		else if (pTarget.target_angle.z < 45f)
		{
			pTarget.target_angle.z += BehaviourActionBase<Actor>.world.elapsed * 100f;
			pTarget.rotation_cooldown = 1f;
		}
		if (pTarget.hasTrait("poisonous"))
		{
			pMain.addStatusEffect("poisoned");
		}
		if (pMain.target_angle.z == 0f)
		{
			pMain.punchTargetAnimation(Vector2.op_Implicit(pTarget.current_position), pFlip: false);
			int num = (int)((float)pTarget.getMaxHealth() * 0.15f) + 1;
			Clan clan = pTarget.clan;
			pTarget.getHit(num, pFlash: true, AttackType.Eaten, pMain, pSkipIfShake: false);
			pTarget.startShake(0.2f);
			if (pTarget.hasHealth())
			{
				pMain.addNutritionFromEating(num);
			}
			else
			{
				pMain.addNutritionFromEating(100, pSetMaxNutrition: true, pSetJustAte: true);
				pMain.countConsumed();
				AchievementLibrary.clannibals.checkBySignal((pMain, clan));
			}
		}
		pTarget.cancelAllBeh();
	}
}
// --- End of File: BehConsumeActorTarget.cs ---



// --- Start of File: BehConsumeGrass.cs ---
namespace ai.behaviours;

public class BehConsumeGrass : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		WorldTile beh_tile_target = pActor.beh_tile_target;
		if (!beh_tile_target.Type.grass)
		{
			return BehResult.Stop;
		}
		pActor.punchTargetAnimation(beh_tile_target.posV3, pFlip: false);
		pActor.consumeTopTile(beh_tile_target);
		return BehResult.Continue;
	}
}
// --- End of File: BehConsumeGrass.cs ---



// --- Start of File: BehConsumeTargetBuilding.cs ---
namespace ai.behaviours;

public class BehConsumeTargetBuilding : BehActorUsableBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (pActor.beh_building_target.asset.type == "type_fruits")
		{
			if (pActor.beh_building_target.hasResourcesToCollect())
			{
				pActor.beh_building_target.extractResources(pActor);
				pActor.addNutritionFromEating(pActor.beh_building_target.asset.nutrition_restore, pSetMaxNutrition: false, pSetJustAte: true);
				pActor.countConsumed();
			}
		}
		else if (pActor.beh_building_target.isAlive())
		{
			pActor.beh_building_target.startDestroyBuilding();
			pActor.addNutritionFromEating(pActor.beh_building_target.asset.nutrition_restore, pSetMaxNutrition: false, pSetJustAte: true);
			pActor.countConsumed();
		}
		WorldTile current_tile = pActor.beh_building_target.current_tile;
		pActor.punchTargetAnimation(current_tile.posV3, pFlip: false);
		return BehResult.Continue;
	}
}
// --- End of File: BehConsumeTargetBuilding.cs ---



// --- Start of File: BehConsumeTargetTile.cs ---
namespace ai.behaviours;

public class BehConsumeTargetTile : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		WorldTile beh_tile_target = pActor.beh_tile_target;
		if (!beh_tile_target.Type.canBeEatenByGeophag())
		{
			return BehResult.Stop;
		}
		pActor.punchTargetAnimation(beh_tile_target.posV3, pFlip: false);
		pActor.consumeTopTile(beh_tile_target);
		MapAction.terraformMain(beh_tile_target, TileLibrary.pit_deep_ocean, TerraformLibrary.destroy_no_flash);
		return BehResult.Continue;
	}
}
// --- End of File: BehConsumeTargetTile.cs ---



// --- Start of File: BehCopyAggro.cs ---
using ai.behaviours;

public class BehCopyAggro : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Actor actor = pActor.beh_actor_target?.a;
		if (actor == null)
		{
			return BehResult.Continue;
		}
		pActor.copyAggroFrom(actor);
		copyEnemiesOf(pActor, actor);
		return BehResult.Continue;
	}

	private void copyEnemiesOf(Actor pCopyTo, Actor pTarget)
	{
		foreach (Actor item in Finder.getUnitsFromChunk(pTarget.current_tile, 1, 0f, pRandom: true))
		{
			if (item != pCopyTo && item.isInAggroList(pTarget) && pCopyTo.isSameIslandAs(item))
			{
				pCopyTo.addAggro(item);
			}
		}
	}
}
// --- End of File: BehCopyAggro.cs ---



// --- Start of File: BehCrabBurrow.cs ---
namespace ai.behaviours;

public class BehCrabBurrow : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		force_animation = true;
		force_animation_id = "burrow";
		special_prevent_can_be_attacked = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.isHungry())
		{
			pActor.endJob();
			return BehResult.Stop;
		}
		if (!Toolbox.hasDifferentSpeciesInChunkAround(pActor.current_tile, pActor.asset.id))
		{
			pActor.endJob();
			return BehResult.Stop;
		}
		pActor.timer_action = Randy.randomFloat(10f, 20f);
		return BehResult.RepeatStep;
	}
}
// --- End of File: BehCrabBurrow.cs ---



// --- Start of File: BehDealDamageToTargetBuilding.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehDealDamageToTargetBuilding : BehaviourActionActor
{
	private const float DAMAGE_MULTIPLIER = 0.1f;

	private float _min;

	private float _max;

	public BehDealDamageToTargetBuilding(float pMinMultiplier, float pMaxMultiplier)
	{
		_min = pMinMultiplier;
		_max = pMaxMultiplier;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Building beh_building_target = pActor.beh_building_target;
		float num = Randy.randomFloat(_min, _max);
		if (num <= 0f)
		{
			return BehResult.Continue;
		}
		int num2 = (int)Mathf.Max(pActor.stats["damage"] * num, 1f);
		beh_building_target.getHit(num2);
		pActor.spawnSlash(beh_building_target.current_position);
		return BehResult.Continue;
	}
}
// --- End of File: BehDealDamageToTargetBuilding.cs ---



// --- Start of File: BehDecideWhereToPoop.cs ---
using ai.behaviours;

public class BehDecideWhereToPoop : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isAdult() && pActor.hasHouseCityInBordersAndSameIsland())
		{
			return forceTask(pActor, "poop_inside", pClean: false, pForceAction: true);
		}
		return forceTask(pActor, "poop_outside", pClean: false, pForceAction: true);
	}
}
// --- End of File: BehDecideWhereToPoop.cs ---



// --- Start of File: BehDecideWhereToSleep.cs ---
using ai.behaviours;

public class BehDecideWhereToSleep : BehaviourActionActor
{
	public override BehResult execute(Actor pObject)
	{
		if (pObject.hasHouseCityInBordersAndSameIsland())
		{
			return forceTask(pObject, "sleep_inside", pClean: false, pForceAction: true);
		}
		return forceTask(pObject, "sleep_outside", pClean: false, pForceAction: true);
	}
}
// --- End of File: BehDecideWhereToSleep.cs ---



// --- Start of File: BehDoTalk.cs ---
using UnityEngine;
using ai.behaviours;

public class BehDoTalk : BehaviourActionActor
{
	public BehDoTalk()
	{
		socialize = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Actor actor = pActor.beh_actor_target?.a;
		if (actor == null)
		{
			return BehResult.Stop;
		}
		if (!stillCanTalk(actor))
		{
			return BehResult.Stop;
		}
		if ((!pActor.hasTelepathicLink() || !actor.hasTelepathicLink()) && (float)Toolbox.SquaredDistTile(actor.current_tile, pActor.current_tile) > 16f)
		{
			return BehResult.Stop;
		}
		pActor.data.get("socialize", out var pResult, 0);
		int num = Randy.randomInt(5, 10);
		if (pResult > num)
		{
			return BehResult.Continue;
		}
		continueTalk(pActor, actor);
		return BehResult.RepeatStep;
	}

	private bool stillCanTalk(Actor pTarget)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isLying())
		{
			return false;
		}
		return true;
	}

	private void continueTalk(Actor pActor, Actor pTarget)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		pActor.data.get("socialize", out var pResult, 0);
		pActor.data.set("socialize", ++pResult);
		bool flag = false;
		if (Randy.randomChance(0.4f))
		{
			pActor.clearLastTopicSprite();
			flag = true;
		}
		else if (Randy.randomChance(0.4f))
		{
			pTarget.clearLastTopicSprite();
			flag = true;
		}
		if (!flag && (Object)(object)pTarget.getTopicSpriteTrait() != (Object)null && Randy.randomChance(0.45f))
		{
			pActor.cloneTopicSprite(pTarget.getSocializeTopic());
		}
		pActor.lookTowardsPosition(pTarget.current_position);
		pTarget.lookTowardsPosition(pActor.current_position);
		pTarget.setTask("socialize_receiving", pClean: true, pCleanJob: false, pForceAction: true);
		float num = 10f;
		if (Randy.randomBool())
		{
			pActor.playIdleSound();
		}
		else
		{
			pTarget.playIdleSound();
		}
		pActor.setTargetAngleZ(Randy.randomFloat(0f - num, num));
		pTarget.setTargetAngleZ(Randy.randomFloat(0f - num, num));
		pTarget.timer_action = (pActor.timer_action = Randy.randomFloat(1.1f, 3.3f));
		if (pActor.timestamp_tween_session_social == 0.0)
		{
			pActor.timestamp_tween_session_social = BehaviourActionBase<Actor>.world.getCurSessionTime();
			pTarget.timestamp_tween_session_social = BehaviourActionBase<Actor>.world.getCurSessionTime();
		}
	}
}
// --- End of File: BehDoTalk.cs ---



// --- Start of File: BehDragon.cs ---
namespace ai.behaviours;

public class BehDragon : BehaviourActionActor
{
	internal Dragon dragon;

	public override void prepare(Actor pActor)
	{
		base.prepare(pActor);
		dragon = pActor.children_special[0] as Dragon;
	}
}
// --- End of File: BehDragon.cs ---



// --- Start of File: BehDragonCantLand.cs ---
namespace ai.behaviours;

public class BehDragonCantLand : BehaviourActionActor
{
	private string task_id;

	public BehDragonCantLand(string pNextAction)
	{
		task_id = pNextAction;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!Dragon.canLand(pActor))
		{
			return forceTask(pActor, task_id);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCantLand.cs ---



// --- Start of File: BehDragonCheckAttackCity.cs ---
namespace ai.behaviours;

public class BehDragonCheckAttackCity : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_tile_target != null)
		{
			return BehResult.Continue;
		}
		pActor.data.get("cityToAttack", out var pResult, -1L);
		if (!pResult.hasValue())
		{
			return BehResult.Continue;
		}
		pActor.data.get("attacksForCity", out var pResult2, 0);
		if (pResult2 < 1)
		{
			pActor.data.removeLong("cityToAttack");
			return BehResult.Continue;
		}
		City city = BehaviourActionBase<Actor>.world.cities.get(pResult);
		bool flag = true;
		if (city != null && city.isAlive() && city.buildings.Count > 0)
		{
			WorldTile random = city.buildings.GetRandom().current_tile.zone.tiles.GetRandom();
			pActor.beh_tile_target = dragon.randomTileWithinLandAttackRange(random);
			pActor.data.set("attacksForCity", --pResult2);
			flag = false;
		}
		if (flag)
		{
			pActor.data.removeLong("cityToAttack");
			pActor.data.removeInt("attacksForCity");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCheckAttackCity.cs ---



// --- Start of File: BehDragonCheckAttackTargetAlive.cs ---
namespace ai.behaviours;

public class BehDragonCheckAttackTargetAlive : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (dragon.aggroTargets.Count == 0)
		{
			return BehResult.Continue;
		}
		dragon.aggroTargets.RemoveWhere((Actor tAttacker) => tAttacker == null || !tAttacker.isAlive());
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCheckAttackTargetAlive.cs ---



// --- Start of File: BehDragonCheckAttackTile.cs ---
namespace ai.behaviours;

public class BehDragonCheckAttackTile : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (dragon.aggroTargets.Count == 0)
		{
			return BehResult.Continue;
		}
		Actor closestActor = Toolbox.getClosestActor(dragon.aggroTargets, pActor.current_tile);
		if (closestActor != null && closestActor.data != null && closestActor.isAlive() && closestActor.current_tile != null)
		{
			pActor.beh_tile_target = dragon.randomTileWithinLandAttackRange(closestActor.current_tile);
			if (pActor.current_tile != dragon.lastLanded && dragon.landAttackRange(closestActor.current_tile) && Dragon.canLand(pActor))
			{
				return forceTask(pActor, "dragon_land");
			}
		}
		if (pActor.isFlying())
		{
			foreach (Actor aggroTarget in dragon.aggroTargets)
			{
				if (aggroTarget != null && aggroTarget.isAlive() && dragon.targetWithinSlide(aggroTarget.current_tile))
				{
					return forceTask(pActor, "dragon_slide");
				}
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCheckAttackTile.cs ---



// --- Start of File: BehDragonCheckOverTargetActor.cs ---
namespace ai.behaviours;

public class BehDragonCheckOverTargetActor : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (WorldLawLibrary.world_law_peaceful_monsters.isEnabled())
		{
			return BehResult.Continue;
		}
		if (dragon.aggroTargets.Count == 0)
		{
			return BehResult.Continue;
		}
		if (!Dragon.canLand(pActor))
		{
			return BehResult.Continue;
		}
		if (dragon.targetsWithinLandAttackRange())
		{
			return forceTask(pActor, "dragon_land_attack");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCheckOverTargetActor.cs ---



// --- Start of File: BehDragonCheckOverTargetCity.cs ---
namespace ai.behaviours;

public class BehDragonCheckOverTargetCity : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (WorldLawLibrary.world_law_peaceful_monsters.isEnabled())
		{
			return BehResult.Continue;
		}
		pActor.data.get("attacksForCity", out var pResult, 0);
		if (pResult == 0)
		{
			return BehResult.Continue;
		}
		pActor.data.get("cityToAttack", out var pResult2, -1L);
		if ((pResult2.hasValue() ? BehaviourActionBase<Actor>.world.cities.get(pResult2) : null) == null)
		{
			return BehResult.Continue;
		}
		if (Randy.randomChance(0.8f))
		{
			return BehResult.Continue;
		}
		if (pActor.isFlying() && !Dragon.canLand(pActor) && dragon.hasTargetsForSlide() && Randy.randomBool())
		{
			pActor.data.set("attacksForCity", --pResult);
			return forceTask(pActor, "dragon_slide");
		}
		if (!pActor.isFlying() && Dragon.canLand(pActor))
		{
			pActor.data.set("attacksForCity", --pResult);
			return forceTask(pActor, "dragon_land_attack");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonCheckOverTargetCity.cs ---



// --- Start of File: BehDragonFindRandomTile.cs ---
using System;
using UnityEngine;

namespace ai.behaviours;

public class BehDragonFindRandomTile : BehaviourActionActor
{
	public unsafe override BehResult execute(Actor pActor)
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (pActor.beh_tile_target != null)
		{
			return BehResult.Continue;
		}
		WorldTile worldTile = Toolbox.getRandomTileWithinDistance(pActor.current_tile, 100);
		if (!BehaviourActionBase<Actor>.world.islands_calculator.hasGround())
		{
			pActor.beh_tile_target = worldTile;
			return BehResult.Continue;
		}
		int num = 5;
		while (!worldTile.Type.ground && !worldTile.Type.lava && num > 0)
		{
			worldTile = Toolbox.getRandomTileWithinDistance(pActor.current_tile, 100);
			num--;
		}
		if (!worldTile.Type.ground && !worldTile.Type.lava && BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandGround() != null)
		{
			Span<Vector2Int> pArray = new Span<Vector2Int>(stackalloc Vector2Int[8], 8);
			for (int i = 0; i < 8; i++)
			{
				pArray[i] = BehaviourActionBase<Actor>.world.islands_calculator.tryGetRandomGround().pos;
			}
			Vector2Int closestTile = Toolbox.getClosestTile(pArray, pActor.current_tile);
			worldTile = BehaviourActionBase<Actor>.world.GetTileSimple(((Vector2Int)(ref closestTile)).x, ((Vector2Int)(ref closestTile)).y);
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonFindRandomTile.cs ---



// --- Start of File: BehDragonFinishAnimation.cs ---
namespace ai.behaviours;

public class BehDragonFinishAnimation : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.flipAnimationActive())
		{
			return BehResult.RepeatStep;
		}
		SpriteAnimation spriteAnimation = dragon.spriteAnimation;
		if (spriteAnimation.currentFrameIndex < spriteAnimation.frames.Length - 1)
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonFinishAnimation.cs ---



// --- Start of File: BehDragonFlyUp.cs ---
namespace ai.behaviours;

public class BehDragonFlyUp : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.set("landAttacks", 0);
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonFlyUp.cs ---



// --- Start of File: BehDragonIdle.cs ---
namespace ai.behaviours;

public class BehDragonIdle : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (dragon.aggroTargets.Count > 0)
		{
			return BehResult.Continue;
		}
		if (dragon.idle_time == -1f)
		{
			dragon.idle_time = Randy.randomFloat(1f, 3f);
		}
		dragon.idle_time -= BehaviourActionBase<Actor>.world.elapsed;
		if (dragon.idle_time > 0f)
		{
			return BehResult.RepeatStep;
		}
		dragon.idle_time = -1f;
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonIdle.cs ---



// --- Start of File: BehDragonLandAttack.cs ---
namespace ai.behaviours;

public class BehDragonLandAttack : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		SpriteAnimation spriteAnimation = dragon.spriteAnimation;
		if (spriteAnimation.currentFrameIndex == 4)
		{
			pActor.data.set("shouldAttack", pData: true);
		}
		if (spriteAnimation.currentFrameIndex == 5)
		{
			pActor.data.get("shouldAttack", out var pResult, pDefault: false);
			if (pResult)
			{
				pActor.data.removeBool("shouldAttack");
				foreach (WorldTile item in dragon.landAttackTiles(pActor.current_tile))
				{
					if (item != null && (item.hasUnits() || !Randy.randomBool()))
					{
						dragon.attackTile(item);
					}
				}
				pActor.data.get("landAttacks", out var pResult2, 0);
				pActor.data.set("landAttacks", ++pResult2);
			}
		}
		if (spriteAnimation.currentFrameIndex < spriteAnimation.frames.Length - 1)
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonLandAttack.cs ---



// --- Start of File: BehDragonLanded.cs ---
namespace ai.behaviours;

public class BehDragonLanded : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		dragon.lastLanded = pActor.current_tile;
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonLanded.cs ---



// --- Start of File: BehDragonSetAnimation.cs ---
namespace ai.behaviours;

public class BehDragonSetAnimation : BehDragon
{
	private DragonState state;

	private bool looped;

	private bool forceRestart;

	public BehDragonSetAnimation(DragonState pState, bool pLooped = true, bool pForceRestart = true)
	{
		state = pState;
		looped = pLooped;
		forceRestart = pForceRestart;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.flipAnimationActive())
		{
			return BehResult.RepeatStep;
		}
		SpriteAnimation spriteAnimation = dragon.spriteAnimation;
		dragon.setFrames(state, forceRestart);
		spriteAnimation.looped = looped;
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonSetAnimation.cs ---



// --- Start of File: BehDragonSleep.cs ---
namespace ai.behaviours;

public class BehDragonSleep : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		pActor.setFlip(pFlip: false);
		pActor.data.set("sleepy", 0);
		if (dragon.sleep_time == -1f)
		{
			dragon.sleep_time = Randy.randomFloat(10f, 80f);
		}
		dragon.sleep_time -= BehaviourActionBase<Actor>.world.elapsed;
		if (!pActor.hasMaxHealth() && Randy.randomChance(0.1f))
		{
			pActor.restoreHealth(1);
		}
		if (dragon.sleep_time > 0f)
		{
			return BehResult.RepeatStep;
		}
		dragon.sleep_time = -1f;
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonSleep.cs ---



// --- Start of File: BehDragonSleepy.cs ---
namespace ai.behaviours;

public class BehDragonSleepy : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasTrait("zombie"))
		{
			return BehResult.Continue;
		}
		pActor.data.get("sleepy", out var pResult, 0);
		pActor.data.set("sleepy", ++pResult);
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonSleepy.cs ---



// --- Start of File: BehDragonSlide.cs ---
namespace ai.behaviours;

public class BehDragonSlide : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		SpriteAnimation spriteAnimation = dragon.spriteAnimation;
		if (spriteAnimation.currentFrameIndex == 7)
		{
			foreach (WorldTile item in dragon.attackRange(pActor.flip))
			{
				if (item != null && (item.hasUnits() || !Randy.randomBool()))
				{
					dragon.attackTile(item);
				}
			}
		}
		if (spriteAnimation.currentFrameIndex < spriteAnimation.frames.Length - 1)
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonSlide.cs ---



// --- Start of File: BehDragonZombieFindGoldenBrain.cs ---
namespace ai.behaviours;

public class BehDragonZombieFindGoldenBrain : BehDragon
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasTrait("zombie"))
		{
			return BehResult.Continue;
		}
		if (dragon.aggroTargets.Count > 0)
		{
			return BehResult.Continue;
		}
		pActor.data.get("cityToAttack", out var pResult, -1L);
		if (pResult.hasValue())
		{
			return BehResult.Continue;
		}
		if (BehaviourActionBase<Actor>.world.kingdoms_wild.get("golden_brain").hasBuildings())
		{
			float num = 0f;
			float num2 = 0f;
			WorldTile worldTile = null;
			foreach (Building building in BehaviourActionBase<Actor>.world.kingdoms_wild.get("golden_brain").buildings)
			{
				num = Toolbox.DistTile(building.current_tile, pActor.current_tile);
				if (worldTile == null || num < num2)
				{
					worldTile = building.current_tile;
					num2 = num;
				}
			}
			if (worldTile != null)
			{
				if (dragon.landAttackRange(worldTile))
				{
					return forceTask(pActor, "dragon_land");
				}
				pActor.beh_tile_target = dragon.randomTileWithinLandAttackRange(worldTile);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehDragonZombieFindGoldenBrain.cs ---



// --- Start of File: BehEndJob.cs ---
namespace ai.behaviours;

public class BehEndJob : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.endJob();
		return BehResult.Continue;
	}
}
// --- End of File: BehEndJob.cs ---



// --- Start of File: BehExitBuilding.cs ---
namespace ai.behaviours;

public class BehExitBuilding : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_building_target = true;
		check_building_target_non_usable = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.exitBuilding();
		pActor.beh_building_target.startShake(0.01f);
		return BehResult.Continue;
	}
}
// --- End of File: BehExitBuilding.cs ---



// --- Start of File: BehExtractResourcesFromBuilding.cs ---
namespace ai.behaviours;

public class BehExtractResourcesFromBuilding : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_building_target = true;
		check_building_target_non_usable = true;
	}

	public override BehResult execute(Actor pActor)
	{
		BuildingAsset asset = pActor.beh_building_target.asset;
		pActor.beh_building_target.extractResources(pActor);
		if (asset.resources_given != null)
		{
			foreach (ResourceContainer item in asset.resources_given)
			{
				int num = item.amount;
				if (asset.building_type == BuildingType.Building_Mineral && pActor.hasTrait("miner") && Randy.randomBool())
				{
					num++;
				}
				pActor.addToInventory(item.id, num);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehExtractResourcesFromBuilding.cs ---



// --- Start of File: BehFamilyAlphaMove.cs ---
namespace ai.behaviours;

public class BehFamilyAlphaMove : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		WorldTile worldTile = null;
		if (pActor.isHerbivore())
		{
			worldTile = findTileForHerbivore(pActor);
		}
		else if (pActor.isCarnivore())
		{
			worldTile = findTileForCarnivore(pActor);
		}
		if (worldTile != null)
		{
			worldTile = worldTile.region.tiles.GetRandom();
		}
		if (worldTile == null)
		{
			return forceTask(pActor, "random_move");
		}
		pActor.beh_tile_target = worldTile.region.tiles.GetRandom();
		return BehResult.Continue;
	}

	private Building getNearbyBuildings(WorldTile pTile)
	{
		float num = float.MaxValue;
		Building result = null;
		foreach (Building item in Finder.getBuildingsFromChunk(pTile, 3, 0, pRandom: true))
		{
			float num2 = Toolbox.SquaredDistTile(item.current_tile, pTile);
			if (!(num2 >= num) && item.asset.flora && item.current_tile.isSameIsland(pTile))
			{
				result = item;
				num = num2;
				if (num < 25f)
				{
					return result;
				}
			}
		}
		return result;
	}

	private Actor getNearbyActor(Actor pActor, WorldTile pTile)
	{
		float num = float.MaxValue;
		Actor result = null;
		foreach (Actor item in Finder.getUnitsFromChunk(pTile, 3, 0f, pRandom: true))
		{
			float num2 = Toolbox.SquaredDistTile(item.current_tile, pTile);
			if (!(num2 >= num) && item.family != pActor.family && !item.isSameSpecies(pActor) && item.current_tile.isSameIsland(pTile) && item.asset.source_meat)
			{
				result = item;
				num = num2;
				if (num < 5f)
				{
					return result;
				}
			}
		}
		return result;
	}

	private WorldTile findTileForHerbivore(Actor pActor)
	{
		return getNearbyBuildings(pActor.current_tile)?.current_tile.region.tiles.GetRandom();
	}

	private WorldTile findTileForCarnivore(Actor pActor)
	{
		WorldTile current_tile = pActor.current_tile;
		Actor nearbyActor = getNearbyActor(pActor, current_tile);
		if (nearbyActor != null)
		{
			return nearbyActor.current_tile.region.tiles.GetRandom();
		}
		if (nearbyActor == null)
		{
			return current_tile.region.island.getRandomTile();
		}
		return null;
	}
}
// --- End of File: BehFamilyAlphaMove.cs ---



// --- Start of File: BehFamilyCheckMembers.cs ---
using ai.behaviours;

public class BehFamilyCheckMembers : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.family.countUnits() > 1)
		{
			return BehResult.Stop;
		}
		pActor.setFamily(null);
		return BehResult.Continue;
	}
}
// --- End of File: BehFamilyCheckMembers.cs ---



// --- Start of File: BehFamilyFollowAlpha.cs ---
namespace ai.behaviours;

public class BehFamilyFollowAlpha : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasFamily())
		{
			return BehResult.Stop;
		}
		if (pActor.family.isAlpha(pActor))
		{
			return BehResult.Stop;
		}
		pActor.family.checkAlpha();
		Actor actor = pActor.family.getAlpha();
		if (pActor.family.isAlpha(pActor))
		{
			return BehResult.Stop;
		}
		if (actor != null && !actor.current_tile.isSameIsland(pActor.current_tile))
		{
			actor = null;
		}
		if (actor == null)
		{
			return BehResult.Stop;
		}
		if (pActor.distanceToObjectTarget(actor) > 400f)
		{
			return BehResult.Stop;
		}
		pActor.beh_actor_target = actor;
		return BehResult.Continue;
	}
}
// --- End of File: BehFamilyFollowAlpha.cs ---



// --- Start of File: BehFamilyGroupJoin.cs ---
namespace ai.behaviours;

public class BehFamilyGroupJoin : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasFamily())
		{
			return BehResult.Stop;
		}
		Family nearbyFamily = BehaviourActionBase<Actor>.world.families.getNearbyFamily(pActor.asset, pActor.current_tile);
		if (nearbyFamily != null)
		{
			pActor.setFamily(nearbyFamily);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFamilyGroupJoin.cs ---



// --- Start of File: BehFamilyGroupLeave.cs ---
namespace ai.behaviours;

public class BehFamilyGroupLeave : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasFamily())
		{
			return BehResult.Stop;
		}
		if (!pActor.family.isFull())
		{
			return BehResult.Stop;
		}
		pActor.setFamily(null);
		return BehResult.Continue;
	}
}
// --- End of File: BehFamilyGroupLeave.cs ---



// --- Start of File: BehFamilyGroupNew.cs ---
namespace ai.behaviours;

public class BehFamilyGroupNew : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasFamily())
		{
			return BehResult.Stop;
		}
		Actor nearbySameSpecies = getNearbySameSpecies(pActor, pActor.asset, pActor.current_tile);
		if (nearbySameSpecies == null)
		{
			return BehResult.Stop;
		}
		BehaviourActionBase<Actor>.world.families.newFamily(pActor, pActor.current_tile, nearbySameSpecies);
		return BehResult.Continue;
	}

	public Actor getNearbySameSpecies(Actor pActor, ActorAsset pUnitAsset, WorldTile pTile)
	{
		foreach (Actor item in Finder.getUnitsFromChunk(pTile, 4, pUnitAsset.family_spawn_radius, pRandom: true))
		{
			if (item != pActor && item.current_tile.isSameIsland(pTile) && !item.hasFamily() && item.isSameSpecies(pUnitAsset.id) && item.isSameSubspecies(pActor.subspecies))
			{
				return item;
			}
		}
		return null;
	}
}
// --- End of File: BehFamilyGroupNew.cs ---



// --- Start of File: BehFightCheckEnemyIsOk.cs ---
namespace ai.behaviours;

public class BehFightCheckEnemyIsOk : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.has_attack_target)
		{
			return BehResult.Stop;
		}
		if (!pActor.isEnemyTargetAlive())
		{
			return BehResult.Stop;
		}
		if (!pActor.shouldContinueToAttackTarget())
		{
			pActor.clearAttackTarget();
			return BehResult.Stop;
		}
		if (!pActor.canAttackTarget(pActor.attack_target))
		{
			pActor.ignoreTarget(pActor.attack_target);
			pActor.clearAttackTarget();
			return BehResult.Stop;
		}
		if (!pActor.isInAttackRange(pActor.attack_target))
		{
			if (pActor.isWaterCreature())
			{
				if ((!pActor.attack_target.isInLiquid() && !pActor.asset.force_land_creature) || pActor.attack_target.isFlying())
				{
					pActor.ignoreTarget(pActor.attack_target);
					pActor.clearAttackTarget();
					return BehResult.Stop;
				}
			}
			else if ((pActor.attack_target.isInLiquid() && !pActor.isWaterCreature()) || pActor.attack_target.isFlying())
			{
				pActor.ignoreTarget(pActor.attack_target);
				pActor.clearAttackTarget();
				return BehResult.Stop;
			}
		}
		int x = pActor.chunk.x;
		int y = pActor.chunk.y;
		int x2 = pActor.attack_target.chunk.x;
		int y2 = pActor.attack_target.chunk.y;
		float num = 1f;
		if (Toolbox.Dist(x, y, x2, y2) >= (float)SimGlobals.m.unit_chunk_sight_range + num)
		{
			pActor.clearAttackTarget();
			return BehResult.Stop;
		}
		pActor.beh_actor_target = pActor.attack_target;
		return BehResult.Continue;
	}
}
// --- End of File: BehFightCheckEnemyIsOk.cs ---



// --- Start of File: BehFindBuilding.cs ---
namespace ai.behaviours;

public class BehFindBuilding : BehaviourActionActor
{
	private readonly bool _only_non_targeted;

	private readonly bool _only_with_resources;

	private readonly string _type;

	public BehFindBuilding(string pType, bool pOnlyNonTargeted, bool pOnlyWithResources)
	{
		_type = pType;
		_only_non_targeted = pOnlyNonTargeted;
		_only_with_resources = pOnlyWithResources;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.beh_building_target = findBuildingType(pActor, _type);
		if (pActor.beh_building_target != null)
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}

	private Building findBuildingType(Actor pActor, string pType)
	{
		Building result = null;
		var (array, pLength) = Toolbox.getAllChunksFromTile(pActor.current_tile);
		foreach (MapChunk item in array.LoopRandom(pLength))
		{
			foreach (Building item2 in Toolbox.getBuildingsTypeFromChunk(item, pType, _only_non_targeted, _only_with_resources))
			{
				if (item2.current_tile.isSameIsland(pActor.current_tile))
				{
					return item2;
				}
				result = item2;
			}
		}
		return result;
	}
}
// --- End of File: BehFindBuilding.cs ---



// --- Start of File: BehFindBuildingWithFood.cs ---
namespace ai.behaviours;

public class BehFindBuildingWithFood : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		Building storageWithFoodNear = pActor.city.getStorageWithFoodNear(pActor.current_tile);
		if (storageWithFoodNear != null)
		{
			pActor.beh_building_target = storageWithFoodNear;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehFindBuildingWithFood.cs ---



// --- Start of File: BehFindConstructionTile.cs ---
namespace ai.behaviours;

public class BehFindConstructionTile : BehActorBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		pActor.beh_tile_target = pActor.beh_building_target.getConstructionTile();
		return BehResult.Continue;
	}
}
// --- End of File: BehFindConstructionTile.cs ---



// --- Start of File: BehFindDesireWaypoint.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFindDesireWaypoint : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		string building_attractor_id = pActor.kingdom.asset.building_attractor_id;
		if (string.IsNullOrEmpty(building_attractor_id))
		{
			return BehResult.Stop;
		}
		BuildingAsset buildingAsset = AssetManager.buildings.get(building_attractor_id);
		if (buildingAsset == null)
		{
			return BehResult.Stop;
		}
		HashSet<Building> buildings = buildingAsset.buildings;
		if (buildings.Count == 0)
		{
			return BehResult.Stop;
		}
		Building closestBuildingFrom = Finder.getClosestBuildingFrom(pActor, buildings);
		if (closestBuildingFrom == null)
		{
			return BehResult.Stop;
		}
		if (Toolbox.DistTile(pActor.current_tile, closestBuildingFrom.current_tile) < 10f)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = closestBuildingFrom;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindDesireWaypoint.cs ---



// --- Start of File: BehFindFarmField.cs ---
namespace ai.behaviours;

public class BehFindFarmField : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.city.calculated_grown_wheat.Count > 0)
		{
			return BehResult.Stop;
		}
		int num = int.MaxValue;
		WorldTile worldTile = null;
		WorldTile current_tile = pActor.current_tile;
		WorldTileContainer calculated_farm_fields = pActor.city.calculated_farm_fields;
		calculated_farm_fields.checkAddRemove();
		foreach (WorldTile item in calculated_farm_fields)
		{
			int num2 = Toolbox.SquaredDistTile(current_tile, item);
			if (num2 < num && item.Type.farm_field && !item.isTargeted() && current_tile.isSameIsland(item) && (!item.hasBuilding() || (item.building.canRemoveForFarms() && !item.building.asset.wheat)))
			{
				num = num2;
				worldTile = item;
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindFarmField.cs ---



// --- Start of File: BehFindGoldenBrain.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFindGoldenBrain : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (WorldLawLibrary.world_law_peaceful_monsters.isEnabled())
		{
			return BehResult.Stop;
		}
		List<Building> buildings = BehaviourActionBase<Actor>.world.kingdoms_wild.get("golden_brain").buildings;
		if (buildings.Count == 0)
		{
			return BehResult.Stop;
		}
		Building closestBuildingFrom = Finder.getClosestBuildingFrom(pActor, buildings);
		if (closestBuildingFrom == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_building_target = closestBuildingFrom;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindGoldenBrain.cs ---



// --- Start of File: BehFindHouse.cs ---
using ai.behaviours;

public class BehFindHouse : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasHouse())
		{
			return BehResult.Stop;
		}
		Building building = null;
		foreach (Building building2 in pActor.city.buildings)
		{
			if (!building2.isUnderConstruction() && building2.hasResidentSlots())
			{
				building = building2;
				break;
			}
		}
		if (building == null)
		{
			building = tryToFindFamilyHouse(pActor);
		}
		if (building == null)
		{
			return BehResult.Stop;
		}
		pActor.setHomeBuilding(building);
		pActor.changeHappiness("just_found_house", building.asset.housing_happiness);
		return BehResult.Continue;
	}

	private static Building tryToFindFamilyHouse(Actor pActor)
	{
		if (!pActor.hasFamily())
		{
			return null;
		}
		int num = 0;
		Family family = pActor.family;
		foreach (Actor item in pActor.family.units.LoopRandom())
		{
			if (item == pActor)
			{
				continue;
			}
			if (++num > 5)
			{
				break;
			}
			if (item.hasHouse() && item.city == pActor.city)
			{
				Building building = checkBuilding(item.home_building, family);
				if (building != null)
				{
					return building;
				}
			}
		}
		return null;
	}

	private static Building checkBuilding(Building pGetHomeBuilding, Family pFamily)
	{
		foreach (long resident in pGetHomeBuilding.residents)
		{
			Actor actor = BehaviourActionBase<Actor>.world.units.get(resident);
			if (actor != null && actor.isAlive() && actor.family == pFamily)
			{
				actor.clearHomeBuilding();
				return pGetHomeBuilding;
			}
		}
		return null;
	}
}
// --- End of File: BehFindHouse.cs ---



// --- Start of File: BehFindLover.cs ---
using ai.behaviours;

public class BehFindLover : BehaviourActionActor
{
	public override bool shouldRetry(Actor pActor)
	{
		if (pActor.hasCity() && BehaviourActionBase<Actor>.world.cities.isLocked())
		{
			return true;
		}
		return base.shouldRetry(pActor);
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasLover())
		{
			return BehResult.Stop;
		}
		Actor actor = findLoverAround(pActor);
		if (actor == null)
		{
			actor = checkCityLovers(pActor);
		}
		if (actor != null)
		{
			pActor.becomeLoversWith(actor);
		}
		return BehResult.Continue;
	}

	private Actor findLoverAround(Actor pActor)
	{
		Actor result = null;
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, 1))
		{
			if (checkIfPossibleLover(pActor, item))
			{
				result = item;
				break;
			}
		}
		return result;
	}

	private bool checkIfPossibleLover(Actor pActor, Actor pTarget)
	{
		if (pTarget == pActor)
		{
			return false;
		}
		if (!pTarget.hasSubspecies())
		{
			return false;
		}
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (!pTarget.canFallInLoveWith(pActor))
		{
			return false;
		}
		return true;
	}

	private Actor checkCityLovers(Actor pActor)
	{
		if (!pActor.hasCity())
		{
			return null;
		}
		Actor result = null;
		foreach (Actor item in pActor.city.getUnits().LoopRandom())
		{
			if (checkIfPossibleLover(pActor, item) && item.inOwnCityBorders())
			{
				result = item;
				break;
			}
		}
		return result;
	}
}
// --- End of File: BehFindLover.cs ---



// --- Start of File: BehFindMeatInsectSource.cs ---
namespace ai.behaviours;

public class BehFindMeatInsectSource : BehFindMeatSource
{
	public BehFindMeatInsectSource(bool pCheckForFactions = true)
		: base(MeatTargetType.Insect, pCheckForFactions)
	{
	}
}
// --- End of File: BehFindMeatInsectSource.cs ---



// --- Start of File: BehFindMeatSameSpeciesSource.cs ---
namespace ai.behaviours;

public class BehFindMeatSameSpeciesSource : BehFindMeatSource
{
	public BehFindMeatSameSpeciesSource(bool pCheckForFactions)
		: base(MeatTargetType.MeatSameSpecies, pCheckForFactions)
	{
	}
}
// --- End of File: BehFindMeatSameSpeciesSource.cs ---



// --- Start of File: BehFindMeatSource.cs ---
namespace ai.behaviours;

public class BehFindMeatSource : BehaviourActionActor
{
	private MeatTargetType _meat_target_type;

	private bool _check_for_factions;

	public BehFindMeatSource(MeatTargetType pMeatTargetType = MeatTargetType.Meat, bool pCheckForFactions = true)
	{
		_check_for_factions = pCheckForFactions;
		_meat_target_type = pMeatTargetType;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_actor_target != null && isTargetOk(pActor, pActor.beh_actor_target.a))
		{
			return BehResult.Continue;
		}
		pActor.beh_actor_target = getClosestMeatActor(pActor);
		if (pActor.beh_actor_target != null)
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}

	private Actor getClosestMeatActor(Actor pActor)
	{
		bool flag = Randy.randomBool();
		WorldTile current_tile = pActor.current_tile;
		float num = 2.1474836E+09f;
		Actor result = null;
		int pChunkRadius = Randy.randomInt(1, 3);
		foreach (Actor item in Finder.getUnitsFromChunk(current_tile, pChunkRadius, 0f, flag))
		{
			float num2 = Toolbox.SquaredDistTile(item.current_tile, current_tile);
			if (num2 >= num || !isTargetOk(pActor, item))
			{
				continue;
			}
			bool flag2 = item.isSameSpecies(pActor.asset.id);
			switch (_meat_target_type)
			{
			case MeatTargetType.Meat:
				if (!item.asset.source_meat || flag2)
				{
					continue;
				}
				break;
			case MeatTargetType.MeatSameSpecies:
				if (!flag2)
				{
					continue;
				}
				break;
			case MeatTargetType.Insect:
				if (!item.asset.source_meat_insect || flag2)
				{
					continue;
				}
				break;
			}
			num = num2;
			result = item;
			if (flag && Randy.randomBool())
			{
				break;
			}
		}
		return result;
	}

	private bool isTargetOk(Actor pActor, Actor pTarget)
	{
		if (pTarget == pActor)
		{
			return false;
		}
		if (!pActor.canAttackTarget(pTarget, _check_for_factions))
		{
			return false;
		}
		if (pTarget.asset.actor_size > pActor.asset.actor_size)
		{
			return false;
		}
		if (!pTarget.current_tile.isSameIsland(pActor.current_tile))
		{
			return false;
		}
		return true;
	}
}
// --- End of File: BehFindMeatSource.cs ---



// --- Start of File: BehFindNearbyPotentialCivCityToJoin.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehFindNearbyPotentialCivCityToJoin : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		City cityToJoin = getCityToJoin(pActor);
		if (cityToJoin == null)
		{
			return BehResult.Stop;
		}
		if (cityToJoin.kingdom != pActor.kingdom)
		{
			pActor.removeFromPreviousFaction();
		}
		pActor.stopBeingWarrior();
		pActor.joinCity(cityToJoin);
		return BehResult.Continue;
	}

	private static City getCityToJoin(Actor pActor)
	{
		City zone_city = pActor.current_tile.zone_city;
		if (zone_city != null && !zone_city.isNeutral() && zone_city.isWelcomedToJoin(pActor))
		{
			return zone_city;
		}
		return getPotentialCityNearby(pActor.current_tile, pActor);
	}

	public static City getPotentialCityNearby(WorldTile pFromTile, Actor pActor)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		City city = null;
		foreach (City item in BehaviourActionBase<Actor>.world.cities.list.LoopRandom())
		{
			WorldTile tile = item.getTile();
			if (tile == null || item.isNeutral())
			{
				continue;
			}
			float num = SimGlobals.m.nomad_check_far_city_range;
			if (!pActor.isNomad() && item.kingdom != pActor.kingdom)
			{
				num *= 3f;
			}
			if (Toolbox.DistVec3(pFromTile.posV, Vector2.op_Implicit(item.city_center)) > num || !item.isWelcomedToJoin(pActor) || !tile.isSameIsland(pFromTile))
			{
				continue;
			}
			if (city != null)
			{
				if (item.kingdom == pActor.kingdom && city.kingdom != pActor.kingdom)
				{
					city = item;
				}
			}
			else
			{
				city = item;
			}
		}
		return city;
	}
}
// --- End of File: BehFindNearbyPotentialCivCityToJoin.cs ---



// --- Start of File: BehFindRandomCivBuildingTile.cs ---
namespace ai.behaviours;

public class BehFindRandomCivBuildingTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		MapRegion region = pActor.current_tile.region;
		if (Randy.randomChance(0.65f) && region.tiles.Count > 0)
		{
			pActor.beh_tile_target = region.getRandomTile();
			return BehResult.Continue;
		}
		Building building = null;
		foreach (Building item in Finder.getBuildingsFromChunk(pActor.current_tile, 1, 0, pRandom: true))
		{
			if (item.asset.city_building && item.current_tile.isSameIsland(pActor.current_tile) && item.isCiv())
			{
				building = item;
				break;
			}
		}
		if (building == null)
		{
			if (region.tiles.Count > 0)
			{
				pActor.beh_tile_target = region.getRandomTile();
				return BehResult.Continue;
			}
			return BehResult.Stop;
		}
		pActor.beh_tile_target = building.current_tile.region.getRandomTile();
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomCivBuildingTile.cs ---



// --- Start of File: BehFindRandomFarmTile.cs ---
namespace ai.behaviours;

public class BehFindRandomFarmTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		MapRegion mapRegion = pActor.current_tile.region;
		if (Randy.randomChance(0.65f) && mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		if (mapRegion.neighbours.Count > 0 && Randy.randomBool())
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehFindRandomFarmTile.cs ---



// --- Start of File: BehFindRandomFarTile.cs ---
using ai.behaviours;

public class BehFindRandomFarTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		MapRegion mapRegion = pActor.current_tile.region;
		for (int i = 0; i < 5; i++)
		{
			if (mapRegion.neighbours.Count == 0)
			{
				break;
			}
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehFindRandomFarTile.cs ---



// --- Start of File: BehFindRandomFrontTileNearHouse.cs ---
using ai.behaviours;

public class BehFindRandomFrontTileNearHouse : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return BehResult.Stop;
		}
		WorldTile door_tile = homeBuilding.door_tile;
		if (!door_tile.isSameIsland(pActor.current_tile))
		{
			if (homeBuilding.current_tile.isSameIsland(pActor.current_tile))
			{
				pActor.beh_tile_target = homeBuilding.current_tile;
				return BehResult.Continue;
			}
			return BehResult.Stop;
		}
		using ListPool<WorldTile> listPool = new ListPool<WorldTile>();
		for (int i = 0; i < 3; i++)
		{
			WorldTile tile = BehaviourActionBase<Actor>.world.GetTile(door_tile.x + i, door_tile.y);
			if (tile != null && door_tile.isSameIsland(tile))
			{
				listPool.Add(tile);
			}
		}
		for (int j = 0; j < 3; j++)
		{
			WorldTile tile2 = BehaviourActionBase<Actor>.world.GetTile(door_tile.x - j, door_tile.y);
			if (tile2 != null && door_tile.isSameIsland(tile2))
			{
				listPool.Add(tile2);
			}
		}
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		WorldTile random = listPool.GetRandom();
		pActor.beh_tile_target = random;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomFrontTileNearHouse.cs ---



// --- Start of File: BehFindRandomNeighbourTile.cs ---
namespace ai.behaviours;

public class BehFindRandomNeighbourTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if ((pActor.beh_tile_target = pActor.current_tile.getWalkableTileAround(pActor.current_tile)) == null)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomNeighbourTile.cs ---



// --- Start of File: BehFindRandomTile.cs ---
namespace ai.behaviours;

public class BehFindRandomTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		MapRegion mapRegion = pActor.current_tile.region;
		if (Randy.randomChance(0.65f) && mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		if (mapRegion.neighbours.Count > 0 && Randy.randomBool())
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehFindRandomTile.cs ---



// --- Start of File: BehFindRandomTile4Directions.cs ---
namespace ai.behaviours;

public class BehFindRandomTile4Directions : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("direction", out var pResult, -1);
		ActorDirection actorDirection;
		if (pResult == -1)
		{
			actorDirection = Randy.getRandom(Toolbox.directions);
			pResult = Toolbox.directions.IndexOf(actorDirection);
			pActor.data.set("direction", pResult);
		}
		else
		{
			actorDirection = Toolbox.directions[pResult];
		}
		pActor.beh_tile_target = Ant.getNextTile(pActor.current_tile, actorDirection);
		if (pActor.beh_tile_target == null)
		{
			pActor.beh_tile_target = Ant.randomNeighbour(pActor.current_tile);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomTile4Directions.cs ---



// --- Start of File: BehFindRandomTile8Directions.cs ---
namespace ai.behaviours;

public class BehFindRandomTile8Directions : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("random_steps", out var pResult, 0);
		pActor.data.get("direction", out var pResult2, -1);
		ActorDirection actorDirection;
		if (pResult > 0)
		{
			if (pActor.beh_tile_target != null && pActor.current_tile != pActor.beh_tile_target)
			{
				return BehResult.Continue;
			}
			actorDirection = Toolbox.directions_all[pResult2];
		}
		else
		{
			int pMinInclusive = Randy.randomInt(1, 6);
			int pMaxExclusive = Randy.randomInt(10, 60);
			pResult = Randy.randomInt(pMinInclusive, pMaxExclusive);
			if (pResult2 < 0)
			{
				actorDirection = Randy.getRandom(Toolbox.directions_all);
				pResult2 = Toolbox.directions_all.IndexOf(actorDirection);
			}
			else
			{
				actorDirection = Toolbox.directions_all[pResult2];
				actorDirection = Randy.getRandom(Toolbox.directions_all_turns[actorDirection]);
				pResult2 = Toolbox.directions_all.IndexOf(actorDirection);
			}
			pActor.data.set("direction", pResult2);
		}
		pResult--;
		pActor.beh_tile_target = Ant.getNextTile(pActor.current_tile, actorDirection);
		if (pActor.beh_tile_target == null)
		{
			pActor.data.set("random_steps", 0);
			pActor.data.set("direction", -1);
			return BehResult.RepeatStep;
		}
		pActor.data.set("random_steps", pResult);
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomTile8Directions.cs ---



// --- Start of File: BehFindRandomTileAroundHouse.cs ---
using ai.behaviours;

public class BehFindRandomTileAroundHouse : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Building homeBuilding = pActor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return BehResult.Stop;
		}
		if (!homeBuilding.current_tile.isSameIsland(pActor.current_tile))
		{
			return BehResult.Stop;
		}
		MapRegion mapRegion = homeBuilding.current_tile.region;
		if (Randy.randomChance(0.2f) && mapRegion.neighbours.Count > 0)
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		WorldTile random = mapRegion.tiles.GetRandom();
		pActor.beh_tile_target = random;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomTileAroundHouse.cs ---



// --- Start of File: BehFindRandomTileNearBuildingTarget.cs ---
using ai.behaviours;

public class BehFindRandomTileNearBuildingTarget : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_building_target == null)
		{
			return BehResult.Stop;
		}
		if (!pActor.beh_building_target.current_tile.isSameIsland(pActor.current_tile))
		{
			return BehResult.Stop;
		}
		MapRegion mapRegion = pActor.beh_building_target.current_tile.region;
		if (Randy.randomChance(0.2f) && mapRegion.neighbours.Count > 0)
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		WorldTile random = mapRegion.tiles.GetRandom();
		pActor.beh_tile_target = random;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRandomTileNearBuildingTarget.cs ---



// --- Start of File: BehFindRaycastTileForBuildingTarget.cs ---
using System.Collections.Generic;
using ai.behaviours;

public class BehFindRaycastTileForBuildingTarget : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Building beh_building_target = pActor.beh_building_target;
		if (beh_building_target == null)
		{
			return BehResult.Stop;
		}
		WorldTile current_tile = beh_building_target.current_tile;
		WorldTile current_tile2 = pActor.current_tile;
		if (!current_tile.isSameIsland(current_tile2))
		{
			return BehResult.Stop;
		}
		List<WorldTile> list = PathfinderTools.raycast(current_tile2, current_tile);
		WorldTile worldTile = null;
		float resourceThrowDistance = pActor.getResourceThrowDistance();
		for (int i = 0; i < list.Count; i++)
		{
			WorldTile worldTile2 = list[i];
			if (worldTile2.isSameIsland(current_tile2) && Toolbox.DistTile(worldTile2, current_tile) < resourceThrowDistance)
			{
				worldTile = worldTile2;
				break;
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindRaycastTileForBuildingTarget.cs ---



// --- Start of File: BehFindTantrumTarget.cs ---
using ai.behaviours;

public class BehFindTantrumTarget : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_actor_target != null && pActor.isTargetOkToAttack(pActor.beh_actor_target.a))
		{
			return BehResult.Continue;
		}
		Actor closestActor = getClosestActor(pActor);
		if (closestActor == null)
		{
			return forceTask(pActor, "random_move");
		}
		pActor.beh_actor_target = closestActor;
		return BehResult.Continue;
	}

	private Actor getClosestActor(Actor pActor)
	{
		bool pRandom = Randy.randomBool();
		WorldTile current_tile = pActor.current_tile;
		float num = 2.1474836E+09f;
		Actor result = null;
		foreach (Actor item in Finder.getUnitsFromChunk(current_tile, 1, 0f, pRandom))
		{
			float num2 = Toolbox.SquaredDistTile(item.current_tile, current_tile);
			if (!(num2 >= num) && pActor.isTargetOkToAttack(item) && (!item.hasStatusStunned() || pActor.areFoes(item)))
			{
				num = num2;
				result = item;
				if (Randy.randomBool())
				{
					break;
				}
			}
		}
		return result;
	}
}
// --- End of File: BehFindTantrumTarget.cs ---



// --- Start of File: BehFindTargetForHunter.cs ---
namespace ai.behaviours;

public class BehFindTargetForHunter : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_actor_target != null && pActor.isTargetOkToAttack(pActor.beh_actor_target.a))
		{
			return BehResult.Continue;
		}
		pActor.beh_actor_target = getClosestMeatActor(pActor, 3);
		if (pActor.beh_actor_target != null)
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}

	private Actor getClosestMeatActor(Actor pActor, int pMinAge = 0, bool pCheckSame = false)
	{
		BehaviourActionActor.temp_actors.Clear();
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, 3))
		{
			if (!item.isSameKingdom(pActor) && pActor.isTargetOkToAttack(item) && item.asset.source_meat && (pMinAge <= 0 || item.getAge() >= pMinAge))
			{
				BehaviourActionActor.temp_actors.Add(item);
			}
		}
		return Toolbox.getClosestActor(BehaviourActionActor.temp_actors, pActor.current_tile);
	}
}
// --- End of File: BehFindTargetForHunter.cs ---



// --- Start of File: BehFindTargetToStealFrom.cs ---
using ai.behaviours;

public class BehFindTargetToStealFrom : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		Actor closestActorWithMoneys = getClosestActorWithMoneys(pActor);
		if (closestActorWithMoneys == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_actor_target = closestActorWithMoneys;
		return BehResult.Continue;
	}

	private Actor getClosestActorWithMoneys(Actor pActor)
	{
		using ListPool<Actor> listPool = new ListPool<Actor>(4);
		bool pRandom = Randy.randomBool();
		int pChunkRadius = Randy.randomInt(1, 4);
		int num = Randy.randomInt(1, 4);
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, pChunkRadius, 0f, pRandom))
		{
			if (item != pActor && pActor.isSameIslandAs(item) && item.hasAnyCash())
			{
				listPool.Add(item);
				if (listPool.Count >= num)
				{
					break;
				}
			}
		}
		return Toolbox.getClosestActor(listPool, pActor.current_tile);
	}
}
// --- End of File: BehFindTargetToStealFrom.cs ---



// --- Start of File: BehFindTile.cs ---
namespace ai.behaviours;

public class BehFindTile : BehaviourActionActor
{
	private TileFinderType _type;

	public BehFindTile(TileFinderType pType)
	{
		_type = pType;
	}

	public override BehResult execute(Actor pActor)
	{
		if (_type == TileFinderType.NewRoad)
		{
			using (ListPool<WorldTile> listPool = new ListPool<WorldTile>(5))
			{
				WorldTile roadTileToBuild = pActor.city.getRoadTileToBuild(pActor);
				if (roadTileToBuild != null)
				{
					listPool.Add(roadTileToBuild);
				}
				if (listPool.Count == 0)
				{
					return BehResult.Stop;
				}
				pActor.beh_tile_target = Randy.getRandom(listPool);
				return BehResult.Continue;
			}
		}
		WorldTile worldTile = Finder.findTileInChunk(pActor.current_tile, _type);
		if (worldTile != null)
		{
			pActor.beh_tile_target = worldTile;
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehFindTile.cs ---



// --- Start of File: BehFindTileBeach.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFindTileBeach : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		BehaviourActionActor.possible_moves.Clear();
		findEdgesInRegion(pActor.current_tile.region);
		if (BehaviourActionActor.possible_moves.Count == 0)
		{
			for (int i = 0; i < pActor.current_tile.region.neighbours.Count; i++)
			{
				MapRegion pRegion = pActor.current_tile.region.neighbours[i];
				findEdgesInRegion(pRegion);
			}
		}
		if (BehaviourActionActor.possible_moves.Count == 0)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = BehaviourActionActor.possible_moves.GetRandom();
		BehaviourActionActor.possible_moves.Clear();
		return BehResult.Continue;
	}

	private void findEdgesInRegion(MapRegion pRegion)
	{
		List<WorldTile> edgeTiles = pRegion.getEdgeTiles();
		int count = edgeTiles.Count;
		int num = Randy.randomInt(0, count);
		for (int i = 0; i < count; i++)
		{
			int index = (i + num) % count;
			WorldTile worldTile = edgeTiles[index];
			if (worldTile.Type.ocean)
			{
				BehaviourActionActor.possible_moves.Add(worldTile);
				break;
			}
		}
	}
}
// --- End of File: BehFindTileBeach.cs ---



// --- Start of File: BehFindTileForCity.cs ---
using System.Collections.Generic;
using UnityEngine;

namespace ai.behaviours;

public class BehFindTileForCity : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!BehaviourActionBase<Actor>.world.city_zone_helper.city_place_finder.hasPossibleZones())
		{
			return BehResult.Stop;
		}
		TileZone tileZone = null;
		float num = float.MaxValue;
		List<TileZone> zones = BehaviourActionBase<Actor>.world.city_zone_helper.city_place_finder.zones;
		Vector3 posV = pActor.current_tile.posV3;
		TileZone tileZone2 = null;
		for (int i = 0; i < zones.Count; i++)
		{
			TileZone tileZone3 = zones[i];
			float num2 = Toolbox.SquaredDistVec3(posV, tileZone3.centerTile.posV3);
			if (!(num <= num2) && tileZone3.tiles[0].isSameIsland(pActor.current_tile) && tileZone3.isGoodForNewCity())
			{
				num = num2;
				tileZone = tileZone3;
			}
		}
		if (tileZone != null)
		{
			pActor.beh_tile_target = tileZone.tiles.GetRandom();
			return BehResult.Continue;
		}
		if (tileZone2 != null)
		{
			pActor.beh_tile_target = tileZone2.tiles.GetRandom();
			return BehResult.Continue;
		}
		TileIsland randomIslandGround = BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandGround();
		if (randomIslandGround == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = randomIslandGround.getRandomTile();
		return BehResult.Continue;
	}
}
// --- End of File: BehFindTileForCity.cs ---



// --- Start of File: BehFindTileForEating.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFindTileForEating : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		WorldTile worldTile = null;
		worldTile = findTileAround(pActor.current_tile.neighboursAll);
		if (worldTile == null)
		{
			worldTile = findTileAround(pActor.current_tile.region.tiles);
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}

	private WorldTile findTileAround(IEnumerable<WorldTile> pList)
	{
		WorldTile worldTile = null;
		foreach (WorldTile p in pList)
		{
			if (p.Type.canBeEatenByGeophag())
			{
				if (worldTile == null)
				{
					worldTile = p;
				}
				else if (Randy.randomBool())
				{
					worldTile = p;
					break;
				}
			}
		}
		return worldTile;
	}
}
// --- End of File: BehFindTileForEating.cs ---



// --- Start of File: BehFindTileForFarm.cs ---
namespace ai.behaviours;

public class BehFindTileForFarm : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		Building buildingOfType = pActor.city.getBuildingOfType("type_windmill");
		if (buildingOfType == null)
		{
			return BehResult.Stop;
		}
		int num = int.MaxValue;
		WorldTile worldTile = null;
		foreach (WorldTile calculated_place_for_farm in pActor.city.calculated_place_for_farms)
		{
			int num2 = Toolbox.SquaredDistTile(buildingOfType.current_tile, calculated_place_for_farm);
			if (num2 < num && (!calculated_place_for_farm.hasBuilding() || calculated_place_for_farm.building.canRemoveForFarms()) && !calculated_place_for_farm.isTargeted() && pActor.current_tile.isSameIsland(calculated_place_for_farm) && calculated_place_for_farm.IsTypeAround(TopTileLibrary.field))
			{
				num = num2;
				worldTile = calculated_place_for_farm;
			}
		}
		if (worldTile == null)
		{
			foreach (WorldTile calculated_place_for_farm2 in pActor.city.calculated_place_for_farms)
			{
				int num3 = Toolbox.SquaredDistTile(buildingOfType.current_tile, calculated_place_for_farm2);
				if (num3 < num && (!calculated_place_for_farm2.hasBuilding() || calculated_place_for_farm2.building.canRemoveForFarms()) && !calculated_place_for_farm2.isTargeted() && pActor.current_tile.isSameIsland(calculated_place_for_farm2))
				{
					num = num3;
					worldTile = calculated_place_for_farm2;
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindTileForFarm.cs ---



// --- Start of File: BehFindTileNearbyGroupLeader.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFindTileNearbyGroupLeader : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasArmy())
		{
			return BehResult.Stop;
		}
		if (!pActor.army.hasCaptain())
		{
			return BehResult.Stop;
		}
		Actor captain = pActor.army.getCaptain();
		WorldTile worldTile = null;
		List<WorldTile> current_path = captain.current_path;
		if (current_path != null && current_path.Count > 0)
		{
			worldTile = current_path[current_path.Count - 1].region.tiles.GetRandom();
		}
		else
		{
			MapRegion mapRegion = captain.current_tile.region;
			if (mapRegion.tiles.Count < 20 && mapRegion.neighbours.Count > 0)
			{
				mapRegion = mapRegion.neighbours.GetRandom();
			}
			worldTile = mapRegion.tiles.GetRandom();
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindTileNearbyGroupLeader.cs ---



// --- Start of File: BehFindTileWhenOnFire.cs ---
namespace ai.behaviours;

public class BehFindTileWhenOnFire : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		WorldTile worldTile = findWaterIn(pActor.chunk);
		if (worldTile == null)
		{
			MapChunk[] neighbours_all = pActor.chunk.neighbours_all;
			foreach (MapChunk pChunk in neighbours_all)
			{
				worldTile = findWaterIn(pChunk);
				if (worldTile != null)
				{
					break;
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}

	private WorldTile findWaterIn(MapChunk pChunk)
	{
		foreach (MapRegion item in pChunk.regions.LoopRandom())
		{
			if (item.type == TileLayerType.Ocean)
			{
				return item.tiles.GetRandom();
			}
		}
		return null;
	}
}
// --- End of File: BehFindTileWhenOnFire.cs ---



// --- Start of File: BehFindWheat.cs ---
namespace ai.behaviours;

public class BehFindWheat : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		int num = int.MaxValue;
		WorldTile worldTile = null;
		Building beh_building_target = null;
		foreach (WorldTile item in pActor.city.calculated_grown_wheat)
		{
			if (item.building != null && item.building.asset.wheat)
			{
				int num2 = Toolbox.SquaredDistTile(pActor.current_tile, item);
				if (num2 < num && item.building.isUsable() && item.building.component_wheat.isMaxLevel() && item.isSameIsland(pActor.current_tile) && !item.isTargeted())
				{
					num = num2;
					worldTile = item;
					beh_building_target = item.building;
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		pActor.beh_building_target = beh_building_target;
		return BehResult.Continue;
	}
}
// --- End of File: BehFindWheat.cs ---



// --- Start of File: BehFinger.cs ---
namespace ai.behaviours;

public class BehFinger : BehaviourActionActor
{
	protected GodFinger finger;

	public bool drawing_action;

	public override void prepare(Actor pActor)
	{
		finger = pActor.children_special[0] as GodFinger;
		base.prepare(pActor);
	}
}
// --- End of File: BehFinger.cs ---



// --- Start of File: BehFingerCheckCanDraw.cs ---
namespace ai.behaviours;

public class BehFingerCheckCanDraw : BehFingerDrawAction
{
	protected override void setupErrorChecks()
	{
		check_has_target_tiles = true;
		check_current_tile_in_target_tiles = true;
		check_target_tile_in_target_tiles = false;
		base.setupErrorChecks();
	}
}
// --- End of File: BehFingerCheckCanDraw.cs ---



// --- Start of File: BehFingerDrawAction.cs ---
namespace ai.behaviours;

public class BehFingerDrawAction : BehFinger
{
	public bool check_has_target_tiles = true;

	public bool check_current_tile_in_target_tiles = true;

	public bool check_target_tile_in_target_tiles = true;

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		if (check_target_tile_in_target_tiles)
		{
			null_check_tile_target = true;
		}
	}

	public override bool errorsFound(Actor pActor)
	{
		if (base.errorsFound(pActor))
		{
			return true;
		}
		finger = pActor.children_special[0] as GodFinger;
		if (check_has_target_tiles && finger.target_tiles.Count == 0)
		{
			return true;
		}
		if (check_current_tile_in_target_tiles)
		{
			pActor.findCurrentTile(pCheckNeighbours: false);
			if (!finger.target_tiles.Contains(pActor.current_tile))
			{
				bool flag = false;
				if (pActor.beh_tile_target != null && Toolbox.DistTile(pActor.current_tile, pActor.beh_tile_target) < 6f)
				{
					flag = true;
				}
				else
				{
					WorldTile[] neighboursAll = pActor.current_tile.neighboursAll;
					foreach (WorldTile item in neighboursAll)
					{
						if (finger.target_tiles.Contains(item))
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag)
				{
					return true;
				}
			}
		}
		if (check_target_tile_in_target_tiles && !finger.target_tiles.Contains(pActor.beh_tile_target))
		{
			return true;
		}
		return false;
	}
}
// --- End of File: BehFingerDrawAction.cs ---



// --- Start of File: BehFingerDrawToTileTarget.cs ---
using System.Collections.Generic;
using UnityPools;

namespace ai.behaviours;

public class BehFingerDrawToTileTarget : BehFingerDrawAction
{
	public BehFingerDrawToTileTarget()
	{
		drawing_action = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pickBrush(finger);
		pickPower(finger);
		using ListPool<WorldTile> pTiles = new ListPool<WorldTile>(finger.target_tiles);
		ExecuteEvent executeEvent;
		if (pActor.current_tile == pActor.beh_tile_target || Toolbox.DistTile(pActor.current_tile, pActor.beh_tile_target) < 6f)
		{
			executeEvent = ActorMove.goToCurved(pActor, pActor.current_tile, pActor.current_tile.neighboursAll.GetRandom(), pActor.current_tile.neighboursAll.GetRandom(), pActor.beh_tile_target.neighboursAll.GetRandom(), pActor.beh_tile_target.neighboursAll.GetRandom(), pActor.beh_tile_target);
		}
		else if (finger.target_tiles.Count > 10)
		{
			WorldTile randomTileWithinDistance = Toolbox.getRandomTileWithinDistance(pActor.current_tile, 25, pTiles);
			WorldTile randomTileWithinDistance2 = Toolbox.getRandomTileWithinDistance(randomTileWithinDistance, 25, pTiles);
			WorldTile randomTileWithinDistance3 = Toolbox.getRandomTileWithinDistance(pActor.beh_tile_target, 25, pTiles);
			WorldTile randomTileWithinDistance4 = Toolbox.getRandomTileWithinDistance(randomTileWithinDistance3, 25, pTiles);
			executeEvent = ActorMove.goToCurved(pActor, pActor.current_tile, randomTileWithinDistance, randomTileWithinDistance2, randomTileWithinDistance4, randomTileWithinDistance3, pActor.beh_tile_target);
		}
		else
		{
			executeEvent = ActorMove.goToCurved(pActor, pActor.current_tile, pActor.beh_tile_target);
		}
		pActor.timer_action = 0.5f;
		if (executeEvent == ExecuteEvent.False)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}

	private static void pickBrush(GodFinger pFinger)
	{
		if (pFinger.target_tiles.Count > 0)
		{
			int pMinSize = pFinger.target_tiles.Count / 10;
			int pMaxSize = pFinger.target_tiles.Count / 3;
			pFinger.brush = Brush.getRandom(pMinSize, pMaxSize, brushFilter);
		}
	}

	private static bool brushFilter(BrushData pBrush)
	{
		if (!pBrush.id.StartsWith("circ_"))
		{
			return pBrush.id.StartsWith("special_");
		}
		return true;
	}

	private static void pickPower(GodFinger pFinger)
	{
		bool drawing_over_ground = pFinger.drawing_over_ground;
		bool drawing_over_water = pFinger.drawing_over_water;
		HashSet<WorldTile> target_tiles = pFinger.target_tiles;
		if (pFinger.god_power != null && ((drawing_over_water && GodFinger.power_over_water.Contains(pFinger.god_power.id)) || (drawing_over_ground && GodFinger.power_over_ground.Contains(pFinger.god_power.id))))
		{
			return;
		}
		Dictionary<string, int> dictionary = UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Get();
		Dictionary<TileTypeBase, int> dictionary2 = UnsafeCollectionPool<Dictionary<TileTypeBase, int>, KeyValuePair<TileTypeBase, int>>.Get();
		HashSet<WorldTile> hashSet = UnsafeCollectionPool<HashSet<WorldTile>, WorldTile>.Get();
		int num = 0;
		foreach (WorldTile item in target_tiles)
		{
			WorldTile[] neighboursAll = item.neighboursAll;
			foreach (WorldTile worldTile in neighboursAll)
			{
				if (target_tiles.Contains(worldTile) || !hashSet.Add(worldTile))
				{
					continue;
				}
				num++;
				dictionary2.TryGetValue(worldTile.Type, out var value);
				value = (dictionary2[worldTile.Type] = value + 1);
				if (drawing_over_ground)
				{
					BiomeAsset biome_asset = worldTile.Type.biome_asset;
					if (biome_asset != null && !biome_asset.special_biome)
					{
						dictionary.TryGetValue(biome_asset.tile_high, out var value2);
						value2 = (dictionary[biome_asset.tile_high] = value2 + 1);
						dictionary.TryGetValue(biome_asset.tile_low, out var value3);
						value3 = (dictionary[biome_asset.tile_low] = value3 + 1);
					}
				}
			}
		}
		if (drawing_over_water)
		{
			using ListPool<string> listPool = new ListPool<string>(num);
			string[] power_over_water = GodFinger.power_over_water;
			foreach (string text in power_over_water)
			{
				GodPower godPower = AssetManager.powers.get(text);
				bool flag = false;
				TileType cached_tile_type_asset = godPower.cached_tile_type_asset;
				if (cached_tile_type_asset != null)
				{
					flag = true;
					if (dictionary2.TryGetValue(cached_tile_type_asset, out var value4))
					{
						listPool.AddTimes(value4, text);
					}
				}
				TopTileType cached_top_tile_type_asset = godPower.cached_top_tile_type_asset;
				if (cached_top_tile_type_asset != null)
				{
					flag = true;
					if (dictionary2.TryGetValue(cached_top_tile_type_asset, out var value5))
					{
						listPool.AddTimes(value5, text);
					}
				}
				if (!flag)
				{
					listPool.Add(text);
				}
			}
			string pID = Randy.getRandom(listPool) ?? Randy.getRandom(GodFinger.power_over_water);
			pFinger.god_power = AssetManager.powers.get(pID);
		}
		else if (drawing_over_ground)
		{
			using ListPool<string> listPool2 = new ListPool<string>(num);
			string[] power_over_water = GodFinger.power_over_ground;
			foreach (string text2 in power_over_water)
			{
				GodPower godPower2 = AssetManager.powers.get(text2);
				bool flag2 = false;
				DropAsset cached_drop_asset = godPower2.cached_drop_asset;
				if (cached_drop_asset != null)
				{
					if (!string.IsNullOrEmpty(cached_drop_asset.drop_type_high))
					{
						flag2 = true;
						if (dictionary.TryGetValue(cached_drop_asset.drop_type_high, out var value6))
						{
							listPool2.AddTimes(value6, text2);
						}
					}
					if (!string.IsNullOrEmpty(cached_drop_asset.drop_type_low))
					{
						flag2 = true;
						if (dictionary.TryGetValue(cached_drop_asset.drop_type_low, out var value7))
						{
							listPool2.AddTimes(value7, text2);
						}
					}
				}
				TileType cached_tile_type_asset2 = godPower2.cached_tile_type_asset;
				if (cached_tile_type_asset2 != null)
				{
					flag2 = true;
					if (dictionary2.TryGetValue(cached_tile_type_asset2, out var value8))
					{
						listPool2.AddTimes(value8, text2);
					}
				}
				TopTileType cached_top_tile_type_asset2 = godPower2.cached_top_tile_type_asset;
				if (cached_top_tile_type_asset2 != null)
				{
					flag2 = true;
					if (dictionary2.TryGetValue(cached_top_tile_type_asset2, out var value9))
					{
						listPool2.AddTimes(value9, text2);
					}
				}
				if (!flag2)
				{
					listPool2.Add(text2);
				}
			}
			string pID2 = Randy.getRandom(listPool2) ?? Randy.getRandom(GodFinger.power_over_ground);
			pFinger.god_power = AssetManager.powers.get(pID2);
		}
		else
		{
			pFinger.god_power = null;
		}
		UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Release(dictionary);
		UnsafeCollectionPool<Dictionary<TileTypeBase, int>, KeyValuePair<TileTypeBase, int>>.Release(dictionary2);
		UnsafeCollectionPool<HashSet<WorldTile>, WorldTile>.Release(hashSet);
	}
}
// --- End of File: BehFingerDrawToTileTarget.cs ---



// --- Start of File: BehFingerFindCloseTile.cs ---
namespace ai.behaviours;

public class BehFingerFindCloseTile : BehFinger
{
	public override BehResult execute(Actor pActor)
	{
		pActor.findCurrentTile(pCheckNeighbours: false);
		if (finger.target_tiles.Count == 0)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = finger.target_tiles.GetRandom();
		if (finger.target_tiles.Contains(pActor.current_tile))
		{
			while (pActor.beh_tile_target.region != pActor.current_tile.region)
			{
				pActor.beh_tile_target = finger.target_tiles.GetRandom();
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerFindCloseTile.cs ---



// --- Start of File: BehFingerFindRandomTile.cs ---
namespace ai.behaviours;

public class BehFingerFindRandomTile : BehFinger
{
	private int _range;

	public BehFingerFindRandomTile(int pRange = 75)
	{
		_range = pRange;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.findCurrentTile(pCheckNeighbours: false);
		pActor.beh_tile_target = Toolbox.getRandomTileWithinDistance(pActor.current_tile, _range);
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerFindRandomTile.cs ---



// --- Start of File: BehFingerFindTarget.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehFingerFindTarget : BehFinger
{
	private const float RANDOM_CHANCE_ADD_TILE = 0.65f;

	private const float RANDOM_CHANCE_FIND_PITS = 0.95f;

	private const float RANDOM_CHANCE_FIND_WATER = 0.95f;

	private const float RANDOM_CHANCE_FIND_GROUND = 0.95f;

	private const float RANDOM_CHANCE_USE_CURRENT_ISLAND = 0.6f;

	public override BehResult execute(Actor pActor)
	{
		pActor.findCurrentTile(pCheckNeighbours: false);
		clearTargets(finger);
		if (finger.target_tiles.Count == 0)
		{
			finger.finger_target = fillRandomTiles(pActor.current_tile, finger.target_tiles);
		}
		pActor.beh_tile_target = finger.target_tiles.GetRandom();
		return BehResult.Continue;
	}

	private FingerTarget fillRandomTiles(WorldTile pTile, HashSet<WorldTile> pTargetTiles)
	{
		float num = BehaviourActionBase<Actor>.world.islands_calculator.groundIslandRatio() * 4f;
		int num2 = TileLibrary.pit_deep_ocean.hashset.Count + TileLibrary.pit_close_ocean.hashset.Count + TileLibrary.pit_shallow_waters.hashset.Count;
		if (num2 > 20 && Randy.randomChance(0.95f))
		{
			using (ListPool<WorldTile> listPool = new ListPool<WorldTile>(num2))
			{
				listPool.AddRange(TileLibrary.pit_deep_ocean.hashset);
				listPool.AddRange(TileLibrary.pit_close_ocean.hashset);
				listPool.AddRange(TileLibrary.pit_shallow_waters.hashset);
				Toolbox.sortTilesByDistance(pTile, listPool);
				listPool.Clear(10);
				WorldTile random = listPool.GetRandom();
				(MapChunk[], int) allChunksFromTile = Toolbox.getAllChunksFromTile(random);
				MapChunk[] item = allChunksFromTile.Item1;
				int item2 = allChunksFromTile.Item2;
				bool flag = false;
				for (int i = 0; i < item2; i++)
				{
					WorldTile[] tiles = item[i].tiles;
					foreach (WorldTile worldTile in tiles)
					{
						if (worldTile.Type.IsType(random.Type) && Randy.randomChance(0.65f))
						{
							pTargetTiles.Add(worldTile);
							if (pTargetTiles.Count >= 1200)
							{
								flag = true;
								break;
							}
						}
					}
					if (flag)
					{
						break;
					}
				}
				return FingerTarget.Water;
			}
		}
		if (BehaviourActionBase<Actor>.world.islands_calculator.hasNonGround() && Randy.randomChance(0.95f * num))
		{
			TileIsland tileIsland;
			if (pTile.region.island.type == TileLayerType.Ocean && Randy.randomChance(0.6f))
			{
				tileIsland = pTile.region.island;
			}
			else
			{
				tileIsland = BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandNonGroundWeighted();
				if (tileIsland == null)
				{
					tileIsland = BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandNonGround(pMinRegions: false);
				}
				pTile = tileIsland.getRandomTile();
			}
			foreach (MapRegion item3 in tileIsland.regions.getSimpleList().LoopRandom())
			{
				if (pTile.region != item3 && !pTile.region.hasNeighbour(item3))
				{
					continue;
				}
				foreach (WorldTile item4 in item3.tiles.LoopRandom())
				{
					if (Randy.randomChance(0.65f))
					{
						pTargetTiles.Add(item4);
					}
				}
				if (pTargetTiles.Count >= 1200)
				{
					break;
				}
			}
			return FingerTarget.Water;
		}
		if (BehaviourActionBase<Actor>.world.islands_calculator.hasGround() && Randy.randomChance(0.95f))
		{
			TileIsland tileIsland;
			if (pTile.region.island.type == TileLayerType.Ground && Randy.randomChance(0.6f))
			{
				tileIsland = pTile.region.island;
			}
			else
			{
				tileIsland = BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandGroundWeighted();
				if (tileIsland == null)
				{
					tileIsland = BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandGround(pMinRegions: false);
				}
				pTile = tileIsland.getRandomTile();
			}
			foreach (MapRegion item5 in tileIsland.regions.getSimpleList().LoopRandom())
			{
				if (pTile.region != item5 && !pTile.region.hasNeighbour(item5))
				{
					continue;
				}
				foreach (WorldTile item6 in item5.tiles.LoopRandom())
				{
					if (Randy.randomChance(0.65f))
					{
						pTargetTiles.Add(item6);
					}
				}
				if (pTargetTiles.Count >= 1200)
				{
					break;
				}
			}
			return FingerTarget.Ground;
		}
		WorldTile randomTileWithinDistance = Toolbox.getRandomTileWithinDistance(pTile, 75);
		foreach (MapRegion item7 in randomTileWithinDistance.region.island.regions.getSimpleList().LoopRandom())
		{
			if (randomTileWithinDistance.region != item7 && !randomTileWithinDistance.region.hasNeighbour(item7))
			{
				continue;
			}
			foreach (WorldTile item8 in item7.tiles.LoopRandom())
			{
				if (Randy.randomChance(0.65f))
				{
					pTargetTiles.Add(item8);
				}
			}
			if (pTargetTiles.Count >= 1200)
			{
				break;
			}
		}
		return getFingerTarget(randomTileWithinDistance);
	}

	private static FingerTarget getFingerTarget(WorldTile pTile)
	{
		if (pTile.Type.layer_type == TileLayerType.Ocean || pTile.Type.can_be_filled_with_ocean)
		{
			return FingerTarget.Water;
		}
		return FingerTarget.Ground;
	}

	private static void clearTargets(GodFinger pFinger)
	{
		if (pFinger.finger_target == FingerTarget.None)
		{
			return;
		}
		if (pFinger.drawing_over_water)
		{
			pFinger.target_tiles.RemoveWhere((WorldTile x) => x.Type.layer_type != TileLayerType.Ocean && !x.Type.can_be_filled_with_ocean);
		}
		if (pFinger.drawing_over_ground)
		{
			pFinger.target_tiles.RemoveWhere((WorldTile x) => x.Type.layer_type != TileLayerType.Ground);
		}
	}
}
// --- End of File: BehFingerFindTarget.cs ---



// --- Start of File: BehFingerGoToCircleTarget.cs ---
namespace ai.behaviours;

public class BehFingerGoToCircleTarget : BehFinger
{
	private int _min_range;

	private int _max_range;

	public BehFingerGoToCircleTarget(int pMinRange = 20, int pMaxRange = 25)
	{
		_min_range = pMinRange;
		_max_range = pMaxRange;
	}

	public override BehResult execute(Actor pActor)
	{
		WorldTile current_tile = pActor.current_tile;
		int num = Randy.randomInt(_min_range, _max_range);
		using ListPool<WorldTile> item = new ListPool<WorldTile>
		{
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x - num / 2, current_tile.y + num / 2),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x - num, current_tile.y),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x - num / 2, current_tile.y - num / 2)
		};
		using ListPool<WorldTile> item2 = new ListPool<WorldTile>
		{
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x + num / 2, current_tile.y + num / 2),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x + num, current_tile.y),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x + num / 2, current_tile.y - num / 2)
		};
		using ListPool<WorldTile> item3 = new ListPool<WorldTile>
		{
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x - num / 2, current_tile.y + num / 2),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x, current_tile.y + num),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x + num / 2, current_tile.y + num / 2)
		};
		using ListPool<WorldTile> item4 = new ListPool<WorldTile>
		{
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x - num / 2, current_tile.y - num / 2),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x, current_tile.y - num),
			BehaviourActionBase<Actor>.world.GetTile(current_tile.x + num / 2, current_tile.y - num / 2)
		};
		using ListPool<ListPool<WorldTile>> listPool = new ListPool<ListPool<WorldTile>> { item, item2, item3, item4 };
		listPool.RemoveAll((ListPool<WorldTile> tList) => tList.Contains(null));
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		ListPool<WorldTile> random = listPool.GetRandom();
		if (ActorMove.goToCurved(pActor, pActor.current_tile, random[0], random[1], random[2], pActor.current_tile) == ExecuteEvent.False)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerGoToCircleTarget.cs ---



// --- Start of File: BehFingerGoTowardsTileTarget.cs ---
namespace ai.behaviours;

public class BehFingerGoTowardsTileTarget : BehFinger
{
	private int _tile_range;

	public BehFingerGoTowardsTileTarget(int pRadiusTileRange = 25)
	{
		_tile_range = pRadiusTileRange;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		WorldTile randomTileWithinDistance = Toolbox.getRandomTileWithinDistance(pActor.current_tile, _tile_range);
		WorldTile randomTileWithinDistance2 = Toolbox.getRandomTileWithinDistance(randomTileWithinDistance, _tile_range);
		WorldTile randomTileWithinDistance3 = Toolbox.getRandomTileWithinDistance(pActor.beh_tile_target, _tile_range);
		WorldTile randomTileWithinDistance4 = Toolbox.getRandomTileWithinDistance(randomTileWithinDistance3, _tile_range);
		if (ActorMove.goToCurved(pActor, pActor.current_tile, randomTileWithinDistance, randomTileWithinDistance2, randomTileWithinDistance4, randomTileWithinDistance3) == ExecuteEvent.False)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerGoTowardsTileTarget.cs ---



// --- Start of File: BehFingerSetFlying.cs ---
namespace ai.behaviours;

public class BehFingerSetFlying : BehFinger
{
	private bool _flying;

	private float _height_target = -1f;

	public BehFingerSetFlying(bool pFlying, float pHeightTarget = -1f)
	{
		_flying = pFlying;
		if (pHeightTarget > -1f)
		{
			_height_target = pHeightTarget;
		}
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.setFlying(_flying);
		if (_flying)
		{
			if (_height_target > -1f)
			{
				finger.flying_target = _height_target;
			}
			else
			{
				finger.flying_target = Randy.randomFloat(5f, 13f);
			}
		}
		else
		{
			finger.flying_target = 0.3f;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerSetFlying.cs ---



// --- Start of File: BehFingerWaitForFlying.cs ---
namespace ai.behaviours;

public class BehFingerWaitForFlying : BehFinger
{
	public override BehResult execute(Actor pActor)
	{
		if (finger.flying_target != pActor.position_height)
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehFingerWaitForFlying.cs ---



// --- Start of File: BehFinishReading.cs ---
using ai.behaviours;

public class BehFinishReading : BehCitizenActionCity
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_books = true;
		uses_religions = true;
		uses_languages = true;
		uses_cultures = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Book beh_book_target = pActor.beh_book_target;
		if (beh_book_target == null || !beh_book_target.isAlive())
		{
			return BehResult.Stop;
		}
		checkBookTrait(pActor, beh_book_target);
		checkBookValueBonuses(pActor, beh_book_target);
		checkBookAttributes(pActor, beh_book_target);
		checkSpecialBookRewards(pActor, beh_book_target);
		tryToConvertActorToMetaFromBook(pActor, beh_book_target);
		checkBookAssetAction(pActor, beh_book_target);
		tryToGetMetaTraitsFromBook(pActor, beh_book_target);
		beh_book_target.increaseReadTimes();
		return BehResult.Continue;
	}

	private void checkBookAttributes(Actor pActor, Book pBook)
	{
		foreach (BaseStatsContainer item in pBook.getBaseStats().getList())
		{
			if (item.asset.actor_data_attribute)
			{
				pActor.data[item.id] += item.value;
			}
		}
	}

	private void checkBookAssetAction(Actor pActor, Book pBook)
	{
		BookTypeAsset asset = pBook.getAsset();
		asset.read_action?.Invoke(pActor, asset);
	}

	private void checkSpecialBookRewards(Actor pActor, Book pBook)
	{
		foreach (LanguageTrait trait in pBook.getLanguage().getTraits())
		{
			trait.read_book_trait_action?.Invoke(pActor, trait, pBook);
		}
	}

	private void checkBookValueBonuses(Actor pActor, Book pBook)
	{
		int num = pBook.getHappiness();
		int num2 = pBook.getExperience();
		int mana = pBook.getMana();
		if (pActor.hasCulture())
		{
			if (pActor.culture.hasTrait("reading_lovers") && num < 0)
			{
				num *= -1;
			}
			if (pActor.culture.hasTrait("attentive_readers"))
			{
				num2 *= (int)((float)num2 * CultureTraitLibrary.getValueFloat("attentive_readers"));
			}
		}
		pActor.changeHappiness("just_read_book", num);
		pActor.addExperience(num2);
		pActor.addMana(mana);
	}

	private void checkBookTrait(Actor pActor, Book pBook)
	{
		if (Randy.randomBool())
		{
			ActorTrait bookTraitActor = pBook.getBookTraitActor();
			if (bookTraitActor != null)
			{
				pActor.addTrait(bookTraitActor);
			}
		}
	}

	private void tryToConvertActorToMetaFromBook(Actor pActor, Book pBook)
	{
		tryToConvertActorToBookCulture(pActor, pBook);
		tryToConvertActorToBookLanguage(pActor, pBook);
		tryToConvertActorToBookReligion(pActor, pBook);
	}

	private void tryToGetMetaTraitsFromBook(Actor pActor, Book pBook)
	{
		if (pActor.isKing() || pActor.isCityLeader())
		{
			tryToGetMetaTraitFromBookCulture(pActor, pBook);
			tryToGetMetaTraitFromBookLanguage(pActor, pBook);
			tryToGetMetaTraitFromBookReligion(pActor, pBook);
		}
	}

	private void tryToGetMetaTraitFromBookCulture(Actor pActor, Book pBook)
	{
		if (pActor.hasCulture())
		{
			CultureTrait bookTraitCulture = pBook.getBookTraitCulture();
			if (bookTraitCulture != null && Randy.randomBool())
			{
				pActor.culture.addTrait(bookTraitCulture);
			}
		}
	}

	private void tryToGetMetaTraitFromBookLanguage(Actor pActor, Book pBook)
	{
		if (pActor.hasLanguage())
		{
			LanguageTrait bookTraitLanguage = pBook.getBookTraitLanguage();
			if (bookTraitLanguage != null && Randy.randomBool())
			{
				pActor.language.addTrait(bookTraitLanguage);
			}
		}
	}

	private void tryToGetMetaTraitFromBookReligion(Actor pActor, Book pBook)
	{
		if (pActor.hasReligion())
		{
			ReligionTrait bookTraitReligion = pBook.getBookTraitReligion();
			if (bookTraitReligion != null && Randy.randomBool())
			{
				pActor.religion.addTrait(bookTraitReligion);
			}
		}
	}

	private void tryToConvertActorToBookReligion(Actor pActor, Book pBook)
	{
		Religion religion = pBook.getReligion();
		if (religion == null || pActor.religion == religion)
		{
			return;
		}
		using ListPool<Religion> listPool = new ListPool<Religion>(6);
		if (pActor.hasReligion())
		{
			listPool.AddTimes(3, pActor.religion);
			if (hasStylishWritingActor(pActor))
			{
				listPool.AddTimes(getStylishWritingValue(), pActor.religion);
			}
		}
		listPool.AddTimes(3, religion);
		if (hasStylishWritingBook(pBook))
		{
			listPool.AddTimes(getStylishWritingValue(), religion);
		}
		Religion random = listPool.GetRandom();
		if (random != pActor.religion)
		{
			pActor.tryToConvertToReligion(random);
		}
	}

	private void tryToConvertActorToBookLanguage(Actor pActor, Book pBook)
	{
		Language language = pBook.getLanguage();
		if (language == null || pActor.language == language)
		{
			return;
		}
		using ListPool<Language> listPool = new ListPool<Language>();
		if (pActor.hasLanguage())
		{
			listPool.AddTimes(3, pActor.language);
			if (hasStylishWritingActor(pActor))
			{
				listPool.AddTimes(getStylishWritingValue(), pActor.language);
			}
		}
		listPool.AddTimes(3, language);
		if (hasStylishWritingBook(pBook))
		{
			listPool.AddTimes(getStylishWritingValue(), language);
		}
		Language random = listPool.GetRandom();
		if (random != pActor.language)
		{
			pActor.tryToConvertToLanguage(random);
		}
	}

	private void tryToConvertActorToBookCulture(Actor pActor, Book pBook)
	{
		Culture culture = pBook.getCulture();
		if (culture == null)
		{
			return;
		}
		Culture culture2 = pActor.culture;
		if (culture2 == culture)
		{
			return;
		}
		using ListPool<Culture> listPool = new ListPool<Culture>();
		if (pActor.hasCulture())
		{
			listPool.AddTimes(3, culture2);
			if (hasStylishWritingActor(pActor))
			{
				listPool.AddTimes(getStylishWritingValue(), culture2);
			}
		}
		listPool.AddTimes(3, culture);
		if (hasStylishWritingBook(pBook))
		{
			listPool.AddTimes(getStylishWritingValue(), culture);
		}
		Culture random = listPool.GetRandom();
		if (random != culture2)
		{
			pActor.tryToConvertToCulture(random);
		}
	}

	private bool hasStylishWritingActor(Actor pActor)
	{
		if (pActor.hasLanguage() && pActor.language.hasTrait("stylish_writing"))
		{
			return true;
		}
		return false;
	}

	private bool hasStylishWritingBook(Book pBook)
	{
		if (pBook.getLanguage().hasTrait("stylish_writing"))
		{
			return true;
		}
		return false;
	}

	private int getStylishWritingValue()
	{
		return LanguageTraitLibrary.getValue("stylish_writing");
	}
}
// --- End of File: BehFinishReading.cs ---



// --- Start of File: BehFinishSinging.cs ---
using ai.behaviours;

public class BehFinishSinging : BehaviourActionActor
{
	public override BehResult execute(Actor pObject)
	{
		return base.execute(pObject);
	}
}
// --- End of File: BehFinishSinging.cs ---



// --- Start of File: BehFinishTalk.cs ---
using ai;
using ai.behaviours;

public class BehFinishTalk : BehaviourActionActor
{
	public BehFinishTalk()
	{
		socialize = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Actor actor = pActor.beh_actor_target?.a;
		if (actor == null)
		{
			return BehResult.Stop;
		}
		if (!stillCanTalk(actor))
		{
			return BehResult.Stop;
		}
		finishTalk(pActor, actor);
		return BehResult.Continue;
	}

	private bool stillCanTalk(Actor pTarget)
	{
		if (!pTarget.isAlive())
		{
			return false;
		}
		if (pTarget.isLying())
		{
			return false;
		}
		return true;
	}

	private void finishTalk(Actor pActor, Actor pTarget)
	{
		pActor.resetSocialize();
		pTarget.resetSocialize();
		bool num = Randy.randomChance(0.7f);
		int pValue = ((!num) ? (-15) : 10);
		pActor.changeHappiness("just_talked", pValue);
		pTarget.changeHappiness("just_talked", pValue);
		pActor.addStatusEffect("recovery_social");
		pTarget.addStatusEffect("recovery_social");
		if (num)
		{
			ActorTool.checkFallInLove(pActor, pTarget);
		}
		if (num)
		{
			ActorTool.checkBecomingBestFriends(pActor, pTarget);
		}
		checkMetaSpread(pActor, pTarget);
		if (pActor.hasCulture() && pActor.culture.hasTrait("youth_reverence") && throwDiceForGift(pActor, pTarget) && pActor.isAdult() && pTarget.getAge() < pActor.getAge())
		{
			makeGift(pActor, pTarget);
		}
		if (pActor.hasCulture() && pActor.culture.hasTrait("elder_reverence") && throwDiceForGift(pActor, pTarget) && pActor.isAdult() && pTarget.getAge() > pActor.getAge())
		{
			makeGift(pActor, pTarget);
		}
		checkPassLearningAttributes(pActor, pTarget);
		pTarget.timer_action = (pActor.timer_action = Randy.randomFloat(1.1f, 3.3f));
	}

	private void checkAttribue(Actor pActor, Actor pTarget, string pAttributeID)
	{
		if (Randy.randomChance(0.3f))
		{
			if (pActor.stats[pAttributeID] > pTarget.stats[pAttributeID])
			{
				pTarget.stats[pAttributeID]++;
			}
			else if (pActor.stats[pAttributeID] < pTarget.stats[pAttributeID])
			{
				pActor.stats[pAttributeID]++;
			}
		}
	}

	private void checkPassLearningAttributes(Actor pActor, Actor pTarget)
	{
		checkAttribue(pActor, pTarget, "intelligence");
		checkAttribue(pActor, pTarget, "warfare");
		checkAttribue(pActor, pTarget, "diplomacy");
		checkAttribue(pActor, pTarget, "stewardship");
	}

	private void checkMetaSpread(Actor pActor, Actor pTarget)
	{
		if (pActor.hasSubspecies() && pTarget.hasSubspecies())
		{
			tryToSpreadCulture(pActor, pTarget);
			tryToSpreadLanguage(pActor, pTarget);
			tryToSpreadReligion(pActor, pTarget);
		}
	}

	private void tryToSpreadCulture(Actor pActor, Actor pTarget)
	{
		if (!pActor.subspecies.has_advanced_memory || !pTarget.subspecies.has_advanced_memory)
		{
			return;
		}
		Culture culture = decideCulture(pActor, pTarget);
		if (culture != null)
		{
			pActor.tryToConvertToCulture(culture);
			pTarget.tryToConvertToCulture(culture);
			if (culture.hasTrait("pep_talks") && Randy.randomChance(0.5f))
			{
				pActor.addStatusEffect("inspired");
				pTarget.addStatusEffect("inspired");
			}
			if (culture.hasTrait("expertise_exchange"))
			{
				pActor.addExperience(CultureTraitLibrary.getValue("expertise_exchange"));
				pTarget.addExperience(CultureTraitLibrary.getValue("expertise_exchange"));
			}
			if (culture.hasTrait("gossip_lovers"))
			{
				pActor.changeHappiness("just_talked_gossip");
				pTarget.changeHappiness("just_talked_gossip");
			}
		}
	}

	private void tryToSpreadLanguage(Actor pActor, Actor pTarget)
	{
		if (pActor.subspecies.has_advanced_communication && pTarget.subspecies.has_advanced_communication)
		{
			Language language = decideLanguage(pActor, pTarget);
			if (language != null)
			{
				pActor.tryToConvertToLanguage(language);
				pTarget.tryToConvertToLanguage(language);
			}
		}
	}

	private void tryToSpreadReligion(Actor pActor, Actor pTarget)
	{
		if (pActor.subspecies.has_advanced_memory && pTarget.subspecies.has_advanced_memory)
		{
			Religion religion = decideReligion(pActor, pTarget);
			if (religion != null)
			{
				pActor.tryToConvertToReligion(religion);
				pTarget.tryToConvertToReligion(religion);
			}
		}
	}

	private Religion decideReligion(Actor pActor1, Actor pActor2)
	{
		Religion religion = pActor1.religion;
		Religion religion2 = pActor2.religion;
		if (religion == null && religion2 == null)
		{
			return null;
		}
		if (religion == null)
		{
			return religion2;
		}
		if (religion2 == null)
		{
			return religion;
		}
		using ListPool<Religion> listPool = new ListPool<Religion>();
		listPool.Add(religion);
		listPool.Add(religion2);
		if (pActor1.hasCity() && pActor1.religion == pActor1.city.getReligion())
		{
			listPool.Add(pActor1.religion);
		}
		if (pActor1.kingdom.hasReligion() && pActor1.religion == pActor1.kingdom.getReligion())
		{
			listPool.Add(pActor1.religion);
		}
		if (pActor2.hasCity() && pActor2.religion == pActor2.city.getReligion())
		{
			listPool.Add(pActor2.religion);
		}
		if (pActor2.kingdom.hasReligion() && pActor2.religion == pActor2.kingdom.getReligion())
		{
			listPool.Add(pActor2.religion);
		}
		return listPool.GetRandom();
	}

	private Language decideLanguage(Actor pActor1, Actor pActor2)
	{
		Language language = pActor1.language;
		Language language2 = pActor2.language;
		if (language == null && language2 == null)
		{
			return null;
		}
		if (language == null)
		{
			return language2;
		}
		if (language2 == null)
		{
			return language;
		}
		using ListPool<Language> listPool = new ListPool<Language>();
		int num = 3;
		int num2 = 3;
		if (pActor1.hasLanguage() && pActor1.language.hasTrait("melodic"))
		{
			num += LanguageTraitLibrary.getValue("melodic");
		}
		if (pActor2.hasLanguage() && pActor2.language.hasTrait("melodic"))
		{
			num2 += LanguageTraitLibrary.getValue("melodic");
		}
		if (pActor1.hasCity() && pActor1.language == pActor1.city.getLanguage())
		{
			num++;
		}
		if (pActor1.kingdom.hasLanguage() && pActor1.language == pActor1.kingdom.getLanguage())
		{
			num++;
		}
		if (pActor2.hasCity() && pActor2.language == pActor2.city.getLanguage())
		{
			num2++;
		}
		if (pActor2.kingdom.hasLanguage() && pActor2.language == pActor2.kingdom.getLanguage())
		{
			num2++;
		}
		listPool.AddTimes(num, language);
		listPool.AddTimes(num2, language2);
		return listPool.GetRandom();
	}

	private Culture decideCulture(Actor pActor1, Actor pActor2)
	{
		Culture culture = pActor1.culture;
		Culture culture2 = pActor2.culture;
		if (culture == null && culture2 == null)
		{
			return null;
		}
		if (culture == null)
		{
			return culture2;
		}
		if (culture2 == null)
		{
			return culture;
		}
		using ListPool<Culture> listPool = new ListPool<Culture>();
		int num = 3;
		int num2 = 3;
		if (pActor1.hasLanguage() && pActor1.language.hasTrait("melodic"))
		{
			num += LanguageTraitLibrary.getValue("melodic");
		}
		if (pActor2.hasLanguage() && pActor2.language.hasTrait("melodic"))
		{
			num2 += LanguageTraitLibrary.getValue("melodic");
		}
		if (pActor1.hasCity() && pActor1.culture == pActor1.city.getCulture())
		{
			num++;
		}
		if (pActor1.kingdom.hasCulture() && pActor1.culture == pActor1.kingdom.getCulture())
		{
			num++;
		}
		if (pActor2.hasCity() && pActor2.culture == pActor2.city.getCulture())
		{
			num2++;
		}
		if (pActor2.kingdom.hasCulture() && pActor2.culture == pActor2.kingdom.getCulture())
		{
			num2++;
		}
		listPool.AddTimes(num, culture);
		listPool.AddTimes(num2, culture2);
		return listPool.GetRandom();
	}

	private bool throwDiceForGift(Actor pActor, Actor pTarget)
	{
		bool num = pActor.isRelatedTo(pTarget) || pActor.isImportantTo(pTarget);
		float num2 = 0.2f;
		if (num)
		{
			num2 += 0.3f;
		}
		return Randy.randomChance(num2);
	}

	private void makeGift(Actor pActor, Actor pTarget)
	{
		bool flag = pTarget.tryToAcceptGift(pActor);
		int moneyForGift = pActor.getMoneyForGift();
		if (moneyForGift > 0)
		{
			pTarget.addMoney(moneyForGift);
		}
		if (moneyForGift > 0 || flag)
		{
			pActor.changeHappiness("just_gave_gift");
			pTarget.changeHappiness("just_received_gift");
		}
	}
}
// --- End of File: BehFinishTalk.cs ---



// --- Start of File: BehGenerateLootFromHouse.cs ---
using UnityEngine;
using ai.behaviours;

public class BehGenerateLootFromHouse : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasHouse())
		{
			return BehResult.Stop;
		}
		Building homeBuilding = pActor.getHomeBuilding();
		int loot_generation = homeBuilding.asset.loot_generation;
		int num = 0;
		BiomeAsset biome = homeBuilding.current_tile.getBiome();
		if (biome != null)
		{
			num = biome.loot_generation;
		}
		int num2 = loot_generation + num;
		num2 = Mathf.Max(1, num2);
		pActor.addLoot(num2);
		return BehResult.Continue;
	}
}
// --- End of File: BehGenerateLootFromHouse.cs ---



// --- Start of File: BehGetDamaged.cs ---
using ai.behaviours;

public class BehGetDamaged : BehaviourActionActor
{
	private int _damage;

	private AttackType _attackType;

	public BehGetDamaged(int pDamage, AttackType pAttackType)
	{
		_damage = pDamage;
		_attackType = pAttackType;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.getHit(_damage, pFlash: true, _attackType);
		if (pActor.hasHealth())
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehGetDamaged.cs ---



// --- Start of File: BehGetRandomZoneTile.cs ---
namespace ai.behaviours;

public class BehGetRandomZoneTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		MapChunk randomChunkFromTile = Toolbox.getRandomChunkFromTile(pActor.current_tile);
		if (randomChunkFromTile != null)
		{
			pActor.beh_tile_target = randomChunkFromTile.tiles.GetRandom();
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehGetRandomZoneTile.cs ---



// --- Start of File: BehGetResourcesFromMine.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehGetResourcesFromMine : BehActorUsableBuildingTarget
{
	private const string ASSET_FOR_NO_BIOME = "mineral_stone";

	private static List<string> pool_mineral_assets_default = new List<string>();

	public override void create()
	{
		base.create();
		if (pool_mineral_assets_default.Count == 0)
		{
			initPool();
		}
	}

	private static void initPool()
	{
		addToPool("mineral_gems", 1, pool_mineral_assets_default);
		addToPool("mineral_gems", 4, pool_mineral_assets_default);
		addToPool("mineral_stone", 20, pool_mineral_assets_default);
		addToPool("mineral_metals", 10, pool_mineral_assets_default);
	}

	private static void addToPool(string pID, int pAmount, List<string> pPool)
	{
		for (int i = 0; i < pAmount; i++)
		{
			pPool.Add(pID);
		}
	}

	public override BehResult execute(Actor pActor)
	{
		if (Randy.randomChance(0.4f))
		{
			return BehResult.Continue;
		}
		BuildingAsset randomAssetFromPool = getRandomAssetFromPool(pActor);
		if (randomAssetFromPool == null)
		{
			return BehResult.Continue;
		}
		BuildingHelper.tryToBuildNear(pActor.beh_building_target.current_tile, randomAssetFromPool);
		pActor.addLoot(SimGlobals.m.coins_for_mine);
		return BehResult.Continue;
	}

	private static BuildingAsset getRandomAssetFromPool(Actor pActor)
	{
		Building beh_building_target = pActor.beh_building_target;
		WorldTile worldTile = beh_building_target.current_tile;
		if (!worldTile.Type.is_biome)
		{
			bool flag = false;
			foreach (WorldTile tile in beh_building_target.tiles)
			{
				if (tile.Type.is_biome)
				{
					flag = true;
					worldTile = tile;
					break;
				}
			}
			if (!flag)
			{
				for (int i = 0; i < worldTile.neighboursAll.Length; i++)
				{
					WorldTile worldTile2 = worldTile.neighboursAll[i];
					if (worldTile2.Type.is_biome)
					{
						flag = true;
						worldTile = worldTile2;
						break;
					}
				}
			}
			if (!flag)
			{
				return AssetManager.buildings.get("mineral_stone");
			}
		}
		List<string> list = worldTile.Type.biome_asset?.pot_minerals_spawn;
		if (list == null)
		{
			list = pool_mineral_assets_default;
		}
		string random = list.GetRandom();
		return AssetManager.buildings.get(random);
	}
}
// --- End of File: BehGetResourcesFromMine.cs ---



// --- Start of File: BehGetTargetBuildingMainTile.cs ---
namespace ai.behaviours;

public class BehGetTargetBuildingMainTile : BehActorBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		pActor.beh_tile_target = pActor.beh_building_target.current_tile;
		return BehResult.Continue;
	}
}
// --- End of File: BehGetTargetBuildingMainTile.cs ---



// --- Start of File: BehGoOrSwimToTileTarget.cs ---
namespace ai.behaviours;

public class BehGoOrSwimToTileTarget : BehGoToTileTarget
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
		walk_on_water = true;
	}
}
// --- End of File: BehGoOrSwimToTileTarget.cs ---



// --- Start of File: BehGoToActorTarget.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehGoToActorTarget : BehaviourActionActor
{
	private GoToActorTargetType _type;

	private bool _path_on_water;

	private bool _check_can_attack_target;

	private bool _check_same_island;

	private bool _check_inside_something;

	public BehGoToActorTarget(GoToActorTargetType pType = GoToActorTargetType.SameTile, bool pPathOnWater = false, bool pCheckCanAttackTarget = false, bool pCalibrateTargetPosition = false, float pCheckDistance = 2f, bool pCheckSameIsland = true, bool pCheckInsideSomething = true)
	{
		_path_on_water = pPathOnWater;
		_type = pType;
		_check_can_attack_target = pCheckCanAttackTarget;
		_check_same_island = pCheckSameIsland;
		_check_inside_something = pCheckInsideSomething;
		calibrate_target_position = pCalibrateTargetPosition;
		check_actor_target_position_distance = pCheckDistance;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		BaseSimObject beh_actor_target = pActor.beh_actor_target;
		WorldTile worldTile = beh_actor_target.current_tile;
		if (beh_actor_target.isActor())
		{
			Actor a = beh_actor_target.a;
			if (_check_can_attack_target && !pActor.isTargetOkToAttack(a))
			{
				return BehResult.Stop;
			}
			if (_check_same_island && !pActor.isSameIslandAs(a))
			{
				return BehResult.Stop;
			}
			if (_check_inside_something && a.isInsideSomething())
			{
				return BehResult.Stop;
			}
		}
		switch (_type)
		{
		case GoToActorTargetType.RaycastWithAttackRange:
			worldTile = raycastToTarget(pActor, beh_actor_target);
			if (worldTile == pActor.current_tile)
			{
				return BehResult.Continue;
			}
			break;
		case GoToActorTargetType.SameTile:
			worldTile = beh_actor_target.current_tile;
			break;
		case GoToActorTargetType.SameRegion:
			worldTile = beh_actor_target.current_tile.region.tiles.GetRandom();
			break;
		case GoToActorTargetType.NearbyTile:
			worldTile = beh_actor_target.current_tile.getTileAroundThisOnSameIsland(pActor.current_tile);
			break;
		case GoToActorTargetType.NearbyTileClosest:
			worldTile = beh_actor_target.current_tile.getTileAroundThisOnSameIsland(pActor.current_tile, pClosest: true);
			break;
		}
		if (worldTile == null)
		{
			pActor.ignoreTarget(beh_actor_target);
			return BehResult.Stop;
		}
		if (pActor.goTo(worldTile, _path_on_water) == ExecuteEvent.True)
		{
			return BehResult.Continue;
		}
		pActor.ignoreTarget(beh_actor_target);
		return BehResult.Stop;
	}

	private WorldTile raycastToTarget(Actor pSelf, BaseSimObject pTarget)
	{
		WorldTile current_tile = pSelf.current_tile;
		WorldTile current_tile2 = pTarget.current_tile;
		List<WorldTile> list = PathfinderTools.raycast(current_tile, current_tile2);
		WorldTile worldTile = null;
		float attackRangeSquared = pSelf.getAttackRangeSquared();
		for (int i = 0; i < list.Count; i++)
		{
			WorldTile worldTile2 = list[i];
			if (worldTile2.isSameIsland(current_tile) && (float)Toolbox.SquaredDistTile(worldTile2, current_tile2) < attackRangeSquared)
			{
				worldTile = worldTile2;
				break;
			}
		}
		if (worldTile == null)
		{
			worldTile = current_tile2;
		}
		return worldTile;
	}
}
// --- End of File: BehGoToActorTarget.cs ---



// --- Start of File: BehGoToBuildingTarget.cs ---
namespace ai.behaviours;

public class BehGoToBuildingTarget : BehActorBuildingTarget
{
	private bool _path_on_water;

	public BehGoToBuildingTarget(bool pPathOnWater = false)
	{
		_path_on_water = pPathOnWater;
	}

	public override BehResult execute(Actor pActor)
	{
		goToBuilding(pActor);
		return BehResult.Continue;
	}

	internal void goToBuilding(Actor pActor)
	{
		WorldTile current_tile = pActor.beh_building_target.current_tile;
		pActor.goTo(current_tile, _path_on_water);
	}
}
// --- End of File: BehGoToBuildingTarget.cs ---



// --- Start of File: BehGoToStablePlace.cs ---
using System.Collections.Generic;
using UnityEngine;

namespace ai.behaviours;

public class BehGoToStablePlace : BehaviourActionActor
{
	private static MapRegion best_region;

	private static int best_fast_dist = int.MaxValue;

	internal static List<KeyValuePair<int, MapRegion>> bestRegions = new List<KeyValuePair<int, MapRegion>>(4);

	internal static WorldTile best_tile = null;

	private const int MAX_DISTANCE = 15;

	public override BehResult execute(Actor pActor)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		TileIsland island = pActor.current_tile.region.island;
		if (island.isGoodIslandForActor(pActor))
		{
			return BehResult.Stop;
		}
		best_region = null;
		best_fast_dist = int.MaxValue;
		best_tile = null;
		best_region = findIslandNearby(pActor);
		if (best_region != null)
		{
			pActor.beh_tile_target = best_region.tiles.GetRandom();
			best_tile = pActor.beh_tile_target;
			return BehResult.Continue;
		}
		bestRegions.Clear();
		Vector2Int pos = pActor.current_tile.pos;
		for (int i = 0; i < BehaviourActionBase<Actor>.world.islands_calculator.islands.Count; i++)
		{
			TileIsland tileIsland = BehaviourActionBase<Actor>.world.islands_calculator.islands[i];
			if (!checkIsland(island, tileIsland, pActor))
			{
				continue;
			}
			selectBorderRegionsForComparison(tileIsland, island, out var pOut, out var pOut2);
			MapRegion mapRegion = null;
			int num = int.MaxValue;
			foreach (MapRegion item in pOut)
			{
				if (pOut2.Contains(item))
				{
					int x2 = ((Vector2Int)(ref pos)).x;
					int y2 = ((Vector2Int)(ref pos)).y;
					Vector2Int pos2 = item.tiles[0].pos;
					int x3 = ((Vector2Int)(ref pos2)).x;
					pos2 = item.tiles[0].pos;
					int num2 = Toolbox.SquaredDist(x2, y2, x3, ((Vector2Int)(ref pos2)).y);
					if (num2 < num)
					{
						num = num2;
						mapRegion = item;
					}
				}
			}
			if (mapRegion == null)
			{
				continue;
			}
			MapRegion mapRegion2 = mapRegion;
			List<WorldTile> edgeTiles = mapRegion2.getEdgeTiles();
			if (edgeTiles.Count == 0)
			{
				continue;
			}
			float num3 = Toolbox.DistTile(pActor.current_tile, edgeTiles.GetRandom());
			if (bestRegions.Count > 0 && (float)(bestRegions[0].Key + 15) < num3)
			{
				continue;
			}
			if (bestRegions.Count < 4)
			{
				bestRegions.Add(new KeyValuePair<int, MapRegion>((int)num3, mapRegion2));
				continue;
			}
			bestRegions.Sort((KeyValuePair<int, MapRegion> x, KeyValuePair<int, MapRegion> y) => x.Key.CompareTo(y.Key));
			if ((float)bestRegions[3].Key > num3)
			{
				bestRegions[3] = new KeyValuePair<int, MapRegion>((int)num3, mapRegion2);
			}
		}
		bestRegions.RemoveAll((KeyValuePair<int, MapRegion> x) => x.Key - 15 > bestRegions[0].Key);
		if (Randy.randomChance(0.8f) && bestRegions.Count > 0)
		{
			pActor.beh_tile_target = bestRegions.GetRandom().Value.tiles.GetRandom();
		}
		else
		{
			MapRegion mapRegion3 = ((!Randy.randomChance(0.5f)) ? Randy.getRandom(pActor.current_tile.region.neighbours) : pActor.current_tile.region);
			if (mapRegion3 != null)
			{
				pActor.beh_tile_target = Randy.getRandom(mapRegion3.tiles);
			}
		}
		if (!DebugConfig.isOn(DebugOption.ShowSwimToIslandLogic))
		{
			bestRegions.Clear();
		}
		else
		{
			best_tile = pActor.beh_tile_target;
		}
		return BehResult.Continue;
	}

	private static MapRegion findIslandNearby(Actor pActor)
	{
		(MapChunk[], int) allChunksFromTile = Toolbox.getAllChunksFromTile(pActor.current_tile);
		MapChunk[] item = allChunksFromTile.Item1;
		int item2 = allChunksFromTile.Item2;
		TileIsland island = pActor.current_tile.region.island;
		for (int i = 0; i < item2; i++)
		{
			MapChunk mapChunk = item[i];
			for (int j = 0; j < mapChunk.regions.Count; j++)
			{
				MapRegion mapRegion = mapChunk.regions[j];
				if (!checkIsland(island, mapRegion.island, pActor))
				{
					continue;
				}
				List<WorldTile> edgeTiles = mapRegion.getEdgeTiles();
				if (edgeTiles.Count != 0)
				{
					WorldTile closestTile = Toolbox.getClosestTile(edgeTiles, pActor.current_tile);
					int num = Toolbox.SquaredDistTile(pActor.current_tile, closestTile);
					if (num < best_fast_dist)
					{
						best_region = mapRegion;
						best_fast_dist = num;
					}
				}
			}
		}
		return best_region;
	}

	private static bool checkIsland(TileIsland pCurrentIsland, TileIsland pIsland, Actor pActor)
	{
		if (pCurrentIsland == pIsland)
		{
			return false;
		}
		if (!pIsland.isGoodIslandForActor(pActor))
		{
			return false;
		}
		if (!((pCurrentIsland.getTileCount() <= pIsland.getTileCount()) ? pCurrentIsland.isConnectedWith(pIsland) : pIsland.isConnectedWith(pCurrentIsland)))
		{
			return false;
		}
		if (pIsland.insideRegionEdges.Count == 0)
		{
			return false;
		}
		return true;
	}

	private static void selectBorderRegionsForComparison(TileIsland pIsland1, TileIsland pIsland2, out HashSet<MapRegion> pOut1, out HashSet<MapRegion> pOut2)
	{
		if (pIsland1.outsideRegionEdges.Count + pIsland2.insideRegionEdges.Count < pIsland1.insideRegionEdges.Count + pIsland2.outsideRegionEdges.Count)
		{
			if (pIsland1.outsideRegionEdges.Count > pIsland2.insideRegionEdges.Count)
			{
				pOut1 = pIsland2.insideRegionEdges;
				pOut2 = pIsland1.outsideRegionEdges;
			}
			else
			{
				pOut2 = pIsland2.insideRegionEdges;
				pOut1 = pIsland1.outsideRegionEdges;
			}
		}
		else if (pIsland1.insideRegionEdges.Count > pIsland2.outsideRegionEdges.Count)
		{
			pOut1 = pIsland2.outsideRegionEdges;
			pOut2 = pIsland1.insideRegionEdges;
		}
		else
		{
			pOut2 = pIsland2.outsideRegionEdges;
			pOut1 = pIsland1.insideRegionEdges;
		}
	}
}
// --- End of File: BehGoToStablePlace.cs ---



// --- Start of File: BehGoToTileTarget.cs ---
namespace ai.behaviours;

public class BehGoToTileTarget : BehaviourActionActor
{
	public bool walk_on_water;

	public bool walk_on_blocks;

	public int limit_pathfinding_regions;

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
		walk_on_water = false;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.goTo(pActor.beh_tile_target, walk_on_water, walk_on_blocks, pWalkOnLava: false, limit_pathfinding_regions) == ExecuteEvent.False)
		{
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehGoToTileTarget.cs ---



// --- Start of File: BehGreenAntSwitchGround.cs ---
namespace ai.behaviours;

public class BehGreenAntSwitchGround : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("direction", out var pResult, 0);
		string pType;
		if (pActor.beh_tile_target.Type.liquid)
		{
			pType = "sand";
			pResult--;
		}
		else if (pActor.beh_tile_target.Type.IsType("sand"))
		{
			pType = "soil_low";
			pResult++;
		}
		else if (pActor.beh_tile_target.Type.IsType("soil_low"))
		{
			pType = "soil_high";
			pResult--;
		}
		else if (pActor.beh_tile_target.Type.IsType("soil_high"))
		{
			pType = "soil_low";
			pResult++;
		}
		else
		{
			pType = "sand";
			pResult--;
		}
		if (pResult > Toolbox.directions.Length - 1)
		{
			pResult = 0;
		}
		if (pResult < 0)
		{
			pResult = Toolbox.directions.Length - 1;
		}
		Ant.antUseOnTile(pActor.beh_tile_target, pType);
		pActor.data.set("direction", pResult);
		return BehResult.Continue;
	}
}
// --- End of File: BehGreenAntSwitchGround.cs ---



// --- Start of File: BehHeal.cs ---
namespace ai.behaviours;

public class BehHeal : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasMaxHealth())
		{
			return BehResult.Stop;
		}
		AssetManager.spells.get("cast_blood_rain").action?.Invoke(pActor, pActor, pActor.current_tile);
		pActor.doCastAnimation();
		return BehResult.Continue;
	}
}
// --- End of File: BehHeal.cs ---



// --- Start of File: BehJoinCity.cs ---
namespace ai.behaviours;

public class BehJoinCity : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.current_zone.city;
		if (city == null)
		{
			return BehResult.Stop;
		}
		if (!city.isPossibleToJoin(pActor))
		{
			return BehResult.Stop;
		}
		if (city.isNeutral())
		{
			if (pActor.kingdom.isCiv())
			{
				city.setKingdom(pActor.kingdom);
			}
			else
			{
				Kingdom kingdom = BehaviourActionBase<Actor>.world.kingdoms.makeNewCivKingdom(pActor);
				pActor.createDefaultCultureAndLanguageAndClan();
				city.setKingdom(kingdom);
				city.setUnitMetas(pActor);
				kingdom.setUnitMetas(pActor);
			}
		}
		if (city.kingdom != pActor.kingdom)
		{
			pActor.removeFromPreviousFaction();
		}
		pActor.joinCity(city);
		pActor.setMetasFromCity(city);
		return BehResult.Continue;
	}
}
// --- End of File: BehJoinCity.cs ---



// --- Start of File: BehJumpingAnimation.cs ---
namespace ai.behaviours;

public class BehJumpingAnimation : BehaviourActionActor
{
	private float _timer_action;

	private float _timer_jumping;

	public BehJumpingAnimation(float pTimerAction, float pTimerJumpAnimation)
	{
		_timer_action = pTimerAction;
		_timer_jumping = pTimerJumpAnimation;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.timer_jump_animation = _timer_jumping;
		pActor.timer_action = _timer_action;
		return BehResult.Continue;
	}
}
// --- End of File: BehJumpingAnimation.cs ---



// --- Start of File: BehKingCheckNewCityFoundation.cs ---
using System.Collections.Generic;
using UnityEngine;
using ai.behaviours;

public class BehKingCheckNewCityFoundation : BehaviourActionActor
{
	private const int MAX_MOVED = 6;

	private List<TileZone> _next_wave = new List<TileZone>();

	private List<TileZone> _wave = new List<TileZone>();

	private HashSet<TileZone> _checked_zones = new HashSet<TileZone>();

	private static Color _color1 = new Color(1f, 0f, 0f, 0.3f);

	private static Color _color2 = new Color(0f, 0f, 1f, 0.3f);

	private static Color _color3 = new Color(1f, 0.92f, 0.016f, 0.3f);

	private static Color _color4 = new Color(0f, 1f, 0f, 0.3f);

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_families = true;
		uses_cities = true;
		uses_kingdoms = true;
	}

	public override BehResult execute(Actor pActor)
	{
		Kingdom kingdom = pActor.kingdom;
		if (!kingdom.hasCapital())
		{
			return BehResult.Stop;
		}
		if (hasCitiesWithoutPopulation(kingdom))
		{
			return BehResult.Stop;
		}
		BehaviourActionBase<Actor>.world.city_zone_helper.city_place_finder.recalc();
		if (!BehaviourActionBase<Actor>.world.city_zone_helper.city_place_finder.hasPossibleZones())
		{
			return BehResult.Stop;
		}
		using ListPool<City> listPool = getCityListForExpansion(kingdom);
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		City pCityExpandFrom;
		TileZone tileZone = findZoneForExpansion(pActor, listPool, out pCityExpandFrom);
		if (tileZone == null)
		{
			return BehResult.Stop;
		}
		City pNewCity = BehaviourActionBase<Actor>.world.cities.buildNewCity(pActor, tileZone);
		moveSomeUnitsToNewCity(pNewCity, pCityExpandFrom);
		return BehResult.Continue;
	}

	private bool hasCitiesWithoutPopulation(Kingdom pKingdom)
	{
		WorldTile tile = pKingdom.capital.getTile();
		if (tile == null)
		{
			return false;
		}
		foreach (City city in pKingdom.getCities())
		{
			if (city.countUnits() <= 30)
			{
				WorldTile tile2 = city.getTile();
				if (tile2 != null && tile2.reachableFrom(tile))
				{
					return true;
				}
			}
		}
		return false;
	}

	private void moveSomeUnitsToNewCity(City pNewCity, City pFromCity)
	{
		int num = Mathf.Min(pFromCity.units.Count, 6);
		int num2 = 0;
		foreach (Actor item in pFromCity.units.LoopRandom())
		{
			if (isPossibleToMoveUnitToCity(item, pNewCity))
			{
				moveToCity(item, pNewCity);
				num2++;
				int num3 = checkUnitFamilyAndLovers(item, pNewCity, num2);
				num2 += num3;
				if (num2 >= num)
				{
					break;
				}
			}
		}
	}

	private int checkUnitFamilyAndLovers(Actor pActor, City pCity, int pMovedAlready)
	{
		int num = 0;
		if (pActor.hasLover())
		{
			Actor lover = pActor.lover;
			if (isPossibleToMoveUnitToCity(lover, pCity))
			{
				moveToCity(lover, pCity);
				num++;
			}
		}
		if (pActor.hasFamily())
		{
			foreach (Actor unit in pActor.family.units)
			{
				if (isPossibleToMoveUnitToCity(unit, pCity))
				{
					moveToCity(unit, pCity);
					num++;
				}
				if (num + pMovedAlready >= 6)
				{
					break;
				}
			}
		}
		return num;
	}

	private void moveToCity(Actor pActor, City pCity)
	{
		pActor.stopBeingWarrior();
		pActor.joinCity(pCity);
		pActor.cancelAllBeh();
	}

	private bool isPossibleToMoveUnitToCity(Actor pUnit, City pCity)
	{
		if (pUnit.isRekt())
		{
			return false;
		}
		if (!pUnit.isAdult())
		{
			return false;
		}
		if (pUnit.isCityLeader())
		{
			return false;
		}
		if (pUnit.isKing())
		{
			return false;
		}
		if (pUnit.isArmyGroupLeader())
		{
			return false;
		}
		if (pUnit.army != null)
		{
			return false;
		}
		if (pUnit.hasLover())
		{
			if (pUnit.lover.isKing())
			{
				return false;
			}
			if (pUnit.lover.isCityLeader())
			{
				return false;
			}
		}
		if (pUnit.city == pCity)
		{
			return false;
		}
		return true;
	}

	private TileZone findZoneForExpansion(Actor pActor, ListPool<City> pPossibleCitiesToExpandFrom, out City pCityExpandFrom)
	{
		pCityExpandFrom = null;
		TileZone tileZone = null;
		foreach (ref City item in pPossibleCitiesToExpandFrom)
		{
			City current = item;
			TileZone tileZone2 = findZoneForCityOnTheSameIsland2(pActor, current);
			if (tileZone2 != null)
			{
				pCityExpandFrom = current;
				tileZone = tileZone2;
				break;
			}
		}
		if (tileZone == null)
		{
			foreach (ref City item2 in pPossibleCitiesToExpandFrom)
			{
				City current2 = item2;
				if (current2.hasTransportBoats())
				{
					TileZone tileZone3 = findZoneForCityOnFarIsland(pActor, current2);
					if (tileZone3 != null)
					{
						pCityExpandFrom = current2;
						tileZone = tileZone3;
						break;
					}
				}
			}
		}
		return tileZone;
	}

	private TileZone findZoneForCityOnFarIsland(Actor pActor, City pCity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		TileZone result = null;
		int num = int.MaxValue;
		WorldTile tile = pCity.getTile();
		if (tile == null)
		{
			return null;
		}
		Vector2Int pos = tile.pos;
		foreach (TileZone zone in BehaviourActionBase<Actor>.world.city_zone_helper.city_place_finder.zones)
		{
			int num2 = Toolbox.SquaredDistVec2(zone.centerTile.pos, pos);
			if (num2 <= num && tile.reachableFrom(zone.centerTile) && zone.checkCanSettleInThisBiomes(pActor.subspecies))
			{
				num = num2;
				result = zone;
			}
		}
		return result;
	}

	private TileZone findZoneForCityOnTheSameIsland2(Actor pActor, City pMainCity)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		WorldTile tile = pMainCity.getTile();
		if (tile == null)
		{
			return null;
		}
		using ListPool<TileZone> listPool = new ListPool<TileZone>();
		bool flag = DebugConfig.isOn(DebugOption.CitySettleCalc);
		if (flag)
		{
			DebugHighlight.clear();
		}
		foreach (City city in pMainCity.kingdom.getCities())
		{
			if (city != pMainCity)
			{
				continue;
			}
			WorldTile tile2 = city.getTile();
			if (tile2 == null || !tile.isSameIsland(tile2))
			{
				continue;
			}
			foreach (TileZone neighbour_zone in city.neighbour_zones)
			{
				if (!neighbour_zone.hasCity())
				{
					_wave.Add(neighbour_zone);
					_checked_zones.Add(neighbour_zone);
				}
			}
		}
		int num = 0;
		while (_wave.Count > 0)
		{
			if (flag)
			{
				switch (num)
				{
				case 0:
					DebugHighlight.newHighlightList(_color1, _wave);
					break;
				case 1:
					DebugHighlight.newHighlightList(_color2, _wave);
					break;
				case 2:
					DebugHighlight.newHighlightList(_color3, _wave);
					break;
				case 3:
					DebugHighlight.newHighlightList(_color4, _wave);
					break;
				}
			}
			startWave(num, tile, listPool, pActor);
			if (_next_wave.Count > 0)
			{
				_wave.AddRange(_next_wave);
				_next_wave.Clear();
				num++;
				if (num >= 4)
				{
					break;
				}
			}
		}
		_wave.Clear();
		_checked_zones.Clear();
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	private void startWave(int pWave, WorldTile pCityTile, ListPool<TileZone> pGoodZones, Actor pActor)
	{
		List<TileZone> wave = _wave;
		HashSet<TileZone> checked_zones = _checked_zones;
		while (wave.Count > 0)
		{
			TileZone tileZone = wave.Pop();
			checked_zones.Add(tileZone);
			if (pWave > 2 && tileZone.isGoodForNewCity(pActor) && tileZone.centerTile.isSameIsland(pCityTile))
			{
				pGoodZones.Add(tileZone);
			}
			TileZone[] neighbours = tileZone.neighbours;
			foreach (TileZone tileZone2 in neighbours)
			{
				if (checked_zones.Add(tileZone2) && !tileZone2.hasCity())
				{
					_next_wave.Add(tileZone2);
				}
			}
		}
	}

	private ListPool<City> getCityListForExpansion(Kingdom pKingdom)
	{
		ListPool<City> listPool = new ListPool<City>(pKingdom.countCities());
		foreach (City city in pKingdom.getCities())
		{
			if (city.getTile() != null && city.status.population_adults >= 30 && !city.needSettlers())
			{
				listPool.Add(city);
			}
		}
		listPool.Shuffle();
		return listPool;
	}

	private TileZone findCityForMigration(City pCity)
	{
		WorldTile tile = pCity.getTile();
		if (tile == null)
		{
			return null;
		}
		foreach (City item in pCity.kingdom.getCities().LoopRandom())
		{
			if (item == pCity)
			{
				continue;
			}
			WorldTile tile2 = item.getTile();
			if (tile2 != null && tile.reachableFrom(tile2) && item.needSettlers())
			{
				TileZone tileZone = item.getTile()?.zone;
				if (tileZone != null)
				{
					return tileZone;
				}
			}
		}
		return null;
	}
}
// --- End of File: BehKingCheckNewCityFoundation.cs ---



// --- Start of File: BehLaunchFireworks.cs ---
using ai.behaviours;

public class BehLaunchFireworks : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasEnoughMoney(SimGlobals.m.festive_fireworks_cost))
		{
			return BehResult.Stop;
		}
		pActor.finishStatusEffect("festive_spirit");
		spawnFireworksByUnit(pActor);
		pActor.spendMoney(SimGlobals.m.festive_fireworks_cost);
		return BehResult.Continue;
	}

	internal void spawnFireworksByUnit(Actor pActor)
	{
		EffectsLibrary.spawn("fx_fireworks", pActor.current_tile);
	}
}
// --- End of File: BehLaunchFireworks.cs ---



// --- Start of File: BehLookAtBuildingTarget.cs ---
namespace ai.behaviours;

public class BehLookAtBuildingTarget : BehActorBuildingTarget
{
	private float _timer;

	public BehLookAtBuildingTarget(float pTimer = 0.3f)
	{
		_timer = pTimer;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		pActor.lookTowardsPosition(pActor.beh_building_target.current_position);
		pActor.timer_action = _timer;
		return BehResult.Continue;
	}
}
// --- End of File: BehLookAtBuildingTarget.cs ---



// --- Start of File: BehMadnessRandomEmotion.cs ---
using ai.behaviours;

public class BehMadnessRandomEmotion : BehaviourActionActor
{
	private const int STATUS_DURATION = 10;

	public override BehResult execute(Actor pActor)
	{
		if (Randy.randomBool())
		{
			using (ListPool<string> listPool = new ListPool<string>())
			{
				listPool.Add("laughing");
				listPool.Add("crying");
				listPool.Add("swearing");
				string random = listPool.GetRandom();
				pActor.addStatusEffect(random, 10f, pColorEffect: false);
				return BehResult.Continue;
			}
		}
		using ListPool<string> listPool2 = new ListPool<string>();
		listPool2.Add("happy_laughing");
		listPool2.Add("crying");
		listPool2.Add("swearing");
		if (listPool2.Count == 0)
		{
			return BehResult.Stop;
		}
		string random2 = listPool2.GetRandom();
		return forceTask(pActor, random2, pClean: false, pForceAction: true);
	}
}
// --- End of File: BehMadnessRandomEmotion.cs ---



// --- Start of File: BehMagicMakeSkeleton.cs ---
namespace ai.behaviours;

public class BehMagicMakeSkeleton : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		int num = 0;
		foreach (Actor item in Finder.findSpeciesAroundTileChunk(pActor.current_tile, "skeleton"))
		{
			_ = item;
			if (num++ > 6)
			{
				return BehResult.Stop;
			}
		}
		WorldTile worldTile = pActor.current_tile?.region?.tiles.GetRandom();
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		if (worldTile.hasUnits())
		{
			return BehResult.Stop;
		}
		pActor.doCastAnimation();
		ActionLibrary.spawnSkeleton(pActor, worldTile);
		return BehResult.Continue;
	}
}
// --- End of File: BehMagicMakeSkeleton.cs ---



// --- Start of File: BehMakeDecision.cs ---
using ai.behaviours;

public class BehMakeDecision : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.isEgg())
		{
			return BehResult.Stop;
		}
		pActor.batch.c_make_decision.Add(pActor);
		return BehResult.Stop;
	}
}
// --- End of File: BehMakeDecision.cs ---



// --- Start of File: BehMakeFarm.cs ---
namespace ai.behaviours;

public class BehMakeFarm : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.beh_tile_target.Type.can_be_farm)
		{
			return BehResult.Stop;
		}
		if (pActor.beh_tile_target.hasBuilding() && !pActor.beh_tile_target.building.canRemoveForFarms())
		{
			return BehResult.Stop;
		}
		MapAction.terraformTop(pActor.beh_tile_target, TopTileLibrary.field);
		MusicBox.playSound("event:/SFX/CIVILIZATIONS/MakeFarmField", pActor.beh_tile_target, pGameViewOnly: true, pVisibleOnly: true);
		pActor.addLoot(SimGlobals.m.coins_for_field);
		return BehResult.Continue;
	}
}
// --- End of File: BehMakeFarm.cs ---



// --- Start of File: BehMakeItem.cs ---
namespace ai.behaviours;

public class BehMakeItem : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		ItemCrafting.tryToCraftRandomWeapon(pActor, pActor.city);
		for (int i = 0; i < 5; i++)
		{
			if (!ItemCrafting.tryToCraftRandomEquipment(pActor, pActor.city))
			{
				break;
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehMakeItem.cs ---



// --- Start of File: BehMoveAwayFromBlock.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehMoveAwayFromBlock : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.current_tile.region.island.type != TileLayerType.Block)
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		int num = int.MaxValue;
		worldTile = getBestTileToMove(pActor.current_tile.region, pActor);
		if (worldTile == null)
		{
			foreach (MapRegion neighbour in pActor.current_tile.region.neighbours)
			{
				WorldTile bestTileToMove = getBestTileToMove(neighbour, pActor);
				if (bestTileToMove != null)
				{
					int num2 = Toolbox.SquaredDistTile(pActor.current_tile, bestTileToMove);
					if (num2 < num)
					{
						worldTile = bestTileToMove;
						num = num2;
					}
				}
			}
		}
		if (worldTile == null)
		{
			foreach (MapRegion insideRegionEdge in pActor.current_tile.region.island.insideRegionEdges)
			{
				WorldTile bestTileToMove2 = getBestTileToMove(insideRegionEdge, pActor);
				if (bestTileToMove2 != null)
				{
					int num3 = Toolbox.SquaredDistTile(pActor.current_tile, bestTileToMove2);
					if (num3 < num)
					{
						worldTile = bestTileToMove2;
						num = num3;
					}
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}

	private static WorldTile getBestTileToMove(MapRegion pRegion, Actor pActor)
	{
		List<WorldTile> edgeTiles = pRegion.getEdgeTiles();
		if (edgeTiles.Count == 0)
		{
			return null;
		}
		WorldTile current_tile = pActor.current_tile;
		WorldTile result = null;
		int num = int.MaxValue;
		TileIsland island = current_tile.region.island;
		foreach (WorldTile item in edgeTiles.LoopRandom())
		{
			int num2 = Toolbox.SquaredDistTile(current_tile, item);
			if (num2 < num)
			{
				MapRegion region = item.region;
				if (isGoodTileRegion(region, pActor) && region.island != island && region.island.getTileCount() > 5)
				{
					result = item;
					num = num2;
				}
			}
		}
		return result;
	}

	private static bool isGoodTileRegion(MapRegion pRegion, Actor pActor)
	{
		if (pRegion.type == TileLayerType.Ocean && pActor.isDamagedByOcean())
		{
			return false;
		}
		if (pRegion.type == TileLayerType.Lava && pActor.asset.die_in_lava)
		{
			return false;
		}
		return true;
	}
}
// --- End of File: BehMoveAwayFromBlock.cs ---



// --- Start of File: BehNectarNectarFromFlower.cs ---
namespace ai.behaviours;

public class BehNectarNectarFromFlower : BehActorUsableBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (pActor.beh_building_target.asset.type != "type_flower")
		{
			return BehResult.Stop;
		}
		if (pActor.beh_building_target.isAlive())
		{
			int pVal = (int)((float)pActor.beh_building_target.asset.nutrition_restore * 0.5f);
			pActor.addNutritionFromEating(pVal, pSetMaxNutrition: false, pSetJustAte: true);
			pActor.countConsumed();
		}
		WorldTile current_tile = pActor.beh_building_target.current_tile;
		pActor.punchTargetAnimation(current_tile.posV3, pFlip: false);
		return BehResult.Continue;
	}
}
// --- End of File: BehNectarNectarFromFlower.cs ---



// --- Start of File: BehPlantCrops.cs ---
namespace ai.behaviours;

public class BehPlantCrops : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.beh_tile_target.Type == TopTileLibrary.field && !pActor.beh_tile_target.hasBuilding())
		{
			BehaviourActionBase<Actor>.world.buildings.addBuilding("wheat", pActor.beh_tile_target);
			pActor.addLoot(SimGlobals.m.coins_for_planting);
			MusicBox.playSound("event:/SFX/CIVILIZATIONS/PlantCrops", pActor.beh_tile_target, pGameViewOnly: true);
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehPlantCrops.cs ---



// --- Start of File: BehPollinate.cs ---
namespace ai.behaviours;

public class BehPollinate : BehaviourActionActor
{
	public BehPollinate()
	{
		land_if_hovering = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.current_tile.hasBuilding())
		{
			return BehResult.Stop;
		}
		if (pActor.current_tile.building.asset.type == "type_flower")
		{
			pActor.data.pollen++;
			pActor.current_tile.pollinate();
			if (pActor.asset.id != "bee" && pActor.data.pollen >= 10)
			{
				pActor.data.pollen -= 10;
				if (pActor.isKingdomCiv())
				{
					pActor.addToInventory("honey", 1);
				}
			}
		}
		pActor.timer_action = Randy.randomFloat(4f, 10f);
		return BehResult.Continue;
	}
}
// --- End of File: BehPollinate.cs ---



// --- Start of File: BehPoopInside.cs ---
using ai.behaviours;

public class BehPoopInside : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.donePooping();
		string text = ((!pActor.hasSubspecies()) ? "poop" : pActor.subspecies.getRandomBioProduct());
		if (text != "poop")
		{
			BuildingHelper.tryToBuildNear(pActor.current_tile, text);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehPoopInside.cs ---



// --- Start of File: BehPoopOutside.cs ---
using ai.behaviours;

public class BehPoopOutside : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.poop(pApplyForce: true);
		return BehResult.Continue;
	}
}
// --- End of File: BehPoopOutside.cs ---



// --- Start of File: BehPrinterSetup.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehPrinterSetup : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		pActor.data.get("step", out var pResult, -1);
		if (pResult < 0)
		{
			ActorData data = pActor.data;
			Vector2Int pos = pActor.current_tile.pos;
			data.set("origin_x", ((Vector2Int)(ref pos)).x);
			ActorData data2 = pActor.data;
			pos = pActor.current_tile.pos;
			data2.set("origin_y", ((Vector2Int)(ref pos)).y);
			pActor.data.get("template", out var pResult2, null);
			PrintTemplate template = PrintLibrary.getTemplate(pResult2);
			pActor.data.set("steps", template.steps.Length);
			pActor.data.set("step", 0);
		}
		pActor.data.get("steps", out var pResult3, -1);
		if (pResult >= pResult3)
		{
			pActor.dieSimpleNone();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehPrinterSetup.cs ---



// --- Start of File: BehPrinterStep.cs ---
namespace ai.behaviours;

public class BehPrinterStep : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("template", out var pResult, null);
		pActor.data.get("step", out var pResult2, -1);
		pActor.data.get("origin_x", out var pResult3, 0);
		pActor.data.get("origin_y", out var pResult4, 0);
		PrintTemplate template = PrintLibrary.getTemplate(pResult);
		for (int i = 0; i < template.steps_per_tick; i++)
		{
			if (pResult2 >= template.steps.Length)
			{
				pActor.data.set("step", pResult2);
				return BehResult.Stop;
			}
			PrintStep printStep = template.steps[pResult2];
			WorldTile tile = BehaviourActionBase<Actor>.world.GetTile(pResult3 + printStep.x, pResult4 + printStep.y);
			if (tile != null)
			{
				pActor.spawnOn(tile);
				printTile(pActor);
			}
			pResult2++;
		}
		pActor.data.set("step", pResult2);
		return BehResult.RestartTask;
	}

	private static void printTile(Actor pActor)
	{
		MusicBox.playSound("event:/SFX/UNIQUE/PrinterStep", pActor.current_tile);
		if (pActor.current_tile.top_type != null)
		{
			MapAction.decreaseTile(pActor.current_tile, pDamage: false);
		}
		if (pActor.current_tile.Type.increase_to != null)
		{
			MapAction.terraformMain(pActor.current_tile, pActor.current_tile.Type.increase_to, AssetManager.terraform.get("destroy"));
			BehaviourActionBase<Actor>.world.setTileDirty(pActor.current_tile);
		}
		BehaviourActionBase<Actor>.world.conway_layer.remove(pActor.current_tile);
	}
}
// --- End of File: BehPrinterStep.cs ---



// --- Start of File: BehRandomSocializeTopic.cs ---
using ai.behaviours;

public class BehRandomSocializeTopic : BehaviourActionActor
{
	private float _timer_min;

	private float _timer_max;

	private float _chance;

	public BehRandomSocializeTopic(float pMinTimer, float pMaxTimer, float pChance)
	{
		socialize = true;
		_timer_min = pMinTimer;
		_timer_max = pMaxTimer;
		_chance = pChance;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.clearLastTopicSprite();
		if (!pActor.hasSubspecies())
		{
			return BehResult.Stop;
		}
		if (!pActor.subspecies.has_advanced_communication)
		{
			return BehResult.Stop;
		}
		if (!Randy.randomChance(_chance))
		{
			return BehResult.Stop;
		}
		float pValue = Randy.randomFloat(_timer_min, _timer_max);
		pActor.makeWait(pValue);
		return BehResult.Continue;
	}
}
// --- End of File: BehRandomSocializeTopic.cs ---



// --- Start of File: BehRandomSwim.cs ---
namespace ai.behaviours;

public class BehRandomSwim : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		BehaviourActionActor.possible_moves.Clear();
		WorldTile[] neighboursAll = pActor.current_tile.neighboursAll;
		foreach (WorldTile worldTile in neighboursAll)
		{
			if (worldTile.Type.liquid)
			{
				BehaviourActionActor.possible_moves.Add(worldTile);
			}
		}
		if (BehaviourActionActor.possible_moves.Count > 0)
		{
			WorldTile random = BehaviourActionActor.possible_moves.GetRandom();
			BehaviourActionActor.possible_moves.Clear();
			pActor.moveTo(random);
			pActor.setTileTarget(random);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehRandomSwim.cs ---



// --- Start of File: BehRandomTeleport.cs ---
namespace ai.behaviours;

public class BehRandomTeleport : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasMaxHealth())
		{
			return BehResult.Stop;
		}
		if (!Randy.randomChance(0.3f))
		{
			return BehResult.Stop;
		}
		SpellAsset spellAsset = AssetManager.spells.get("teleport");
		bool flag = false;
		if (spellAsset.action != null)
		{
			flag = spellAsset.action.RunAnyTrue(pActor, pActor, pActor.current_tile);
		}
		if (flag)
		{
			pActor.doCastAnimation();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehRandomTeleport.cs ---



// --- Start of File: BehRandomWait.cs ---
namespace ai.behaviours;

public class BehRandomWait : BehaviourActionActor
{
	private float min;

	private float max;

	public BehRandomWait(float pMin = 0f, float pMax = 1f, bool pLand = false)
	{
		min = pMin;
		max = pMax;
		land_if_hovering = pLand;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.timer_action = Randy.randomFloat(min, max);
		return BehResult.Continue;
	}
}
// --- End of File: BehRandomWait.cs ---



// --- Start of File: BehReflection.cs ---
using ai.behaviours;

public class BehReflection : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		int happiness = pActor.getHappiness();
		bool flag = happiness > 50;
		bool flag2 = happiness < -70;
		using ListPool<string> listPool = new ListPool<string>();
		if (pActor.subspecies.hasTrait("super_positivity"))
		{
			fillFromSuperPositivity(pActor, listPool);
		}
		else
		{
			fillFromHappinessHistory(pActor, listPool);
			if (pActor.hasTrait("hotheaded"))
			{
				listPool.Add("swearing");
				listPool.Add("swearing");
				listPool.Add("swearing");
				listPool.Add("swearing");
			}
			if (pActor.subspecies.hasTrait("aggressive") && happiness < 0)
			{
				listPool.Add("start_tantrum");
			}
			if (pActor.hasTrait("hotheaded") && happiness < 0)
			{
				listPool.Add("start_tantrum");
			}
			if (flag)
			{
				listPool.Add("happy_laughing");
				listPool.Add("happy_laughing");
				listPool.Add("happy_laughing");
				listPool.Add("singing");
				if (pActor.hasLanguage() && pActor.language.hasTrait("melodic"))
				{
					listPool.Add("singing");
					listPool.Add("singing");
					listPool.Add("singing");
					listPool.Add("singing");
				}
				if (pActor.isBaby())
				{
					listPool.Add("child_random_flips");
					listPool.Add("child_random_flips");
					listPool.Add("child_play_at_one_spot");
					listPool.Add("child_play_at_one_spot");
					listPool.Add("child_random_jump");
					listPool.Add("child_random_jump");
				}
				else
				{
					listPool.Add("wait5");
				}
			}
			else if (flag2)
			{
				if (!pActor.hasTag("strong_mind"))
				{
					listPool.Add("crying");
					listPool.Add("crying");
					if (happiness <= -100)
					{
						listPool.Add("crying");
						listPool.Add("crying");
						listPool.Add("crying");
						listPool.Add("start_tantrum");
					}
					listPool.Add("start_tantrum");
				}
				listPool.Add("swearing");
				listPool.Add("swearing");
				listPool.Add("punch_a_tree");
				listPool.Add("punch_a_tree");
				listPool.Add("punch_a_building");
				listPool.Add("punch_a_building");
				listPool.Add("wait5");
				if (pActor.hasTrait("pyromaniac"))
				{
					listPool.Add("start_fire");
				}
			}
			else
			{
				listPool.Add("wait5");
			}
		}
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		string random = listPool.GetRandom();
		return forceTask(pActor, random, pClean: false, pForceAction: true);
	}

	private void fillFromHappinessHistory(Actor pActor, ListPool<string> pPot)
	{
		if (!pActor.hasHappinessHistory())
		{
			return;
		}
		foreach (HappinessHistory item in pActor.happiness_change_history)
		{
			HappinessAsset asset = item.asset;
			if (asset.pot_task_id != null)
			{
				for (int i = 0; i < asset.pot_amount; i++)
				{
					pPot.Add(asset.pot_task_id);
				}
			}
		}
	}

	private void fillFromSuperPositivity(Actor pActor, ListPool<string> pPot)
	{
		pPot.Add("happy_laughing");
		pPot.Add("happy_laughing");
		pPot.Add("happy_laughing");
		pPot.Add("singing");
		pPot.Add("child_random_flips");
		pPot.Add("child_play_at_one_spot");
		pPot.Add("child_random_jump");
	}
}
// --- End of File: BehReflection.cs ---



// --- Start of File: BehRemoveRuins.cs ---
namespace ai.behaviours;

public class BehRemoveRuins : BehActorBuildingTarget
{
	public override BehResult execute(Actor pActor)
	{
		BuildingAsset asset = pActor.beh_building_target.asset;
		switch (asset.building_type)
		{
		case BuildingType.Building_Tree:
			if (asset.hasResourceGiven("wood"))
			{
				pActor.addToInventory("wood", 1);
			}
			break;
		case BuildingType.Building_Civ:
			if (asset.cost.wood > 0)
			{
				pActor.addToInventory("wood", 1);
			}
			if (asset.cost.stone > 0)
			{
				pActor.addToInventory("stone", 1);
			}
			break;
		}
		pActor.beh_building_target.startDestroyBuilding();
		pActor.addLoot(SimGlobals.m.coins_for_cleaning);
		return BehResult.Continue;
	}
}
// --- End of File: BehRemoveRuins.cs ---



// --- Start of File: BehRepairEquipment.cs ---
using ai.behaviours;

public class BehRepairEquipment : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		bool flag = false;
		foreach (ActorEquipmentSlot item2 in pActor.equipment)
		{
			if (item2.isEmpty())
			{
				continue;
			}
			Item item = item2.getItem();
			if (item.needRepair())
			{
				int pCost = (int)((float)item2.getItem().getAsset().cost_gold * SimGlobals.m.item_repair_cost_multiplier);
				if (pActor.hasEnoughMoney(pCost))
				{
					pActor.spendMoney(pCost);
					item.fullRepair();
					flag = true;
				}
			}
		}
		if (flag)
		{
			pActor.setStatsDirty();
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehRepairEquipment.cs ---



// --- Start of File: BehRepairInDock.cs ---
using System;

namespace ai.behaviours;

public class BehRepairInDock : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasMaxHealth())
		{
			return BehResult.Continue;
		}
		int num = pActor.getMaxHealth() - pActor.getHealth();
		num = ((num > 100) ? 100 : num);
		pActor.restoreHealth(num);
		float num2 = num / 25;
		pActor.timer_action = (float)Math.Ceiling(num2);
		pActor.stayInBuilding(pActor.beh_building_target);
		pActor.beh_tile_target = null;
		pActor.beh_building_target.startShake(0.5f);
		if (!pActor.hasMaxHealth())
		{
			return BehResult.RepeatStep;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehRepairInDock.cs ---



// --- Start of File: BehRepeatTaskChance.cs ---
namespace ai.behaviours;

public class BehRepeatTaskChance : BehaviourActionActor
{
	private float chance;

	public BehRepeatTaskChance(float pChance = 0.5f)
	{
		chance = pChance;
	}

	public override BehResult execute(Actor pActor)
	{
		if (Randy.randomChance(chance))
		{
			return BehResult.RestartTask;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehRepeatTaskChance.cs ---



// --- Start of File: BehReplenishEnergy.cs ---
namespace ai.behaviours;

public class BehReplenishEnergy : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.setMaxMana();
		pActor.setMaxStamina();
		return BehResult.Continue;
	}
}
// --- End of File: BehReplenishEnergy.cs ---



// --- Start of File: BehReplenishNutrition.cs ---
namespace ai.behaviours;

public class BehReplenishNutrition : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.addNutritionFromEating(pActor.getMaxNutrition(), pSetMaxNutrition: false, pSetJustAte: true);
		pActor.countConsumed();
		return BehResult.Continue;
	}
}
// --- End of File: BehReplenishNutrition.cs ---



// --- Start of File: BehResourceGatheringAnimation.cs ---
namespace ai.behaviours;

public class BehResourceGatheringAnimation : BehaviourActionActor
{
	private float _timer_action;

	private string _sound_event_id;

	public BehResourceGatheringAnimation(float pTimerAction, string pSound = "", bool pLandIfHovering = true)
	{
		_sound_event_id = pSound;
		_timer_action = pTimerAction;
		land_if_hovering = pLandIfHovering;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_building_target = true;
		check_building_target_non_usable = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (pActor.beh_building_target.asset.gatherable && !pActor.beh_building_target.hasResourcesToCollect())
		{
			return BehResult.Stop;
		}
		pActor.punchTargetAnimation(pActor.beh_building_target.current_tile.posV3);
		pActor.beh_building_target.resourceGathering(BehaviourActionBase<Actor>.world.elapsed);
		pActor.beh_building_target.startShake(0.01f);
		if (!string.IsNullOrEmpty(_sound_event_id))
		{
			MusicBox.playSound(_sound_event_id, pActor.beh_building_target.current_tile, pGameViewOnly: true, pVisibleOnly: true);
		}
		pActor.timer_action = _timer_action;
		return BehResult.Continue;
	}
}
// --- End of File: BehResourceGatheringAnimation.cs ---



// --- Start of File: BehRestartTask.cs ---
namespace ai.behaviours;

public class BehRestartTask : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		return BehResult.RestartTask;
	}
}
// --- End of File: BehRestartTask.cs ---



// --- Start of File: BehRestoreStats.cs ---
using ai.behaviours;

public class BehRestoreStats : BehaviourActionActor
{
	private readonly float _health;

	private readonly float _mana;

	public BehRestoreStats(float pHealth = 0f, float pMana = 0f)
	{
		_health = pHealth;
		_mana = pMana;
	}

	public override BehResult execute(Actor pActor)
	{
		if (_health != 0f)
		{
			pActor.restoreHealthPercent(_health);
		}
		if (_mana != 0f)
		{
			pActor.restoreManaPercent(_mana);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehRestoreStats.cs ---



// --- Start of File: BehResult.cs ---
namespace ai.behaviours;

public enum BehResult
{
	Continue,
	Stop,
	RepeatStep,
	Skip,
	StepBack,
	RestartTask,
	ActiveTaskReturn,
	ImmediateRun
}
// --- End of File: BehResult.cs ---



// --- Start of File: BehSandspiderBuildSand.cs ---
namespace ai.behaviours;

public class BehSandspiderBuildSand : BehGoToTileTarget
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (!pActor.beh_tile_target.Type.IsType("sand"))
		{
			pActor.data.get("ant_steps", out var pResult, 0);
			Ant.antUseOnTile(pActor.beh_tile_target, "sand");
			pActor.data.set("ant_steps", ++pResult);
			pActor.data.removeBool("changed_direction");
		}
		else if (Randy.randomChance(0.1f))
		{
			pActor.data.get("ant_steps", out var pResult2, 0);
			pActor.data.set("ant_steps", ++pResult2);
			pActor.data.removeBool("changed_direction");
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehSandspiderBuildSand.cs ---



// --- Start of File: BehSandspiderCheckDie.cs ---
namespace ai.behaviours;

public class BehSandspiderCheckDie : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("ant_steps", out var pResult, 0);
		if (pActor.beh_tile_target == null || pResult > 20)
		{
			pActor.dieSimpleNone();
			return BehResult.Stop;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehSandspiderCheckDie.cs ---



// --- Start of File: BehSandspiderCheckSand.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehSandspiderCheckSand : BehaviourActionActor
{
	private static List<int> _list_directions = new List<int>(3);

	public override BehResult execute(Actor pActor)
	{
		WorldTile beh_tile_target = pActor.beh_tile_target;
		if (beh_tile_target == null)
		{
			return BehResult.Continue;
		}
		pActor.data.get("changed_direction", out var pResult, pDefault: false);
		if (!pResult && beh_tile_target.Type.IsType("sand"))
		{
			pActor.data.get("direction", out var pResult2, 0);
			int newDirectionIndex = getNewDirectionIndex(pResult2);
			pActor.data.set("direction", newDirectionIndex);
			pActor.data.set("changed_direction", pData: true);
			return BehResult.RestartTask;
		}
		return BehResult.Continue;
	}

	private static int getNewDirectionIndex(int pOldIndex)
	{
		_list_directions.Clear();
		for (int i = 0; i < Toolbox.directions.Length; i++)
		{
			if (i != pOldIndex)
			{
				_list_directions.Add(i);
			}
		}
		return _list_directions.GetRandom();
	}
}
// --- End of File: BehSandspiderCheckSand.cs ---



// --- Start of File: BehSetActorSpeed.cs ---
namespace ai.behaviours;

public class BehSetActorSpeed : BehaviourActionActor
{
	private float speed;

	public BehSetActorSpeed(float pSpeed = 0f)
	{
		speed = pSpeed;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.stats["speed"] = speed;
		return BehResult.Continue;
	}
}
// --- End of File: BehSetActorSpeed.cs ---



// --- Start of File: BehSetNextTask.cs ---
namespace ai.behaviours;

public class BehSetNextTask : BehaviourActionActor
{
	private bool _clean;

	private bool _force;

	private string _task_id;

	public BehSetNextTask(string taskID, bool pClean = true, bool pForce = false)
	{
		_task_id = taskID;
		_clean = pClean;
		_force = pForce;
	}

	public override BehResult execute(Actor pActor)
	{
		return forceTask(pActor, _task_id, _clean, _force);
	}
}
// --- End of File: BehSetNextTask.cs ---



// --- Start of File: BehSexualReproductionTry.cs ---
using ai.behaviours;

public class BehSexualReproductionTry : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		base.execute(pActor);
		bool flag = (pActor.hasHouseCityInBordersAndSameIsland() ? true : false);
		pActor.subspecies.counter_reproduction_sexual_try?.registerEvent();
		if (flag)
		{
			return forceTask(pActor, "sexual_reproduction_inside", pClean: false, pForceAction: true);
		}
		return forceTask(pActor, "sexual_reproduction_check_outside", pClean: false, pForceAction: true);
	}
}
// --- End of File: BehSexualReproductionTry.cs ---



// --- Start of File: BehShakeBuilding.cs ---
namespace ai.behaviours;

public class BehShakeBuilding : BehaviourActionActor
{
	private float _shake_time;

	private float _shake_intensity_x;

	private float _shake_intensity_y;

	public BehShakeBuilding(float pShakeParam = 0.7f, float pIntensityX = 0.04f, float pIntensityY = 0.04f)
	{
		_shake_time = pShakeParam;
		_shake_intensity_x = pIntensityX;
		_shake_intensity_y = pIntensityY;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.beh_building_target.startShake(_shake_time, _shake_intensity_x, _shake_intensity_y);
		return BehResult.Continue;
	}
}
// --- End of File: BehShakeBuilding.cs ---



// --- Start of File: BehShortRandomMove.cs ---
namespace ai.behaviours;

public class BehShortRandomMove : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		foreach (WorldTile item in pActor.current_tile.neighboursAll.LoopRandom())
		{
			if (item.Type.layer_type == pActor.current_tile.Type.layer_type)
			{
				pActor.beh_tile_target = item;
				return BehResult.Continue;
			}
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehShortRandomMove.cs ---



// --- Start of File: BehSkeletonFindTile.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehSkeletonFindTile : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		using (IEnumerator<Actor> enumerator = Finder.findSpeciesAroundTileChunk(pActor.current_tile, "necromancer").GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Actor current = enumerator.Current;
				pActor.beh_tile_target = current.current_tile.region.tiles.GetRandom();
				return BehResult.Continue;
			}
		}
		MapRegion mapRegion = pActor.current_tile.region;
		if (mapRegion.neighbours.Count > 0 && Randy.randomBool())
		{
			mapRegion = mapRegion.neighbours.GetRandom();
		}
		if (mapRegion.tiles.Count > 0)
		{
			pActor.beh_tile_target = mapRegion.tiles.GetRandom();
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehSkeletonFindTile.cs ---



// --- Start of File: BehSocializeStartCheck.cs ---
using ai.behaviours;

public class BehSocializeStartCheck : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		base.execute(pActor);
		if (pActor.hasTelepathicLink())
		{
			return forceTask(pActor, "socialize_try_to_start_immediate", pClean: false);
		}
		if (pActor.hasCity() && pActor.city.hasBuildingType("type_bonfire", pCountOnlyFinished: true, pActor.current_island))
		{
			return forceTask(pActor, "socialize_try_to_start_near_bonfire", pClean: false);
		}
		return forceTask(pActor, "socialize_try_to_start_immediate", pClean: false);
	}
}
// --- End of File: BehSocializeStartCheck.cs ---



// --- Start of File: BehSocializeTalk.cs ---
using ai.behaviours;

public class BehSocializeTalk : BehaviourActionActor
{
	public BehSocializeTalk()
	{
		socialize = true;
	}
}
// --- End of File: BehSocializeTalk.cs ---



// --- Start of File: BehSpawnCityBorderEffect.cs ---
using ai.behaviours;

public class BehSpawnCityBorderEffect : BehaviourActionActor
{
	private int _amount;

	public BehSpawnCityBorderEffect(int pAmount = 1)
	{
		_amount = pAmount;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		_ = pActor.current_tile.zone;
		for (int i = 0; i < _amount; i++)
		{
			WorldTile random = pActor.current_tile.neighbours.GetRandom();
			EffectsLibrary.spawnAt("fx_new_border", random.posV, 0.25f);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnCityBorderEffect.cs ---



// --- Start of File: BehSpawnHeartsFromBuilding.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehSpawnHeartsFromBuilding : BehaviourActionActor
{
	private float _amount;

	public BehSpawnHeartsFromBuilding(float pAmount = 1f)
	{
		_amount = pAmount;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasLover())
		{
			pActor.addAfterglowStatus();
			pActor.lover.addAfterglowStatus();
			spawnHearts(pActor);
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}

	private void spawnHearts(Actor pActor)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Building beh_building_target = pActor.beh_building_target;
		Vector3 pPos = default(Vector3);
		for (int i = 0; (float)i < _amount; i++)
		{
			float num = (float)beh_building_target.current_tile.x + Randy.randomFloat(-1f, 1f);
			float num2 = (float)beh_building_target.current_tile.y + Randy.randomFloat(0f, 1f) + 2f;
			((Vector3)(ref pPos))._002Ector(num, num2);
			EffectsLibrary.spawnAt("fx_hearts", pPos, 0.15f);
		}
	}
}
// --- End of File: BehSpawnHeartsFromBuilding.cs ---



// --- Start of File: BehSpawnHmmEffect.cs ---
using ai.behaviours;

public class BehSpawnHmmEffect : BehaviourActionActor
{
	private int _amount;

	public BehSpawnHmmEffect(int pAmount = 1)
	{
		_amount = pAmount;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		_ = pActor.current_tile.zone;
		for (int i = 0; i < _amount; i++)
		{
			WorldTile random = pActor.current_tile.neighbours.GetRandom();
			EffectsLibrary.spawnAt("fx_hmm", random.posV, pActor.actor_scale);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnHmmEffect.cs ---



// --- Start of File: BehSpawnPlotProgressEffect.cs ---
using UnityEngine;
using ai.behaviours;

public class BehSpawnPlotProgressEffect : BehaviourActionActor
{
	private int _amount;

	public BehSpawnPlotProgressEffect(int pAmount = 1)
	{
		_amount = pAmount;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		_ = pActor.current_tile.zone;
		for (int i = 0; i < _amount; i++)
		{
			Vector3 pPos = Vector2.op_Implicit(pActor.current_position);
			pPos.y += 5f * pActor.actor_scale;
			pPos.y += Randy.randomFloat((0f - pActor.actor_scale) * 3f, pActor.actor_scale * 3f);
			pPos.x += Randy.randomFloat((0f - pActor.actor_scale) * 2f, pActor.actor_scale * 2f);
			_ = (Object)(object)EffectsLibrary.spawnAt("fx_plot_progress", pPos, pActor.actor_scale * 0.8f) == (Object)null;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnPlotProgressEffect.cs ---



// --- Start of File: BehSpawnSlashTalkTowardTileTarget.cs ---
using UnityEngine;
using ai.behaviours;

public class BehSpawnSlashTalkTowardTileTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		pActor.spawnSlashTalk(Vector2Int.op_Implicit(pActor.beh_tile_target.pos));
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnSlashTalkTowardTileTarget.cs ---



// --- Start of File: BehSpawnSlashYellTowardTileTarget.cs ---
using UnityEngine;
using ai.behaviours;

public class BehSpawnSlashYellTowardTileTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		pActor.spawnSlashYell(Vector2Int.op_Implicit(pActor.beh_tile_target.pos));
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnSlashYellTowardTileTarget.cs ---



// --- Start of File: BehSpawnTreeFertilizer.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehSpawnTreeFertilizer : BehaviourActionActor
{
	private static List<WorldTile> _tiles = new List<WorldTile>();

	public override BehResult execute(Actor pActor)
	{
		if (!Randy.randomChance(0.3f))
		{
			return BehResult.Stop;
		}
		if (!pActor.current_tile.Type.ground)
		{
			return BehResult.Stop;
		}
		BiomeAsset biome_asset = pActor.current_tile.Type.biome_asset;
		if (biome_asset == null)
		{
			return BehResult.Stop;
		}
		if (biome_asset.grow_vegetation_auto)
		{
			return BehResult.Stop;
		}
		SpellAsset spellAsset = AssetManager.spells.get("spawn_vegetation");
		_tiles.Clear();
		foreach (WorldTile tile in pActor.current_tile.region.tiles)
		{
			if (!(tile.Type.biome_id == "biome_grass"))
			{
				BiomeAsset biome_asset2 = tile.Type.biome_asset;
				if (biome_asset2 != null && biome_asset2.grow_vegetation_auto)
				{
					_tiles.Add(tile);
				}
			}
		}
		if (_tiles.Count == 0)
		{
			return BehResult.Stop;
		}
		spellAsset.action?.Invoke(pActor, pActor, _tiles.GetRandom());
		pActor.doCastAnimation();
		return BehResult.Continue;
	}
}
// --- End of File: BehSpawnTreeFertilizer.cs ---



// --- Start of File: BehStartShake.cs ---
namespace ai.behaviours;

public class BehStartShake : BehaviourActionActor
{
	private float _timer_shake;

	private float _wait_action;

	public BehStartShake(float pTimerShake = 1f, float pTimeWaitAction = 0f)
	{
		_timer_shake = pTimerShake;
		_wait_action = pTimeWaitAction;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.startShake(_timer_shake);
		pActor.timer_action = _wait_action;
		return BehResult.Continue;
	}
}
// --- End of File: BehStartShake.cs ---



// --- Start of File: BehStayInBuildingTarget.cs ---
namespace ai.behaviours;

public class BehStayInBuildingTarget : BehCityActor
{
	private float min;

	private float max;

	public BehStayInBuildingTarget(float pMin = 0f, float pMax = 1f)
	{
		min = pMin;
		max = pMax;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.timer_action = Randy.randomFloat(min, max);
		pActor.stayInBuilding(pActor.beh_building_target);
		pActor.beh_tile_target = null;
		pActor.beh_building_target.startShake(0.5f);
		return BehResult.Continue;
	}
}
// --- End of File: BehStayInBuildingTarget.cs ---



// --- Start of File: BehStealFromTarget.cs ---
using UnityEngine;
using ai.behaviours;

public class BehStealFromTarget : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_actor_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		Actor a = pActor.beh_actor_target.a;
		if (a == null || !a.isAlive() || a.isInsideSomething())
		{
			return BehResult.Stop;
		}
		if (pActor.distanceToActorTile(a) > 2f)
		{
			return BehResult.Stop;
		}
		bool flag = false;
		float pWaitTimerForThief = 0.5f;
		float pTargetStunnedTimer = 1f;
		bool pAddAggro = false;
		if (a.canSeeTileBasedOnDirection(pActor.current_tile))
		{
			if (Randy.randomChance(0.4f))
			{
				flag = true;
				pTargetStunnedTimer = 1f;
				pWaitTimerForThief = 0.9f;
				pAddAggro = true;
			}
		}
		else if (Randy.randomChance(0.7f))
		{
			flag = true;
			pTargetStunnedTimer = 5f;
			pWaitTimerForThief = 1f;
		}
		else
		{
			pActor.makeWait(1f);
		}
		if (flag)
		{
			pActor.spawnSlashTalk(a.current_position);
			pActor.punchTargetAnimation(Vector2.op_Implicit(a.current_position), pFlip: false, pReverse: false, -20f);
			pActor.stealActionFrom(a, pTargetStunnedTimer, pWaitTimerForThief, pAddAggro);
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehStealFromTarget.cs ---



// --- Start of File: BehTaxiCheck.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehTaxiCheck : BehCitizenActionCity
{
	public override BehResult execute(Actor pActor)
	{
		WorldTile tile = pActor.city.getTile();
		if (tile == null)
		{
			return BehResult.Stop;
		}
		bool flag = false;
		if (pActor.isCitizenJob("attacker"))
		{
			if (!pActor.current_tile.isSameIsland(tile) && (!pActor.city.hasAttackZoneOrder() || !pActor.city.target_attack_zone.centerTile.isSameIsland(pActor.current_tile)))
			{
				flag = true;
			}
		}
		else if (!pActor.current_tile.isSameIsland(tile))
		{
			flag = true;
		}
		if (!flag)
		{
			return BehResult.Stop;
		}
		TaxiManager.newRequest(pActor, tile);
		return BehResult.Continue;
	}
}
// --- End of File: BehTaxiCheck.cs ---



// --- Start of File: BehTaxiEmbark.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehTaxiEmbark : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		TaxiRequest requestForActor = TaxiManager.getRequestForActor(pActor);
		if (requestForActor == null || !requestForActor.hasAssignedBoat() || requestForActor.state != TaxiRequestState.Loading)
		{
			return BehResult.Stop;
		}
		Boat boat = requestForActor.getBoat();
		bool flag = requestForActor.isBoatNearDock();
		if ((float)Toolbox.SquaredDistTile(boat.actor.current_tile, pActor.current_tile) < 25f || flag)
		{
			pActor.beh_tile_target = null;
			pActor.embarkInto(requestForActor.getBoat());
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehTaxiEmbark.cs ---



// --- Start of File: BehTaxiFindShipTile.cs ---
using life.taxi;

namespace ai.behaviours;

public class BehTaxiFindShipTile : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		TaxiRequest requestForActor = TaxiManager.getRequestForActor(pActor);
		if (requestForActor == null || !requestForActor.hasAssignedBoat() || requestForActor.state != TaxiRequestState.Loading)
		{
			return BehResult.Stop;
		}
		Boat boat = requestForActor.getBoat();
		WorldTile worldTile = null;
		if (boat.pickup_near_dock)
		{
			Building homeBuilding = boat.actor.getHomeBuilding();
			if (homeBuilding != null)
			{
				WorldTile constructionTile = homeBuilding.getConstructionTile();
				if (constructionTile != null)
				{
					worldTile = constructionTile.region.tiles.GetRandom();
				}
			}
		}
		if (worldTile == null)
		{
			worldTile = PathfinderTools.raycastTileForUnitToEmbark(pActor.current_tile, boat.actor.current_tile);
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehTaxiFindShipTile.cs ---



// --- Start of File: BehTaxiSitInside.cs ---
namespace ai.behaviours;

public class BehTaxiSitInside : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.timer_action = 1f;
		return BehResult.RestartTask;
	}
}
// --- End of File: BehTaxiSitInside.cs ---



// --- Start of File: BehTeleportHome.cs ---
namespace ai.behaviours;

public class BehTeleportHome : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.hasCity())
		{
			return BehResult.Stop;
		}
		City city = pActor.getCity();
		if (!city.hasZones())
		{
			return BehResult.Stop;
		}
		TileZone random = city.zones.GetRandom();
		if (random == null)
		{
			return BehResult.Stop;
		}
		WorldTile random2 = random.tiles.GetRandom();
		ActionLibrary.teleportEffect(pActor, random2);
		pActor.cancelAllBeh();
		pActor.spawnOn(random2);
		pActor.doCastAnimation();
		return BehResult.Continue;
	}
}
// --- End of File: BehTeleportHome.cs ---



// --- Start of File: BehThrowResourceAnimation.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehThrowResourceAnimation : BehCityActor
{
	private string _resource_id;

	public BehThrowResourceAnimation(string pResourceId)
	{
		_resource_id = pResourceId;
	}

	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		Building beh_building_target = pActor.beh_building_target;
		float num = Toolbox.DistTile(pActor.current_tile, beh_building_target.current_tile);
		num = Mathf.Max(num, 1f);
		if (num > 1.5f)
		{
			num = 1.5f;
		}
		if (pActor.is_visible)
		{
			float pDuration = num;
			Vector2 pStart = Vector2.op_Implicit(pActor.getThrowStartPosition());
			Vector2 pEnd = beh_building_target.current_position + beh_building_target.asset.stockpile_center_offset;
			pEnd.x += Randy.randomFloat(-0.1f, 0.1f);
			pEnd.y += Randy.randomFloat(-0.1f, 0.1f);
			BehaviourActionBase<Actor>.world.resource_throw_manager.addNew(pStart, pEnd, pDuration, _resource_id, 1, 2f, beh_building_target);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehThrowResourceAnimation.cs ---



// --- Start of File: BehThrowResources.cs ---
using System.Collections.Generic;
using UnityEngine;

namespace ai.behaviours;

public class BehThrowResources : BehCityActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		check_building_target_non_usable = true;
		null_check_building_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (!pActor.isCarryingResources())
		{
			return BehResult.Continue;
		}
		Building beh_building_target = pActor.beh_building_target;
		float num = Toolbox.DistTile(pActor.current_tile, beh_building_target.current_tile);
		num = Mathf.Max(num, 1f);
		if (num > 1.5f)
		{
			num = 1.5f;
		}
		using (Dictionary<string, ResourceContainer>.Enumerator enumerator = pActor.inventory.getResources().GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				KeyValuePair<string, ResourceContainer> current = enumerator.Current;
				string key = current.Key;
				ResourceAsset resourceAsset = AssetManager.resources.get(key);
				if (pActor.is_visible)
				{
					int amount = current.Value.amount;
					float pDuration = num;
					Vector2 pStart = Vector2.op_Implicit(pActor.getThrowStartPosition());
					Vector2 pEnd = beh_building_target.current_position + beh_building_target.asset.stockpile_center_offset;
					pEnd.x += Randy.randomFloat(-0.1f, 0.1f);
					pEnd.y += Randy.randomFloat(-0.1f, 0.1f);
					BehaviourActionBase<Actor>.world.resource_throw_manager.addNew(pStart, pEnd, pDuration, key, amount, 4f, beh_building_target);
				}
				pActor.takeFromInventory(key, 1);
				beh_building_target.addResources(key, 1);
				pActor.addLoot(resourceAsset.loot_value);
				pActor.makeWait(0.2f);
				if (pActor.isCarryingResources())
				{
					return BehResult.StepBack;
				}
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehThrowResources.cs ---



// --- Start of File: BehTryFindTargetWithStatusNearby.cs ---
using ai.behaviours;

public class BehTryFindTargetWithStatusNearby : BehaviourActionActor
{
	private string[] _status_ids;

	public BehTryFindTargetWithStatusNearby(params string[] pStatusIDs)
	{
		_status_ids = pStatusIDs;
	}

	public override BehResult execute(Actor pActor)
	{
		Actor closestActorWithStatus = getClosestActorWithStatus(pActor, _status_ids);
		if (closestActorWithStatus == null)
		{
			WorldTile worldTile = Finder.findTileInChunk(pActor.current_tile, TileFinderType.FreeTile);
			if (worldTile == null)
			{
				return BehResult.Stop;
			}
			pActor.beh_tile_target = worldTile;
			return BehResult.Continue;
		}
		pActor.beh_tile_target = closestActorWithStatus.current_tile.getTileAroundThisOnSameIsland(pActor.current_tile);
		pActor.beh_actor_target = closestActorWithStatus;
		return BehResult.Continue;
	}

	private Actor getClosestActorWithStatus(Actor pSelf, string[] pStatusIDs)
	{
		bool flag = Randy.randomBool();
		int num = int.MaxValue;
		Actor result = null;
		foreach (Actor item in Finder.getUnitsFromChunk(pSelf.current_tile, 1, 0f, flag))
		{
			if (item == pSelf)
			{
				continue;
			}
			int num2 = Toolbox.SquaredDistTile(item.current_tile, pSelf.current_tile);
			if (num2 >= num || !pSelf.isSameIslandAs(item) || !item.hasAnyStatusEffect())
			{
				continue;
			}
			bool flag2 = false;
			foreach (string pID in pStatusIDs)
			{
				if (item.hasStatus(pID))
				{
					flag2 = true;
					break;
				}
			}
			if (flag2)
			{
				num = num2;
				result = item;
				if (flag || Randy.randomBool())
				{
					break;
				}
			}
		}
		return result;
	}
}
// --- End of File: BehTryFindTargetWithStatusNearby.cs ---



// --- Start of File: BehTryNewPlot.cs ---
using System.Collections.Generic;
using UnityPools;
using ai.behaviours;

public class BehTryNewPlot : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.hasPlot())
		{
			return BehResult.Continue;
		}
		if (pActor.isFighting())
		{
			return BehResult.Continue;
		}
		using ListPool<PlotAsset> listPool = new ListPool<PlotAsset>();
		fillRandomPlots(pActor, listPool);
		if (listPool.Count == 0)
		{
			return BehResult.Continue;
		}
		startPlotFromTheList(pActor, listPool);
		return BehResult.Continue;
	}

	private void fillRandomPlots(Actor pActor, ListPool<PlotAsset> pPotPlots)
	{
		fillPlotsToTry(pActor, AssetManager.plots_library.basic_plots, pPotPlots);
		if (pActor.hasReligion() && WorldLawLibrary.world_law_rites.isEnabled())
		{
			fillPlotsToTry(pActor, pActor.religion.possible_rites, pPotPlots);
		}
		pPotPlots.Shuffle();
	}

	private void fillPlotsToTry(Actor pActor, List<PlotAsset> pPlotList, ListPool<PlotAsset> pPotPossiblePlots)
	{
		for (int i = 0; i < pPlotList.Count; i++)
		{
			PlotAsset plotAsset = pPlotList[i];
			if (plotAsset.checkIsPossible(pActor))
			{
				pPotPossiblePlots.AddTimes(plotAsset.pot_rate, plotAsset);
			}
		}
	}

	private void startPlotFromTheList(Actor pActor, ListPool<PlotAsset> pPotList)
	{
		HashSet<PlotAsset> hashSet = UnsafeCollectionPool<HashSet<PlotAsset>, PlotAsset>.Get();
		for (int i = 0; i < pPotList.Count; i++)
		{
			PlotAsset plotAsset = pPotList[i];
			if (!hashSet.Contains(plotAsset))
			{
				if (BehaviourActionBase<Actor>.world.plots.tryStartPlot(pActor, plotAsset))
				{
					break;
				}
				hashSet.Add(plotAsset);
			}
		}
		UnsafeCollectionPool<HashSet<PlotAsset>, PlotAsset>.Release(hashSet);
	}
}
// --- End of File: BehTryNewPlot.cs ---



// --- Start of File: BehTrySleep.cs ---
using ai.behaviours;

public class BehTrySleep : BehaviourActionActor
{
	private bool _sleep_outside;

	public BehTrySleep(bool pSleepOutside = false)
	{
		_sleep_outside = pSleepOutside;
	}

	public override BehResult execute(Actor pActor)
	{
		float waitTimer = getWaitTimer(pActor);
		pActor.makeSleep(waitTimer);
		if (pActor.hasCity() && !pActor.hasHouse() && pActor.isSapient())
		{
			pActor.changeHappiness("slept_outside");
		}
		return BehResult.Continue;
	}

	private float getWaitTimer(Actor pActor)
	{
		if (!pActor.hasSubspecies())
		{
			return 20f;
		}
		WorldAgeAsset currentAge = BehaviourActionBase<Actor>.world.era_manager.getCurrentAge();
		Subspecies subspecies = pActor.subspecies;
		float num = 0f;
		bool flag = false;
		if (currentAge.flag_winter && subspecies.hasTrait("winter_slumberers"))
		{
			flag = true;
		}
		else if (currentAge.flag_night && subspecies.hasTrait("nocturnal_dormancy"))
		{
			flag = true;
		}
		else if (!currentAge.flag_chaos && subspecies.hasTrait("chaos_driven"))
		{
			flag = true;
		}
		else if (currentAge.flag_light_age && subspecies.hasTrait("circadian_drift"))
		{
			flag = true;
		}
		if (flag)
		{
			num = 100f;
		}
		else
		{
			float pMinInclusive = 20f;
			float pMaxExclusive = 60f;
			if (subspecies.hasTrait("monophasic_sleep"))
			{
				pMinInclusive = 40f;
				pMaxExclusive = 90f;
			}
			num = Randy.randomFloat(pMinInclusive, pMaxExclusive);
			if (subspecies.hasTrait("prolonged_rest"))
			{
				num += Randy.randomFloat(pMinInclusive, pMaxExclusive);
			}
		}
		return num;
	}
}
// --- End of File: BehTrySleep.cs ---



// --- Start of File: BehTryToEatCityFood.cs ---
using ai.behaviours;

public class BehTryToEatCityFood : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		City city = pActor.city;
		if (!city.hasSuitableFood(pActor.subspecies))
		{
			return BehResult.Stop;
		}
		ResourceAsset foodItem = city.getFoodItem(pActor.subspecies, pActor.data.favorite_food);
		bool flag = !pActor.isFoodFreeForThisPerson();
		if (foodItem != null)
		{
			if (flag && !pActor.hasEnoughMoney(foodItem.money_cost))
			{
				return BehResult.Stop;
			}
			eatFood(pActor, city, foodItem, flag);
			if (pActor.hasTrait("gluttonous"))
			{
				foodItem = city.getFoodItem(pActor.subspecies, pActor.data.favorite_food);
				if (foodItem != null && flag && pActor.hasEnoughMoney(foodItem.money_cost))
				{
					eatFood(pActor, city, foodItem, pNeedToPay: true);
				}
			}
		}
		return BehResult.Continue;
	}

	private void eatFood(Actor pActor, City pCity, ResourceAsset pFoodItem, bool pNeedToPay)
	{
		if (pNeedToPay)
		{
			pActor.spendMoney(pFoodItem.money_cost);
		}
		pCity.eatFoodItem(pFoodItem.id);
		pActor.consumeFoodResource(pFoodItem);
	}
}
// --- End of File: BehTryToEatCityFood.cs ---



// --- Start of File: BehTryToRead.cs ---
using ai.behaviours;

public class BehTryToRead : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.city.hasBooksToRead(pActor))
		{
			return BehResult.Stop;
		}
		Book book;
		if (pActor.hasTag("can_read_any_book"))
		{
			book = pActor.city.getRandomBook();
		}
		else
		{
			if (!pActor.hasLanguage())
			{
				return BehResult.Stop;
			}
			if (!pActor.city.hasBooksOfLanguage(pActor.language))
			{
				return BehResult.Stop;
			}
			book = pActor.city.getRandomBookOfLanguage(pActor.language);
		}
		if (book == null)
		{
			return BehResult.Stop;
		}
		book.readIt();
		pActor.beh_book_target = book;
		return BehResult.Continue;
	}
}
// --- End of File: BehTryToRead.cs ---



// --- Start of File: BehTryToSocialize.cs ---
using ai.behaviours;

public class BehTryToSocialize : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.resetSocialize();
		Actor randomActorAround = getRandomActorAround(pActor);
		if (randomActorAround != null)
		{
			pActor.beh_actor_target = randomActorAround;
			if (pActor.canFallInLoveWith(randomActorAround))
			{
				pActor.becomeLoversWith(randomActorAround);
			}
			pActor.resetSocialize();
			randomActorAround.resetSocialize();
			if (pActor.hasTelepathicLink() && randomActorAround.hasTelepathicLink())
			{
				return forceTask(pActor, "socialize_do_talk", pClean: false);
			}
			return forceTask(pActor, "socialize_go_to_target", pClean: false);
		}
		return BehResult.Stop;
	}

	private Actor getRandomActorAround(Actor pActor)
	{
		using ListPool<Actor> listPool = new ListPool<Actor>(4);
		using ListPool<Actor> listPool2 = new ListPool<Actor>(4);
		bool flag = pActor.subspecies.needOppositeSexTypeForReproduction();
		bool flag2 = pActor.hasCulture() && pActor.culture.hasTrait("animal_whisperers");
		bool num = pActor.hasTelepathicLink();
		if (num)
		{
			fillUnitsViaTelepathicLink(pActor, listPool, listPool2);
		}
		int pChunkRadius = 1;
		if (num)
		{
			pChunkRadius = 2;
		}
		foreach (Actor item in Finder.getUnitsFromChunk(pActor.current_tile, pChunkRadius, 0f, pRandom: true))
		{
			if (!pActor.canTalkWith(item))
			{
				continue;
			}
			if (pActor.isKingdomCiv())
			{
				if (item.isKingdomMob())
				{
					if (!flag2)
					{
						continue;
					}
				}
				else if (!item.isKingdomCiv())
				{
				}
			}
			else if (!pActor.isSameSpecies(item))
			{
				continue;
			}
			if (flag && pActor.canFallInLoveWith(item))
			{
				listPool.Add(item);
				break;
			}
			listPool2.Add(item);
			if (listPool2.Count > 3)
			{
				break;
			}
		}
		if (listPool.Count > 0)
		{
			return listPool.GetRandom();
		}
		if (listPool2.Count > 0)
		{
			return listPool2.GetRandom();
		}
		return null;
	}

	private void fillUnitsViaTelepathicLink(Actor pActor, ListPool<Actor> pBestTargets, ListPool<Actor> pNormalTargets)
	{
		if (pActor.hasFamily())
		{
			foreach (Actor unit in pActor.family.units)
			{
				if (pActor.canTalkWith(unit))
				{
					pNormalTargets.Add(unit);
				}
			}
		}
		foreach (Actor parent in pActor.getParents())
		{
			if (pActor.canTalkWith(parent))
			{
				pBestTargets.Add(parent);
			}
		}
	}
}
// --- End of File: BehTryToSocialize.cs ---



// --- Start of File: BehUFOBeam.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehUFOBeam : BehaviourActionActor
{
	private bool enabled;

	public BehUFOBeam(bool pEnabled = false)
	{
		enabled = pEnabled;
	}

	public override BehResult execute(Actor pActor)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		UFO actorComponent = pActor.getActorComponent<UFO>();
		if (!enabled)
		{
			actorComponent.hideBeam();
			return BehResult.Continue;
		}
		if (actorComponent.beamAnim.isOn)
		{
			if (actorComponent.beamAnim.currentFrameIndex == 4)
			{
				for (int i = 0; i < 8; i++)
				{
					for (int j = 0; j < 8; j++)
					{
						MapBox mapBox = BehaviourActionBase<Actor>.world;
						Vector2Int pos = pActor.current_tile.pos;
						int pX = ((Vector2Int)(ref pos)).x + j - 4;
						pos = pActor.current_tile.pos;
						WorldTile tile = mapBox.GetTile(pX, ((Vector2Int)(ref pos)).y + i - 4);
						if (tile != null)
						{
							pos = pActor.current_tile.pos;
							int x = ((Vector2Int)(ref pos)).x;
							pos = pActor.current_tile.pos;
							int y = ((Vector2Int)(ref pos)).y;
							pos = tile.pos;
							int x2 = ((Vector2Int)(ref pos)).x;
							pos = tile.pos;
							if (!(Toolbox.Dist(x, y, x2, ((Vector2Int)(ref pos)).y) > 4f))
							{
								MapAction.damageWorld(tile, 0, AssetManager.terraform.get("ufo_attack"), pActor);
							}
						}
					}
				}
			}
			if (actorComponent.beamAnim.currentFrameIndex == actorComponent.beamAnim.frames.Length - 1)
			{
				actorComponent.hideBeam();
				return BehResult.Continue;
			}
			return BehResult.RepeatStep;
		}
		actorComponent.startBeam();
		return BehResult.RepeatStep;
	}
}
// --- End of File: BehUFOBeam.cs ---



// --- Start of File: BehUFOCheckAttackCity.cs ---
namespace ai.behaviours;

public class BehUFOCheckAttackCity : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("cityToAttack", out var pResult, -1L);
		if (pResult.hasValue() && pActor.current_tile.hasBuilding() && !WorldLawLibrary.world_law_peaceful_monsters.isEnabled() && pActor.current_tile.building.isUsable())
		{
			return forceTask(pActor, "ufo_attack");
		}
		pActor.data.get("attacksForCity", out var pResult2, 0);
		if (pResult2 > 0)
		{
			return BehResult.RestartTask;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehUFOCheckAttackCity.cs ---



// --- Start of File: BehUFOCheckExplore.cs ---
namespace ai.behaviours;

public class BehUFOCheckExplore : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("exploringTicks", out var pResult, 0);
		if (pResult > 0)
		{
			pResult--;
			pActor.data.set("exploringTicks", pResult);
			if (pActor.current_tile.zone.city != null)
			{
				pActor.data.set("cityToAttack", pActor.current_tile.zone.city.data.id);
				pActor.data.set("attacksForCity", Randy.randomInt(3, 10));
				return forceTask(pActor, "ufo_fly", pClean: false);
			}
			if (pActor.ai.task?.id == "ufo_explore")
			{
				return BehResult.RestartTask;
			}
			return forceTask(pActor, "ufo_explore", pClean: false);
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehUFOCheckExplore.cs ---



// --- Start of File: BehUFOExplore.cs ---
namespace ai.behaviours;

public class BehUFOExplore : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.set("exploringTicks", Randy.randomInt(3, 7));
		return BehResult.Continue;
	}
}
// --- End of File: BehUFOExplore.cs ---



// --- Start of File: BehUFOFindTarget.cs ---
using System;
using UnityEngine;

namespace ai.behaviours;

public class BehUFOFindTarget : BehaviourActionActor
{
	public unsafe override BehResult execute(Actor pActor)
	{
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		pActor.beh_tile_target = null;
		pActor.data.get("attacksForCity", out var pResult, 0);
		pActor.data.get("cityToAttack", out var pResult2, -1L);
		City city = (pResult2.hasValue() ? BehaviourActionBase<Actor>.world.cities.get(pResult2) : null);
		if (pResult > 0 && city != null)
		{
			if (!city.isAlive() || city.buildings.Count == 0)
			{
				pActor.beh_tile_target = null;
				pResult = 0;
				pActor.data.removeLong("cityToAttack");
			}
			else
			{
				Building random = city.buildings.GetRandom();
				pActor.beh_tile_target = random.current_tile.zone.tiles.GetRandom();
				pResult--;
			}
		}
		else if (pResult <= 0)
		{
			pActor.beh_tile_target = null;
			pActor.data.removeLong("cityToAttack");
		}
		if (pResult > 0)
		{
			pActor.data.set("attacksForCity", pResult);
		}
		else
		{
			pActor.data.removeInt("attacksForCity");
		}
		if (pActor.beh_tile_target == null)
		{
			WorldTile worldTile = Toolbox.getRandomTileWithinDistance(pActor.current_tile, 100);
			if (!BehaviourActionBase<Actor>.world.islands_calculator.hasGround())
			{
				pActor.beh_tile_target = worldTile;
				return BehResult.Continue;
			}
			int num = 5;
			while (!worldTile.Type.ground && num > 0)
			{
				worldTile = Toolbox.getRandomTileWithinDistance(pActor.current_tile, 100);
				num--;
			}
			if (!worldTile.Type.ground && BehaviourActionBase<Actor>.world.islands_calculator.getRandomIslandGround() != null)
			{
				Span<Vector2Int> pArray = new Span<Vector2Int>(stackalloc Vector2Int[8], 8);
				for (int i = 0; i < 8; i++)
				{
					pArray[i] = BehaviourActionBase<Actor>.world.islands_calculator.tryGetRandomGround().pos;
				}
				Vector2Int closestTile = Toolbox.getClosestTile(pArray, pActor.current_tile);
				worldTile = BehaviourActionBase<Actor>.world.GetTileSimple(((Vector2Int)(ref closestTile)).x, ((Vector2Int)(ref closestTile)).y);
			}
			pActor.beh_tile_target = worldTile;
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehUFOFindTarget.cs ---



// --- Start of File: BehUFOSelectTarget.cs ---
namespace ai.behaviours;

public class BehUFOSelectTarget : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		UFO actorComponent = pActor.getActorComponent<UFO>();
		if (actorComponent.aggroTargets.Count > 0)
		{
			BehaviourActionActor.temp_actors.Clear();
			foreach (Actor aggroTarget in actorComponent.aggroTargets)
			{
				if (aggroTarget != null && aggroTarget.isAlive())
				{
					BehaviourActionActor.temp_actors.Add(aggroTarget);
				}
			}
			actorComponent.aggroTargets.Clear();
			Actor closestActor = Toolbox.getClosestActor(BehaviourActionActor.temp_actors, pActor.current_tile);
			if (closestActor != null)
			{
				if (closestActor.city != null)
				{
					pActor.data.get("cityToAttack", out var pResult, -1L);
					if (!pResult.hasValue())
					{
						pActor.data.set("cityToAttack", closestActor.city.data.id);
						pActor.data.set("attacksForCity", Randy.randomInt(3, 10));
					}
				}
				pActor.beh_tile_target = closestActor.current_tile;
				return forceTask(pActor, "ufo_chase", pClean: false);
			}
		}
		return BehResult.Continue;
	}
}
// --- End of File: BehUFOSelectTarget.cs ---



// --- Start of File: BehUnloadResources.cs ---
namespace ai.behaviours;

public class BehUnloadResources : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.isCarryingResources())
		{
			return BehResult.Continue;
		}
		pActor.giveInventoryResourcesToCity();
		return BehResult.Continue;
	}
}
// --- End of File: BehUnloadResources.cs ---



// --- Start of File: BehVerifierAttackZone.cs ---
namespace ai.behaviours;

public class BehVerifierAttackZone : BehCitizenActionCity
{
	public override BehResult execute(Actor pActor)
	{
		if (pActor.city == null)
		{
			return BehResult.Stop;
		}
		TileZone target_attack_zone = pActor.city.target_attack_zone;
		if (!pActor.city.hasAttackZoneOrder())
		{
			return BehResult.Stop;
		}
		City city = pActor.city.target_attack_zone.city;
		if (city == null)
		{
			return BehResult.Stop;
		}
		if (target_attack_zone == null)
		{
			return BehResult.Stop;
		}
		if (pActor.kingdom.isEnemy(city.kingdom))
		{
			return BehResult.Continue;
		}
		return BehResult.Stop;
	}
}
// --- End of File: BehVerifierAttackZone.cs ---



// --- Start of File: BehWait.cs ---
namespace ai.behaviours;

public class BehWait : BehaviourActionActor
{
	private float _wait_interval;

	public BehWait(float pWaitInterval = 1f)
	{
		_wait_interval = pWaitInterval;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.timer_action = _wait_interval;
		return BehResult.Continue;
	}
}
// --- End of File: BehWait.cs ---



// --- Start of File: BehWalkIntoWaterCorner.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehWalkIntoWaterCorner : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		TileIsland island = pActor.current_tile.region.island;
		if (island.isGoodIslandForActor(pActor))
		{
			return BehResult.Stop;
		}
		WorldTile worldTile = null;
		int num = int.MaxValue;
		foreach (MapRegion insideRegionEdge in island.insideRegionEdges)
		{
			List<WorldTile> edgeTiles = insideRegionEdge.getEdgeTiles();
			for (int i = 0; i < edgeTiles.Count; i++)
			{
				WorldTile worldTile2 = edgeTiles[i];
				if (worldTile2.Type.ocean)
				{
					int num2 = Toolbox.SquaredDistTile(pActor.current_tile, worldTile2);
					if (num2 < num)
					{
						worldTile = worldTile2;
						num = num2;
					}
				}
			}
		}
		if (worldTile == null)
		{
			return BehResult.Stop;
		}
		pActor.beh_tile_target = worldTile;
		return BehResult.Continue;
	}
}
// --- End of File: BehWalkIntoWaterCorner.cs ---



// --- Start of File: BehWarriorCaptainWait.cs ---
using ai.behaviours;

public class BehWarriorCaptainWait : BehCityActor
{
	public override BehResult execute(Actor pActor)
	{
		if (!pActor.isArmyGroupLeader())
		{
			return BehResult.Stop;
		}
		Army army = pActor.army;
		WorldTile current_tile = pActor.current_tile;
		int num = 0;
		foreach (Actor unit in army.units)
		{
			if (Toolbox.SquaredDist(current_tile.posV3.x, current_tile.posV3.y, unit.current_tile.x, unit.current_tile.y) < 100f)
			{
				num++;
			}
		}
		float num2 = 2f;
		float num3 = (float)num / (float)army.units.Count;
		if (num3 < 0.2f)
		{
			num2 = 13f;
		}
		else if (num3 < 0.4f)
		{
			num2 = 7f;
		}
		else if (num3 < 0.6f)
		{
			num2 = 4f;
		}
		pActor.timer_action = Randy.randomFloat(num2, num2 * 2f);
		return BehResult.Continue;
	}
}
// --- End of File: BehWarriorCaptainWait.cs ---



// --- Start of File: BehWormDig.cs ---
using System;

namespace ai.behaviours;

public class BehWormDig : BehaviourActionActor
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		null_check_tile_target = true;
	}

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("size", out var pResult, 0);
		if (pResult > 0 && pActor.beh_tile_target.Height < 220)
		{
			BehaviourActionBase<Actor>.world.loopWithBrush(pActor.beh_tile_target, Brush.get(pResult), tileDrawWorm);
		}
		else
		{
			BehaviourActionBase<Actor>.world.loopWithBrush(pActor.beh_tile_target, Brush.get(pResult), tileFlashWorm);
		}
		return BehResult.RestartTask;
	}

	public static bool tileFlashWorm(WorldTile pTile, string pPowerID)
	{
		BehaviourActionBase<Actor>.world.flash_effects.flashPixel(pTile, 20);
		return true;
	}

	public static bool tileDrawWorm(WorldTile pTile, string pPowerID)
	{
		wormTile(pTile);
		return true;
	}

	public static void wormTile(WorldTile pTile)
	{
		BehaviourActionBase<Actor>.world.flash_effects.flashPixel(pTile, 20);
		if (pTile.top_type != null)
		{
			MapAction.decreaseTile(pTile, pDamage: false);
		}
		else if (pTile.Type.increase_to != null && !pTile.Type.road)
		{
			bool num = pTile.Type.increase_to.id.StartsWith("mountain", StringComparison.Ordinal);
			bool flag = pTile.Type.increase_to.id.StartsWith("hill", StringComparison.Ordinal);
			if (!num && !flag && (pTile.Type.decrease_to == null || Randy.randomBool()))
			{
				MapAction.increaseTile(pTile, pDamage: false, "destroy");
			}
			else if (pTile.Type.decrease_to != null)
			{
				MapAction.decreaseTile(pTile, pDamage: false, "destroy");
			}
		}
	}
}
// --- End of File: BehWormDig.cs ---



// --- Start of File: BehWormDigEat.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class BehWormDigEat : BehaviourActionActor
{
	private static List<BrushPixelData> myRange = new List<BrushPixelData>();

	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("worm_size", out var pResult, 1);
		if (pActor.current_tile.Height < 220)
		{
			loopWithBrush(pActor.current_tile, pResult, tileDrawWorm);
		}
		checkForWorms(pActor.current_tile, pResult, pActor);
		return BehResult.Continue;
	}

	public static void checkForWorms(WorldTile pCenterTile, int pBrushSize, Actor pActor)
	{
		int num = 0;
		int num2 = 0;
		BrushData brushData = Brush.get(pBrushSize, "hcirc_");
		for (int i = 0; i < brushData.pos.Length; i++)
		{
			num = pCenterTile.x + brushData.pos[i].x;
			num2 = pCenterTile.y + brushData.pos[i].y;
			if (num >= 0 && num < MapBox.width && num2 >= 0 && num2 < MapBox.height)
			{
				WorldTile tileSimple = BehaviourActionBase<Actor>.world.GetTileSimple(num, num2);
				checkWorms(tileSimple, pActor);
				BehaviourActionBase<Actor>.world.flash_effects.flashPixel(tileSimple, 10, ColorType.Purple);
			}
		}
	}

	public void loopWithBrush(WorldTile pCenterTile, int pBrushSize, PowerActionWithID pAction, string pPowerID = null)
	{
		int num = 0;
		int num2 = 0;
		BrushData brushData = Brush.get(pBrushSize, "hcirc_");
		for (int i = 0; i < brushData.pos.Length; i++)
		{
			num = pCenterTile.x + brushData.pos[i].x;
			num2 = pCenterTile.y + brushData.pos[i].y;
			if (num >= 0 && num < MapBox.width && num2 >= 0 && num2 < MapBox.height)
			{
				WorldTile tileSimple = BehaviourActionBase<Actor>.world.GetTileSimple(num, num2);
				pAction(tileSimple, pPowerID);
			}
		}
	}

	public static void checkWorms(WorldTile pTile, Actor pActor)
	{
		pTile.doUnits(delegate(Actor tActor)
		{
			if (pActor.data.id != tActor.data.id && tActor.asset.id == "worm")
			{
				pActor.data.get("worm_size", out var pResult, 1);
				tActor.data.get("worm_size", out var pResult2, 1);
				tActor.dieSimpleNone();
				pResult += pResult2;
				pActor.data.set("worm_size", pResult);
			}
		});
	}

	public static bool tileDrawWorm(WorldTile pTile, string pPowerID)
	{
		if (pTile == null)
		{
			return false;
		}
		BehWormDig.wormTile(pTile);
		if (pTile.Type.ocean && pTile.Type.liquid && Randy.randomChance(0.25f))
		{
			spawnBurst(pTile, "rain", pCreateGround: false);
		}
		if (pTile.Type.lava)
		{
			LavaHelper.removeLava(pTile);
			if (Randy.randomChance(0.25f))
			{
				spawnBurst(pTile, "lava");
			}
		}
		if (pTile.isOnFire())
		{
			pTile.stopFire();
		}
		if (Randy.randomChance(0.25f))
		{
			if (pTile.Type.IsType("sand"))
			{
				spawnBurst(pTile, "pixel", pCreateGround: false);
			}
			else if (pTile.Type.can_be_farm)
			{
				spawnBurst(pTile, "pixel", pCreateGround: false);
			}
		}
		return true;
	}

	private static void spawnBurst(WorldTile pTile, string pType, bool pCreateGround = true)
	{
		if (BehaviourActionBase<Actor>.world.drop_manager.getActiveIndex() <= 300)
		{
			BehaviourActionBase<Actor>.world.drop_manager.spawnParabolicDrop(pTile, pType, 0f, 0.62f, 104f, 0.7f, 23.5f);
		}
	}
}
// --- End of File: BehWormDigEat.cs ---



// --- Start of File: BehWormDive.cs ---
using UnityEngine;

namespace ai.behaviours;

public class BehWormDive : BehaviourActionActor
{
	public override BehResult execute(Actor pActor)
	{
		pActor.data.get("dive_steps", out var pResult, 0);
		if (--pResult < 1)
		{
			pResult = Randy.randomInt(Randy.randomInt(1, 6), Randy.randomInt(10, 60));
			pActor.data.get("size", out var pResult2, 0);
			pResult2 = Mathf.Clamp((!Randy.randomBool()) ? (--pResult2) : (++pResult2), 0, 2);
			pActor.data.set("size", pResult2);
		}
		pActor.data.set("dive_steps", pResult);
		return BehResult.Continue;
	}
}
// --- End of File: BehWormDive.cs ---



// --- Start of File: Bench.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

public class Bench
{
	public static bool bench_enabled = false;

	public static bool bench_ai_enabled = false;

	private static Dictionary<string, BenchmarkGroup> dict = new Dictionary<string, BenchmarkGroup>();

	private static float _timer_flatten = 0f;

	public static void update()
	{
		if (bench_enabled)
		{
			finishSplitBenchmarkGroupAI();
			finishSplitBenchmarkGroup("effects_traits");
			finishSplitBenchmarkGroup("effects_items");
			if (_timer_flatten > 0f)
			{
				_timer_flatten -= Time.deltaTime;
				return;
			}
			_timer_flatten = 0.05f;
			flatten("effects_traits");
			flatten("effects_items");
		}
	}

	private static void flatten(string pID)
	{
		if (dict.TryGetValue(pID, out var value))
		{
			value.flatten();
		}
	}

	private static void finishSplitBenchmarkGroupAI()
	{
		DebugConfig.isOn(DebugOption.BenchAiEnabled);
	}

	private static void finishSplitBenchmarkGroup(string pID)
	{
		if (!dict.TryGetValue(pID, out var value))
		{
			return;
		}
		double num = 0.0;
		foreach (ToolBenchmarkData value2 in value.dict_data.Values)
		{
			num += value2.latest_result;
			value2.saveAverageCounter();
		}
		benchSaveSplit(pID, num, 1, "game_total");
	}

	public static void saveAverageCounter(string pID, string pGroup)
	{
		get(pID, pGroup).saveAverageCounter();
	}

	public static BenchmarkGroup getGroup(string pID)
	{
		if (dict.ContainsKey(pID))
		{
			return dict[pID];
		}
		BenchmarkGroup benchmarkGroup = new BenchmarkGroup();
		benchmarkGroup.id = pID;
		dict.Add(pID, benchmarkGroup);
		return benchmarkGroup;
	}

	private static ToolBenchmarkData get(string pID, string pGroupID = "main", bool pNew = true)
	{
		if (!dict.TryGetValue(pGroupID, out var value))
		{
			value = new BenchmarkGroup();
			value.id = pGroupID;
			dict.Add(pGroupID, value);
		}
		if (!value.dict_data.TryGetValue(pID, out var value2) && pNew)
		{
			value2 = new ToolBenchmarkData();
			value2.id = pID;
			value.dict_data.Add(pID, value2);
		}
		return value2;
	}

	public static void clearBenchmarkEntrySkipMultiple(string pGroupID = "main", params string[] pEntries)
	{
		foreach (string pID in pEntries)
		{
			bench(pID, pGroupID);
			benchEnd(pID, pGroupID, pSaveCounter: false, 0L);
		}
	}

	public static void clearBenchmarkEntrySkip(string pID, string pGroupID = "main")
	{
		bench(pID, pGroupID);
		benchEnd(pID, pGroupID, pSaveCounter: false, 0L);
	}

	public static double bench(string pID, string pGroupID = "main", bool pForce = false)
	{
		if (!(bench_enabled || pForce))
		{
			return 0.0;
		}
		ToolBenchmarkData toolBenchmarkData = get(pID, pGroupID);
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		toolBenchmarkData.start(realtimeSinceStartupAsDouble);
		return realtimeSinceStartupAsDouble;
	}

	public static double benchEnd(string pID, string pGroupID = "main", bool pSaveCounter = false, long pCounter = 0L, bool pForce = false)
	{
		if (!(bench_enabled || pForce))
		{
			return 0.0;
		}
		ToolBenchmarkData toolBenchmarkData = get(pID, pGroupID);
		double num = Time.realtimeSinceStartupAsDouble - toolBenchmarkData.latest_time;
		toolBenchmarkData.end(num);
		if (pSaveCounter)
		{
			toolBenchmarkData.newCount(pCounter);
			toolBenchmarkData.saveAverageCounter();
		}
		return num;
	}

	public static void benchSet(string pID, double pVal, int pCounter, string pGroupID = "main")
	{
		if (bench_enabled)
		{
			benchSave(pID, pVal, pCounter, pGroupID);
			saveAverageCounter(pID, pGroupID);
		}
	}

	public static void benchSetValue(string pID, int pValue, string pGroupID = "main")
	{
		if (bench_enabled)
		{
			get(pID, pGroupID).newValue(pValue);
		}
	}

	public static int getBenchValue(string pID, string pGroupID = "main")
	{
		if (!bench_enabled)
		{
			return 0;
		}
		return (int)get(pID, pGroupID).debug_value;
	}

	public static double benchSave(string pID, double pValue, int pCounter, string pGroupID = "main")
	{
		if (!bench_enabled)
		{
			return 0.0;
		}
		ToolBenchmarkData toolBenchmarkData = get(pID, pGroupID);
		toolBenchmarkData.end(pValue);
		toolBenchmarkData.newCount(pCounter);
		return pValue;
	}

	public static double benchSaveSplit(string pID, double pValue, int pCounter, string pGroupID = "main")
	{
		if (!bench_enabled)
		{
			return 0.0;
		}
		ToolBenchmarkData toolBenchmarkData = get(pID, pGroupID);
		toolBenchmarkData.end(pValue);
		toolBenchmarkData.newCount(pCounter);
		return pValue;
	}

	public static string getBenchResult(string pID, string pGroupID = "main", bool pAverage = true)
	{
		return getBenchResultAsDouble(pID, pGroupID, pAverage).ToString("##,0.#######");
	}

	public static double getBenchResultAsDouble(string pID, string pGroupID = "main", bool pAverage = true)
	{
		ToolBenchmarkData toolBenchmarkData = get(pID, pGroupID, pNew: false);
		if (toolBenchmarkData == null)
		{
			return -1.0;
		}
		if (pAverage)
		{
			return toolBenchmarkData.getAverage();
		}
		return toolBenchmarkData.latest_result;
	}

	public static string printableBenchResults(string pGroupID = "main", bool pAverage = false, params string[] pID)
	{
		double[] array = new double[pID.Length];
		double num = 0.0;
		double num2 = double.MaxValue;
		for (int i = 0; i < pID.Length; i++)
		{
			array[i] = getBenchResultAsDouble(pID[i], pGroupID, pAverage);
			if (array[i] > num)
			{
				num = array[i];
			}
			if (array[i] < num2)
			{
				num2 = array[i];
			}
		}
		Array.Sort(array, pID);
		using ListPool<string[]> listPool = new ListPool<string[]>();
		listPool.Add(new string[5] { "ID", "TIME", "PERCENT", "WINNER", "BAR" });
		listPool.Add(new string[0]);
		for (int j = 0; j < pID.Length; j++)
		{
			double num3 = array[j] / num;
			bool flag = array[j].Equals(num2);
			bool flag2 = array[j].Equals(num);
			string text = "";
			string text2 = "";
			string text3 = "";
			int num4 = (int)(num3 * 10.0);
			for (int k = 0; k < num4; k++)
			{
				text3 += "";
			}
			text3 = Toolbox.fillRight(text3, 10);
			if (flag || flag2)
			{
				if (flag)
				{
					text = "<color=green>";
				}
				if (flag2)
				{
					text = "<color=red>";
				}
				text2 = "</color>";
			}
			string text4 = text + pID[j] + text2;
			string text5 = text + array[j].ToString("F7") + text2;
			string text6 = text + num3.ToString("P0") + text2;
			string text7 = text + (flag ? "WINNER" : (flag2 ? "SLOWEST" : "")) + text2;
			string text8 = text + text3 + text2;
			listPool.Add(new string[5] { text4, text5, text6, text7, text8 });
		}
		return Toolbox.printRows(listPool);
	}

	public static void printBenchResult(string pID, string pGroupID = "main", bool pAverage = false)
	{
		double benchResultAsDouble = getBenchResultAsDouble(pID, pGroupID, pAverage);
		string text = benchResultAsDouble.ToString("##,0.##########");
		if (benchResultAsDouble > 0.3)
		{
			text = "<color=red>" + text + "</color>";
		}
		else if (benchResultAsDouble > 0.1)
		{
			text = "<color=yellow>" + text + "</color>";
		}
		Debug.Log((object)("#benchmark: <color=white>" + pID + "</color>: " + text));
	}
}
// --- End of File: Bench.cs ---



// --- Start of File: Benchmark.cs ---
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Unity.Collections;
using UnityEngine;

public static class Benchmark
{
	public static void benchHashsetStart()
	{
		for (int i = 0; i < 1000; i++)
		{
			benchObjHashsetCreateVsAdd(5000);
		}
		Debug.Log((object)("- BenchTest - list:" + Bench.getBenchResult("BenchTest - list")));
		Debug.Log((object)("- BenchTest - hashset:" + Bench.getBenchResult("BenchTest - hashset")));
	}

	public static void benchObjHashsetCreateVsAdd(int pAmount = 3000)
	{
		Bench.bench_enabled = true;
		List<BenchObject> list = new List<BenchObject>();
		for (int i = 0; i < pAmount; i++)
		{
			list.Add(new BenchObject());
		}
		int num = 10;
		List<BenchObject> list2 = new List<BenchObject>();
		list2.AddRange(list);
		Bench.bench("BenchTest - list");
		for (int j = 0; j < num; j++)
		{
			BenchObject random = list2.GetRandom();
			list2.Remove(random);
		}
		Bench.benchEnd("BenchTest - list", "main", pSaveCounter: false, 0L);
		HashSet<BenchObject> hashSet = new HashSet<BenchObject>();
		hashSet.UnionWith(list);
		Bench.bench("BenchTest - hashset");
		for (int k = 0; k < num; k++)
		{
			BenchObject random2 = list.GetRandom();
			hashSet.Remove(random2);
		}
		list2.Clear();
		list2.AddRange(hashSet);
		Bench.benchEnd("BenchTest - hashset", "main", pSaveCounter: false, 0L);
	}

	public static void benchObjectsVsData(int pObjects)
	{
		double num = 1000.0;
		Bench.bench_enabled = true;
		int num2 = pObjects;
		Debug.Log((object)"----");
		Debug.Log((object)("NEW BENCH - " + pObjects));
		BenchObject[] array = new BenchObject[num2];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = new BenchObject();
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int j = 0; (double)j < num; j++)
		{
			for (int k = 0; k < array.Length; k++)
			{
				array[k].update(0f);
			}
		}
		stopwatch.Stop();
		array = new BenchObject[num2];
		for (int l = 0; l < array.Length; l++)
		{
			array[l] = new BenchObject();
		}
		Stopwatch stopwatch2 = new Stopwatch();
		stopwatch2.Start();
		for (int m = 0; (double)m < num; m++)
		{
			for (int n = 0; n < array.Length; n++)
			{
				array[n].updateMove(0f);
				array[n].updateMove(0f);
				array[n].updateMove(0f);
				array[n].updateMove(0f);
				array[n].updateMove(0f);
			}
		}
		stopwatch2.Stop();
		array = new BenchObject[num2];
		for (int num3 = 0; num3 < array.Length; num3++)
		{
			array[num3] = new BenchObject();
		}
		Stopwatch stopwatch3 = new Stopwatch();
		stopwatch3.Start();
		for (int num4 = 0; (double)num4 < num; num4++)
		{
			foreach (BenchObject obj in array)
			{
				obj.updateMove(0f);
				obj.updateMove(0f);
				obj.updateMove(0f);
				obj.updateMove(0f);
				obj.updateMove(0f);
			}
		}
		stopwatch3.Stop();
		array = new BenchObject[num2];
		for (int num6 = 0; num6 < array.Length; num6++)
		{
			array[num6] = new BenchObject();
		}
		Stopwatch stopwatch4 = new Stopwatch();
		stopwatch4.Start();
		for (int num7 = 0; (double)num7 < num; num7++)
		{
			Parallel.ForEach(array, World.world.parallel_options, delegate(BenchObject pObject)
			{
				pObject.updateMove(0f);
				pObject.updateMove(0f);
				pObject.updateMove(0f);
				pObject.updateMove(0f);
				pObject.updateMove(0f);
			});
		}
		stopwatch4.Stop();
		array = new BenchObject[num2];
		for (int num8 = 0; num8 < array.Length; num8++)
		{
			array[num8] = new BenchObject();
		}
		Stopwatch stopwatch5 = new Stopwatch();
		stopwatch5.Start();
		for (int num9 = 0; (double)num9 < num; num9++)
		{
			for (int num10 = 0; num10 < array.Length; num10++)
			{
				array[num10].derp += 22;
				if (array[num10].derp == 1000)
				{
					array[num10].derp += 10;
					if (array[num10].derp < 10)
					{
						array[num10].derp += 5;
					}
					else
					{
						array[num10].derp -= 5;
					}
				}
			}
			for (int num11 = 0; num11 < array.Length; num11++)
			{
				array[num11].derp += 22;
				if (array[num11].derp == 1000)
				{
					array[num11].derp += 10;
					if (array[num11].derp < 10)
					{
						array[num11].derp += 5;
					}
					else
					{
						array[num11].derp -= 5;
					}
				}
			}
			for (int num12 = 0; num12 < array.Length; num12++)
			{
				array[num12].derp += 22;
				if (array[num12].derp == 1000)
				{
					array[num12].derp += 10;
					if (array[num12].derp < 10)
					{
						array[num12].derp += 5;
					}
					else
					{
						array[num12].derp -= 5;
					}
				}
			}
			for (int num13 = 0; num13 < array.Length; num13++)
			{
				array[num13].derp += 22;
				if (array[num13].derp == 1000)
				{
					array[num13].derp += 10;
					if (array[num13].derp < 10)
					{
						array[num13].derp += 5;
					}
					else
					{
						array[num13].derp -= 5;
					}
				}
			}
			for (int num14 = 0; num14 < array.Length; num14++)
			{
				array[num14].derp += 22;
				if (array[num14].derp == 1000)
				{
					array[num14].derp += 10;
					if (array[num14].derp < 10)
					{
						array[num14].derp += 5;
					}
					else
					{
						array[num14].derp -= 5;
					}
				}
			}
		}
		stopwatch5.Stop();
		array = new BenchObject[num2];
		for (int num15 = 0; num15 < array.Length; num15++)
		{
			array[num15] = new BenchObject();
		}
		Stopwatch stopwatch6 = new Stopwatch();
		stopwatch6.Start();
		for (int num16 = 0; (double)num16 < num; num16++)
		{
			foreach (BenchObject benchObject in array)
			{
				benchObject.derp += 22;
				if (benchObject.derp == 1000)
				{
					benchObject.derp += 10;
					if (benchObject.derp < 10)
					{
						benchObject.derp += 5;
					}
					else
					{
						benchObject.derp -= 5;
					}
				}
			}
			foreach (BenchObject benchObject2 in array)
			{
				benchObject2.derp += 22;
				if (benchObject2.derp == 1000)
				{
					benchObject2.derp += 10;
					if (benchObject2.derp < 10)
					{
						benchObject2.derp += 5;
					}
					else
					{
						benchObject2.derp -= 5;
					}
				}
			}
			foreach (BenchObject benchObject3 in array)
			{
				benchObject3.derp += 22;
				if (benchObject3.derp == 1000)
				{
					benchObject3.derp += 10;
					if (benchObject3.derp < 10)
					{
						benchObject3.derp += 5;
					}
					else
					{
						benchObject3.derp -= 5;
					}
				}
			}
			foreach (BenchObject benchObject4 in array)
			{
				benchObject4.derp += 22;
				if (benchObject4.derp == 1000)
				{
					benchObject4.derp += 10;
					if (benchObject4.derp < 10)
					{
						benchObject4.derp += 5;
					}
					else
					{
						benchObject4.derp -= 5;
					}
				}
			}
			foreach (BenchObject benchObject5 in array)
			{
				benchObject5.derp += 22;
				if (benchObject5.derp == 1000)
				{
					benchObject5.derp += 10;
					if (benchObject5.derp < 10)
					{
						benchObject5.derp += 5;
					}
					else
					{
						benchObject5.derp -= 5;
					}
				}
			}
		}
		stopwatch6.Stop();
		Debug.Log((object)("bench_objects " + (double)stopwatch.ElapsedTicks / num + " 100%"));
		Debug.Log((object)("bench_data " + getResult(stopwatch, stopwatch2, num)));
		Debug.Log((object)("bench_data_index " + getResult(stopwatch, stopwatch5, num)));
		Debug.Log((object)("bench_data_temp " + getResult(stopwatch, stopwatch6, num)));
		Debug.Log((object)("stopwatch_parallel " + getResult(stopwatch, stopwatch4, num)));
		Debug.Log((object)("stopwatch_data_optimized " + getResult(stopwatch, stopwatch3, num)));
	}

	private static string getResult(Stopwatch p1, Stopwatch p2, double pTries)
	{
		double num = (double)p1.ElapsedTicks / pTries;
		double num2 = (double)p2.ElapsedTicks / pTries;
		double num3 = num / num2 * 100.0 - 100.0;
		return num2 + ", " + num3 + "%";
	}

	public static void benchNativeECSAndOOP()
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Bench.bench_enabled = true;
		int num = 200000;
		NativeArray<Vector3> val = default(NativeArray<Vector3>);
		val._002Ector(num, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<int> val2 = default(NativeArray<int>);
		val2._002Ector(num, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<int> val3 = default(NativeArray<int>);
		val3._002Ector(num, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<int> val4 = default(NativeArray<int>);
		val4._002Ector(num, (Allocator)3, (NativeArrayOptions)1);
		ActorData[] array = new ActorData[num];
		for (int i = 0; i < num; i++)
		{
			array[i] = new ActorData();
		}
		Bench.bench("test_native_vectors");
		for (int j = 0; j < num; j++)
		{
			Vector3 val5 = val[j];
			val5.x = j;
			val5.y = j;
			val[j] = val5;
		}
		for (int k = 0; k < num; k++)
		{
			val4[k] = k;
		}
		Bench.benchEnd("test_native_vectors", "main", pSaveCounter: false, 0L);
		Bench.bench("test_native_x_y");
		for (int l = 0; l < num; l++)
		{
			val2[l] = l;
			val3[l] = l;
		}
		for (int m = 0; m < num; m++)
		{
			val4[m] = m;
		}
		Bench.benchEnd("test_native_x_y", "main", pSaveCounter: false, 0L);
		Bench.bench("test_normal_temp_var");
		for (int n = 0; n < num; n++)
		{
			ActorData obj = array[n];
			obj.x = n;
			obj.y = n;
		}
		for (int num2 = 0; num2 < num; num2++)
		{
			array[num2].health = num2;
		}
		Bench.benchEnd("test_normal_temp_var", "main", pSaveCounter: false, 0L);
		Bench.bench("test_normal_direct");
		for (int num3 = 0; num3 < num; num3++)
		{
			array[num3].x = num3;
			array[num3].y = num3;
		}
		for (int num4 = 0; num4 < num; num4++)
		{
			array[num4].health = num4;
		}
		Bench.benchEnd("test_normal_direct", "main", pSaveCounter: false, 0L);
		Debug.Log((object)"-  - - - - - - ");
		Debug.Log((object)("- BenchTest - test_native_vectors: " + Bench.getBenchResult("test_native_vectors", "main", pAverage: false)));
		Debug.Log((object)("- BenchTest - test_native_x_y: " + Bench.getBenchResult("test_native_x_y", "main", pAverage: false)));
		Debug.Log((object)("- BenchTest - test_normal_temp_var: " + Bench.getBenchResult("test_normal_temp_var", "main", pAverage: false)));
		Debug.Log((object)("- BenchTest - test_normal_direct: " + Bench.getBenchResult("test_normal_direct", "main", pAverage: false)));
		Debug.Log((object)("- BenchTest - test_job_native_vectors: " + Bench.getBenchResult("test_job_native_vectors", "main", pAverage: false)));
		Debug.Log((object)("- BenchTest - test_job_native_xy: " + Bench.getBenchResult("test_job_native_xy", "main", pAverage: false)));
		val.Dispose();
		val2.Dispose();
		val3.Dispose();
		val4.Dispose();
	}

	public static void benchReferenceVsDict()
	{
	}

	public static void testVirtual()
	{
		int num = 1000;
		BenchTest1 benchTest = new BenchTest1();
		BenchTest2 benchTest2 = new BenchTest2();
		Bench.bench("BenchTest - normal");
		for (int i = 0; i < num; i++)
		{
			benchTest.test();
		}
		Bench.benchEnd("BenchTest - normal", "main", pSaveCounter: false, 0L);
		Bench.bench("BenchTest - virtual");
		for (int j = 0; j < num; j++)
		{
			benchTest2.testVirtual();
		}
		Bench.benchEnd("BenchTest - virtual", "main", pSaveCounter: false, 0L);
		Debug.Log((object)"Benchmark:");
		Debug.Log((object)("- BenchTest - normal:" + Bench.getBenchResult("BenchTest - normal")));
		Debug.Log((object)("- BenchTest - virtual:" + Bench.getBenchResult("BenchTest - virtual")));
	}

	public static void testQueue()
	{
		int num = 10000;
		List<TileType> list = new List<TileType>();
		Queue<TileType> queue = new Queue<TileType>();
		LinkedList<TileType> linkedList = new LinkedList<TileType>();
		for (int i = 0; i < num; i++)
		{
			list.Add(new TileType());
			queue.Enqueue(new TileType());
			linkedList.AddLast(new TileType());
		}
		Bench.bench("list");
		for (int j = 0; j < list.Count; j++)
		{
			_ = list[0];
			list.RemoveAt(0);
		}
		Bench.benchEnd("list", "main", pSaveCounter: false, 0L);
		Bench.bench("queue");
		for (int k = 0; k < queue.Count; k++)
		{
			queue.Dequeue();
		}
		Bench.benchEnd("queue", "main", pSaveCounter: false, 0L);
		Bench.bench("linked");
		for (int l = 0; l < linkedList.Count; l++)
		{
			_ = linkedList.First;
			linkedList.RemoveFirst();
		}
		Bench.benchEnd("linked", "main", pSaveCounter: false, 0L);
		Debug.Log((object)("!!!BENCH REMOVE AT 0 " + num));
		Bench.printBenchResult("list");
		Bench.printBenchResult("queue");
		Bench.printBenchResult("linked");
	}

	public static void testRemoveStructs()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		int num = 100;
		int num2 = 500;
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		for (int i = 0; i < num2; i++)
		{
			Vector3 item = default(Vector3);
			item.x = Randy.randomInt(0, 1000);
			item.y = Randy.randomInt(0, 1000);
			item.z = Randy.randomInt(0, 1000);
			list.Add(item);
		}
		list.Shuffle();
		for (int j = 0; j < num; j++)
		{
			list2.Add(list.GetRandom());
		}
		Bench.bench("remove");
		foreach (Vector3 item2 in list)
		{
			list3.Add(item2);
		}
		for (int k = 0; k < num; k++)
		{
			list3.Remove(list2[k]);
		}
		Bench.benchEnd("remove", "main", pSaveCounter: false, 0L);
		Bench.bench("RemoveAtSwapBack");
		foreach (Vector3 item3 in list)
		{
			list4.Add(item3);
		}
		for (int l = 0; l < num; l++)
		{
			list4.RemoveAtSwapBack(list2[l]);
		}
		Bench.benchEnd("RemoveAtSwapBack", "main", pSaveCounter: false, 0L);
		Bench.benchEnd("remove_native", "main", pSaveCounter: false, 0L);
		Bench.bench("remove_hashset");
		foreach (Vector3 item4 in list)
		{
			hashSet.Add(item4);
		}
		for (int m = 0; m < num; m++)
		{
			hashSet.Remove(list2[m]);
		}
		Bench.benchEnd("remove_hashset", "main", pSaveCounter: false, 0L);
		Debug.Log((object)"Benchmark:");
		Debug.Log((object)("- built-in remove:" + Bench.getBenchResult("remove")));
		Debug.Log((object)("- own RemoveAtSwapBack: " + Bench.getBenchResult("RemoveAtSwapBack")));
		Debug.Log((object)("- native RemoveAtSwapBack: " + Bench.getBenchResult("remove_native")));
		Debug.Log((object)("- remove hashset: " + Bench.getBenchResult("remove_hashset")));
	}

	public static void testCapacity()
	{
		int num = 100;
		int num2 = 100000;
		Bench.bench("new_list");
		List<List<int>> list = new List<List<int>>(num);
		for (int i = 0; i < num; i++)
		{
			List<int> list2 = new List<int>();
			list.Add(list2);
			for (int j = 0; j < num2; j++)
			{
				list2.Add(j);
			}
		}
		Bench.benchEnd("new_list", "main", pSaveCounter: false, 0L);
		Bench.bench("new_list_reused");
		for (int k = 0; k < list.Count; k++)
		{
			List<int> list3 = list[k];
			list3.Clear();
			for (int l = 0; l < num2; l++)
			{
				list3.Add(l);
			}
		}
		Bench.benchEnd("new_list_reused", "main", pSaveCounter: false, 0L);
		Bench.bench("new_list_set_capacity");
		list = new List<List<int>>(num);
		for (int m = 0; m < num; m++)
		{
			List<int> list4 = new List<int>(num2);
			list.Add(list4);
			for (int n = 0; n < num2; n++)
			{
				list4.Add(n);
			}
		}
		Bench.benchEnd("new_list_set_capacity", "main", pSaveCounter: false, 0L);
		Bench.bench("new_list_set_capacity_reused");
		for (int num3 = 0; num3 < list.Count; num3++)
		{
			List<int> list5 = list[num3];
			list5.Clear();
			for (int num4 = 0; num4 < num2; num4++)
			{
				list5.Add(num4);
			}
		}
		Bench.benchEnd("new_list_set_capacity_reused", "main", pSaveCounter: false, 0L);
		Bench.printBenchResult("new_list");
		Bench.printBenchResult("new_list_set_capacity");
		Bench.printBenchResult("new_list_reused");
		Bench.printBenchResult("new_list_set_capacity_reused");
	}
}
// --- End of File: Benchmark.cs ---



// --- Start of File: BenchmarkBlacklist.cs ---
using System.Collections.Generic;
using UnityEngine;

public static class BenchmarkBlacklist
{
	private static List<WorldTile> _test_world_tiles = new List<WorldTile>();

	private static HashSet<WorldTile> _test_hashset = new HashSet<WorldTile>();

	private static WorldTile[] _test_world_tiles_arr;

	private static List<string> _names = new List<string>();

	private static HashSet<string> _names_set = new HashSet<string>();

	private static int _runs = 0;

	private static int _max = 250;

	private static HashSet<string> _good_words = new HashSet<string>();

	private static HashSet<string> _bad_words = new HashSet<string>();

	private static HashSet<string> _result_good_words = new HashSet<string>();

	private static HashSet<string> _result_bad_words = new HashSet<string>();

	public static void start()
	{
		if (_runs-- <= 0)
		{
			_names.Clear();
			_names_set.Clear();
			_max = Randy.randomInt(50, 255);
			_runs = 5;
		}
		if (_names.Count == 0)
		{
			_good_words.Clear();
			_bad_words.Clear();
			_names_set.Clear();
			Blacklist.init();
			BlacklistTest.init();
			BlacklistTest2.init();
			BlacklistTest3.init();
			BlacklistTest4.init();
			BlacklistTest5.init();
			BlacklistTest6.init();
			BlacklistTest7.init();
			BlacklistTest8.init();
			BlacklistTest9.init();
			BlacklistTest10.init();
			BlacklistTest11.init();
			BlacklistTest12.init();
			BlacklistTest13.init();
			AssetManager.name_generator.list.Shuffle();
			foreach (NameGeneratorAsset item in AssetManager.name_generator.list)
			{
				if (_names_set.Count > _max)
				{
					break;
				}
				for (int i = 0; i < 150; i++)
				{
					string text = NameGenerator.generateNameFromTemplate(item);
					if (string.IsNullOrEmpty(text))
					{
						Debug.LogError((object)("name generator returned null or empty string " + item.id));
						continue;
					}
					_names_set.Add(text);
					if (_names_set.Count > _max)
					{
						break;
					}
				}
			}
			_names.AddRange(_names_set);
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < _names.Count; j++)
			{
				if (!Blacklist.checkBlackList(_names[j]))
				{
					flag = true;
					_good_words.Add(_names[j]);
				}
				else
				{
					flag2 = true;
					_bad_words.Add(_names[j]);
				}
			}
			if (!flag || !flag2)
			{
				_runs = 0;
				start();
			}
			Debug.Log((object)("Unique names for test " + _names.Count + " / " + _max + " => " + _good_words.Count + " / " + _bad_words.Count));
		}
		_result_good_words.Clear();
		_result_bad_words.Clear();
		Bench.bench("blacklist_test", "blacklist_test_total");
		Bench.bench("current_blacklist_good", "blacklist_test");
		int num = 0;
		for (int k = 0; k < _names.Count; k++)
		{
			if (!Blacklist.checkBlackList(_names[k]))
			{
				num++;
				_result_good_words.Add(_names[k]);
			}
		}
		Bench.benchEnd("current_blacklist_good", "blacklist_test", pSaveCounter: true, num);
		Bench.bench("current_blacklist_bad", "blacklist_test");
		int num2 = 0;
		for (int l = 0; l < _names.Count; l++)
		{
			if (Blacklist.checkBlackList(_names[l]))
			{
				num2++;
				_result_bad_words.Add(_names[l]);
			}
		}
		Bench.benchEnd("current_blacklist_bad", "blacklist_test", pSaveCounter: true, num2);
		checkResult("current_blacklist_bad");
		Bench.bench("three_blacklist_good_9", "blacklist_test");
		int num3 = 0;
		for (int m = 0; m < _names.Count; m++)
		{
			if (!BlacklistTest9.checkBlackList(_names[m]))
			{
				num3++;
				_result_good_words.Add(_names[m]);
			}
		}
		Bench.benchEnd("three_blacklist_good_9", "blacklist_test", pSaveCounter: true, num3);
		Bench.bench("three_blacklist_bad_9", "blacklist_test");
		int num4 = 0;
		for (int n = 0; n < _names.Count; n++)
		{
			if (BlacklistTest9.checkBlackList(_names[n]))
			{
				num4++;
				_result_bad_words.Add(_names[n]);
			}
		}
		Bench.benchEnd("three_blacklist_bad_9", "blacklist_test", pSaveCounter: true, num4);
		checkResult("three_blacklist_bad_9");
		Bench.bench("old_blacklist_good_10", "blacklist_test");
		int num5 = 0;
		for (int num6 = 0; num6 < _names.Count; num6++)
		{
			if (!BlacklistTest10.checkBlackList(_names[num6]))
			{
				num5++;
				_result_good_words.Add(_names[num6]);
			}
		}
		Bench.benchEnd("old_blacklist_good_10", "blacklist_test", pSaveCounter: true, num5);
		Bench.bench("old_blacklist_bad_10", "blacklist_test");
		int num7 = 0;
		for (int num8 = 0; num8 < _names.Count; num8++)
		{
			if (BlacklistTest10.checkBlackList(_names[num8]))
			{
				num7++;
				_result_bad_words.Add(_names[num8]);
			}
		}
		Bench.benchEnd("old_blacklist_bad_10", "blacklist_test", pSaveCounter: true, num7);
		checkResult("old_blacklist_bad_10");
		Bench.bench("slice_blacklist_good_11", "blacklist_test");
		int num9 = 0;
		for (int num10 = 0; num10 < _names.Count; num10++)
		{
			if (!BlacklistTest11.checkBlackList(_names[num10]))
			{
				num9++;
				_result_good_words.Add(_names[num10]);
			}
		}
		Bench.benchEnd("slice_blacklist_good_11", "blacklist_test", pSaveCounter: true, num9);
		Bench.bench("slice_blacklist_bad_11", "blacklist_test");
		int num11 = 0;
		for (int num12 = 0; num12 < _names.Count; num12++)
		{
			if (BlacklistTest11.checkBlackList(_names[num12]))
			{
				num11++;
				_result_bad_words.Add(_names[num12]);
			}
		}
		Bench.benchEnd("slice_blacklist_bad_11", "blacklist_test", pSaveCounter: true, num11);
		checkResult("slice_blacklist_bad_11");
		Bench.bench("ref_blacklist_good_12", "blacklist_test");
		int num13 = 0;
		for (int num14 = 0; num14 < _names.Count; num14++)
		{
			if (!BlacklistTest12.checkBlackList(_names[num14]))
			{
				num13++;
				_result_good_words.Add(_names[num14]);
			}
		}
		Bench.benchEnd("ref_blacklist_good_12", "blacklist_test", pSaveCounter: true, num13);
		Bench.bench("ref_blacklist_bad_12", "blacklist_test");
		int num15 = 0;
		for (int num16 = 0; num16 < _names.Count; num16++)
		{
			if (BlacklistTest12.checkBlackList(_names[num16]))
			{
				num15++;
				_result_bad_words.Add(_names[num16]);
			}
		}
		Bench.benchEnd("ref_blacklist_bad_12", "blacklist_test", pSaveCounter: true, num15);
		checkResult("ref_blacklist_bad_12");
		Bench.bench("idx_blacklist_good_13", "blacklist_test");
		int num17 = 0;
		for (int num18 = 0; num18 < _names.Count; num18++)
		{
			if (!BlacklistTest13.checkBlackList(_names[num18]))
			{
				num17++;
				_result_good_words.Add(_names[num18]);
			}
		}
		Bench.benchEnd("idx_blacklist_good_13", "blacklist_test", pSaveCounter: true, num17);
		Bench.bench("idx_blacklist_bad_13", "blacklist_test");
		int num19 = 0;
		for (int num20 = 0; num20 < _names.Count; num20++)
		{
			if (BlacklistTest13.checkBlackList(_names[num20]))
			{
				num19++;
				_result_bad_words.Add(_names[num20]);
			}
		}
		Bench.benchEnd("idx_blacklist_bad_13", "blacklist_test", pSaveCounter: true, num19);
		checkResult("idx_blacklist_bad_13");
		Bench.benchEnd("blacklist_test", "blacklist_test_total", pSaveCounter: false, 0L);
	}

	public static void checkResult(string pBenchmarkName)
	{
		if (_result_good_words.Count != _good_words.Count || _result_bad_words.Count != _bad_words.Count)
		{
			Debug.LogError((object)(pBenchmarkName + ": Blacklist check failed " + _result_good_words.Count + " " + _good_words.Count + " " + _result_bad_words.Count + " " + _bad_words.Count));
			foreach (string result_good_word in _result_good_words)
			{
				if (!_good_words.Contains(result_good_word))
				{
					Debug.LogError((object)(pBenchmarkName + ": Missing good word: " + result_good_word));
				}
			}
			foreach (string result_bad_word in _result_bad_words)
			{
				if (!_bad_words.Contains(result_bad_word))
				{
					Debug.LogError((object)(pBenchmarkName + ": Missing bad word: " + result_bad_word));
				}
			}
			foreach (string good_word in _good_words)
			{
				if (!_result_good_words.Contains(good_word))
				{
					Debug.LogError((object)(pBenchmarkName + ": Extra good word: " + good_word));
				}
			}
			foreach (string bad_word in _bad_words)
			{
				if (!_result_bad_words.Contains(bad_word))
				{
					Debug.LogError((object)(pBenchmarkName + ": Extra bad word: " + bad_word));
				}
			}
		}
		_result_good_words.Clear();
		_result_bad_words.Clear();
	}
}
// --- End of File: BenchmarkBlacklist.cs ---



// --- Start of File: BenchmarkDist.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public class BenchmarkDist
{
	public long result;

	internal string benchmark_group_id;

	internal string benchmark_id;

	internal List<WorldTile> test_tiles;

	internal bool print_to_console;

	private static BenchmarkDist _instance;

	public BenchmarkDist()
	{
		if (_instance == null)
		{
			benchmark_group_id = "dist_test_total";
			benchmark_id = "dist_test";
			test_tiles = new List<WorldTile>();
			_instance = this;
			setup();
		}
	}

	public static void update()
	{
		_instance.run();
	}

	public void setup()
	{
		if (!Config.game_loaded)
		{
			MapBox.on_world_loaded = (Action)Delegate.Combine(MapBox.on_world_loaded, (Action)delegate
			{
				setup();
			});
		}
		else
		{
			test_tiles.AddRange(World.world.tiles_list);
			test_tiles.ShuffleHalf();
			test_tiles.RemoveRange(test_tiles.Count / 2, test_tiles.Count / 2);
		}
	}

	public void run()
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0779: Unknown result type (might be due to invalid IL or missing references)
		//IL_077d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0807: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0976: Unknown result type (might be due to invalid IL or missing references)
		//IL_0978: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a1f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b30: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b39: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bc0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c44: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c49: Unknown result type (might be due to invalid IL or missing references)
		string pGroupID = benchmark_group_id;
		string text = benchmark_id;
		int num = 0;
		double num2 = 0.0;
		int num3 = -1;
		int num4 = int.MaxValue;
		float num5 = float.MaxValue;
		List<WorldTile> list = test_tiles;
		list.Shuffle();
		int2[] array = (int2[])(object)new int2[list.Count];
		for (int i = 0; i < list.Count; i++)
		{
			array[i] = new int2(list[i].x, list[i].y);
		}
		float2[] array2 = (float2[])(object)new float2[list.Count];
		for (int j = 0; j < list.Count; j++)
		{
			array2[j] = new float2((float)list[j].x, (float)list[j].y);
		}
		NativeArray<int2> val = default(NativeArray<int2>);
		val._002Ector(array, (Allocator)3);
		NativeArray<float2> val2 = default(NativeArray<float2>);
		val2._002Ector(array2, (Allocator)3);
		WorldTile worldTile = list[0];
		Vector2Int pos = worldTile.pos;
		Vector3 posV = worldTile.posV3;
		int2 val3 = default(int2);
		((int2)(ref val3))._002Ector(worldTile.x, worldTile.y);
		float2 val4 = default(float2);
		((float2)(ref val4))._002Ector((float)worldTile.x, (float)worldTile.y);
		Bench.bench(text, pGroupID);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("DistTile", text);
		for (int k = 1; k < list.Count; k++)
		{
			WorldTile pT = list[k];
			float num6 = Toolbox.DistTile(worldTile, pT);
			if (num6 < num5)
			{
				num5 = num6;
				num3 = k;
			}
			num2 += (double)num6;
			num++;
		}
		Bench.benchEnd("DistTile", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("DistVec2", text);
		for (int l = 1; l < list.Count; l++)
		{
			WorldTile worldTile2 = list[l];
			float num7 = Toolbox.DistVec2(pos, worldTile2.pos);
			if (num7 < num5)
			{
				num5 = num7;
				num3 = l;
			}
			num2 += (double)num7;
			num++;
		}
		Bench.benchEnd("DistVec2", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("DistVec3", text);
		for (int m = 1; m < list.Count; m++)
		{
			WorldTile worldTile3 = list[m];
			float num8 = Toolbox.DistVec3(posV, worldTile3.posV3);
			if (num8 < num5)
			{
				num5 = num8;
				num3 = m;
			}
			num2 += (double)num8;
			num++;
		}
		Bench.benchEnd("DistVec3", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("Dist", text);
		for (int n = 1; n < list.Count; n++)
		{
			WorldTile worldTile4 = list[n];
			float num9 = Toolbox.Dist(worldTile.x, worldTile.y, worldTile4.x, worldTile4.y);
			if (num9 < num5)
			{
				num5 = num9;
				num3 = n;
			}
			num2 += (double)num9;
			num++;
		}
		Bench.benchEnd("Dist", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("DistFloat", text);
		for (int num10 = 1; num10 < list.Count; num10++)
		{
			WorldTile worldTile5 = list[num10];
			float num11 = DistFloat(worldTile.x, worldTile.y, worldTile5.x, worldTile5.y);
			if (num11 < num5)
			{
				num5 = num11;
				num3 = num10;
			}
			num2 += (double)num11;
			num++;
		}
		Bench.benchEnd("DistFloat", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("Dist.pos", text);
		for (int num12 = 1; num12 < list.Count; num12++)
		{
			Vector2Int pos2 = list[num12].pos;
			float num13 = Toolbox.Dist(((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, ((Vector2Int)(ref pos2)).x, ((Vector2Int)(ref pos2)).y);
			if (num13 < num5)
			{
				num5 = num13;
				num3 = num12;
			}
			num2 += (double)num13;
			num++;
		}
		Bench.benchEnd("Dist.pos", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDistTile", text);
		for (int num14 = 1; num14 < list.Count; num14++)
		{
			WorldTile pT2 = list[num14];
			int num15 = Toolbox.SquaredDistTile(worldTile, pT2);
			if (num15 < num4)
			{
				num4 = num15;
				num3 = num14;
			}
			num2 += (double)num15;
			num++;
		}
		Bench.benchEnd("FastDistTile", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDist", text);
		for (int num16 = 1; num16 < list.Count; num16++)
		{
			WorldTile worldTile6 = list[num16];
			int num17 = Toolbox.SquaredDist(worldTile.x, worldTile.y, worldTile6.x, worldTile6.y);
			if (num17 < num4)
			{
				num4 = num17;
				num3 = num16;
			}
			num2 += (double)num17;
			num++;
		}
		Bench.benchEnd("FastDist", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDistFloat", text);
		for (int num18 = 1; num18 < list.Count; num18++)
		{
			WorldTile worldTile7 = list[num18];
			float num19 = FastDistFloat(worldTile.x, worldTile.y, worldTile7.x, worldTile7.y);
			if (num19 < num5)
			{
				num5 = num19;
				num3 = num18;
			}
			num2 += (double)num19;
			num++;
		}
		Bench.benchEnd("FastDistFloat", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDistVec2", text);
		for (int num20 = 1; num20 < list.Count; num20++)
		{
			WorldTile worldTile8 = list[num20];
			int num21 = Toolbox.SquaredDistVec2(pos, worldTile8.pos);
			if (num21 < num4)
			{
				num4 = num21;
				num3 = num20;
			}
			num2 += (double)num21;
			num++;
		}
		Bench.benchEnd("FastDistVec2", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDistVec3", text);
		for (int num22 = 1; num22 < list.Count; num22++)
		{
			WorldTile worldTile9 = list[num22];
			float num23 = Toolbox.SquaredDistVec3(posV, worldTile9.posV3);
			if (num23 < num5)
			{
				num5 = num23;
				num3 = num22;
			}
			num2 += (double)num23;
			num++;
		}
		Bench.benchEnd("FastDistVec3", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("FastDist.pos", text);
		for (int num24 = 1; num24 < list.Count; num24++)
		{
			Vector2Int pos3 = list[num24].pos;
			float num25 = Toolbox.SquaredDist(((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, ((Vector2Int)(ref pos3)).x, ((Vector2Int)(ref pos3)).y);
			if (num25 < num5)
			{
				num5 = num25;
				num3 = num24;
			}
			num2 += (double)num25;
			num++;
		}
		Bench.benchEnd("FastDist.pos", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("distancesq", text);
		for (int num26 = 1; num26 < list.Count; num26++)
		{
			WorldTile worldTile10 = list[num26];
			float num27 = math.distancesq((float)worldTile.x, (float)worldTile10.x) + math.distancesq((float)worldTile.y, (float)worldTile10.y);
			if (num27 < num5)
			{
				num5 = num27;
				num3 = num26;
			}
			num2 += (double)num27;
			num++;
		}
		Bench.benchEnd("distancesq", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("float2", text);
		float2 val5 = default(float2);
		for (int num28 = 1; num28 < list.Count; num28++)
		{
			WorldTile worldTile11 = list[num28];
			((float2)(ref val5))._002Ector((float)worldTile11.x, (float)worldTile11.y);
			float num29 = math.distancesq(val4, val5);
			if (num29 < num5)
			{
				num5 = num29;
				num3 = num28;
			}
			num2 += (double)num29;
			num++;
		}
		Bench.benchEnd("float2", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("int2", text);
		int2 val6 = default(int2);
		for (int num30 = 1; num30 < list.Count; num30++)
		{
			WorldTile worldTile12 = list[num30];
			((int2)(ref val6))._002Ector(worldTile12.x, worldTile12.y);
			float num31 = math.distancesq(float2.op_Implicit(val3), float2.op_Implicit(val6));
			if (num31 < num5)
			{
				num5 = num31;
				num3 = num30;
			}
			num2 += (double)num31;
			num++;
		}
		Bench.benchEnd("int2", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("int2array", text);
		for (int num32 = 1; num32 < array.Length; num32++)
		{
			float num33 = math.distancesq(float2.op_Implicit(val3), float2.op_Implicit(array[num32]));
			if (num33 < num5)
			{
				num5 = num33;
				num3 = num32;
			}
			num2 += (double)num33;
			num++;
		}
		Bench.benchEnd("int2array", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("nint2array", text);
		for (int num34 = 1; num34 < val2.Length; num34++)
		{
			float num35 = math.distancesq(float2.op_Implicit(val3), val2[num34]);
			if (num35 < num5)
			{
				num5 = num35;
				num3 = num34;
			}
			num2 += (double)num35;
			num++;
		}
		Bench.benchEnd("nint2array", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("float2array", text);
		for (int num36 = 1; num36 < array2.Length; num36++)
		{
			float num37 = math.distancesq(val4, array2[num36]);
			if (num37 < num5)
			{
				num5 = num37;
				num3 = num36;
			}
			num2 += (double)num37;
			num++;
		}
		Bench.benchEnd("float2array", text, pSaveCounter: true, list[num3].tile_id);
		num3 = -1;
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		num2 = 0.0;
		num = 0;
		Bench.bench("nfloat2array", text);
		for (int num38 = 1; num38 < val.Length; num38++)
		{
			float num39 = math.distancesq(val4, float2.op_Implicit(val[num38]));
			if (num39 < num5)
			{
				num5 = num39;
				num3 = num38;
			}
			num2 += (double)num39;
			num++;
		}
		Bench.benchEnd("nfloat2array", text, pSaveCounter: true, list[num3].tile_id);
		val.Dispose();
		val2.Dispose();
		Bench.benchEnd(text, pGroupID, pSaveCounter: false, 0L);
		if (print_to_console)
		{
			Debug.Log((object)("LAST:\n" + Bench.printableBenchResults(text, false, "DistTile", "DistVec2", "DistVec3", "Dist", "DistFloat", "Dist.pos", "FastDistTile", "FastDistVec2", "FastDistVec3", "FastDist", "FastDistFloat", "FastDist.pos", "int2", "int2array", "nint2array", "float2", "float2array", "nfloat2array", "distancesq", "job_new", "job_prefill", "pjob_prefill", "BurstDist", "BurstDistFloat", "BurstFastDistFloat", "BurstDist.pos", "BurstFastDist", "BurstFastDist.pos")));
			Debug.Log((object)("AVG:\n" + Bench.printableBenchResults(text, true, "DistTile", "DistVec2", "DistVec3", "Dist", "DistFloat", "Dist.pos", "FastDistTile", "FastDistVec2", "FastDistVec3", "FastDist", "FastDistFloat", "FastDist.pos", "int2", "int2array", "nint2array", "float2", "float2array", "nfloat2array", "distancesq", "job_new", "job_prefill", "pjob_prefill", "BurstDist", "BurstDistFloat", "BurstFastDistFloat", "BurstDist.pos", "BurstFastDist", "BurstFastDist.pos")));
		}
		result = (long)num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float DistFloat(float x1, float y1, float x2, float y2)
	{
		return Mathf.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float FastDistFloat(float x1, float y1, float x2, float y2)
	{
		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	}
}
// --- End of File: BenchmarkDist.cs ---



// --- Start of File: BenchmarkFieldAccess.cs ---
public class BenchmarkFieldAccess
{
	public static void start()
	{
		if (Config.game_loaded)
		{
			int num = 100000;
			Bench.bench("field_acess_test", "field_acess_total");
			Bench.bench("field_access", "field_acess_test");
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				num2 += World.world.tiles_list.Length;
			}
			Bench.benchEnd("field_access", "field_acess_test", pSaveCounter: true, num);
			Bench.bench("temp_var", "field_acess_test");
			num2 = 0;
			MapBox world = World.world;
			for (int j = 0; j < num; j++)
			{
				num2 += world.tiles_list.Length;
			}
			Bench.benchEnd("temp_var", "field_acess_test", pSaveCounter: true, num);
			Bench.bench("temp_var_2", "field_acess_test");
			num2 = 0;
			WorldTile[] tiles_list = World.world.tiles_list;
			for (int k = 0; k < num; k++)
			{
				int num3 = tiles_list.Length;
				num2 += num3;
			}
			Bench.benchEnd("temp_var_2", "field_acess_test", pSaveCounter: true, num);
			Bench.bench("result_len", "field_acess_test");
			num2 = 0;
			int num4 = World.world.tiles_list.Length;
			for (int l = 0; l < num; l++)
			{
				num2 += num4;
			}
			Bench.benchEnd("result_len", "field_acess_test", pSaveCounter: true, num);
			Bench.benchEnd("field_acess_test", "field_acess_total", pSaveCounter: false, 0L);
		}
	}
}
// --- End of File: BenchmarkFieldAccess.cs ---



// --- Start of File: BenchmarkGroup.cs ---
using System.Collections.Generic;

public class BenchmarkGroup
{
	public string id;

	public Dictionary<string, ToolBenchmarkData> dict_data = new Dictionary<string, ToolBenchmarkData>();

	public void flatten()
	{
		foreach (ToolBenchmarkData value in dict_data.Values)
		{
			value.end(0.0);
		}
	}
}
// --- End of File: BenchmarkGroup.cs ---



// --- Start of File: BenchmarkGroupID.cs ---
public static class BenchmarkGroupID
{
	public const string main = "main";

	public const string quantum_sprites = "quantum_sprites";

	public const string world_beh = "world_beh";

	public const string zone_camera = "zone_camera";

	public const string zone_camera_total = "zone_camera_total";

	public const string world_cache_manager = "world_cache_manager";

	public const string sim_zones = "sim_zones";

	public const string chunks = "chunks";

	public const string chunks_total = "chunks_total";

	public const string sprites_test = "sprites_test";

	public const string sprites_test_total = "sprites_test_total";

	public const string field_acess_test = "field_acess_test";

	public const string field_acess_total = "field_acess_total";

	public const string borders_renderer = "borders_renderer";

	public const string borders_renderer_total = "borders_renderer_total";

	public const string fluid_zones_data = "fluid_zones_data";

	public const string fluid_zones_data_total = "fluid_zones_data_total";

	public const string game_total = "game_total";

	public const string music_box = "music_box";

	public const string music_box_total = "music_box_total";

	public const string nameplates = "nameplates";

	public const string nameplates_total = "nameplates_total";

	public const string loops_test_10 = "loops_test_10";

	public const string loops_test_100 = "loops_test_100";

	public const string loops_test_1000 = "loops_test_1000";

	public const string loops_test_10000 = "loops_test_10000";

	public const string loops_test_total_10 = "loops_test_total_10";

	public const string loops_test_total_100 = "loops_test_total_100";

	public const string loops_test_total_1000 = "loops_test_total_1000";

	public const string loops_test_total_10000 = "loops_test_total_10000";

	public const string dist_test = "dist_test";

	public const string dist_test_total = "dist_test_total";

	public const string shuffle_test_10 = "shuffle_test_10";

	public const string shuffle_test_100 = "shuffle_test_100";

	public const string shuffle_test_1000 = "shuffle_test_1000";

	public const string shuffle_test_10000 = "shuffle_test_10000";

	public const string shuffle_test_total_10 = "shuffle_test_total_10";

	public const string shuffle_test_total_100 = "shuffle_test_total_100";

	public const string shuffle_test_total_1000 = "shuffle_test_total_1000";

	public const string shuffle_test_total_10000 = "shuffle_test_total_10000";

	public const string loops_struct_test = "loops_struct_test";

	public const string loops_struct_test_total = "loops_struct_test_total";

	public const string decisions_test = "decisions_test";

	public const string decisions_test_total = "decisions_test_total";

	public const string ecs_test = "ecs_test";

	public const string ecs_test_total = "ecs_test_total";

	public const string blacklist_test = "blacklist_test";

	public const string blacklist_test_total = "blacklist_test_total";

	public const string actors = "actors";

	public const string buildings = "buildings";

	public const string effects_items = "effects_items";

	public const string effects_traits = "effects_traits";

	public const string loading = "loading";

	public const string ai_actions = "ai_actions";

	public const string ai_actions_total = "ai_actions_total";

	public const string ai_tasks = "ai_tasks";

	public const string ai_tasks_total = "ai_tasks_total";
}
// --- End of File: BenchmarkGroupID.cs ---



// --- Start of File: BenchmarkLoops.cs ---
using System;
using System.Collections.Generic;

public class BenchmarkLoops
{
	private List<WorldTile> _test_world_tiles = new List<WorldTile>();

	private ListPool<WorldTile> _test_world_tiles_pool;

	private HashSet<WorldTile> _test_hashset = new HashSet<WorldTile>();

	private WorldTile[] _test_world_tiles_arr;

	private List<WorldTile> _new_tiles = new List<WorldTile>();

	private int _runs;

	private bool _counter;

	private int _max_amount;

	private DebugToolAsset _asset;

	internal static Dictionary<string, BenchmarkLoops> _benchmarks = new Dictionary<string, BenchmarkLoops>();

	public BenchmarkLoops(DebugToolAsset pAsset, int pMaxAmount)
	{
		if (!_benchmarks.ContainsKey(pAsset.benchmark_group_id))
		{
			_benchmarks.Add(pAsset.benchmark_group_id, this);
			_max_amount = pMaxAmount;
			_asset = pAsset;
		}
	}

	public static void update(DebugToolAsset pAsset)
	{
		_benchmarks[pAsset.benchmark_group_id].run();
	}

	public void run()
	{
		string benchmark_group_id = _asset.benchmark_group_id;
		string benchmark_total_group = _asset.benchmark_total_group;
		int count = _test_world_tiles.Count;
		_counter = Randy.randomBool();
		if (_runs++ > 10 || _test_world_tiles_arr == null)
		{
			_runs = 0;
			_test_world_tiles_pool?.Dispose();
			_test_hashset.Clear();
			_test_world_tiles_arr?.Clear();
			_test_world_tiles.Clear();
			foreach (WorldTile new_tile in _new_tiles)
			{
				new_tile.Dispose();
			}
			_new_tiles.Clear();
			for (int i = 0; i < _max_amount; i++)
			{
				_test_world_tiles.Add(World.world.tiles_list.GetRandom());
			}
			_test_hashset.UnionWith(_test_world_tiles);
			_test_world_tiles_pool = new ListPool<WorldTile>(_test_world_tiles);
			_test_world_tiles_arr = _test_world_tiles.ToArray();
		}
		Bench.bench(benchmark_group_id, benchmark_total_group);
		_test_world_tiles.Shuffle();
		_test_world_tiles.Shuffle();
		_test_world_tiles.Shuffle();
		_test_world_tiles.Shuffle();
		_test_world_tiles_arr.Shuffle();
		_test_world_tiles_arr.Shuffle();
		_test_world_tiles_arr.Shuffle();
		_test_world_tiles_arr.Shuffle();
		_test_world_tiles_pool.Shuffle();
		_test_world_tiles_pool.Shuffle();
		_test_world_tiles_pool.Shuffle();
		_test_world_tiles_pool.Shuffle();
		Bench.bench("list_for_field", benchmark_group_id);
		int num = 0;
		count = 0;
		for (int j = 0; j < _test_world_tiles.Count; j++)
		{
			WorldTile worldTile = _test_world_tiles[j];
			num += worldTile.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_for_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_for_field", benchmark_group_id);
		num = 0;
		count = 0;
		for (int k = 0; k < _test_world_tiles_pool.Count; k++)
		{
			WorldTile worldTile2 = _test_world_tiles_pool[k];
			num += worldTile2.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_for_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_span_for", benchmark_group_id);
		num = 0;
		count = 0;
		Span<WorldTile> span = _test_world_tiles_pool.AsSpan();
		for (int l = 0; l < span.Length; l++)
		{
			WorldTile worldTile3 = span[l];
			num += worldTile3.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_span_for", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_for_local", benchmark_group_id);
		num = 0;
		count = 0;
		List<WorldTile> test_world_tiles = _test_world_tiles;
		for (int m = 0; m < test_world_tiles.Count; m++)
		{
			WorldTile worldTile4 = test_world_tiles[m];
			num += worldTile4.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_for_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_for_local", benchmark_group_id);
		num = 0;
		count = 0;
		ListPool<WorldTile> test_world_tiles_pool = _test_world_tiles_pool;
		for (int n = 0; n < test_world_tiles_pool.Count; n++)
		{
			WorldTile worldTile5 = test_world_tiles_pool[n];
			num += worldTile5.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_for_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_span_for_local", benchmark_group_id);
		num = 0;
		count = 0;
		Span<WorldTile> span2 = _test_world_tiles_pool.AsSpan();
		for (int num2 = 0; num2 < span2.Length; num2++)
		{
			WorldTile worldTile6 = span2[num2];
			num += worldTile6.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_span_for_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_for_local_len", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles = _test_world_tiles;
		int count2 = test_world_tiles.Count;
		for (int num3 = 0; num3 < count2; num3++)
		{
			WorldTile worldTile7 = test_world_tiles[num3];
			num += worldTile7.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_for_local_len", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_for_local_len", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles_pool = _test_world_tiles_pool;
		count2 = test_world_tiles_pool.Count;
		for (int num4 = 0; num4 < count2; num4++)
		{
			WorldTile worldTile8 = test_world_tiles_pool[num4];
			num += worldTile8.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_for_local_len", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_span_for_local_len", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = _test_world_tiles_pool.AsSpan();
		count2 = span2.Length;
		for (int num5 = 0; num5 < count2; num5++)
		{
			WorldTile worldTile9 = span2[num5];
			num += worldTile9.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_span_for_local_len", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_foreach_field", benchmark_group_id);
		num = 0;
		count = 0;
		foreach (WorldTile test_world_tile in _test_world_tiles)
		{
			num += test_world_tile.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_foreach_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_foreach_field", benchmark_group_id);
		num = 0;
		count = 0;
		foreach (ref WorldTile item in _test_world_tiles_pool)
		{
			WorldTile current2 = item;
			num += current2.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_foreach_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_foreach_local", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles = _test_world_tiles;
		foreach (WorldTile item2 in test_world_tiles)
		{
			num += item2.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_foreach_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_foreach_local", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles_pool = _test_world_tiles_pool;
		foreach (ref WorldTile item3 in test_world_tiles_pool)
		{
			WorldTile current4 = item3;
			num += current4.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_foreach_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_pool.Shuffle();
		Bench.bench("lpool_span_foreach", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = _test_world_tiles_pool.AsSpan();
		Span<WorldTile> span3 = span2;
		for (int num6 = 0; num6 < span3.Length; num6++)
		{
			WorldTile worldTile10 = span3[num6];
			num += worldTile10.data.tile_id;
			count++;
		}
		Bench.benchEnd("lpool_span_foreach", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_span_for", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = _test_world_tiles.AsSpan();
		for (int num7 = 0; num7 < span2.Length; num7++)
		{
			WorldTile worldTile11 = span2[num7];
			num += worldTile11.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_span_for", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_span_for_new", benchmark_group_id);
		num = 0;
		count = 0;
		Span<WorldTile> span4 = _test_world_tiles.AsSpan();
		for (int num8 = 0; num8 < span4.Length; num8++)
		{
			WorldTile worldTile12 = span4[num8];
			num += worldTile12.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_span_for_new", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_span_foreach", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = _test_world_tiles.AsSpan();
		span3 = span2;
		for (int num6 = 0; num6 < span3.Length; num6++)
		{
			WorldTile worldTile13 = span3[num6];
			num += worldTile13.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_span_foreach", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_span_foreach_new", benchmark_group_id);
		num = 0;
		count = 0;
		span3 = _test_world_tiles.AsSpan();
		for (int num6 = 0; num6 < span3.Length; num6++)
		{
			WorldTile worldTile14 = span3[num6];
			num += worldTile14.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_span_foreach_new", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_rspan_for", benchmark_group_id);
		num = 0;
		count = 0;
		ReadOnlySpan<WorldTile> readOnlySpan = _test_world_tiles.AsReadOnlySpan();
		for (int num9 = 0; num9 < readOnlySpan.Length; num9++)
		{
			WorldTile worldTile15 = readOnlySpan[num9];
			num += worldTile15.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_rspan_for", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_rspan_for_new", benchmark_group_id);
		num = 0;
		count = 0;
		ReadOnlySpan<WorldTile> readOnlySpan2 = _test_world_tiles.AsReadOnlySpan();
		for (int num10 = 0; num10 < readOnlySpan2.Length; num10++)
		{
			WorldTile worldTile16 = readOnlySpan2[num10];
			num += worldTile16.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_rspan_for_new", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_rspan_foreach", benchmark_group_id);
		num = 0;
		count = 0;
		readOnlySpan = _test_world_tiles.AsReadOnlySpan();
		ReadOnlySpan<WorldTile> readOnlySpan3 = readOnlySpan;
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		{
			WorldTile worldTile17 = readOnlySpan3[num6];
			num += worldTile17.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_rspan_foreach", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles.Shuffle();
		Bench.bench("list_rspan_foreach_new", benchmark_group_id);
		num = 0;
		count = 0;
		readOnlySpan3 = _test_world_tiles.AsReadOnlySpan();
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		{
			WorldTile worldTile18 = readOnlySpan3[num6];
			num += worldTile18.data.tile_id;
			count++;
		}
		Bench.benchEnd("list_rspan_foreach_new", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_for_field", benchmark_group_id);
		num = 0;
		count = 0;
		for (int num11 = 0; num11 < _test_world_tiles_arr.Length; num11++)
		{
			WorldTile worldTile19 = _test_world_tiles_arr[num11];
			num += worldTile19.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_for_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_for_local", benchmark_group_id);
		num = 0;
		count = 0;
		WorldTile[] test_world_tiles_arr = _test_world_tiles_arr;
		foreach (WorldTile worldTile20 in test_world_tiles_arr)
		{
			num += worldTile20.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_for_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_for_local_len", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles_arr = _test_world_tiles_arr;
		count2 = test_world_tiles_arr.Length;
		for (int num13 = 0; num13 < count2; num13++)
		{
			WorldTile worldTile21 = test_world_tiles_arr[num13];
			num += worldTile21.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_for_local_len", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_foreach_field", benchmark_group_id);
		num = 0;
		count = 0;
		WorldTile[] test_world_tiles_arr2 = _test_world_tiles_arr;
		foreach (WorldTile worldTile22 in test_world_tiles_arr2)
		{
			num += worldTile22.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_foreach_field", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_foreach_local", benchmark_group_id);
		num = 0;
		count = 0;
		test_world_tiles_arr = _test_world_tiles_arr;
		test_world_tiles_arr2 = test_world_tiles_arr;
		foreach (WorldTile worldTile23 in test_world_tiles_arr2)
		{
			num += worldTile23.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_foreach_local", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_rspan_foreach", benchmark_group_id);
		readOnlySpan = new ReadOnlySpan<WorldTile>(_test_world_tiles_arr);
		num = 0;
		count = 0;
		readOnlySpan3 = readOnlySpan;
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		{
			WorldTile worldTile24 = readOnlySpan3[num6];
			num += worldTile24.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_rspan_foreach", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_rspan_for", benchmark_group_id);
		readOnlySpan = new ReadOnlySpan<WorldTile>(_test_world_tiles_arr);
		num = 0;
		count = 0;
		for (int num14 = 0; num14 < readOnlySpan.Length; num14++)
		{
			WorldTile worldTile25 = readOnlySpan[num14];
			num += worldTile25.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_rspan_for", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_span_foreach", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = new Span<WorldTile>(_test_world_tiles_arr);
		span3 = span2;
		for (int num6 = 0; num6 < span3.Length; num6++)
		{
			WorldTile worldTile26 = span3[num6];
			num += worldTile26.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_span_foreach", benchmark_group_id, pSaveCounter: true, num);
		_test_world_tiles_arr.Shuffle();
		Bench.bench("arr_span_for", benchmark_group_id);
		num = 0;
		count = 0;
		span2 = new Span<WorldTile>(_test_world_tiles_arr);
		for (int num15 = 0; num15 < span2.Length; num15++)
		{
			WorldTile worldTile27 = span2[num15];
			num += worldTile27.data.tile_id;
			count++;
		}
		Bench.benchEnd("arr_span_for", benchmark_group_id, pSaveCounter: true, num);
		Bench.benchEnd(benchmark_group_id, benchmark_total_group, pSaveCounter: false, 0L);
	}
}
// --- End of File: BenchmarkLoops.cs ---



// --- Start of File: BenchmarkObjects.cs ---
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

public class BenchmarkObjects : MonoBehaviour
{
	public static BenchmarkObjects instance;

	public List<Sprite> some_sprites = new List<Sprite>();

	public TestActorGameObject prefab_unity_object;

	private List<TestActorGameObject> actors_unity = new List<TestActorGameObject>();

	internal List<TestActorSimpleObject> actors_simple = new List<TestActorSimpleObject>();

	internal List<TestActorSimpleObject> actors_simple_visible = new List<TestActorSimpleObject>();

	public int total_unity_objects;

	public int total_simple_objects;

	public int total_simple_objects_visible;

	public BenchmarkObjects()
	{
		instance = this;
	}

	private void Update()
	{
		update(Time.deltaTime);
		total_unity_objects = actors_unity.Count;
		total_simple_objects = actors_simple.Count;
		total_simple_objects_visible = actors_simple_visible.Count;
	}

	public void addObjectsSimple(int pAmount = 2000)
	{
		for (int i = 0; i < pAmount; i++)
		{
			TestActorSimpleObject testActorSimpleObject = new TestActorSimpleObject();
			testActorSimpleObject.create(some_sprites);
			actors_simple.Add(testActorSimpleObject);
		}
	}

	public void addObjectsUnity(int pAmount = 2000)
	{
		for (int i = 0; i < pAmount; i++)
		{
			TestActorGameObject testActorGameObject = Object.Instantiate<TestActorGameObject>(prefab_unity_object);
			testActorGameObject.create(some_sprites);
			((Component)testActorGameObject).transform.parent = ((Component)this).transform;
			actors_unity.Add(testActorGameObject);
		}
	}

	public void killAll()
	{
		foreach (TestActorGameObject item in actors_unity)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject, 0.01f);
		}
		actors_unity.Clear();
		actors_simple.Clear();
	}

	public void randomRespawn()
	{
		foreach (TestActorGameObject item in actors_unity)
		{
			item.randomRespawn();
		}
		foreach (TestActorSimpleObject item2 in actors_simple)
		{
			item2.randomRespawn();
		}
	}

	public void update(float pElapsed)
	{
		updateKeys();
		updateUnityActors(pElapsed);
		updateSimpleActors(pElapsed);
		updateVisibility(pElapsed);
	}

	private void updateKeys()
	{
		if (Input.GetKeyDown((KeyCode)49))
		{
			addObjectsSimple();
		}
		if (Input.GetKeyDown((KeyCode)50))
		{
			addObjectsUnity();
		}
		if (Input.GetKeyDown((KeyCode)51))
		{
			randomRespawn();
		}
		if (Input.GetKeyDown((KeyCode)52))
		{
			killAll();
		}
	}

	private void updateUnityActors(float pElapsed)
	{
		for (int i = 0; i < actors_unity.Count; i++)
		{
			actors_unity[i].update(pElapsed);
		}
	}

	private void updateSimpleActors(float pElapsed)
	{
		Parallel.ForEach(actors_simple, World.world.parallel_options, delegate(TestActorSimpleObject pActor)
		{
			pActor.update(pElapsed);
		});
	}

	private void updateVisibility(float pElapsed)
	{
		actors_simple_visible.Clear();
		float num = 8f;
		for (int i = 0; i < actors_simple.Count; i++)
		{
			TestActorSimpleObject testActorSimpleObject = actors_simple[i];
			float pos_x = testActorSimpleObject.pos_x;
			float pos_y = testActorSimpleObject.pos_y;
			int pX = Mathf.FloorToInt(pos_x / num);
			int pY = Mathf.FloorToInt(pos_y / num);
			TileZone zone = World.world.zone_calculator.getZone(pX, pY);
			if (zone != null && zone.visible)
			{
				actors_simple_visible.Add(testActorSimpleObject);
			}
		}
	}
}
// --- End of File: BenchmarkObjects.cs ---



// --- Start of File: BenchmarkShuffle.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

public class BenchmarkShuffle
{
	public int result;

	internal int max_tiles;

	internal int amount;

	internal string benchmark_total_group_id;

	internal string benchmark_group_id;

	internal List<WorldTile> test_tiles;

	internal bool print_to_console;

	internal static Dictionary<string, BenchmarkShuffle> _benchmarks = new Dictionary<string, BenchmarkShuffle>();

	public BenchmarkShuffle(DebugToolAsset pAsset, int pAmount, int pMaxTiles)
	{
		if (!_benchmarks.ContainsKey(pAsset.benchmark_group_id))
		{
			amount = pAmount;
			max_tiles = pMaxTiles;
			benchmark_total_group_id = pAsset.benchmark_total_group;
			benchmark_group_id = pAsset.benchmark_group_id;
			test_tiles = new List<WorldTile>();
			_benchmarks.Add(pAsset.benchmark_group_id, this);
			setup();
		}
	}

	public static void update(DebugToolAsset pAsset)
	{
		_benchmarks[pAsset.benchmark_group_id].run();
	}

	public void setup()
	{
		if (!Config.game_loaded)
		{
			MapBox.on_world_loaded = (Action)Delegate.Combine(MapBox.on_world_loaded, (Action)delegate
			{
				setup();
			});
			return;
		}
		int num = max_tiles;
		test_tiles.Clear();
		int num2 = Mathf.CeilToInt(Mathf.Sqrt((float)num));
		num2 *= num2;
		using ListPool<WorldTile> list = new ListPool<WorldTile>(World.world.tiles_list);
		list.Shuffle();
		for (int i = 0; i < num2; i++)
		{
			test_tiles.Add(list.Pop());
		}
		test_tiles.Shuffle();
	}

	public void run()
	{
		int num = amount;
		string pGroupID = benchmark_total_group_id;
		string text = benchmark_group_id;
		int num2 = 0;
		int num3 = 0;
		List<WorldTile> list = test_tiles;
		for (int num4 = num - 1; num4 >= 0; num4--)
		{
			WorldTile worldTile = list[num4];
			num3 += worldTile.data.tile_id;
			num2++;
		}
		Bench.bench(text, pGroupID);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"no_shuffle_for_{num}", text);
		for (int i = 0; i < num; i++)
		{
			WorldTile worldTile2 = list[i];
			num3 += worldTile2.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"no_shuffle_for_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_all_{num}", text);
		list.Shuffle();
		for (int j = 0; j < num; j++)
		{
			WorldTile worldTile3 = list[j];
			num3 += worldTile3.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"shuffle_all_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_one_new_list_{num}", text);
		ListPool<WorldTile> listPool = new ListPool<WorldTile>(list);
		for (int k = 0; k < num; k++)
		{
			listPool.ShuffleOne(k);
			WorldTile worldTile4 = listPool[k];
			num3 += worldTile4.data.tile_id;
			num2++;
		}
		listPool.Dispose();
		Bench.benchEnd($"shuffle_one_new_list_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_one_{num}", text);
		for (int l = 0; l < num; l++)
		{
			list.ShuffleOne(l);
			WorldTile worldTile5 = list[l];
			num3 += worldTile5.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"shuffle_one_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_for_{num}", text);
		int num5 = Randy.randomInt(0, num);
		int num6 = num + num5;
		for (int m = num5; m < num6; m++)
		{
			int index = m % num;
			WorldTile worldTile6 = list[index];
			num3 += worldTile6.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"shuffle_for_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_2for_{num}", text);
		num5 = Randy.randomInt(0, num);
		for (int n = num5; n < num; n++)
		{
			WorldTile worldTile7 = list[n];
			num3 += worldTile7.data.tile_id;
			num2++;
		}
		for (int num7 = 0; num7 < num5; num7++)
		{
			WorldTile worldTile8 = list[num7];
			num3 += worldTile8.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"shuffle_2for_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_iterator_{num}", text);
		foreach (WorldTile item in list.LoopRandom())
		{
			num3 += item.data.tile_id;
			num2++;
			if (num2 == num)
			{
				break;
			}
		}
		Bench.benchEnd($"shuffle_iterator_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"shuffle_iterator_limit_{num}", text);
		foreach (WorldTile item2 in list.LoopRandom(num))
		{
			num3 += item2.data.tile_id;
			num2++;
		}
		Bench.benchEnd($"shuffle_iterator_limit_{num}", text, pSaveCounter: true, num2);
		test_tiles.Shuffle();
		num3 = 0;
		num2 = 0;
		Bench.bench($"no_shuffle_iterator_{num}", text);
		foreach (WorldTile item3 in list)
		{
			num3 += item3.data.tile_id;
			num2++;
			if (num2 == num)
			{
				break;
			}
		}
		Bench.benchEnd($"no_shuffle_iterator_{num}", text, pSaveCounter: true, num2);
		Bench.benchEnd(text, pGroupID, pSaveCounter: false, 0L);
		if (print_to_console)
		{
			Debug.Log((object)("LAST:\n" + Bench.printableBenchResults(text, false, $"no_shuffle_for_{num}", $"no_shuffle_iterator_{num}", $"shuffle_iterator_{num}", $"shuffle_iterator_limit_{num}", $"shuffle_for_{num}", $"shuffle_2for_{num}", $"shuffle_one_{num}", $"shuffle_one_new_list_{num}", $"shuffle_all_{num}")));
			Debug.Log((object)("AVG:\n" + Bench.printableBenchResults(text, true, $"no_shuffle_for_{num}", $"no_shuffle_iterator_{num}", $"shuffle_iterator_{num}", $"shuffle_iterator_limit_{num}", $"shuffle_for_{num}", $"shuffle_2for_{num}", $"shuffle_one_{num}", $"shuffle_one_new_list_{num}", $"shuffle_all_{num}")));
		}
		result = num3;
	}
}
// --- End of File: BenchmarkShuffle.cs ---



// --- Start of File: BenchmarkSprites.cs ---
public class BenchmarkSprites
{
	public static void start()
	{
		if (!Config.game_loaded || !SelectedUnit.isSet())
		{
			return;
		}
		Actor unit = SelectedUnit.unit;
		if (unit.is_visible)
		{
			int num = 100;
			Bench.bench("sprites_old", "sprites_test");
			for (int i = 0; i < num; i++)
			{
				DynamicSpriteCreator.createNewSpriteUnit(unit.frame_data, unit.calculateMainSprite(), unit.cached_sprite_head, unit.kingdom.getColor(), unit.asset, unit.data.phenotype_index, unit.data.phenotype_shade, UnitTextureAtlasID.Units);
			}
			Bench.benchEnd("sprites_old", "sprites_test", pSaveCounter: true, num);
			Bench.bench("sprites_new", "sprites_test");
			for (int j = 0; j < num; j++)
			{
				DynamicSpriteCreator.createNewSpriteUnit(unit.frame_data, unit.calculateMainSprite(), unit.cached_sprite_head, unit.kingdom.getColor(), unit.asset, unit.data.phenotype_index, unit.data.phenotype_shade, UnitTextureAtlasID.Units);
			}
			Bench.benchEnd("sprites_new", "sprites_test", pSaveCounter: true, num);
		}
	}
}
// --- End of File: BenchmarkSprites.cs ---



// --- Start of File: BenchmarkStructLoops.cs ---
using System;
using System.Collections.Generic;

public static class BenchmarkStructLoops
{
	private static List<WorldTileDataStruct> _test_world_tiles = new List<WorldTileDataStruct>();

	private static ListPool<WorldTileDataStruct> _test_world_tiles_pool;

	private static HashSet<WorldTileDataStruct> _test_hashset = new HashSet<WorldTileDataStruct>();

	private static WorldTileDataStruct[] _test_world_tiles_arr;

	private static int _runs = 0;

	public static void start()
	{
		int count = _test_world_tiles.Count;
		if (_runs++ > 30 || _test_world_tiles_arr == null)
		{
			_runs = 0;
			_test_world_tiles_pool?.Dispose();
			_test_world_tiles.Clear();
			_test_hashset.Clear();
			int num = Randy.randomInt(1, 5);
			int num2 = World.world.tiles_list.Length;
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num2; j++)
				{
					WorldTile worldTile = World.world.tiles_list[j];
					int pTileID = worldTile.data.tile_id + i * num2;
					_test_world_tiles.Add(new WorldTileDataStruct(worldTile, pTileID));
				}
				_test_world_tiles.Shuffle();
			}
			_test_hashset.UnionWith(_test_world_tiles);
			_test_world_tiles_pool = new ListPool<WorldTileDataStruct>(_test_world_tiles);
			_test_world_tiles_arr = _test_world_tiles.ToArray();
		}
		Bench.bench("loops_struct_test", "loops_struct_test_total");
		Bench.bench("list_for", "loops_struct_test");
		int num3 = 0;
		count = 0;
		for (int k = 0; k < _test_world_tiles.Count; k++)
		{
			num3 += _test_world_tiles[k].tile_id;
			count++;
		}
		Bench.benchEnd("list_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for", "loops_struct_test");
		num3 = 0;
		count = 0;
		for (int l = 0; l < _test_world_tiles_pool.Count; l++)
		{
			num3 += _test_world_tiles_pool[l].tile_id;
			count++;
		}
		Bench.benchEnd("listpool_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for", "loops_struct_test");
		num3 = 0;
		count = 0;
		Span<WorldTileDataStruct> span = _test_world_tiles_pool.AsSpan();
		for (int m = 0; m < span.Length; m++)
		{
			WorldTileDataStruct worldTileDataStruct = span[m];
			num3 += worldTileDataStruct.tile_id;
			count++;
		}
		Bench.benchEnd("listpool_span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("hashset_foreach", "loops_struct_test");
		num3 = 0;
		count = 0;
		foreach (WorldTileDataStruct item in _test_hashset)
		{
			num3 += item.tile_id;
			count++;
		}
		Bench.benchEnd("hashset_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_for_local", "loops_struct_test");
		num3 = 0;
		count = 0;
		List<WorldTileDataStruct> test_world_tiles = _test_world_tiles;
		for (int n = 0; n < test_world_tiles.Count; n++)
		{
			num3 += test_world_tiles[n].tile_id;
			count++;
		}
		Bench.benchEnd("list_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for_local", "loops_struct_test");
		num3 = 0;
		count = 0;
		ListPool<WorldTileDataStruct> test_world_tiles_pool = _test_world_tiles_pool;
		for (int num4 = 0; num4 < test_world_tiles_pool.Count; num4++)
		{
			num3 += test_world_tiles_pool[num4].tile_id;
			count++;
		}
		Bench.benchEnd("listpool_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for_local", "loops_struct_test");
		num3 = 0;
		count = 0;
		Span<WorldTileDataStruct> span2 = _test_world_tiles_pool.AsSpan();
		for (int num5 = 0; num5 < span2.Length; num5++)
		{
			WorldTileDataStruct worldTileDataStruct2 = span2[num5];
			num3 += worldTileDataStruct2.tile_id;
			count++;
		}
		Bench.benchEnd("listpool_span_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_for_local_len", "loops_struct_test");
		num3 = 0;
		count = 0;
		test_world_tiles = _test_world_tiles;
		int count2 = test_world_tiles.Count;
		for (int num6 = 0; num6 < count2; num6++)
		{
			num3 += test_world_tiles[num6].tile_id;
			count++;
		}
		Bench.benchEnd("list_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for_local_len", "loops_struct_test");
		num3 = 0;
		count = 0;
		test_world_tiles_pool = _test_world_tiles_pool;
		count2 = test_world_tiles_pool.Count;
		for (int num7 = 0; num7 < count2; num7++)
		{
			num3 += test_world_tiles_pool[num7].tile_id;
			count++;
		}
		Bench.benchEnd("listpool_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for_local_len", "loops_struct_test");
		num3 = 0;
		count = 0;
		span2 = _test_world_tiles_pool.AsSpan();
		count2 = span2.Length;
		for (int num8 = 0; num8 < count2; num8++)
		{
			WorldTileDataStruct worldTileDataStruct3 = span2[num8];
			num3 += worldTileDataStruct3.tile_id;
			count++;
		}
		Bench.benchEnd("listpool_span_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_foreach", "loops_struct_test");
		num3 = 0;
		count = 0;
		foreach (WorldTileDataStruct test_world_tile in _test_world_tiles)
		{
			num3 += test_world_tile.tile_id;
			count++;
		}
		Bench.benchEnd("list_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_foreach", "loops_struct_test");
		num3 = 0;
		count = 0;
		foreach (ref WorldTileDataStruct item2 in _test_world_tiles_pool)
		{
			WorldTileDataStruct current = item2;
			num3 += current.tile_id;
			count++;
		}
		Bench.benchEnd("listpool_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_foreach", "loops_struct_test");
		num3 = 0;
		count = 0;
		span2 = _test_world_tiles_pool.AsSpan();
		Span<WorldTileDataStruct> span3 = span2;
		for (int num9 = 0; num9 < span3.Length; num9++)
		{
			WorldTileDataStruct worldTileDataStruct4 = span3[num9];
			num3 += worldTileDataStruct4.tile_id;
			count++;
		}
		Bench.benchEnd("listpool_span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for", "loops_struct_test");
		num3 = 0;
		count = 0;
		for (int num10 = 0; num10 < _test_world_tiles_arr.Length; num10++)
		{
			WorldTileDataStruct worldTileDataStruct5 = _test_world_tiles_arr[num10];
			num3 += worldTileDataStruct5.tile_id;
			count++;
		}
		Bench.benchEnd("array_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for_local", "loops_struct_test");
		num3 = 0;
		count = 0;
		WorldTileDataStruct[] test_world_tiles_arr = _test_world_tiles_arr;
		for (int num11 = 0; num11 < test_world_tiles_arr.Length; num11++)
		{
			WorldTileDataStruct worldTileDataStruct6 = test_world_tiles_arr[num11];
			num3 += worldTileDataStruct6.tile_id;
			count++;
		}
		Bench.benchEnd("array_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for_local_len", "loops_struct_test");
		num3 = 0;
		count = 0;
		test_world_tiles_arr = _test_world_tiles_arr;
		count2 = _test_world_tiles_arr.Length;
		for (int num12 = 0; num12 < count2; num12++)
		{
			WorldTileDataStruct worldTileDataStruct7 = test_world_tiles_arr[num12];
			num3 += worldTileDataStruct7.tile_id;
			count++;
		}
		Bench.benchEnd("array_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_foreach", "loops_struct_test");
		num3 = 0;
		count = 0;
		WorldTileDataStruct[] test_world_tiles_arr2 = _test_world_tiles_arr;
		for (int num9 = 0; num9 < test_world_tiles_arr2.Length; num9++)
		{
			WorldTileDataStruct worldTileDataStruct8 = test_world_tiles_arr2[num9];
			num3 += worldTileDataStruct8.tile_id;
			count++;
		}
		Bench.benchEnd("array_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("ro_span_foreach", "loops_struct_test");
		ReadOnlySpan<WorldTileDataStruct> readOnlySpan = new ReadOnlySpan<WorldTileDataStruct>(_test_world_tiles_arr);
		num3 = 0;
		count = 0;
		ReadOnlySpan<WorldTileDataStruct> readOnlySpan2 = readOnlySpan;
		for (int num9 = 0; num9 < readOnlySpan2.Length; num9++)
		{
			WorldTileDataStruct worldTileDataStruct9 = readOnlySpan2[num9];
			num3 += worldTileDataStruct9.tile_id;
			count++;
		}
		Bench.benchEnd("ro_span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("ro_span_for", "loops_struct_test");
		readOnlySpan = new ReadOnlySpan<WorldTileDataStruct>(_test_world_tiles_arr);
		num3 = 0;
		count = 0;
		for (int num13 = 0; num13 < readOnlySpan.Length; num13++)
		{
			WorldTileDataStruct worldTileDataStruct10 = readOnlySpan[num13];
			num3 += worldTileDataStruct10.tile_id;
			count++;
		}
		Bench.benchEnd("ro_span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("span_foreach", "loops_struct_test");
		span2 = new Span<WorldTileDataStruct>(_test_world_tiles_arr);
		num3 = 0;
		count = 0;
		span3 = span2;
		for (int num9 = 0; num9 < span3.Length; num9++)
		{
			WorldTileDataStruct worldTileDataStruct11 = span3[num9];
			num3 += worldTileDataStruct11.tile_id;
			count++;
		}
		Bench.benchEnd("span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("span_for", "loops_struct_test");
		span2 = new Span<WorldTileDataStruct>(_test_world_tiles_arr);
		num3 = 0;
		count = 0;
		for (int num14 = 0; num14 < span2.Length; num14++)
		{
			WorldTileDataStruct worldTileDataStruct12 = span2[num14];
			num3 += worldTileDataStruct12.tile_id;
			count++;
		}
		Bench.benchEnd("span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.benchEnd("loops_struct_test", "loops_struct_test_total", pSaveCounter: false, 0L);
	}
}
// --- End of File: BenchmarkStructLoops.cs ---



// --- Start of File: BenchObject.cs ---
public class BenchObject
{
	public int derp;

	public void update(float pElapsed)
	{
		updateMove(pElapsed);
		updateMove(pElapsed);
		updateMove(pElapsed);
		updateMove(pElapsed);
		updateMove(pElapsed);
	}

	public void updateMove(float pElapsed)
	{
		derp += 22;
		if (derp == 1000)
		{
			derp += 10;
			if (derp < 10)
			{
				derp += 5;
			}
			else
			{
				derp -= 5;
			}
		}
	}
}
// --- End of File: BenchObject.cs ---



// --- Start of File: BenchTest1.cs ---
public class BenchTest1
{
	public bool test()
	{
		return false;
	}

	public virtual bool testVirtual()
	{
		return false;
	}
}
// --- End of File: BenchTest1.cs ---



// --- Start of File: BenchTest2.cs ---
public class BenchTest2 : BenchTest1
{
	public override bool testVirtual()
	{
		return true;
	}
}
// --- End of File: BenchTest2.cs ---



// --- Start of File: BiomeAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;

[Serializable]
public class BiomeAsset : Asset, IDescriptionAsset, ILocalizedAsset, IMultiLocalesAsset
{
	public GrowTypeSelector grow_type_selector_trees;

	public GrowTypeSelector grow_type_selector_plants;

	public GrowTypeSelector grow_type_selector_bushes;

	public GrowTypeSelector grow_type_selector_minerals;

	public List<string> pot_sapient_units_spawn;

	public List<string> pot_units_spawn;

	public List<string> pot_trees_spawn;

	public List<string> pot_plants_spawn;

	public List<string> pot_bushes_spawn;

	public List<string> pot_minerals_spawn;

	public bool grow_vegetation_auto;

	public bool grow_minerals_auto;

	public bool pot_spawn_units_auto;

	public bool cold_biome;

	public bool dark_biome;

	public bool spread_ignore_burned_stages;

	public bool spread_biome;

	public bool spread_by_drops_water;

	public bool spread_by_drops_fire;

	public bool spread_by_drops_curse;

	public bool spread_by_drops_blessing;

	public bool spread_by_drops_powerup;

	public bool spread_by_drops_acid;

	public bool spread_by_drops_coffee;

	public bool special_biome;

	[DefaultValue(6)]
	public int grow_strength = 6;

	public string spread_only_in_era;

	public string tile_low;

	public string tile_high;

	[NonSerialized]
	private TopTileType _cached_tile_high;

	[NonSerialized]
	private TopTileType _cached_tile_low;

	public int generator_pot_amount;

	public int generator_max_size;

	public string localized_key;

	public int loot_generation;

	public string[] subspecies_name_suffix;

	public List<string> spawn_trait_actor;

	public List<string> spawn_trait_subspecies;

	public List<string> spawn_trait_subspecies_always;

	public List<string> spawn_trait_culture;

	public List<string> spawn_trait_clan;

	public List<string> spawn_trait_language;

	public List<string> spawn_trait_religion;

	public List<string> evolution_trait_subspecies;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public TopTileType getTile(WorldTile pTile)
	{
		return pTile.main_type.rank_type switch
		{
			TileRank.High => getTileHigh(), 
			TileRank.Low => getTileLow(), 
			_ => null, 
		};
	}

	public int getTileCount()
	{
		return 0 + (getTileHigh()?.getCurrentTiles().Count ?? 0) + (getTileLow()?.getCurrentTiles().Count ?? 0);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CanBeNull]
	public TopTileType getTileHigh()
	{
		if (_cached_tile_high == null)
		{
			_cached_tile_high = AssetManager.top_tiles.get(tile_high);
		}
		return _cached_tile_high;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CanBeNull]
	public TopTileType getTileLow()
	{
		if (_cached_tile_low == null)
		{
			_cached_tile_low = AssetManager.top_tiles.get(tile_low);
		}
		return _cached_tile_low;
	}

	public void addTree(string pID, int pRateAmount = 1)
	{
		grow_vegetation_auto = true;
		if (pot_trees_spawn == null)
		{
			pot_trees_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_trees_spawn.Add(pID);
		}
	}

	public void addPlant(string pID, int pRateAmount = 1)
	{
		grow_vegetation_auto = true;
		if (pot_plants_spawn == null)
		{
			pot_plants_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_plants_spawn.Add(pID);
		}
	}

	public void addBush(string pID, int pRateAmount = 1)
	{
		grow_vegetation_auto = true;
		if (pot_bushes_spawn == null)
		{
			pot_bushes_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_bushes_spawn.Add(pID);
		}
	}

	public void addMineral(string pID, int pRateAmount = 1)
	{
		grow_minerals_auto = true;
		if (pot_minerals_spawn == null)
		{
			pot_minerals_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_minerals_spawn.Add(pID);
		}
	}

	public void addUnit(string pID, int pRateAmount = 1)
	{
		pot_spawn_units_auto = true;
		if (pot_units_spawn == null)
		{
			pot_units_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_units_spawn.Add(pID);
		}
	}

	public void addSapientUnit(string pID, int pRateAmount = 1)
	{
		pot_spawn_units_auto = true;
		if (pot_sapient_units_spawn == null)
		{
			pot_sapient_units_spawn = new List<string>();
		}
		for (int i = 0; i < pRateAmount; i++)
		{
			pot_sapient_units_spawn.Add(pID);
		}
	}

	internal void addActorTrait(string pTrait)
	{
		if (spawn_trait_actor == null)
		{
			spawn_trait_actor = new List<string>();
		}
		if (!spawn_trait_actor.Contains(pTrait))
		{
			spawn_trait_actor.Add(pTrait);
		}
	}

	internal void addSubspeciesTrait(string pTrait)
	{
		if (spawn_trait_subspecies == null)
		{
			spawn_trait_subspecies = new List<string>();
		}
		if (!spawn_trait_subspecies.Contains(pTrait))
		{
			spawn_trait_subspecies.Add(pTrait);
		}
	}

	internal void addSubspeciesTraitAlways(string pTrait)
	{
		if (spawn_trait_subspecies_always == null)
		{
			spawn_trait_subspecies_always = new List<string>();
		}
		if (!spawn_trait_subspecies_always.Contains(pTrait))
		{
			spawn_trait_subspecies_always.Add(pTrait);
		}
	}

	internal void addSubspeciesTraitEvolution(string pTrait)
	{
		if (evolution_trait_subspecies == null)
		{
			evolution_trait_subspecies = new List<string>();
		}
		if (!evolution_trait_subspecies.Contains(pTrait))
		{
			evolution_trait_subspecies.Add(pTrait);
		}
	}

	internal void addCultureTrait(string pTrait)
	{
		if (spawn_trait_culture == null)
		{
			spawn_trait_culture = new List<string>();
		}
		if (!spawn_trait_culture.Contains(pTrait))
		{
			spawn_trait_culture.Add(pTrait);
		}
	}

	internal void addLanguageTrait(string pTrait)
	{
		if (spawn_trait_language == null)
		{
			spawn_trait_language = new List<string>();
		}
		if (!spawn_trait_language.Contains(pTrait))
		{
			spawn_trait_language.Add(pTrait);
		}
	}

	internal void addClanTrait(string pTrait)
	{
		if (spawn_trait_clan == null)
		{
			spawn_trait_clan = new List<string>();
		}
		if (!spawn_trait_clan.Contains(pTrait))
		{
			spawn_trait_clan.Add(pTrait);
		}
	}

	internal void addReligionTrait(string pTrait)
	{
		if (spawn_trait_religion == null)
		{
			spawn_trait_religion = new List<string>();
		}
		if (!spawn_trait_religion.Contains(pTrait))
		{
			spawn_trait_religion.Add(pTrait);
		}
	}

	public string getLocaleID()
	{
		return localized_key.Underscore();
	}

	public string getDescriptionID()
	{
		return getLocaleID() + "_description";
	}

	public IEnumerable<string> getLocaleIDs()
	{
		if (LocalizedTextManager.stringExists(getLocaleID() + "_seeds"))
		{
			yield return getLocaleID() + "_seeds";
		}
	}
}
// --- End of File: BiomeAsset.cs ---



// --- Start of File: BiomeLibrary.cs ---
using System.Collections.Generic;

public class BiomeLibrary : AssetLibrary<BiomeAsset>
{
	public static List<BiomeAsset> pool_biomes = new List<BiomeAsset>();

	public override void init()
	{
		base.init();
		addNormalBiomes();
		addCreepBiomes();
		addSpecialBiomes();
	}

	public void addNormalBiomes()
	{
		add(new BiomeAsset
		{
			id = "biome_grass",
			tile_low = "grass_low",
			tile_high = "grass_high",
			localized_key = "Grass",
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 8,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("graminae", "viridis", "pratensis")
		});
		t.addSubspeciesTrait("fast_builders");
		t.addCultureTrait("pep_talks");
		t.addCultureTrait("youth_reverence");
		t.addCultureTrait("gossip_lovers");
		t.addLanguageTrait("strict_spelling");
		t.addUnit("wolf");
		t.addUnit("fox", 2);
		t.addUnit("raccoon");
		t.addUnit("sheep", 3);
		t.addUnit("chicken", 3);
		t.addUnit("rabbit", 3);
		t.addUnit("fly", 4);
		t.addUnit("beetle", 4);
		t.addUnit("grasshopper", 4);
		t.addSapientUnit("human");
		t.addSapientUnit("dwarf");
		t.addSapientUnit("orc");
		t.addSapientUnit("elf");
		t.addSapientUnit("civ_wolf");
		t.addSapientUnit("civ_fox");
		t.addSapientUnit("bandit");
		t.addSapientUnit("civ_sheep");
		t.addSapientUnit("civ_chicken");
		t.addSapientUnit("civ_rabbit");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("tree_green_1");
		t.addTree("tree_green_2");
		t.addTree("tree_green_3");
		t.addPlant("mushroom_red", 2);
		t.addPlant("mushroom_green", 2);
		t.addPlant("mushroom_teal", 2);
		t.addPlant("mushroom_white", 2);
		t.addPlant("mushroom_yellow", 2);
		t.addPlant("green_herb", 4);
		t.addPlant("flower", 4);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_savanna",
			tile_low = "savanna_low",
			tile_high = "savanna_high",
			localized_key = "Savanna",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 5,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("savannae", "aridus", "praeruptus")
		});
		t.addActorTrait("fast");
		t.addCultureTrait("sword_lovers");
		t.addLanguageTrait("elegant_words");
		t.addUnit("rhino");
		t.addUnit("hyena");
		t.addUnit("buffalo");
		t.addUnit("cat", 3);
		t.addUnit("armadillo");
		t.addUnit("ostrich", 2);
		t.addUnit("fly", 4);
		t.addUnit("beetle", 4);
		t.addSapientUnit("human");
		t.addSapientUnit("dwarf");
		t.addSapientUnit("orc");
		t.addSapientUnit("elf");
		t.addSapientUnit("civ_cat");
		t.addSapientUnit("civ_rhino");
		t.addSapientUnit("civ_hyena");
		t.addSapientUnit("civ_buffalo");
		t.addSapientUnit("civ_armadillo");
		t.addMineral("mineral_stone", 5);
		t.addMineral("mineral_metals", 3);
		t.addTree("savanna_tree_1", 5);
		t.addTree("savanna_tree_2", 5);
		t.addTree("savanna_tree_big_1");
		t.addTree("savanna_tree_big_2");
		t.addPlant("savanna_plant");
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_jungle",
			tile_low = "jungle_low",
			tile_high = "jungle_high",
			localized_key = "Jungle",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 6,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("junglis", "viriditas", "tropicus")
		});
		t.addActorTrait("tiny");
		t.addActorTrait("poison_immune");
		t.addCultureTrait("spear_lovers");
		t.addCultureTrait("city_layout_raindrops");
		t.addLanguageTrait("beautiful_calligraphy");
		t.addUnit("snake");
		t.addUnit("cat", 2);
		t.addUnit("monkey");
		t.addUnit("frog", 3);
		t.addUnit("scorpion");
		t.addSapientUnit("human");
		t.addSapientUnit("dwarf");
		t.addSapientUnit("orc");
		t.addSapientUnit("elf");
		t.addSapientUnit("civ_snake");
		t.addSapientUnit("civ_cat");
		t.addSapientUnit("civ_monkey");
		t.addSapientUnit("civ_frog");
		t.addSapientUnit("civ_scorpion");
		t.addMineral("mineral_silver", 5);
		t.addMineral("mineral_metals");
		t.addMineral("mineral_gems");
		t.addTree("jungle_tree");
		t.addPlant("jungle_plant");
		t.addPlant("jungle_flower");
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_desert",
			tile_low = "desert_low",
			tile_high = "desert_high",
			localized_key = "Desert",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 4,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("solantheria", "ergensis", "deserticus")
		});
		t.addActorTrait("eagle_eyed");
		t.addClanTrait("silver_tongues");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("gossip_lovers");
		t.addLanguageTrait("stylish_writing");
		t.addSubspeciesTraitAlways("adaptation_desert");
		t.addUnit("cat");
		t.addUnit("snake");
		t.addSapientUnit("human");
		t.addSapientUnit("dwarf");
		t.addSapientUnit("orc");
		t.addSapientUnit("elf");
		t.addSapientUnit("civ_cat");
		t.addSapientUnit("civ_snake");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_gems");
		t.addMineral("mineral_silver");
		t.addTree("desert_tree");
		t.addPlant("desert_plant");
		t.addUnit("scorpion");
		add(new BiomeAsset
		{
			id = "biome_lemon",
			tile_low = "lemon_low",
			tile_high = "lemon_high",
			localized_key = "Lemon",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 3,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("aurantium", "acidus", "limonum")
		});
		t.addActorTrait("genius");
		t.addCultureTrait("fast_learners");
		t.addLanguageTrait("melodic");
		t.addLanguageTrait("elegant_words");
		t.addUnit("lemon_snail");
		t.addSapientUnit("civ_lemon_man");
		t.addMineral("mineral_stone", 5);
		t.addMineral("mineral_metals", 3);
		t.addTree("lemon_tree");
		t.addPlant("mushroom_red");
		t.addPlant("mushroom_green");
		t.addPlant("mushroom_teal");
		t.addPlant("mushroom_white");
		t.addPlant("mushroom_yellow");
		t.addPlant("green_herb", 5);
		t.addPlant("flower", 5);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_permafrost",
			tile_low = "permafrost_low",
			tile_high = "permafrost_high",
			localized_key = "Permafrost",
			cold_biome = true,
			spread_biome = true,
			generator_pot_amount = 3,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("albus", "sibericus", "frostis")
		});
		t.addActorTrait("freeze_proof");
		t.addSubspeciesTrait("cold_resistance");
		t.addSubspeciesTraitAlways("adaptation_permafrost");
		t.addCultureTrait("attentive_readers");
		t.addCultureTrait("ancestors_knowledge");
		t.addUnit("penguin", 4);
		t.addUnit("bear");
		t.addUnit("wolf", 2);
		t.addUnit("snowman");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addSapientUnit("human");
		t.addSapientUnit("cold_one");
		t.addSapientUnit("civ_penguin");
		t.addSapientUnit("civ_bear");
		t.addSapientUnit("civ_wolf");
		t.addSapientUnit("snowman");
		t.addTree("pine_tree");
		t.addPlant("snow_plant");
		add(new BiomeAsset
		{
			id = "biome_swamp",
			tile_low = "swamp_low",
			tile_high = "swamp_high",
			localized_key = "Swamp",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 3,
			generator_max_size = 300,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("paludis", "limosa", "paluster")
		});
		t.addActorTrait("regeneration");
		t.addCultureTrait("bow_lovers");
		t.addLanguageTrait("scribble");
		t.addSubspeciesTraitAlways("adaptation_swamp");
		t.addSubspeciesTraitEvolution("mutation_skin_tentacle_horror");
		t.addUnit("crocodile");
		t.addUnit("snake", 4);
		t.addUnit("frog", 6);
		t.addUnit("fly", 5);
		t.addUnit("turtle", 3);
		t.addUnit("capybara");
		t.addSapientUnit("orc");
		t.addSapientUnit("elf");
		t.addSapientUnit("bandit");
		t.addSapientUnit("civ_crocodile");
		t.addSapientUnit("civ_snake");
		t.addSapientUnit("civ_frog");
		t.addSapientUnit("civ_capybara");
		t.addSapientUnit("civ_piranha");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("swamp_tree");
		t.addPlant("swamp_plant");
		t.addPlant("swamp_plant_big");
		add(new BiomeAsset
		{
			id = "biome_crystal",
			tile_low = "crystal_low",
			tile_high = "crystal_high",
			localized_key = "Crystal",
			loot_generation = 2,
			spread_biome = true,
			generator_pot_amount = 2,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("crystallus", "lucidus", "prismatus")
		});
		t.addActorTrait("strong");
		t.addSubspeciesTrait("bioproduct_gems");
		t.addCultureTrait("tiny_legends");
		t.addCultureTrait("armorsmith_mastery");
		t.addCultureTrait("weaponsmith_mastery");
		t.addLanguageTrait("powerful_words");
		t.addUnit("crystal_sword", 2);
		t.addSapientUnit("dwarf");
		t.addSapientUnit("civ_crystal_golem");
		t.addTree("crystal_tree");
		t.addPlant("crystal_plant");
		add(new BiomeAsset
		{
			id = "biome_enchanted",
			tile_low = "enchanted_low",
			tile_high = "enchanted_high",
			localized_key = "Enchanted",
			spread_biome = true,
			spread_by_drops_blessing = true,
			loot_generation = 1,
			generator_pot_amount = 3,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("incantatum", "enchanta", "herbaeonis")
		});
		t.addActorTrait("attractive");
		t.addSubspeciesTrait("gaia_roots");
		t.addSubspeciesTraitEvolution("mutation_skin_energy");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("diplomatic_ascension");
		t.addCultureTrait("legacy_keepers");
		t.addLanguageTrait("ancient_runes");
		t.addLanguageTrait("enlightening_script");
		t.addUnit("butterfly", 5);
		t.addUnit("fairy");
		t.addSapientUnit("elf");
		t.addSapientUnit("white_mage");
		t.addSapientUnit("fairy");
		t.addMineral("mineral_silver", 5);
		t.addMineral("mineral_metals", 2);
		t.addMineral("mineral_gems");
		t.addTree("enchanted_tree");
		t.addPlant("flower", 5);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_corrupted",
			tile_low = "corrupted_low",
			tile_high = "corrupted_high",
			localized_key = "Corrupted",
			loot_generation = -1,
			dark_biome = true,
			spread_biome = true,
			spread_by_drops_curse = true,
			generator_pot_amount = 1,
			generator_max_size = 20,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("corruptus", "morbida", "tenebris")
		});
		t.addActorTrait("weak");
		t.addSubspeciesTrait("death_grow_mythril");
		t.addSubspeciesTraitAlways("adaptation_corruption");
		t.addCultureTrait("happiness_from_war");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("ethnocentric_guard");
		t.addLanguageTrait("cursed_font");
		t.addReligionTrait("rite_of_restless_dead");
		t.addReligionTrait("cast_curse");
		t.addReligionTrait("spawn_skeleton");
		t.addUnit("jumpy_skull");
		t.addSapientUnit("necromancer");
		t.addSapientUnit("jumpy_skull");
		t.addSapientUnit("plague_doctor");
		t.addMineral("mineral_bones", 7);
		t.addTree("corrupted_tree");
		t.addTree("corrupted_tree_big");
		t.addPlant("corrupted_plant");
		add(new BiomeAsset
		{
			id = "biome_infernal",
			tile_low = "infernal_low",
			tile_high = "infernal_high",
			localized_key = "Infernal",
			spread_biome = true,
			spread_by_drops_fire = true,
			spread_ignore_burned_stages = true,
			generator_pot_amount = 1,
			generator_max_size = 20,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("ignifer", "brasarius", "ardorus")
		});
		t.addActorTrait("fire_blood");
		t.addActorTrait("fire_proof");
		t.addSubspeciesTrait("heat_resistance");
		t.addSubspeciesTrait("hydrophobia");
		t.addSubspeciesTraitAlways("adaptation_infernal");
		t.addCultureTrait("happiness_from_war");
		t.addCultureTrait("xenophobic");
		t.addClanTrait("cursed_blood");
		t.addLanguageTrait("raging_paragraphs");
		t.addReligionTrait("rite_of_the_abyss");
		t.addUnit("fire_skull");
		t.addSapientUnit("evil_mage");
		t.addSapientUnit("demon");
		t.addSapientUnit("fire_skull");
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_adamantine", 3);
		t.addTree("infernal_tree");
		t.addTree("infernal_tree_big");
		t.addTree("infernal_tree_small");
		t.addPlant("flame_flower");
		add(new BiomeAsset
		{
			id = "biome_candy",
			tile_low = "candy_low",
			tile_high = "candy_high",
			localized_key = "Candy",
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 1,
			generator_max_size = 30,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("dulcis", "glucosus", "crispus")
		});
		t.addActorTrait("fat");
		t.addActorTrait("gluttonous");
		t.addSubspeciesTrait("annoying_fireworks");
		t.addSubspeciesTrait("super_positivity");
		t.addCultureTrait("tiny_legends");
		t.addLanguageTrait("foolish_glyphs");
		t.addUnit("smore");
		t.addSapientUnit("civ_candy_man");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("candy_tree");
		t.addPlant("candy_plant");
		add(new BiomeAsset
		{
			id = "biome_mushroom",
			tile_low = "mushroom_low",
			tile_high = "mushroom_high",
			localized_key = "Mushroom",
			spread_biome = true,
			spread_by_drops_water = true,
			spread_by_drops_powerup = true,
			generator_pot_amount = 1,
			generator_max_size = 300,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("sporae", "mycota", "mycetis")
		});
		t.addActorTrait("regeneration");
		t.addSubspeciesTrait("bioproduct_mushrooms");
		t.addSubspeciesTrait("super_positivity");
		t.addCultureTrait("animal_whisperers");
		t.addCultureTrait("pep_talks");
		t.addLanguageTrait("powerful_words");
		t.addUnit("frog", 3);
		t.addUnit("sheep");
		t.addSapientUnit("civ_sheep");
		t.addSapientUnit("civ_frog");
		t.addMineral("mineral_silver", 3);
		t.addMineral("mineral_stone", 5);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_gems");
		t.addTree("mushroom_tree");
		t.addPlant("flower", 2);
		t.addPlant("mushroom_red", 2);
		t.addPlant("mushroom_green", 2);
		t.addPlant("mushroom_teal", 2);
		t.addPlant("mushroom_white", 2);
		t.addPlant("mushroom_yellow", 2);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_wasteland",
			tile_low = "wasteland_low",
			tile_high = "wasteland_high",
			localized_key = "Wasteland",
			loot_generation = -2,
			dark_biome = true,
			spread_biome = true,
			spread_by_drops_acid = true,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("toxicus", "wastus")
		});
		t.addActorTrait("ugly");
		t.addSubspeciesTrait("bad_genes");
		t.addSubspeciesTrait("bioluminescence");
		t.addSubspeciesTraitAlways("adaptation_wasteland");
		t.addSubspeciesTraitEvolution("mutation_skin_abomination");
		t.addCultureTrait("xenophobic");
		t.addCultureTrait("solitude_seekers");
		t.addCultureTrait("legacy_keepers");
		t.addLanguageTrait("foolish_glyphs");
		t.addUnit("rat", 4);
		t.addUnit("acid_blob");
		t.addSapientUnit("civ_acid_gentleman");
		t.addSapientUnit("civ_rat");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("wasteland_tree");
		t.addPlant("wasteland_flower");
		add(new BiomeAsset
		{
			id = "biome_birch",
			tile_low = "birch_low",
			tile_high = "birch_high",
			localized_key = "Birch",
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 4,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("silvanus", "virentis", "sylvestris")
		});
		t.addSubspeciesTrait("enhanced_strength");
		t.addCultureTrait("axe_lovers");
		t.addCultureTrait("diplomatic_ascension");
		t.addUnit("wolf");
		t.addUnit("sheep");
		t.addUnit("rabbit");
		t.addUnit("fox");
		t.addSapientUnit("civ_wolf");
		t.addSapientUnit("civ_sheep");
		t.addSapientUnit("civ_rabbit");
		t.addSapientUnit("civ_fox");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("birch_tree");
		t.addPlant("birch_plant");
		t.addPlant("mushroom_red");
		t.addPlant("mushroom_green");
		t.addPlant("mushroom_teal");
		t.addPlant("mushroom_white");
		t.addPlant("mushroom_yellow");
		t.addPlant("green_herb", 4);
		t.addPlant("flower", 4);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_maple",
			tile_low = "maple_low",
			tile_high = "maple_high",
			localized_key = "Maple",
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 5,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("mapleleafus", "canadus", "malifolia")
		});
		t.addSubspeciesTrait("death_grow_tree");
		t.addCultureTrait("xenophiles");
		t.addLanguageTrait("nicely_structured_grammar");
		t.addLanguageTrait("melodic");
		t.addUnit("wolf");
		t.addUnit("dog");
		t.addSapientUnit("civ_wolf");
		t.addSapientUnit("civ_dog");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("maple_tree");
		t.addPlant("maple_plant");
		t.addPlant("mushroom_red");
		t.addPlant("mushroom_green");
		t.addPlant("mushroom_teal");
		t.addPlant("mushroom_white");
		t.addPlant("mushroom_yellow");
		t.addPlant("green_herb", 4);
		t.addPlant("flower", 4);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_rocklands",
			tile_low = "rocklands_low",
			tile_high = "rocklands_high",
			localized_key = "Rocklands",
			grow_strength = 5,
			spread_biome = true,
			generator_pot_amount = 2,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("lithos", "petrae", "rupes")
		});
		t.addActorTrait("giant");
		t.addSubspeciesTrait("bioproduct_stone");
		t.addSubspeciesTrait("parental_care");
		t.addSubspeciesTraitEvolution("mutation_skin_living_rock");
		t.addCultureTrait("statue_lovers");
		t.addCultureTrait("training_potential");
		t.addCultureTrait("city_layout_stone_garden");
		t.addClanTrait("blood_of_giants");
		t.addLanguageTrait("powerful_words");
		t.addUnit("goat");
		t.addUnit("alpaca");
		t.addUnit("armadillo");
		t.addSapientUnit("dwarf");
		t.addSapientUnit("civ_goat");
		t.addSapientUnit("civ_alpaca");
		t.addSapientUnit("civ_armadillo");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_gems");
		t.addTree("rocklands_tree");
		t.addPlant("rocklands_plant");
		add(new BiomeAsset
		{
			id = "biome_garlic",
			tile_low = "garlic_low",
			tile_high = "garlic_high",
			localized_key = "Garlic",
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 2,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("aromatica", "vampiris", "odoratus")
		});
		t.addActorTrait("immune");
		t.addSubspeciesTrait("accelerated_healing");
		t.addCultureTrait("attentive_readers");
		t.addClanTrait("masters_of_propaganda");
		t.addLanguageTrait("enlightening_script");
		t.addUnit("garl");
		t.addSapientUnit("civ_garlic_man");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("garlic_tree");
		t.addPlant("garlic_plant");
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_flower",
			tile_low = "flower_low",
			tile_high = "flower_high",
			localized_key = "Flower",
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 3,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("botanicus", "petala", "fragrans")
		});
		t.addActorTrait("attractive");
		t.addSubspeciesTrait("death_grow_plant");
		t.addCultureTrait("matriarchy");
		t.addCultureTrait("gossip_lovers");
		t.addLanguageTrait("elegant_words");
		t.addUnit("flower_bud");
		t.addUnit("butterfly");
		t.addUnit("beetle");
		t.addUnit("bee");
		t.addUnit("grasshopper");
		t.addUnit("fly");
		t.addSapientUnit("civ_liliar");
		t.addSapientUnit("druid");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addTree("flower_tree_1");
		t.addTree("flower_tree_2");
		t.addTree("flower_tree_3");
		t.addPlant("flower_plant", 3);
		t.addPlant("mushroom_red");
		t.addPlant("mushroom_green");
		t.addPlant("mushroom_teal");
		t.addPlant("mushroom_white");
		t.addPlant("mushroom_yellow");
		t.addPlant("green_herb", 5);
		t.addPlant("flower", 20);
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_celestial",
			tile_low = "celestial_low",
			tile_high = "celestial_high",
			localized_key = "Celestial",
			grow_strength = 5,
			spread_biome = true,
			generator_pot_amount = 1,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("caelestis", "stellaris", "fragrans")
		});
		t.addActorTrait("giant");
		t.addActorTrait("genius");
		t.addSubspeciesTrait("hyper_intelligence");
		t.addSubspeciesTraitEvolution("mutation_skin_light_orb");
		t.addClanTrait("gods_chosen");
		t.addCultureTrait("serenity_now");
		t.addCultureTrait("ancestors_knowledge");
		t.addLanguageTrait("font_of_gods");
		t.addLanguageTrait("magic_words");
		t.addReligionTrait("rite_of_falling_stars");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_mythril");
		t.addTree("celestial_tree", 10);
		t.addTree("celestial_tree_small");
		t.addUnit("unicorn");
		t.addSapientUnit("civ_unicorn");
		t.addPlant("celestial_plant");
		add(new BiomeAsset
		{
			id = "biome_clover",
			tile_low = "clover_low",
			tile_high = "clover_high",
			localized_key = "Clover",
			loot_generation = 3,
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_water = true,
			generator_pot_amount = 2,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("luckii", "trifolii", "prosperus")
		});
		t.addActorTrait("lucky");
		t.addSubspeciesTrait("death_grow_plant");
		t.addCultureTrait("elder_reverence");
		t.addLanguageTrait("stylish_writing");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_gems");
		t.addUnit("rabbit");
		t.addUnit("cow");
		t.addUnit("butterfly", 5);
		t.addUnit("bee", 3);
		t.addUnit("fairy");
		t.addSapientUnit("civ_rabbit");
		t.addSapientUnit("civ_cow");
		t.addTree("clover_tree");
		t.addPlant("clover_plant");
		t.addBush("fruit_bush");
		add(new BiomeAsset
		{
			id = "biome_singularity",
			tile_low = "singularity_low",
			tile_high = "singularity_high",
			localized_key = "Singularity Swamp",
			loot_generation = 3,
			dark_biome = true,
			grow_strength = 5,
			spread_biome = true,
			spread_by_drops_coffee = true,
			generator_pot_amount = 0,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("singularis", "infinitus", "quantumus")
		});
		t.addActorTrait("tiny");
		t.addActorTrait("long_liver");
		t.addSubspeciesTrait("big_stomach");
		t.addSubspeciesTraitEvolution("mutation_skin_void");
		t.addCultureTrait("ancestors_knowledge");
		t.addCultureTrait("gossip_lovers");
		t.addLanguageTrait("repeated_sentences");
		t.addReligionTrait("teleport");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addUnit("angle");
		t.addSapientUnit("angle");
		t.addTree("singularity_tree");
		t.addPlant("singularity_plant");
		add(new BiomeAsset
		{
			id = "biome_paradox",
			tile_low = "paradox_low",
			tile_high = "paradox_high",
			localized_key = "Paradox",
			grow_strength = 5,
			spread_biome = true,
			generator_pot_amount = 0,
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_type_selector_trees = TileActionLibrary.getGrowTypeRandomTrees,
			grow_type_selector_plants = TileActionLibrary.getGrowTypeRandomPlants,
			grow_type_selector_bushes = TileActionLibrary.getGrowTypeRandomBushes,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("temporis", "tempus", "chronos")
		});
		t.addActorTrait("long_liver");
		t.addSubspeciesTrait("rapid_aging");
		t.addSubspeciesTrait("long_lifespan");
		t.addSubspeciesTraitEvolution("mutation_skin_fractal");
		t.addClanTrait("blood_of_eons");
		t.addCultureTrait("reading_lovers");
		t.addCultureTrait("youth_reverence");
		t.addCultureTrait("ancestors_knowledge");
		t.addCultureTrait("elder_reverence");
		t.addCultureTrait("expansionists");
		t.addLanguageTrait("eternal_text");
		t.addLanguageTrait("confusing_semantics");
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals", 3);
		t.addMineral("mineral_mythril");
		t.addTree("paradox_tree");
		t.addUnit("scorpion");
		t.addSapientUnit("alien");
		t.addSapientUnit("civ_scorpion");
		t.addPlant("paradox_plant");
	}

	private void addSpecialBiomes()
	{
		add(new BiomeAsset
		{
			id = "biome_sand",
			localized_key = "Sand",
			grow_type_selector_trees = TileActionLibrary.getGrowTypeSand,
			grow_vegetation_auto = true,
			special_biome = true,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("granitius", "arenarius", "sabulum")
		});
		t.addSubspeciesTrait("metamorphosis_crab");
		t.addUnit("crab");
		t.addSapientUnit("civ_crab");
		add(new BiomeAsset
		{
			id = "biome_hill",
			localized_key = "Hills",
			grow_type_selector_minerals = TileActionLibrary.getGrowTypeRandomMineral,
			grow_vegetation_auto = true,
			special_biome = true,
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("hillus", "stonus", "absolutus")
		});
		t.addMineral("mineral_stone", 4);
		t.addMineral("mineral_metals");
	}

	private void addCreepBiomes()
	{
		add(new BiomeAsset
		{
			id = "biome_biomass",
			tile_low = "biomass_low",
			tile_high = "biomass_high",
			localized_key = "Biomass",
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("organicus", "vivum")
		});
		t.addSubspeciesTraitEvolution("mutation_skin_abomination");
		add(new BiomeAsset
		{
			id = "biome_cybertile",
			tile_low = "cybertile_low",
			tile_high = "cybertile_high",
			localized_key = "Cybercore",
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("machinus", "cyberneticus", "technus")
		});
		t.addSubspeciesTraitEvolution("mutation_skin_metalic_orb");
		add(new BiomeAsset
		{
			id = "biome_pumpkin",
			tile_low = "pumpkin_low",
			tile_high = "pumpkin_high",
			localized_key = "Super Pumpkin",
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("maximus", "pepo", "cucurbitae")
		});
		add(new BiomeAsset
		{
			id = "biome_tumor",
			tile_low = "tumor_low",
			tile_high = "tumor_high",
			localized_key = "Tumor",
			subspecies_name_suffix = AssetLibrary<BiomeAsset>.a<string>("neoplasmis", "cancrosus", "tumoralis")
		});
		t.addSubspeciesTraitEvolution("mutation_skin_blood_vortex");
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (BiomeAsset item in list)
		{
			addBiomeToPool(item);
		}
	}

	private void addBiomeToPool(BiomeAsset pAsset)
	{
		for (int i = 0; i < pAsset.generator_pot_amount; i++)
		{
			pool_biomes.Add(pAsset);
		}
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (BiomeAsset item in list)
		{
			checkLocale(item, item.getLocaleID());
			checkLocale(item, item.getDescriptionID());
		}
	}
}
// --- End of File: BiomeLibrary.cs ---



// --- Start of File: BiomeTag.cs ---
public enum BiomeTag
{
	Green,
	Savanna,
	Enchanted,
	Corrupted,
	Mushroom,
	Swamp,
	Jungle,
	Desert,
	Rocklands,
	Crystal,
	Infernal,
	Candy,
	Lemon,
	Permafrost,
	Birch,
	Maple,
	Flower,
	Wasteland,
	Garlic,
	Soil,
	Field,
	Sand,
	Solitude,
	Paradox,
	Clover,
	Singularity,
	Celestial,
	Hills
}
// --- End of File: BiomeTag.cs ---



// --- Start of File: Blacklist.cs ---
using System;
using System.Collections.Generic;

public class Blacklist
{
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();

	private const int INDEX_LENGTH = 3;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity);
		}
	}

	internal static bool checkBlackList(StringBuilderPool pName)
	{
		pName.ToLowerInvariant();
		Span<char> span = stackalloc char[pName.Length];
		pName.CopyTo(0, span, pName.Length);
		ReadOnlySpan<char> readOnlySpan = span;
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		{
			string key = readOnlySpan.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern, i))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		if (readOnlySpan2 == readOnlySpan || readOnlySpan2.Length <= 2)
		{
			return false;
		}
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
		{
			string key2 = readOnlySpan2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(readOnlySpan2, pSearchPattern2, k))
				{
					return true;
				}
			}
		}
		return false;
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		{
			string key = readOnlySpan.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern, i))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		if (readOnlySpan2 == readOnlySpan || readOnlySpan2.Length <= 2)
		{
			return false;
		}
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
		{
			string key2 = readOnlySpan2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(readOnlySpan2, pSearchPattern2, k))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: Blacklist.cs ---



// --- Start of File: BlacklistTest.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest
{
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	public static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		Dictionary<char, string[]> profanity = _profanity;
		ReadOnlySpan<char> readOnlySpan = text.AsSpan();
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(readOnlySpan2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest.cs ---



// --- Start of File: BlacklistTest10.cs ---
using System.Collections.Generic;

public class BlacklistTest10
{
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	public static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		string text2 = BlacklistTools.cleanString(text);
		bool flag = !(text2 == text);
		Dictionary<char, string[]> profanity = _profanity;
		foreach (char item in _unique)
		{
			if (!profanity.ContainsKey(item))
			{
				continue;
			}
			for (int i = 0; i < profanity[item].Length; i++)
			{
				if (text.Contains(profanity[item][i]))
				{
					return true;
				}
				if (flag && text2.Contains(profanity[item][i]))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest10.cs ---



// --- Start of File: BlacklistTest11.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest11
{
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();

	private const int INDEX_LENGTH = 3;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		int length = readOnlySpan.Length;
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < length - 3 + 1; i++)
		{
			string key = readOnlySpan.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(readOnlySpan.Slice(i), pSearchPattern))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		int length2 = readOnlySpan2.Length;
		if (readOnlySpan2 == readOnlySpan || length2 <= 2)
		{
			return false;
		}
		for (int k = 0; k < length2 - 3 + 1; k++)
		{
			string key2 = readOnlySpan2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(readOnlySpan2.Slice(k), pSearchPattern2))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest11.cs ---



// --- Start of File: BlacklistTest12.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest12
{
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();

	private const int INDEX_LENGTH = 3;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> pText = pName.ToLower().AsSpan();
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < pText.Length - 3 + 1; i++)
		{
			string key = pText.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(ref pText, ref pSearchPattern))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> pText2 = BlacklistTools.cleanSpan(pText);
		if (pText2 == pText || pText2.Length <= 2)
		{
			return false;
		}
		for (int k = 0; k < pText2.Length - 3 + 1; k++)
		{
			string key2 = pText2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(ref pText2, ref pSearchPattern2))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest12.cs ---



// --- Start of File: BlacklistTest13.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest13
{
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();

	private const int INDEX_LENGTH = 3;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		{
			string key = readOnlySpan.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern, i))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		if (readOnlySpan2 == readOnlySpan || readOnlySpan2.Length <= 2)
		{
			return false;
		}
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
		{
			string key2 = readOnlySpan2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(readOnlySpan2, pSearchPattern2, k))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest13.cs ---



// --- Start of File: BlacklistTest2.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest2
{
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		Dictionary<char, string[]> profanity = _profanity;
		string text2 = BlacklistTools.cleanStringAsSpan(text);
		bool flag = !(text2 == text);
		ReadOnlySpan<char> pText = text.AsSpan();
		ReadOnlySpan<char> pText2 = (flag ? text2.AsSpan() : ((ReadOnlySpan<char>)null));
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(pText, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(pText2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest2.cs ---



// --- Start of File: BlacklistTest3.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest3
{
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		Dictionary<char, string[]> profanity = _profanity;
		ReadOnlySpan<char> readOnlySpan = text.AsSpan();
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(readOnlySpan2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest3.cs ---



// --- Start of File: BlacklistTest4.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest4
{
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		ReadOnlySpan<char> readOnlySpan = text.AsSpan();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		Dictionary<char, char[][]> profanity = _profanity;
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(readOnlySpan2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest4.cs ---



// --- Start of File: BlacklistTest5.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest5
{
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		ReadOnlySpan<char> readOnlySpan = text.AsSpan();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		Dictionary<char, char[][]> profanity = _profanity;
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(readOnlySpan2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest5.cs ---



// --- Start of File: BlacklistTest6.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest6
{
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();

	private static readonly HashSet<char> _unique = new HashSet<char>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, _unique);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		string text = pName.ToLower();
		_unique.Clear();
		_unique.UnionWith(text);
		_unique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
		string text2 = BlacklistTools.cleanStringAsSpan(text);
		bool flag = !(text2 == text);
		Dictionary<char, char[][]> profanity = _profanity;
		ReadOnlySpan<char> pText = text.AsSpan();
		ReadOnlySpan<char> pText2 = (flag ? text2.AsSpan() : ((ReadOnlySpan<char>)null));
		foreach (char item in _unique)
		{
			if (!profanity.TryGetValue(item, out var value))
			{
				continue;
			}
			for (int i = 0; i < value.Length; i++)
			{
				ReadOnlySpan<char> pSearchPattern = value[i].AsSpan();
				if (BlacklistTools.contains(pText, pSearchPattern))
				{
					return true;
				}
				if (flag && BlacklistTools.contains(pText2, pSearchPattern))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest6.cs ---



// --- Start of File: BlacklistTest7.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest7
{
	private static readonly Dictionary<int, HashSet<int>> _profanity = new Dictionary<int, HashSet<int>>();

	private static int _min_length = int.MaxValue;

	private static int _max_length = int.MinValue;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, ref _min_length, ref _max_length);
		}
	}

	private static int getCharHashCode(char[] pChar)
	{
		return BlacklistTools.getCharHashCode(pChar);
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		for (int i = _min_length; i <= _max_length; i++)
		{
			HashSet<int> hashSet = _profanity[i];
			for (int j = 0; j < readOnlySpan.Length - i + 1; j++)
			{
				int charHashCode = getCharHashCode(readOnlySpan.Slice(j, i).ToArray());
				if (hashSet.Contains(charHashCode))
				{
					return true;
				}
				if (flag && readOnlySpan2.Length >= j + i)
				{
					charHashCode = getCharHashCode(readOnlySpan2.Slice(j, i).ToArray());
					if (hashSet.Contains(charHashCode))
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest7.cs ---



// --- Start of File: BlacklistTest8.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest8
{
	private static readonly Dictionary<int, HashSet<int>> _profanity = new Dictionary<int, HashSet<int>>();

	private static int _min_length = int.MaxValue;

	private static int _max_length = int.MinValue;

	private static readonly Dictionary<int, char[]> _char_arrays = new Dictionary<int, char[]>();

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity, ref _min_length, ref _max_length);
			for (int i = _min_length; i <= _max_length; i++)
			{
				_char_arrays[i] = new char[i];
			}
		}
	}

	private static int getCharHashCode(char[] pChar)
	{
		return BlacklistTools.getCharHashCode(pChar);
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		bool flag = !(readOnlySpan2 == readOnlySpan);
		for (int i = _min_length; i <= _max_length; i++)
		{
			char[] array = _char_arrays[i];
			HashSet<int> hashSet = _profanity[i];
			for (int j = 0; j < readOnlySpan.Length - i + 1; j++)
			{
				readOnlySpan.Slice(j, i).CopyTo(array);
				int charHashCode = getCharHashCode(array);
				if (hashSet.Contains(charHashCode))
				{
					return true;
				}
				if (flag && readOnlySpan2.Length >= j + i)
				{
					readOnlySpan2.Slice(j, i).CopyTo(array);
					charHashCode = getCharHashCode(array);
					if (hashSet.Contains(charHashCode))
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest8.cs ---



// --- Start of File: BlacklistTest9.cs ---
using System;
using System.Collections.Generic;

public class BlacklistTest9
{
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();

	private const int INDEX_LENGTH = 3;

	private static bool _initiated = false;

	public static void init()
	{
		if (!_initiated)
		{
			_initiated = true;
			BlacklistTools.loadProfanityFilter(_profanity);
		}
	}

	internal static bool checkBlackList(string pName)
	{
		ReadOnlySpan<char> readOnlySpan = pName.ToLower().AsSpan();
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		{
			string key = readOnlySpan.Slice(i, 3).ToString();
			if (!profanity.TryGetValue(key, out var value))
			{
				continue;
			}
			for (int j = 0; j < value.Length; j++)
			{
				ReadOnlySpan<char> pSearchPattern = value[j].AsSpan();
				if (BlacklistTools.contains(readOnlySpan, pSearchPattern))
				{
					return true;
				}
			}
		}
		ReadOnlySpan<char> readOnlySpan2 = BlacklistTools.cleanSpan(readOnlySpan);
		if (readOnlySpan2 == readOnlySpan || readOnlySpan2.Length <= 2)
		{
			return false;
		}
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
		{
			string key2 = readOnlySpan2.Slice(k, 3).ToString();
			if (!profanity.TryGetValue(key2, out var value2))
			{
				continue;
			}
			for (int l = 0; l < value2.Length; l++)
			{
				ReadOnlySpan<char> pSearchPattern2 = value2[l].AsSpan();
				if (BlacklistTools.contains(readOnlySpan2, pSearchPattern2))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTest9.cs ---



// --- Start of File: BlacklistTools.cs ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using UnityEngine;

public static class BlacklistTools
{
	private static string[] _profanities;

	public static string[] getProfanities()
	{
		if (_profanities != null)
		{
			return _profanities;
		}
		Object obj = Resources.Load("blacklisted_names");
		Object obj2 = ((obj is TextAsset) ? obj : null);
		string text = ((TextAsset)obj2).text;
		Resources.UnloadAsset(obj2);
		string[] array = Regex.Split(text, "\r\n?|\n", RegexOptions.Singleline);
		using ListPool<string> listPool = new ListPool<string>(array.Length);
		for (int i = 0; i < array.Length; i++)
		{
			string text2 = array[i].Trim().ToLower();
			if (text2.Length != 0)
			{
				listPool.Add(text2);
			}
		}
		_profanities = listPool.ToArray();
		return _profanities;
	}

	public static void loadProfanityFilter(Dictionary<char, string[]> pProfanity, HashSet<char> pUnique)
	{
		if (pProfanity != null && pProfanity.Count > 0)
		{
			return;
		}
		try
		{
			Dictionary<char, List<string>> dictionary = new Dictionary<char, List<string>>();
			string[] profanities = getProfanities();
			foreach (string text in profanities)
			{
				pUnique.Clear();
				pUnique.UnionWith(text);
				pUnique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
				foreach (char item in pUnique)
				{
					if (!dictionary.ContainsKey(item))
					{
						dictionary[item] = new List<string>();
					}
					dictionary[item].Add(text);
				}
			}
			foreach (char key in dictionary.Keys)
			{
				pProfanity[key] = dictionary[key].ToArray();
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)"Error when loading blacklist");
			Debug.LogError((object)ex);
		}
	}

	public static void loadProfanityFilter(Dictionary<char, char[][]> pProfanity, HashSet<char> pUnique)
	{
		if (pProfanity != null && pProfanity.Count > 0)
		{
			return;
		}
		try
		{
			Dictionary<char, List<char[]>> dictionary = new Dictionary<char, List<char[]>>();
			string[] profanities = getProfanities();
			foreach (string text in profanities)
			{
				pUnique.Clear();
				pUnique.UnionWith(text);
				pUnique.RemoveWhere((char pChar) => !char.IsLetter(pChar));
				char[] item = text.ToCharArray();
				foreach (char item2 in pUnique)
				{
					if (!dictionary.ContainsKey(item2))
					{
						dictionary[item2] = new List<char[]>();
					}
					dictionary[item2].Add(item);
				}
			}
			foreach (char key in dictionary.Keys)
			{
				pProfanity[key] = dictionary[key].ToArray();
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)"Error when loading blacklist");
			Debug.LogError((object)ex);
		}
	}

	public static void loadProfanityFilter(Dictionary<int, HashSet<int>> pProfanity, ref int pMinLength, ref int pMaxLength)
	{
		if (pProfanity != null && pProfanity.Count > 0)
		{
			return;
		}
		try
		{
			string[] profanities = getProfanities();
			foreach (string text in profanities)
			{
				if (text.Length < pMinLength)
				{
					pMinLength = text.Length;
				}
				if (text.Length > pMaxLength)
				{
					pMaxLength = text.Length;
				}
				if (!pProfanity.ContainsKey(text.Length))
				{
					pProfanity.Add(text.Length, new HashSet<int>());
				}
				if (!pProfanity[text.Length].Add(getCharHashCode(text.ToCharArray())))
				{
					Debug.Log((object)("Duplicate profanity: " + text));
				}
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)"Error when loading blacklist");
			Debug.LogError((object)ex);
		}
	}

	public static void loadProfanityFilter(Dictionary<string, string[]> pProfanity, int pIndexLength = 3)
	{
		if (pProfanity != null && pProfanity.Count > 0)
		{
			return;
		}
		try
		{
			Dictionary<string, HashSet<string>> dictionary = new Dictionary<string, HashSet<string>>();
			string[] profanities = getProfanities();
			foreach (string text in profanities)
			{
				string key = text.Substring(0, pIndexLength);
				if (!dictionary.ContainsKey(key))
				{
					dictionary.Add(key, new HashSet<string>());
				}
				if (!dictionary[key].Add(text))
				{
					Debug.Log((object)("Duplicate profanity: " + text));
				}
			}
			foreach (KeyValuePair<string, HashSet<string>> item in dictionary)
			{
				pProfanity.Add(item.Key, item.Value.ToArray());
			}
		}
		catch (Exception ex)
		{
			Debug.Log((object)"Error when loading blacklist");
			Debug.LogError((object)ex);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getCharHashCode(char[] pChar)
	{
		return ((IStructuralEquatable)pChar).GetHashCode((IEqualityComparer)EqualityComparer<char>.Default);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static string cleanString(string pString)
	{
		if (string.IsNullOrEmpty(pString))
		{
			return pString;
		}
		string text = pString[0].ToString();
		for (int i = 0; i < pString.Length - 1; i++)
		{
			if (!pString[i].Equals(pString[i + 1]))
			{
				text += pString[i + 1];
			}
		}
		return text;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static string cleanStringAsSpan(string pString)
	{
		if (string.IsNullOrEmpty(pString))
		{
			return pString;
		}
		ReadOnlySpan<char> readOnlySpan = pString.AsSpan();
		Span<char> span = stackalloc char[readOnlySpan.Length];
		int length = 0;
		span[length++] = readOnlySpan[0];
		for (int i = 1; i < readOnlySpan.Length; i++)
		{
			if (readOnlySpan[i] != readOnlySpan[i - 1])
			{
				span[length++] = readOnlySpan[i];
			}
		}
		return new string(span.Slice(0, length));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> cleanSpan(ReadOnlySpan<char> pSpan)
	{
		if (pSpan.Length == 0)
		{
			return pSpan;
		}
		Span<char> span = new char[pSpan.Length];
		int length = 0;
		span[length++] = pSpan[0];
		for (int i = 1; i < pSpan.Length; i++)
		{
			if (pSpan[i] != pSpan[i - 1])
			{
				span[length++] = pSpan[i];
			}
		}
		return span.Slice(0, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool contains(ReadOnlySpan<char> pText, ReadOnlySpan<char> pSearchPattern)
	{
		if (pSearchPattern.Length == 0)
		{
			return true;
		}
		if (pSearchPattern.Length > pText.Length)
		{
			return false;
		}
		char c = pSearchPattern[0];
		for (int i = 0; i <= pText.Length - pSearchPattern.Length; i++)
		{
			if (pText[i] != c)
			{
				continue;
			}
			bool flag = true;
			for (int j = 1; j < pSearchPattern.Length; j++)
			{
				if (pText[i + j] != pSearchPattern[j])
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				return true;
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool contains(ReadOnlySpan<char> pText, ReadOnlySpan<char> pSearchPattern, int pStartIndex)
	{
		if (pSearchPattern.Length == 0)
		{
			return true;
		}
		if (pSearchPattern.Length > pText.Length)
		{
			return false;
		}
		char c = pSearchPattern[0];
		for (int i = pStartIndex; i <= pText.Length - pSearchPattern.Length; i++)
		{
			if (pText[i] != c)
			{
				continue;
			}
			bool flag = true;
			for (int j = 1; j < pSearchPattern.Length; j++)
			{
				if (pText[i + j] != pSearchPattern[j])
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				return true;
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool contains(ref ReadOnlySpan<char> pText, ref ReadOnlySpan<char> pSearchPattern)
	{
		if (pSearchPattern.Length == 0)
		{
			return true;
		}
		if (pSearchPattern.Length > pText.Length)
		{
			return false;
		}
		char c = pSearchPattern[0];
		for (int i = 0; i <= pText.Length - pSearchPattern.Length; i++)
		{
			if (pText[i] != c)
			{
				continue;
			}
			bool flag = true;
			for (int j = 1; j < pSearchPattern.Length; j++)
			{
				if (pText[i + j] != pSearchPattern[j])
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				return true;
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool contains2(ref ReadOnlySpan<char> pText, ref ReadOnlySpan<char> pSearchPattern)
	{
		int length = pSearchPattern.Length;
		if (length == 0)
		{
			return true;
		}
		int length2 = pText.Length;
		if (length > length2)
		{
			return false;
		}
		int i = 0;
		for (int num = length2 - length; i <= num; i++)
		{
			if (pText.Slice(i, length).SequenceEqual(pSearchPattern))
			{
				return true;
			}
		}
		return false;
	}
}
// --- End of File: BlacklistTools.cs ---



// --- Start of File: Boat.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
using life.taxi;

public class Boat : ActorSimpleComponent
{
	private readonly HashSet<Actor> _passengers = new HashSet<Actor>();

	internal TaxiRequest taxi_request;

	internal int passengerWaitCounter;

	public WorldTile taxi_target;

	public bool pickup_near_dock;

	internal int last_movement_angle;

	private Vector2 _last_step = Vector2.zero;

	private string _boat_texture_id => actor.asset.boat_texture_id;

	internal override void create(Actor pActor)
	{
		base.create(pActor);
		Actor obj = actor;
		obj.callbacks_on_death = (BaseActionActor)Delegate.Combine(obj.callbacks_on_death, new BaseActionActor(deathAction));
		Actor obj2 = actor;
		obj2.callbacks_on_death = (BaseActionActor)Delegate.Combine(obj2.callbacks_on_death, new BaseActionActor(spawnBoatExplosion));
		Actor obj3 = actor;
		obj3.callbacks_landed = (BaseActionActor)Delegate.Combine(obj3.callbacks_landed, new BaseActionActor(cancelWork));
		Actor obj4 = actor;
		obj4.callbacks_cancel_path_movement = (BaseActionActor)Delegate.Combine(obj4.callbacks_cancel_path_movement, new BaseActionActor(cancelPathfinderMovement));
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		if (actor.is_moving)
		{
			calculateMovementAngle();
		}
	}

	public void calculateMovementAngle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector2 current_position = actor.current_position;
		Vector2 next_step_position = actor.next_step_position;
		if (!(_last_step == next_step_position))
		{
			_last_step = next_step_position;
			float angleDegrees = Toolbox.getAngleDegrees(current_position.x, current_position.y, next_step_position.x, next_step_position.y);
			last_movement_angle = (int)angleDegrees;
		}
	}

	public bool isNearDock()
	{
		Building homeBuilding = actor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return false;
		}
		if (homeBuilding.component_docks.tiles_ocean.Contains(actor.current_tile))
		{
			return true;
		}
		return false;
	}

	private void cancelPathfinderMovement(Actor pActor)
	{
		cancelWork(pActor);
	}

	internal void cancelWork(Actor pActor)
	{
		actor.cancelAllBeh();
		if (taxi_request != null)
		{
			TaxiManager.cancelRequest(taxi_request);
			taxi_request = null;
			taxi_target = null;
		}
	}

	public AnimationDataBoat getAnimationDataBoat()
	{
		return ActorAnimationLoader.loadAnimationBoat(_boat_texture_id);
	}

	public void spawnBoatExplosion(Actor pActor)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		EffectsLibrary.spawnAt("fx_boat_explosion", actor.current_position, actor.asset.base_stats["scale"]);
	}

	private void deathAction(Actor pActor)
	{
		if (taxi_request != null)
		{
			TaxiManager.finish(taxi_request);
			taxi_request = null;
		}
		unloadPassengers(actor.current_tile, pRandomForce: true);
	}

	internal void unloadPassengers(WorldTile pTile, bool pRandomForce = false)
	{
		foreach (Actor passenger in _passengers)
		{
			if (passenger.isAlive())
			{
				passenger.disembarkTo(this, pTile);
				if (pRandomForce)
				{
					passenger.applyRandomForce();
				}
			}
		}
		_passengers.Clear();
		taxi_target = null;
	}

	internal bool hasPassengers()
	{
		return _passengers.Count > 0;
	}

	internal int countPassengers()
	{
		return _passengers.Count;
	}

	internal bool hasPassenger(Actor pActor)
	{
		return _passengers.Contains(pActor);
	}

	public IReadOnlyCollection<Actor> getPassengers()
	{
		return _passengers;
	}

	internal void removePassenger(Actor pActor)
	{
		_passengers.Remove(pActor);
	}

	internal void addPassenger(Actor pActor)
	{
		if (_passengers.Add(pActor))
		{
			passengerWaitCounter = 0;
			if (taxi_request != null)
			{
				taxi_request.embarkToBoat(pActor);
			}
		}
	}

	public bool isHomeDockFull()
	{
		Building homeBuilding = actor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return true;
		}
		if (homeBuilding.component_docks.isFull(actor.asset.boat_type))
		{
			return true;
		}
		return false;
	}

	public bool isHomeDockOverfilled()
	{
		Building homeBuilding = actor.getHomeBuilding();
		if (homeBuilding == null)
		{
			return true;
		}
		if (homeBuilding.component_docks.isOverfilled(actor.asset.boat_type))
		{
			return true;
		}
		return false;
	}

	public void destroyBecauseOverfilled()
	{
		if (isHomeDockOverfilled())
		{
			actor.getHitFullHealth(AttackType.Explosion);
		}
	}

	public override void Dispose()
	{
		_passengers.Clear();
		taxi_target = null;
		taxi_request = null;
		base.Dispose();
	}
}
// --- End of File: Boat.cs ---



// --- Start of File: BoatState.cs ---
public enum BoatState
{

}
// --- End of File: BoatState.cs ---



// --- Start of File: Book.cs ---
public class Book : CoreSystemObject<BookData>
{
	private BaseStats _base_stats_read_action = new BaseStats();

	public override BaseSystemManager manager => World.world.books;

	public void newBook(Actor pByActor, BookTypeAsset pBookType, ActorTrait pTraitActor, CultureTrait pTraitCulture, LanguageTrait pTraitLanguage, ReligionTrait pTraitReligion)
	{
		string pName = NameGenerator.generateNameFromTemplate(pBookType.name_template, pByActor);
		setName(pName);
		data.book_type = pBookType.id;
		data.path_cover = World.world.books.getNewCoverPath();
		data.path_icon = pBookType.getNewIconPath();
		data.author_name = pByActor.getName();
		data.author_id = pByActor.getID();
		data.author_clan_name = pByActor.clan?.name;
		data.author_clan_id = pByActor.clan?.id ?? (-1);
		data.author_kingdom_name = pByActor.kingdom?.name;
		data.author_kingdom_id = pByActor.kingdom?.id ?? (-1);
		data.author_city_name = pByActor.city?.name;
		data.author_city_id = pByActor.city?.id ?? (-1);
		data.language_id = pByActor.language.id;
		data.language_name = pByActor.language.name;
		data.trait_id_actor = pTraitActor?.id;
		data.trait_id_language = pTraitLanguage?.id;
		data.trait_id_culture = pTraitCulture?.id;
		data.trait_id_religion = pTraitReligion?.id;
		pByActor.language.books.setDirty();
		if (pBookType.save_culture)
		{
			data.culture_id = pByActor.culture.id;
			data.culture_name = pByActor.culture.name;
			pByActor.culture.books.setDirty();
		}
		if (pBookType.save_religion)
		{
			data.religion_id = pByActor.religion?.id ?? (-1);
			data.religion_name = pByActor.religion?.name;
			pByActor.religion?.books.setDirty();
		}
		pByActor.language.data.books_written++;
		if (pByActor.hasClan())
		{
			pByActor.clan.data.books_written++;
		}
		recalcBaseStats();
	}

	public BaseStats getBaseStats()
	{
		return _base_stats_read_action;
	}

	private void recalcBaseStats()
	{
		_base_stats_read_action.clear();
		_base_stats_read_action.mergeStats(getAsset().base_stats);
	}

	public bool isReadyToBeRead()
	{
		if (World.world.getWorldTimeElapsedSince(data.timestamp_read_last_time) > 10f)
		{
			return true;
		}
		return false;
	}

	public override void loadData(BookData pData)
	{
		base.loadData(pData);
		recalcBaseStats();
	}

	public Religion getReligion()
	{
		return World.world.religions.get(data.religion_id);
	}

	public Language getLanguage()
	{
		return World.world.languages.get(data.language_id);
	}

	public Culture getCulture()
	{
		return World.world.cultures.get(data.culture_id);
	}

	public ActorTrait getBookTraitActor()
	{
		if (string.IsNullOrEmpty(data.trait_id_actor))
		{
			return null;
		}
		return AssetManager.traits.get(data.trait_id_actor);
	}

	public LanguageTrait getBookTraitLanguage()
	{
		if (string.IsNullOrEmpty(data.trait_id_language))
		{
			return null;
		}
		return AssetManager.language_traits.get(data.trait_id_language);
	}

	public CultureTrait getBookTraitCulture()
	{
		if (string.IsNullOrEmpty(data.trait_id_culture))
		{
			return null;
		}
		return AssetManager.culture_traits.get(data.trait_id_culture);
	}

	public ReligionTrait getBookTraitReligion()
	{
		if (string.IsNullOrEmpty(data.trait_id_religion))
		{
			return null;
		}
		return AssetManager.religion_traits.get(data.trait_id_religion);
	}

	public int getHappiness()
	{
		int num = (int)_base_stats_read_action["happiness"];
		if (getLanguage().hasTrait("beautiful_calligraphy"))
		{
			num = (int)((float)num * LanguageTraitLibrary.getValueFloat("beautiful_calligraphy"));
		}
		return num;
	}

	public int getExperience()
	{
		int num = (int)_base_stats_read_action["experience"];
		Language language = getLanguage();
		if (language.hasTrait("scribble"))
		{
			if (num > 1)
			{
				num = 1;
			}
		}
		else if (language.hasTrait("nicely_structured_grammar"))
		{
			num = (int)((float)num * LanguageTraitLibrary.getValueFloat("nicely_structured_grammar"));
		}
		return num;
	}

	public int getMana()
	{
		return (int)_base_stats_read_action["mana"];
	}

	protected sealed override void setDefaultValues()
	{
		base.setDefaultValues();
	}

	public BookTypeAsset getAsset()
	{
		return AssetManager.book_types.get(data.book_type);
	}

	public void readIt()
	{
		data.timestamp_read_last_time = World.world.getCurWorldTime();
	}

	public void increaseReadTimes()
	{
		data.times_read++;
		World.world.game_stats.data.booksRead++;
		World.world.map_stats.booksRead++;
		readIt();
	}

	public override void Dispose()
	{
		base.Dispose();
		_base_stats_read_action.clear();
	}
}
// --- End of File: Book.cs ---



// --- Start of File: BookData.cs ---
using System;
using System.ComponentModel;

[Serializable]
public class BookData : BaseSystemData
{
	public string book_type;

	public string path_cover;

	public string path_icon;

	public string author_name;

	[DefaultValue(-1L)]
	public long author_id = -1L;

	public string author_clan_name;

	[DefaultValue(-1L)]
	public long author_clan_id = -1L;

	public string author_kingdom_name;

	[DefaultValue(-1L)]
	public long author_kingdom_id = -1L;

	public string author_city_name;

	[DefaultValue(-1L)]
	public long author_city_id = -1L;

	[DefaultValue(-1L)]
	public long language_id = -1L;

	public string language_name;

	[DefaultValue(-1L)]
	public long culture_id = -1L;

	public string culture_name;

	[DefaultValue(-1L)]
	public long religion_id = -1L;

	public string religion_name;

	public int times_read;

	public double timestamp_read_last_time;

	public string trait_id_actor = string.Empty;

	public string trait_id_language = string.Empty;

	public string trait_id_culture = string.Empty;

	public string trait_id_religion = string.Empty;

	[DefaultValue(-1L)]
	public long building_id = -1L;
}
// --- End of File: BookData.cs ---



// --- Start of File: BookManager.cs ---
using System.Collections.Generic;
using UnityEngine;

public class BookManager : CoreSystemManager<Book, BookData>
{
	public const string COVER_PATH = "books/book_covers/";

	public const string ICON_PATH = "books/book_icons/";

	private static Sprite[] _cached_covers;

	public BookManager()
	{
		type_id = "book";
	}

	public Book generateNewBook(Actor pActor)
	{
		City city = pActor.getCity();
		Building buildingWithBookSlot = city.getBuildingWithBookSlot();
		if (buildingWithBookSlot == null)
		{
			return null;
		}
		Book book = newBook(pActor);
		if (book == null)
		{
			return null;
		}
		World.world.game_stats.data.booksWritten++;
		World.world.map_stats.booksWritten++;
		pActor.changeHappiness("wrote_book");
		buildingWithBookSlot.addBook(book);
		city.setStatusDirty();
		return book;
	}

	public string getNewCoverPath()
	{
		if (_cached_covers == null)
		{
			_cached_covers = SpriteTextureLoader.getSpriteList("books/book_covers/");
		}
		return ((Object)_cached_covers.GetRandom()).name;
	}

	private BookTypeAsset getPossibleBookType(Actor pActor)
	{
		using ListPool<BookTypeAsset> listPool = new ListPool<BookTypeAsset>(AssetManager.book_types.list.Count * 5);
		for (int i = 0; i < AssetManager.book_types.list.Count; i++)
		{
			BookTypeAsset bookTypeAsset = AssetManager.book_types.list[i];
			if (bookTypeAsset.requirement_check == null || bookTypeAsset.requirement_check(pActor, bookTypeAsset))
			{
				int num = bookTypeAsset.writing_rate;
				if (bookTypeAsset.rate_calc != null)
				{
					num = bookTypeAsset.rate_calc(pActor, bookTypeAsset);
				}
				num = Mathf.Min(num, 10);
				for (int j = 0; j < num; j++)
				{
					listPool.Add(bookTypeAsset);
				}
			}
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	public Book newBook(Actor pActor)
	{
		BookTypeAsset possibleBookType = getPossibleBookType(pActor);
		if (possibleBookType == null)
		{
			return null;
		}
		Book book = newObject();
		ActorTrait bookTrait = getBookTrait(pActor);
		LanguageTrait pTraitLanguage = pActor.language?.getTraitForBook();
		ReligionTrait pTraitReligion = pActor.religion?.getTraitForBook();
		CultureTrait pTraitCulture = pActor.culture?.getTraitForBook();
		book.newBook(pActor, possibleBookType, bookTrait, pTraitCulture, pTraitLanguage, pTraitReligion);
		return book;
	}

	private ActorTrait getBookTrait(Actor pActor)
	{
		IReadOnlyCollection<ActorTrait> traits = pActor.getTraits();
		using ListPool<ActorTrait> listPool = new ListPool<ActorTrait>(traits.Count);
		foreach (ActorTrait item in traits)
		{
			if (item.group_id == "mind")
			{
				listPool.Add(item);
			}
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	public void copyBook(Book pBook)
	{
	}

	public void burnBook(Book pBook)
	{
		pBook.getLanguage()?.books.setDirty();
		pBook.getCulture()?.books.setDirty();
		pBook.getReligion()?.books.setDirty();
		removeObject(pBook);
	}

	public override void removeObject(Book pObject)
	{
		World.world.game_stats.data.booksBurnt++;
		World.world.map_stats.booksBurnt++;
		base.removeObject(pObject);
	}
}
// --- End of File: BookManager.cs ---



// --- Start of File: BookRateCalc.cs ---
public delegate int BookRateCalc(Actor pActor, BookTypeAsset pAsset);
// --- End of File: BookRateCalc.cs ---



// --- Start of File: BookReadAction.cs ---
public delegate void BookReadAction(Actor pActor, BookTypeAsset pBookAsset);
// --- End of File: BookReadAction.cs ---



// --- Start of File: BookRequirementCheck.cs ---
public delegate bool BookRequirementCheck(Actor pActor, BookTypeAsset pAsset);
// --- End of File: BookRequirementCheck.cs ---



// --- Start of File: BooksContainer.cs ---
using System.Collections;
using UnityEngine;

public class BooksContainer : BooksElement
{
	private ObjectPoolGenericMono<CultureBookButton> _pool_books;

	private CultureBookButton _prefab_book;

	[SerializeField]
	private Transform _title;

	[SerializeField]
	private Transform _books_grid;

	protected override void Awake()
	{
		_prefab_book = Resources.Load<CultureBookButton>("ui/PrefabBook");
		_pool_books = new ObjectPoolGenericMono<CultureBookButton>(_prefab_book, _books_grid);
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (books.Count == 0)
		{
			yield break;
		}
		if ((Object)(object)_title != (Object)null)
		{
			((Component)_title).gameObject.SetActive(true);
		}
		((Component)_books_grid).gameObject.SetActive(true);
		using ListPool<long> tBooks = new ListPool<long>(books);
		foreach (ref long item in tBooks)
		{
			long tBookID = item;
			yield return (object)new WaitForSecondsRealtime(0.025f);
			loadBookButton(tBookID);
		}
	}

	public void loadBookButton(long pBookID)
	{
		_pool_books.getNext().load(pBookID);
	}

	protected override void clear()
	{
		_pool_books.clear();
		if ((Object)(object)_title != (Object)null)
		{
			((Component)_title).gameObject.SetActive(false);
		}
		((Component)_books_grid).gameObject.SetActive(false);
		base.clear();
	}

	protected override void clearInitial()
	{
		for (int i = 0; i < _books_grid.childCount; i++)
		{
			Object.Destroy((Object)(object)((Component)_books_grid.GetChild(i)).gameObject);
		}
		base.clearInitial();
	}
}
// --- End of File: BooksContainer.cs ---



// --- Start of File: BooksElement.cs ---
using System.Collections.Generic;
using UnityEngine;

public class BooksElement : WindowMetaElementBase
{
	protected List<long> books;

	private IBooksWindow _books_window;

	protected override void Awake()
	{
		_books_window = ((Component)this).GetComponentInParent<IBooksWindow>();
		base.Awake();
	}

	protected override void OnEnable()
	{
		books = _books_window.getBooks();
		base.OnEnable();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		books = null;
	}

	public override bool checkRefreshWindow()
	{
		if (books != null)
		{
			foreach (long book in books)
			{
				if (World.world.books.get(book).isRekt())
				{
					return true;
				}
			}
		}
		return base.checkRefreshWindow();
	}
}
// --- End of File: BooksElement.cs ---



// --- Start of File: BooksHandler.cs ---
using System.Collections.Generic;

public class BooksHandler
{
	private readonly List<long> _books = new List<long>();

	private bool _books_dirty = true;

	private Culture _culture;

	private Language _language;

	private Religion _religion;

	public void setMeta(Culture pCulture = null, Language pLanguage = null, Religion pReligion = null)
	{
		_culture = pCulture;
		_language = pLanguage;
		_religion = pReligion;
		setDirty();
	}

	public List<long> getList()
	{
		checkBooks();
		return _books;
	}

	public int count()
	{
		return getList().Count;
	}

	public bool hasBooks()
	{
		return count() > 0;
	}

	public void setDirty()
	{
		_books_dirty = true;
	}

	private void checkBooks()
	{
		if (!_books_dirty)
		{
			return;
		}
		_books_dirty = false;
		_books.Clear();
		foreach (Book book in World.world.books)
		{
			if (_culture != null && book.getCulture() == _culture)
			{
				_books.Add(book.id);
			}
			else if (_language != null && book.getLanguage() == _language)
			{
				_books.Add(book.id);
			}
			else if (_religion != null && book.getReligion() == _religion)
			{
				_books.Add(book.id);
			}
		}
	}

	public void clear()
	{
		setDirty();
		_culture = null;
		_language = null;
		_religion = null;
	}
}
// --- End of File: BooksHandler.cs ---



// --- Start of File: BooksNoItems.cs ---
using UnityEngine;

public class BooksNoItems : MonoBehaviour
{
	private GameObject _inner;

	private IBooksWindow _books_window;

	private void Awake()
	{
		_inner = ((Component)((Component)this).transform.GetChild(0)).gameObject;
		_books_window = ((Component)this).GetComponentInParent<IBooksWindow>();
	}

	private void OnEnable()
	{
		_inner.SetActive(!_books_window.hasBooks());
	}
}
// --- End of File: BooksNoItems.cs ---



// --- Start of File: BookTraitAction.cs ---
public delegate void BookTraitAction(Actor pActor, LanguageTrait pTrait, Book pBook);
// --- End of File: BookTraitAction.cs ---



// --- Start of File: BookTypeAsset.cs ---
using System;
using UnityEngine;

[Serializable]
public class BookTypeAsset : Asset, IDescriptionAsset, ILocalizedAsset
{
	public int writing_rate = 1;

	public string name_template;

	public string path_icons;

	public string color_text;

	public BookReadAction read_action;

	public bool save_culture = true;

	public bool save_religion = true;

	public BookRateCalc rate_calc;

	public BookRequirementCheck requirement_check;

	private Sprite[] _cached_icons;

	public BaseStats base_stats = new BaseStats();

	public string getNewIconPath()
	{
		if (_cached_icons == null)
		{
			_cached_icons = SpriteTextureLoader.getSpriteList(getFullIconPath());
		}
		return ((Object)_cached_icons.GetRandom()).name;
	}

	public string getFullIconPath()
	{
		return "books/book_icons/" + path_icons;
	}

	public string getTypeID()
	{
		return "book_type_" + id;
	}

	public string getLocaleID()
	{
		return getTypeID();
	}

	public string getDescriptionID()
	{
		return "book_type_info_" + id;
	}

	public string getDescriptionTranslated()
	{
		return LocalizedTextManager.getText(getDescriptionID());
	}
}
// --- End of File: BookTypeAsset.cs ---



// --- Start of File: BookTypeLibrary.cs ---
public class BookTypeLibrary : AssetLibrary<BookTypeAsset>
{
	public override void init()
	{
		base.init();
		add(new BookTypeAsset
		{
			id = "family_story",
			name_template = "book_name_love_story",
			color_text = "#FFA94D",
			writing_rate = 3,
			path_icons = "family_story/",
			requirement_check = (Actor a, BookTypeAsset _) => a.hasFamily() ? true : false
		});
		t.base_stats["mana"] = 10f;
		t.base_stats["happiness"] = 5f;
		t.base_stats["experience"] = 5f;
		add(new BookTypeAsset
		{
			id = "love_story",
			name_template = "book_name_love_story",
			color_text = "#FF6B6B",
			writing_rate = 3,
			path_icons = "love_story/",
			requirement_check = (Actor a, BookTypeAsset _) => a.hasFamily() ? true : false
		});
		t.base_stats["mana"] = 10f;
		t.base_stats["happiness"] = 10f;
		t.base_stats["experience"] = 5f;
		add(new BookTypeAsset
		{
			id = "friendship_story",
			name_template = "book_name_love_story",
			color_text = "#74C0FC",
			writing_rate = 3,
			path_icons = "friendship_story/",
			requirement_check = (Actor a, BookTypeAsset _) => a.hasFamily() ? true : false
		});
		t.base_stats["mana"] = 10f;
		t.base_stats["happiness"] = 5f;
		t.base_stats["experience"] = 5f;
		add(new BookTypeAsset
		{
			id = "bad_story_about_king",
			name_template = "book_name_bad_story",
			color_text = "#FFD700",
			writing_rate = 3,
			path_icons = "bad_story/",
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (a.isKing())
				{
					return false;
				}
				Actor king = a.kingdom.king;
				if (!king.hasFamily())
				{
					return false;
				}
				return king.hasClan() ? true : false;
			}
		});
		t.base_stats["happiness"] = -10f;
		t.base_stats["experience"] = 10f;
		add(new BookTypeAsset
		{
			id = "fable",
			name_template = "book_name_fable",
			color_text = "#9ACD32",
			writing_rate = 3,
			path_icons = "fable/",
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.hasWeapon())
				{
					return false;
				}
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				return a.city.hasLeader() ? true : false;
			}
		});
		t.base_stats["mana"] = 20f;
		t.base_stats["happiness"] = 10f;
		t.base_stats["experience"] = 30f;
		add(new BookTypeAsset
		{
			id = "warfare_manual",
			name_template = "book_name_warfare_manual",
			color_text = "#E8590C",
			path_icons = "warfare_manual/",
			rate_calc = (Actor a, BookTypeAsset _) => (int)a.stats["warfare"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				if (!a.city.hasLeader())
				{
					return false;
				}
				return (a.city.countWarriors() != 0) ? true : false;
			}
		});
		t.base_stats["warfare"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 5f;
		add(new BookTypeAsset
		{
			id = "economy_manual",
			name_template = "book_name_economy_manual",
			path_icons = "economy_manual/",
			color_text = "#EAC645",
			rate_calc = (Actor a, BookTypeAsset b) => (int)a.stats["stewardship"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				return a.city.hasLeader() ? true : false;
			}
		});
		t.base_stats["happiness"] = -10f;
		t.base_stats["stewardship"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 10f;
		add(new BookTypeAsset
		{
			id = "stewardship_manual",
			name_template = "book_name_stewardship_manual",
			color_text = "#D4A373",
			path_icons = "stewardship_manual/",
			rate_calc = (Actor a, BookTypeAsset b) => (int)a.stats["stewardship"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				return a.city.hasLeader() ? true : false;
			}
		});
		t.base_stats["happiness"] = -5f;
		t.base_stats["stewardship"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 10f;
		add(new BookTypeAsset
		{
			id = "diplomacy_manual",
			name_template = "book_name_diplomacy_manual",
			color_text = "#66D9E8",
			path_icons = "diplomacy_manual/",
			rate_calc = (Actor a, BookTypeAsset _) => (int)a.stats["diplomacy"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				return a.city.hasLeader() ? true : false;
			}
		});
		t.base_stats["happiness"] = -10f;
		t.base_stats["diplomacy"] = 1f;
		t.base_stats["experience"] = 10f;
		add(new BookTypeAsset
		{
			id = "mathbook",
			name_template = "book_name_math",
			color_text = "#3BC9DB",
			path_icons = "mathbook/",
			rate_calc = (Actor a, BookTypeAsset _) => (int)a.stats["intelligence"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				if (!a.city.hasLeader())
				{
					return false;
				}
				return a.hasCulture() ? true : false;
			}
		});
		t.base_stats["happiness"] = -20f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 30f;
		add(new BookTypeAsset
		{
			id = "biology_book",
			name_template = "book_name_biology",
			path_icons = "biology_book/",
			color_text = "#80C980",
			rate_calc = (Actor a, BookTypeAsset _) => (int)a.stats["intelligence"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				if (!a.city.hasLeader())
				{
					return false;
				}
				return a.hasSubspecies() ? true : false;
			}
		});
		t.base_stats["happiness"] = 10f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 30f;
		add(new BookTypeAsset
		{
			id = "history_book",
			name_template = "book_name_history",
			path_icons = "history_book/",
			color_text = "#C49A6C",
			rate_calc = (Actor a, BookTypeAsset _) => (int)a.stats["intelligence"],
			requirement_check = delegate(Actor a, BookTypeAsset _)
			{
				if (!a.kingdom.hasKing())
				{
					return false;
				}
				if (!a.kingdom.king.hasClan())
				{
					return false;
				}
				if (!a.hasCity())
				{
					return false;
				}
				if (!a.city.hasLeader())
				{
					return false;
				}
				return a.hasSubspecies() ? true : false;
			}
		});
		t.base_stats["happiness"] = 5f;
		t.base_stats["warfare"] = 1f;
		t.base_stats["diplomacy"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["experience"] = 30f;
	}

	public override void editorDiagnostic()
	{
		base.editorDiagnostic();
		foreach (BookTypeAsset item in list)
		{
			checkSpriteExists("path_icons", item.getFullIconPath(), item);
		}
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (BookTypeAsset item in list)
		{
			checkLocale(item, item.getDescriptionID());
			checkLocale(item, item.getLocaleID());
		}
	}
}
// --- End of File: BookTypeLibrary.cs ---



// --- Start of File: Boulder.cs ---
using System.Collections.Generic;
using UnityEngine;

public class Boulder : BaseEffect
{
	private const float SPEED = 2.5f;

	private const int BOUNCES_AMOUNT = 3;

	private const float SINGLE_BOUNCE_TIMER = 2f;

	private const float BASE_HEIGHT_MULTIPLIER = 10f;

	private const float BASE_LENGTH_MULTIPLIER = 40f;

	private const float INITIAL_ANGLE_RANGE = 200f;

	private const float CHARGE_VECTOR_MULTIPLIER = 0.777f;

	private const float Z_SORTING_FIX = 5f;

	private const int NO_TOUCH_ID = -2;

	private float angle;

	private float angleRotation;

	private float impactEffect;

	public GameObject mainSprite;

	public GameObject shadowSprite;

	private SpriteRenderer shadowRenderer;

	private Transform mainTransform;

	private Transform shadowTransform;

	private Vector2 _previous_bounce_position;

	private List<Vector2> _bounce_positions = new List<Vector2>();

	private int _bounces_left;

	private float _force_timer;

	private static bool _charge_started;

	private static Vector2 _initial_charge_position;

	private static Touch _latest_touch;

	private static int _latest_touch_id = -2;

	public override void Awake()
	{
		base.Awake();
		sprite_renderer = mainSprite.GetComponent<SpriteRenderer>();
		shadowRenderer = shadowSprite.GetComponent<SpriteRenderer>();
		mainTransform = mainSprite.transform;
		shadowTransform = shadowSprite.transform;
	}

	public override void update(float pElapsed)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		base.update(pElapsed);
		updateForce(pElapsed);
		if (impactEffect > 0f)
		{
			impactEffect -= pElapsed;
		}
		if (position_height != 0f)
		{
			angle += angleRotation * pElapsed;
			mainTransform.localEulerAngles = new Vector3(0f, 0f, angle);
		}
	}

	private void updateForce(float pElapsed)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		_force_timer -= pElapsed * 2.5f;
		if (_force_timer <= 0f)
		{
			_force_timer = 2f;
			actionLanded();
			return;
		}
		float heightPosition = getHeightPosition();
		Vector2 val = calcCurrentPos();
		setCurrentPosition(val.x, val.y, heightPosition);
		updateCurrentPosition();
	}

	private void updateShadow()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		float num = (position_height / -5f + 10f) / 10f;
		float shadowAlpha = Mathf.Clamp(num, 0.15f, 1f) * 0.3f;
		setShadowAlpha(shadowAlpha);
		float num2 = Mathf.Clamp(num, 0.25f, 0.9f) * 0.3f;
		Vector3 localScale = shadowTransform.localScale;
		((Vector3)(ref localScale)).Set(num2, num2, 1f);
		shadowTransform.localScale = localScale;
	}

	private void setShadowAlpha(float pVal)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		float num = pVal;
		if (num < 0f)
		{
			num = 0f;
		}
		Color color = shadowRenderer.color;
		color.a = num;
		shadowRenderer.color = color;
	}

	private void spawnEffect(string pEffectID)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!(impactEffect > 0f))
		{
			impactEffect = 0.8f;
			Vector3 pPos = Vector2.op_Implicit(current_position);
			pPos.y -= 2f;
			EffectsLibrary.spawnAt(pEffectID, pPos, mainTransform.localScale.x);
		}
	}

	internal void actionLanded()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		_previous_bounce_position = current_position;
		_bounces_left--;
		current_tile = World.world.GetTile((int)((Component)this).transform.localPosition.x, (int)((Component)this).transform.localPosition.y);
		bool flag = true;
		if (current_tile != null && current_tile.Type.lava)
		{
			flag = false;
		}
		if (_bounces_left < 1)
		{
			flag = false;
		}
		if (flag)
		{
			sequencedBounce();
		}
		else
		{
			explosion();
		}
	}

	private void sequencedBounce()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pVec = Vector2.op_Implicit(current_position);
		pVec.y -= 2f;
		EffectsLibrary.spawnExplosionWave(pVec, (float)_bounces_left * 0.14f, 6f);
		World.world.startShake(0.3f, 0.01f, 1f);
		if (!Toolbox.inMapBorder(ref current_position))
		{
			spawnEffect("fx_boulder_impact_water");
		}
		else if (current_tile != null)
		{
			if (current_tile.Type.ocean)
			{
				spawnEffect("fx_boulder_impact_water");
			}
			else
			{
				spawnEffect("fx_boulder_impact");
			}
			World.world.loopWithBrush(current_tile, Brush.get(5), tileDrawBoulder);
			World.world.applyForceOnTile(current_tile, 5, 0.5f, pForceOut: false);
			World.world.conway_layer.checkKillRange(current_tile.pos, 5);
		}
	}

	private void explosion()
	{
		if (current_tile == null || current_tile.Type.ocean)
		{
			spawnEffect("fx_boulder_impact_water");
		}
		else
		{
			spawnEffect("fx_boulder_impact");
		}
		impactEffect = 0f;
		if (Toolbox.inMapBorder(ref current_position))
		{
			MapAction.damageWorld(current_tile, 10, AssetManager.terraform.get("bomb"));
		}
		spawnEffect("fx_explosion_small");
		controller.killObject(this);
	}

	public static bool tileDrawBoulder(WorldTile pTile, string pPowerID)
	{
		pTile.doUnits(delegate(Actor pActor)
		{
			AchievementLibrary.ball_to_ball.checkBySignal(pActor);
			pActor.getHitFullHealth(AttackType.Gravity);
		});
		if (pTile.Type.ocean && Randy.randomChance(0.3f))
		{
			World.world.drop_manager.spawnParabolicDrop(pTile, "rain", 0f, 1f, 30f, 0.7f, 22f);
		}
		if (pTile.Type.lava && Randy.randomChance(0.3f))
		{
			World.world.drop_manager.spawnParabolicDrop(pTile, "lava", 0f, 1f, 30f, 0.7f, 22f);
		}
		MapAction.decreaseTile(pTile, pDamage: true, "destroy");
		return true;
	}

	public void spawnOn(Vector2 pPosition)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		_bounce_positions.Clear();
		if (isRandomLaunch(pPosition))
		{
			_force_timer = 1f;
		}
		else
		{
			_force_timer = 2f;
		}
		_bounces_left = 3;
		angle = 0f;
		angleRotation = Randy.randomFloat(-200f, 200f);
		impactEffect = 0f;
		Vector2 val = default(Vector2);
		if (isRandomLaunch(pPosition))
		{
			val.x = Randy.randomFloat(-40f, 40f);
			val.y = Randy.randomFloat(-40f, 40f);
			val = Vector2.ClampMagnitude(val, 40f);
		}
		else
		{
			val = chargeVector(pPosition) * 0.777f;
		}
		_previous_bounce_position = pPosition;
		_previous_bounce_position.y -= getHeightPosition();
		_previous_bounce_position -= val * getBounceProgress();
		for (int i = 0; i < 3; i++)
		{
			int num = i + 1;
			Vector2 item = default(Vector2);
			item.x = _previous_bounce_position.x + val.x * (float)num;
			item.y = _previous_bounce_position.y + val.y * (float)num;
			_bounce_positions.Add(item);
		}
		updateCurrentPosition();
		endCharging();
	}

	private void setCurrentPosition(float pX, float pY, float pHeight)
	{
		current_position.x = pX;
		current_position.y = pY;
		position_height = pHeight;
	}

	private void updateCurrentPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localPosition = ((Component)this).transform.localPosition;
		localPosition.x = current_position.x;
		localPosition.y = current_position.y;
		localPosition.z = position_height + 5f;
		((Component)this).transform.localPosition = localPosition;
		Vector3 localPosition2 = mainTransform.localPosition;
		localPosition2.y = position_height;
		mainTransform.localPosition = localPosition2;
		updateShadow();
	}

	private float getBounceProgress()
	{
		return 1f - _force_timer / 2f;
	}

	private float getBounceProgressMirrored()
	{
		return 1f - Mathf.Abs(getBounceProgress() * 2f - 1f);
	}

	private float getHeightProgress()
	{
		return iTween.easeOutQuad(0f, 1f, getBounceProgressMirrored());
	}

	private float getHeightPosition()
	{
		return (float)_bounces_left * getHeightProgress() * 10f;
	}

	private int getCurrentBounceIndex()
	{
		return 3 - _bounces_left;
	}

	private Vector2 getNextBouncePos()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return _bounce_positions[getCurrentBounceIndex()];
	}

	private Vector2 calcCurrentPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.Lerp(_previous_bounce_position, getNextBouncePos(), getBounceProgress());
	}

	public static void chargeBoulder(Vector2 pPosition, Touch pTouch = default(Touch))
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		_latest_touch = pTouch;
		if (ScrollWindow.isWindowActive())
		{
			endCharging();
		}
		else if (HotkeyLibrary.many_mod.isHolding() || (!InputHelpers.mouseSupported && DebugConfig.isOn(DebugOption.FastSpawn)))
		{
			if (_charge_started)
			{
				endCharging();
			}
			releaseManyBoulders(pPosition);
		}
		else if (isInteractionJustStarted())
		{
			startCharging(pPosition);
		}
		else if (isInteractionJustEnded())
		{
			releaseBoulder();
		}
	}

	private static void startCharging(Vector2 pPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		_charge_started = true;
		_initial_charge_position = pPosition;
		_latest_touch_id = ((Touch)(ref _latest_touch)).fingerId;
	}

	private static void endCharging()
	{
		_charge_started = false;
		_latest_touch_id = -2;
	}

	public static void checkRelease()
	{
		if (!_charge_started)
		{
			return;
		}
		if (!isBoulderPowerSelected())
		{
			endCharging();
			return;
		}
		spawnParticles();
		if (isInteractionJustEnded())
		{
			releaseBoulder();
		}
	}

	private static void releaseManyBoulders(Vector2 pPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		_initial_charge_position = pPosition;
		releaseBoulder();
	}

	private static void releaseBoulder()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 pointerPosition = getPointerPosition();
		EffectsLibrary.spawnAt("fx_boulder", pointerPosition, 1f);
	}

	private static void spawnParticles()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector2 pPosition = Vector2.zero;
		if (getPointerPositionPure(ref pPosition) && !isRandomLaunch(pPosition))
		{
			EffectsLibrary.spawnAt("fx_boulder_charge", pPosition, 1f);
		}
	}

	private static bool isRandomLaunch(Vector2 pPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = chargeVector(pPosition);
		return ((Vector2)(ref val)).magnitude < 1.5f;
	}

	private static bool isBoulderPowerSelected()
	{
		return PowerButtonSelector.instance.selectedButton?.godPower?.id == "bowling_ball";
	}

	private static Vector2 chargeVector(Vector2 pPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _initial_charge_position - pPosition;
	}

	public static Vector2 chargeVector()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return chargeVector(getPointerPosition());
	}

	private static bool isInteractionJustStarted()
	{
		if (_charge_started)
		{
			return false;
		}
		if (InputHelpers.mouseSupported)
		{
			if (Input.GetMouseButtonDown(0))
			{
				return true;
			}
		}
		else if (((Touch)(ref _latest_touch)).fingerId != _latest_touch_id)
		{
			return true;
		}
		return false;
	}

	private static bool isInteractionJustEnded()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Invalid comparison between Unknown and I4
		if (InputHelpers.mouseSupported)
		{
			if (Input.GetMouseButtonUp(0))
			{
				return true;
			}
		}
		else if (Input.touchCount == 0 || (int)((Touch)(ref _latest_touch)).phase == 3)
		{
			return true;
		}
		return false;
	}

	private static Vector2 getPointerPosition()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		if (InputHelpers.mouseSupported)
		{
			return World.world.getMousePos();
		}
		return Vector2.op_Implicit(World.world.camera.ScreenToWorldPoint(Vector2.op_Implicit(((Touch)(ref _latest_touch)).position)));
	}

	private static bool getPointerPositionPure(ref Vector2 pPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (InputHelpers.mouseSupported)
		{
			pPosition = World.world.getMousePos();
			return true;
		}
		if (World.world.player_control.getTouchPos(out var pTouch))
		{
			pPosition = Vector2.op_Implicit(World.world.camera.ScreenToWorldPoint(Vector2.op_Implicit(((Touch)(ref pTouch)).position)));
			return true;
		}
		return false;
	}
}
// --- End of File: Boulder.cs ---



// --- Start of File: BoulderCharge.cs ---
using System.Collections.Generic;
using UnityEngine;

public class BoulderCharge : BaseEffect
{
	private const float BASE_ALPHA = 1f;

	private const float ALPHA_CHANGE = 0.001f;

	private const float RANDOM_OFFSET = 20f;

	private const float BASE_TIME_BETWEEN_FRAMES = 0.2f;

	[SerializeField]
	private List<SpriteSet> _sprite_sets;

	private Vector2 _direction;

	internal override void prepare(Vector2 pVector, float pScale = 1f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		base.prepare(pVector, pScale);
		_direction = Boulder.chargeVector();
		_direction.x += Randy.randomFloat(-20f, 20f);
		_direction.y += Randy.randomFloat(-20f, 20f);
		setAlpha(1f);
		sprite_animation.setFrames(_sprite_sets.GetRandom().sprites);
		sprite_animation.timeBetweenFrames = 0.2f / ((Vector2)(ref _direction)).magnitude;
	}

	public override void update(float pElapsed)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		base.update(pElapsed);
		Transform transform = ((Component)this).transform;
		transform.position += new Vector3((_direction.x + Randy.randomFloat(-20f, 20f)) * Time.deltaTime, _direction.y * Time.deltaTime, 0f);
		setAlpha(alpha - 0.001f);
	}
}
// --- End of File: BoulderCharge.cs ---



// --- Start of File: BoxPreview.cs ---
using System;
using System.Collections;
using System.IO;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BoxPreview : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class _003C_003Ec
	{
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();

		public static UnityAction _003C_003E9__16_1;

		internal void _003CAwake_003Eb__16_1()
		{
			if (InputHelpers.mouseSupported)
			{
				Tooltip.hideTooltip();
			}
		}
	}

	[SerializeField]
	private Sprite _preview_default;

	[SerializeField]
	private Image _icon_gift;

	[SerializeField]
	private Image _icon_premium;

	[SerializeField]
	private Image _icon_broken;

	[SerializeField]
	private Image _icon_modded;

	[SerializeField]
	private Image _cursed_bg;

	[SerializeField]
	private Image _cursed_overlay;

	[SerializeField]
	private GameObject _favorited;

	[SerializeField]
	private Image _preview_image;

	[SerializeField]
	private Button _button;

	[SerializeField]
	private Text _text_id;

	private bool _wantLoad_preview;

	private float _timer_preview;

	private string _world_path;

	private int _slot_id;

	private MapMetaData _metaData;

	private void Awake()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		_button.OnHover((UnityAction)delegate
		{
			if (InputHelpers.mouseSupported)
			{
				showHoverTooltip();
			}
		});
		Button button = _button;
		object obj = _003C_003Ec._003C_003E9__16_1;
		if (obj == null)
		{
			UnityAction val = delegate
			{
				if (InputHelpers.mouseSupported)
				{
					Tooltip.hideTooltip();
				}
			};
			_003C_003Ec._003C_003E9__16_1 = val;
			obj = (object)val;
		}
		button.OnHoverOut((UnityAction)obj);
	}

	public void setSlot(int pID)
	{
		_metaData = null;
		_text_id.text = "#" + pID;
		_slot_id = pID;
		_world_path = SaveManager.getSlotSavePath(pID);
		if (SaveManager.doesSaveExist(_world_path))
		{
			_metaData = SaveManager.getMetaFor(_world_path);
		}
		_preview_image.sprite = _preview_default;
		((Component)_icon_gift).gameObject.SetActive(false);
		((Component)_icon_premium).gameObject.SetActive(false);
		((Component)_icon_broken).gameObject.SetActive(false);
		((Component)_icon_modded).gameObject.SetActive(false);
		((Behaviour)_cursed_bg).enabled = false;
		((Behaviour)_cursed_overlay).enabled = false;
		if (_metaData != null)
		{
			if (_metaData.saveVersion > Config.WORLD_SAVE_VERSION)
			{
				((Component)_icon_broken).gameObject.SetActive(true);
			}
			if (_metaData.modded)
			{
				((Component)_icon_modded).gameObject.SetActive(true);
			}
			if (_metaData.cursed)
			{
				((Behaviour)_cursed_bg).enabled = true;
				((Behaviour)_cursed_overlay).enabled = true;
			}
		}
		_wantLoad_preview = true;
		_timer_preview = 0.02f * (float)pID;
		((Object)((Component)this).gameObject).name = "BoxPreview " + pID;
		bool active = PlayerConfig.instance.data.favorite_world == pID;
		_favorited.SetActive(active);
	}

	private void showHoverTooltip()
	{
		if (_metaData != null && Config.tooltips_active)
		{
			_metaData.temp_date_string = SaveManager.getMapCreationTime(_world_path);
			Tooltip.show(_button, "map_meta", new TooltipData
			{
				map_meta = _metaData
			});
		}
	}

	private void Update()
	{
		if (_wantLoad_preview)
		{
			if (_timer_preview > 0f)
			{
				_timer_preview -= Time.deltaTime;
				return;
			}
			_wantLoad_preview = false;
			((MonoBehaviour)this).StartCoroutine(loadSaveSlotImage());
		}
	}

	public void showDefaultImage()
	{
		_preview_image.sprite = _preview_default;
	}

	private void showPreview(Texture2D pTexture)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Sprite sprite = Sprite.Create(Toolbox.ScaleTexture(pTexture, 100, 100), new Rect(0f, 0f, 100f, 100f), new Vector2(0.5f, 0.5f));
		_preview_image.sprite = sprite;
	}

	private IEnumerator loadSaveSlotImage()
	{
		string tPath = SaveManager.generatePngPreviewPath(_world_path);
		if (string.IsNullOrEmpty(tPath) || !File.Exists(tPath))
		{
			showDefaultImage();
			yield break;
		}
		yield return CoroutineHelper.wait_for_next_frame;
		Texture2D val = new Texture2D(100, 100);
		((Object)val).name = "preview_" + _slot_id;
		try
		{
			byte[] array = File.ReadAllBytes(tPath);
			if (ImageConversion.LoadImage(val, array))
			{
				if ((Object)(object)val == (Object)null)
				{
					Debug.LogError((object)(((Object)((Component)this).gameObject).name + " texture is null from " + tPath));
					showDefaultImage();
				}
				else
				{
					showPreview(val);
				}
			}
			else
			{
				Debug.LogError((object)(((Object)((Component)this).gameObject).name + " cannot load image from " + tPath));
				showDefaultImage();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)(((Object)((Component)this).gameObject).name + " " + ex.Message + " when trying to load " + tPath));
			showDefaultImage();
		}
		Object.Destroy((Object)(object)val);
	}

	public void click()
	{
		if (ScrollWindow.isAnimationActive())
		{
			return;
		}
		if (Input.GetKey((KeyCode)304))
		{
			Application.OpenURL("file://" + _world_path);
			return;
		}
		SaveManager.setCurrentPathAndId(_world_path, _slot_id);
		if (SaveManager.currentSlotExists())
		{
			ScrollWindow.showWindow("save_slot");
		}
		else
		{
			ScrollWindow.showWindow("save_slot_new");
		}
	}
}
// --- End of File: BoxPreview.cs ---



// --- Start of File: BoxState.cs ---
public enum BoxState
{
	Empty,
	WithMap,
	OpenWithReward,
	PremiumOnly
}
// --- End of File: BoxState.cs ---



// --- Start of File: BrainsLibrary.cs ---
namespace ai.behaviours;

public class BrainsLibrary : BehaviourTaskActorLibrary
{
}
// --- End of File: BrainsLibrary.cs ---



// --- Start of File: Brush.cs ---
using System;

public class Brush
{
	public static string getRandom()
	{
		return AssetManager.brush_library.list.GetRandom().id;
	}

	public static string getRandom(int pMinSize, int pMaxSize = 50, Predicate<BrushData> pMatch = null)
	{
		foreach (BrushData item in AssetManager.brush_library.list.LoopRandom())
		{
			if ((pMatch == null || pMatch(item)) && item.sqr_size >= pMinSize && item.sqr_size <= pMaxSize)
			{
				return item.id;
			}
		}
		return "circ_1";
	}

	public static BrushData get(int pSize, string pID = "circ_")
	{
		string text = pID + pSize;
		BrushData brushData = AssetManager.brush_library.get(text);
		if (brushData != null)
		{
			return brushData;
		}
		brushData = AssetManager.brush_library.clone(text, pID + "1");
		brushData.size = pSize;
		AssetManager.brush_library.post_init();
		return brushData;
	}

	public static BrushData get(string pID)
	{
		return AssetManager.brush_library.get(pID);
	}
}
// --- End of File: Brush.cs ---



// --- Start of File: BrushData.cs ---
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public class BrushData : Asset, ILocalizedAsset
{
	[DefaultValue(1)]
	public int size = 1;

	[DefaultValue(1)]
	public int drops = 1;

	public BrushGroup group;

	public bool show_in_brush_window;

	public int width;

	public int height;

	public int sqr_size;

	public bool auto_size;

	public bool continuous;

	public bool fast_spawn;

	public string localized_key;

	public BrushPixelData[] pos;

	public BrushGenerateAction generate_action;

	public Vector2 ui_scale = new Vector2(1f, 1f);

	public Vector2 ui_size = new Vector2(28f, 28f);

	[NonSerialized]
	private Sprite _sprite;

	public void setupImage(Image pSprite)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		pSprite.sprite = getSprite();
		Vector2 val = ui_scale;
		Vector2 val2 = ui_size;
		if (height < 28)
		{
			((Vector2)(ref val2))._002Ector((float)width, (float)height);
		}
		((Graphic)pSprite).rectTransform.sizeDelta = new Vector2(val2.x, val2.y);
		((Component)pSprite).transform.localScale = new Vector3(val.x, val.y, 1f);
	}

	public Sprite getSprite()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_sprite != (Object)null)
		{
			return _sprite;
		}
		Texture2D val = new Texture2D(width, height, (TextureFormat)4, false)
		{
			filterMode = (FilterMode)0,
			wrapMode = (TextureWrapMode)1
		};
		Color[] array = (Color[])(object)new Color[width * height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Color.clear;
		}
		val.SetPixels(array);
		Color white = Color.white;
		int num = 0;
		int num2 = 0;
		BrushPixelData[] array2 = pos;
		for (int j = 0; j < array2.Length; j++)
		{
			BrushPixelData brushPixelData = array2[j];
			if (brushPixelData.x < num)
			{
				num = brushPixelData.x;
			}
			if (brushPixelData.y < num2)
			{
				num2 = brushPixelData.y;
			}
		}
		array2 = pos;
		for (int j = 0; j < array2.Length; j++)
		{
			BrushPixelData brushPixelData2 = array2[j];
			val.SetPixel(brushPixelData2.x - num, brushPixelData2.y - num2, white);
		}
		val.Apply(false, true);
		Rect val2 = default(Rect);
		((Rect)(ref val2))._002Ector(0f, 0f, (float)((Texture)val).width, (float)((Texture)val).height);
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))._002Ector(0f, 0f);
		_sprite = Sprite.Create(val, val2, val3, 1f);
		((Object)_sprite).name = id;
		return _sprite;
	}

	public string getLocaleID()
	{
		return localized_key;
	}
}
// --- End of File: BrushData.cs ---



// --- Start of File: BrushGenerateAction.cs ---
public delegate void BrushGenerateAction(BrushData pAsset);
// --- End of File: BrushGenerateAction.cs ---



// --- Start of File: BrushGroup.cs ---
public enum BrushGroup
{
	None,
	Circles,
	Squares,
	Diamonds,
	Special
}
// --- End of File: BrushGroup.cs ---



// --- Start of File: BrushLibrary.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

public class BrushLibrary : AssetLibrary<BrushData>
{
	[NonSerialized]
	private static readonly List<string> _available_brushes = new List<string>();

	public override void init()
	{
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_052c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0531: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_0633: Unknown result type (might be due to invalid IL or missing references)
		//IL_0638: Unknown result type (might be due to invalid IL or missing references)
		//IL_0682: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_072c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0731: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_083d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0842: Unknown result type (might be due to invalid IL or missing references)
		//IL_0898: Unknown result type (might be due to invalid IL or missing references)
		//IL_089d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f8: Unknown result type (might be due to invalid IL or missing references)
		base.init();
		add(new BrushData
		{
			id = "circ_0",
			size = 0,
			group = BrushGroup.Circles,
			fast_spawn = true,
			continuous = true,
			localized_key = "brush_circ",
			generate_action = delegate(BrushData pAsset)
			{
				pAsset.pos = new BrushPixelData[1]
				{
					new BrushPixelData(0, 0, 0)
				};
			}
		});
		t.show_in_brush_window = true;
		clone("circ_1", "circ_0");
		t.size = 1;
		t.fast_spawn = false;
		t.show_in_brush_window = true;
		t.generate_action = delegate(BrushData pAsset)
		{
			int size2 = pAsset.size;
			int m = 0;
			int num3 = size2;
			int num4 = 1 - size2;
			HashSet<BrushPixelData> hashSet = new HashSet<BrushPixelData>();
			for (; m <= num3; m++)
			{
				for (int n = -m; n <= m; n++)
				{
					int pDist3 = (int)Toolbox.Dist(0, 0, n, num3);
					hashSet.Add(new BrushPixelData(n, num3, pDist3));
					hashSet.Add(new BrushPixelData(n, -num3, pDist3));
				}
				for (int num5 = -num3; num5 <= num3; num5++)
				{
					int pDist4 = (int)Toolbox.Dist(0, 0, m, num5);
					hashSet.Add(new BrushPixelData(num5, m, pDist4));
					hashSet.Add(new BrushPixelData(num5, -m, pDist4));
				}
				if (num4 < 0)
				{
					num4 += 2 * m + 3;
				}
				else
				{
					num4 += 2 * (m - num3) + 5;
					num3--;
				}
			}
			pAsset.pos = hashSet.ToArray();
		};
		clone("circ_2", "circ_1");
		t.size = 2;
		t.show_in_brush_window = true;
		clone("circ_3", "circ_1");
		t.size = 3;
		t.show_in_brush_window = true;
		clone("circ_4", "circ_1");
		t.size = 4;
		t.continuous = false;
		t.show_in_brush_window = true;
		clone("circ_5", "circ_4");
		t.drops = 2;
		t.size = 5;
		t.show_in_brush_window = true;
		clone("circ_6", "circ_5");
		t.size = 6;
		t.show_in_brush_window = true;
		clone("circ_7", "circ_5");
		t.size = 7;
		t.show_in_brush_window = true;
		clone("circ_8", "circ_5");
		t.size = 8;
		clone("circ_9", "circ_5");
		t.size = 9;
		clone("circ_10", "circ_5");
		t.size = 10;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.9f, 0.9f);
		clone("circ_11", "circ_5");
		t.size = 11;
		clone("circ_12", "circ_5");
		t.size = 12;
		clone("circ_15", "circ_5");
		t.size = 15;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.9f, 0.9f);
		clone("circ_20", "circ_5");
		t.size = 20;
		clone("circ_30", "circ_5");
		t.size = 30;
		clone("circ_70", "circ_5");
		t.drops = 3;
		t.size = 70;
		add(new BrushData
		{
			id = "sqr_0",
			size = 0,
			group = BrushGroup.Squares,
			continuous = true,
			fast_spawn = true,
			localized_key = "brush_sqr",
			generate_action = delegate(BrushData pAsset)
			{
				pAsset.pos = new BrushPixelData[1]
				{
					new BrushPixelData(0, 0, 0)
				};
			}
		});
		add(new BrushData
		{
			id = "sqr_1",
			size = 1,
			group = BrushGroup.Squares,
			continuous = true,
			fast_spawn = false,
			localized_key = "brush_sqr"
		});
		t.show_in_brush_window = true;
		t.generate_action = delegate(BrushData pAsset)
		{
			int size = pAsset.size;
			Vector2Int val3 = default(Vector2Int);
			((Vector2Int)(ref val3))._002Ector(size / 2, size / 2);
			using ListPool<BrushPixelData> listPool2 = new ListPool<BrushPixelData>();
			for (int k = -size; k <= size; k++)
			{
				for (int l = -size; l <= size; l++)
				{
					int pDist2 = (int)Toolbox.Dist(k, l, ((Vector2Int)(ref val3)).x, ((Vector2Int)(ref val3)).y);
					listPool2.Add(new BrushPixelData(k, l, pDist2));
				}
			}
			pAsset.pos = listPool2.ToArray();
		};
		clone("sqr_2", "sqr_1");
		t.size = 2;
		t.continuous = false;
		t.show_in_brush_window = true;
		clone("sqr_3", "sqr_1");
		t.size = 3;
		t.continuous = false;
		clone("sqr_4", "sqr_1");
		t.size = 4;
		t.continuous = false;
		t.show_in_brush_window = true;
		clone("sqr_5", "sqr_1");
		t.size = 5;
		t.continuous = false;
		clone("sqr_10", "sqr_1");
		t.size = 10;
		t.drops = 2;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.8f, 0.8f);
		clone("sqr_15", "sqr_10");
		t.size = 15;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.8f, 0.8f);
		add(new BrushData
		{
			id = "diamond_1",
			continuous = true,
			group = BrushGroup.Diamonds,
			localized_key = "brush_diamond",
			size = 1,
			fast_spawn = false
		});
		t.show_in_brush_window = true;
		t.generate_action = delegate(BrushData pAsset)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			string text = "brush_" + pAsset.id;
			Texture2D val = Resources.Load<Texture2D>("ui/Icons/brushes/" + text);
			int width = ((Texture)val).width;
			int height = ((Texture)val).height;
			_ = width / 2;
			Vector2Int val2 = default(Vector2Int);
			((Vector2Int)(ref val2))._002Ector(width / 2, height / 2);
			using ListPool<BrushPixelData> listPool = new ListPool<BrushPixelData>();
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					if (!(val.GetPixel(i, j) != Color.white))
					{
						int num = ((Vector2Int)(ref val2)).x - i;
						int num2 = ((Vector2Int)(ref val2)).y - j;
						int pDist = (int)Toolbox.Dist(num, num2, ((Vector2Int)(ref val2)).x, ((Vector2Int)(ref val2)).y);
						listPool.Add(new BrushPixelData(num, num2, pDist));
					}
				}
			}
			pAsset.pos = listPool.ToArray();
		};
		clone("diamond_2", "diamond_1");
		t.size = 2;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.8f, 0.8f);
		clone("diamond_4", "diamond_1");
		t.size = 4;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.7f, 0.7f);
		clone("diamond_5", "diamond_1");
		t.drops = 2;
		t.size = 5;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.7f, 0.7f);
		clone("diamond_7", "diamond_5");
		t.size = 7;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_scale = new Vector2(0.9f, 0.9f);
		add(new BrushData
		{
			id = "special_1",
			continuous = true,
			group = BrushGroup.Special,
			localized_key = "brush_special",
			size = 1,
			fast_spawn = false
		});
		t.generate_action = get("diamond_1").generate_action;
		t.show_in_brush_window = true;
		t.ui_size = new Vector2(14f, 14f);
		clone("special_2", "special_1");
		t.size = 2;
		t.show_in_brush_window = true;
		t.ui_size = new Vector2(17.93f, 17.93f);
		clone("special_3", "special_1");
		t.size = 3;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_size = new Vector2(21.4f, 21.4f);
		clone("special_4", "special_1");
		t.drops = 2;
		t.size = 4;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_size = new Vector2(23.55f, 23.55f);
		clone("special_5", "special_4");
		t.drops = 2;
		t.size = 5;
		t.continuous = false;
		t.show_in_brush_window = true;
		t.ui_size = new Vector2(28.28f, 28.28f);
	}

	public override void post_init()
	{
		base.post_init();
		foreach (BrushData item in list)
		{
			if (item.show_in_brush_window)
			{
				_available_brushes.Add(item.id);
			}
			BrushPixelData[] pos = item.pos;
			if (pos != null && pos.Length != 0)
			{
				continue;
			}
			item.generate_action(item);
			int num = int.MaxValue;
			int num2 = int.MinValue;
			int num3 = int.MaxValue;
			int num4 = int.MinValue;
			for (int i = 0; i < item.pos.Length; i++)
			{
				BrushPixelData brushPixelData = item.pos[i];
				if (brushPixelData.x < num)
				{
					num = brushPixelData.x;
				}
				if (brushPixelData.x > num2)
				{
					num2 = brushPixelData.x;
				}
				if (brushPixelData.y < num3)
				{
					num3 = brushPixelData.y;
				}
				if (brushPixelData.y > num4)
				{
					num4 = brushPixelData.y;
				}
			}
			item.width = Mathf.Abs(num2 - num) + 1;
			item.height = Mathf.Abs(num4 - num3) + 1;
			item.sqr_size = item.width * item.height;
		}
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (BrushData item in list)
		{
			shuffleBrush(item);
		}
	}

	public static void shuffleBrush(BrushData pAsset)
	{
		pAsset.pos.Shuffle();
		int num = 0;
		for (int i = 0; i < pAsset.pos.Length; i++)
		{
			BrushPixelData brushPixelData = pAsset.pos[i];
			if (brushPixelData.x == 0 && brushPixelData.y == 0)
			{
				num = i;
				break;
			}
		}
		BrushPixelData brushPixelData2 = pAsset.pos[0];
		BrushPixelData brushPixelData3 = pAsset.pos[num];
		pAsset.pos[0] = brushPixelData3;
		pAsset.pos[num] = brushPixelData2;
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (BrushData item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}

	public override BrushData clone(string pNew, string pFrom)
	{
		BrushData brushData = base.clone(pNew, pFrom);
		brushData.show_in_brush_window = false;
		return brushData;
	}

	internal static void nextBrush()
	{
		Config.current_brush = getPrevious(Config.current_brush);
	}

	internal static void previousBrush()
	{
		Config.current_brush = getNext(Config.current_brush);
	}

	private static string getNext(string pBrushName)
	{
		bool flag = false;
		for (int i = 0; i < _available_brushes.Count; i++)
		{
			string text = _available_brushes[i];
			if (text == pBrushName)
			{
				flag = true;
			}
			else if (flag)
			{
				return text;
			}
		}
		return pBrushName;
	}

	private static string getPrevious(string pBrushName)
	{
		bool flag = false;
		for (int num = _available_brushes.Count - 1; num >= 0; num--)
		{
			string text = _available_brushes[num];
			if (text == pBrushName)
			{
				flag = true;
			}
			else if (flag)
			{
				return text;
			}
		}
		return pBrushName;
	}
}
// --- End of File: BrushLibrary.cs ---



// --- Start of File: BrushPixelData.cs ---
using System;
using Newtonsoft.Json;

[Serializable]
[JsonConverter(typeof(BrushPixelDataConverter))]
public readonly struct BrushPixelData : IEquatable<BrushPixelData>
{
	public readonly int x;

	public readonly int y;

	public readonly int dist;

	public BrushPixelData(int pX, int pY, int pDist)
	{
		x = pX;
		y = pY;
		dist = pDist;
	}

	public bool Equals(BrushPixelData pOther)
	{
		if (x == pOther.x)
		{
			return y == pOther.y;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return x * 100000 + y;
	}
}
// --- End of File: BrushPixelData.cs ---



// --- Start of File: BrushPixelDataConverter.cs ---
using System;
using Newtonsoft.Json;

public class BrushPixelDataConverter : JsonConverter
{
	public override void WriteJson(JsonWriter pWriter, object pValue, JsonSerializer pSerializer)
	{
		BrushPixelData brushPixelData = (BrushPixelData)pValue;
		string text = brushPixelData.x + "," + brushPixelData.y + "," + brushPixelData.dist;
		pSerializer.Serialize(pWriter, (object)text, typeof(string));
	}

	public override object ReadJson(JsonReader pReader, Type pObjectType, object pExistingValue, JsonSerializer pSerializer)
	{
		string text = pSerializer.Deserialize<string>(pReader);
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		int[] array = Array.ConvertAll(text.Split(','), int.Parse);
		return new BrushPixelData(array[0], array[1], array[2]);
	}

	public override bool CanConvert(Type pObjectType)
	{
		if (pObjectType != null)
		{
			return pObjectType == typeof(BrushPixelData);
		}
		return false;
	}
}
// --- End of File: BrushPixelDataConverter.cs ---



// --- Start of File: BrushSelectButton.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class BrushSelectButton : MonoBehaviour
{
	public Image icon;

	private BrushData _brush_asset;

	private void Start()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener((UnityAction)delegate
		{
			Config.current_brush = _brush_asset.id;
			ScrollWindow.hideAllEvent();
		});
	}

	public void setup(BrushData pBrushData)
	{
		_brush_asset = pBrushData;
		((Object)((Component)this).gameObject).name = _brush_asset.id;
		_brush_asset.setupImage(icon);
		((Component)this).GetComponent<TipButton>().textOnClick = _brush_asset.getLocaleID();
	}
}
// --- End of File: BrushSelectButton.cs ---



// --- Start of File: BrushSizesButton.cs ---
using UnityEngine;

public class BrushSizesButton : MonoBehaviour
{
	private PowerButton _power_button;

	private string _latest_used = string.Empty;

	private void Awake()
	{
		_power_button = ((Component)this).GetComponent<PowerButton>();
	}

	private void Update()
	{
		if (Config.current_brush != _latest_used)
		{
			_latest_used = Config.current_brush;
			BrushData brushData = Brush.get(Config.current_brush);
			if (brushData == null)
			{
				Debug.LogError((object)(Config.current_brush + " is not a valid brush"));
			}
			else
			{
				brushData.setupImage(_power_button.icon);
			}
		}
	}
}
// --- End of File: BrushSizesButton.cs ---



// --- Start of File: BrushWindow.cs ---
using UnityEngine;

public class BrushWindow : MonoBehaviour
{
	public Transform circles;

	public Transform squares;

	public Transform diamonds;

	public Transform special;

	public BrushSelectButton button_prefab;

	public void Awake()
	{
		foreach (BrushData item in AssetManager.brush_library.list)
		{
			if (item.show_in_brush_window)
			{
				Transform val = null;
				switch (item.group)
				{
				case BrushGroup.Circles:
					val = circles;
					break;
				case BrushGroup.Squares:
					val = squares;
					break;
				case BrushGroup.Diamonds:
					val = diamonds;
					break;
				case BrushGroup.Special:
					val = special;
					break;
				default:
					continue;
				}
				Object.Instantiate<BrushSelectButton>(button_prefab, val).setup(item);
			}
		}
	}

	public void selectBrush(GameObject pObject)
	{
		Config.current_brush = ((Object)pObject.transform).name;
		((Component)this).GetComponent<ScrollWindow>().clickHide();
	}
}
// --- End of File: BrushWindow.cs ---



// --- Start of File: Building.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Mathematics;
using UnityEngine;

public class Building : BaseSimObject, IEquatable<Building>, IComparable<Building>, ILoadable<BuildingData>
{
	public BatchBuildings batch;

	internal bool positionDirty;

	internal bool sprite_dirty;

	internal bool tiles_dirty;

	private Sprite _last_colored_sprite;

	private ColorAsset _last_color_asset;

	internal Sprite last_main_sprite;

	internal BuildingData data;

	internal BuildingAsset asset;

	public bool flip_x;

	internal readonly List<WorldTile> tiles = new List<WorldTile>();

	public BuildingAnimationData animData;

	public int animData_index;

	private float _shake_timer;

	private float _shake_intensity_x;

	private float _shake_intensity_y;

	internal float lastAngle;

	private Vector2 _shake_offset;

	internal readonly List<TileZone> zones = new List<TileZone>();

	internal BuildingAnimationState animation_state;

	internal BuildingOwnershipState state_ownership;

	internal ListPool<BaseBuildingComponent> components_list;

	internal Docks component_docks;

	internal Wheat component_wheat;

	internal BuildingFruitGrowth component_fruit_growth;

	internal UnitSpawner component_unit_spawner;

	internal BuildingSpreadBiome component_biome_spreader;

	internal BuildingMonolith component_monolith;

	internal BuildingWaypoint component_waypoint;

	internal BuildingBiomeFoodProducer component_food_producer;

	internal Beehive component_beehive;

	internal readonly BuildingTweenScaleHelper scale_helper = new BuildingTweenScaleHelper();

	internal bool chopped;

	internal bool is_visible;

	internal bool check_spawn_animation;

	private float _timer_shake_resource;

	private float _auto_remove_timer;

	public HashSet<long> residents = new HashSet<long>();

	private Vector3 _last_scale = Vector3.zero;

	public Material material;

	protected override MetaType meta_type => MetaType.Building;

	internal WorldTile door_tile
	{
		get
		{
			if (!current_tile.has_tile_down)
			{
				return current_tile;
			}
			return current_tile.tile_down;
		}
	}

	public City city => current_tile.zone.city;

	public CityResources resources => data.resources;

	internal bool isBurnable()
	{
		if (!hasHealth())
		{
			return false;
		}
		if (hasCity())
		{
			City city = getCity();
			if (city.hasReligion() && city.getReligion().hasMetaTag("building_immunity_fire"))
			{
				return false;
			}
		}
		return asset.burnable;
	}

	public float getExistenceTime()
	{
		return World.world.getWorldTimeElapsedSince(data.created_time);
	}

	public float getExistenceMonths()
	{
		return getExistenceTime() / 5f;
	}

	public void setAnimData(int pIndex)
	{
		if (pIndex >= asset.building_sprites.animation_data.Count || pIndex < 0)
		{
			pIndex = 0;
		}
		animData = asset.building_sprites.animation_data[pIndex];
		animData_index = pIndex;
	}

	internal void stopFire()
	{
		finishStatusEffect("burning");
	}

	internal override void create()
	{
		base.create();
		setObjectType(MapObjectType.Building);
		startShake(0.3f);
	}

	protected sealed override void setDefaultValues()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.setDefaultValues();
		flip_x = false;
		positionDirty = false;
		sprite_dirty = false;
		tiles_dirty = false;
		_last_colored_sprite = null;
		_last_color_asset = null;
		_shake_timer = 0f;
		lastAngle = 0f;
		residents.Clear();
		_shake_offset = Vector2.zero;
		animation_state = BuildingAnimationState.Normal;
		state_ownership = BuildingOwnershipState.None;
		chopped = false;
		is_visible = false;
		check_spawn_animation = false;
	}

	private T addComponent<T>() where T : BaseBuildingComponent, new()
	{
		T val = World.world.buildings.component_pool.get<T>();
		if (components_list == null)
		{
			components_list = new ListPool<BaseBuildingComponent>();
		}
		components_list.Add(val);
		val.create(this);
		batch.c_components.Add(this);
		return val;
	}

	public bool hasBooks()
	{
		if (data.books == null)
		{
			return false;
		}
		return data.books.hasAny();
	}

	public bool hasFreeBookSlot()
	{
		if (asset.book_slots == 0)
		{
			return false;
		}
		return asset.book_slots > data.books.totalBooks();
	}

	public void addBook(Book pBook)
	{
		data.books.addBook(pBook);
	}

	public bool isState(BuildingState pState)
	{
		return data.state == pState;
	}

	internal void setBuilding(WorldTile pTile, BuildingAsset pAsset, BuildingData pData)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		current_tile = pTile;
		current_tile.zone.addBuildingMain(this);
		if (pData == null)
		{
			setTemplate(pAsset);
			BuildingData buildingData = data;
			Vector2Int pos = pTile.pos;
			buildingData.mainX = ((Vector2Int)(ref pos)).x;
			BuildingData buildingData2 = data;
			pos = pTile.pos;
			buildingData2.mainY = ((Vector2Int)(ref pos)).y;
			setState(BuildingState.Normal);
			updateStats();
			setMaxHealth();
			if (asset.has_resources_grown_to_collect)
			{
				setHaveResourcesToCollect(asset.has_resources_grown_to_collect_on_spawn);
			}
		}
		else
		{
			setData(pData);
			setTemplate(pAsset);
		}
		setStatsDirty();
		current_position = Vector2Int.op_Implicit(current_tile.pos);
		current_scale.x = asset.scale_base.x;
		current_scale.y = asset.scale_base.y;
		fillTiles();
		if (!string.IsNullOrEmpty(asset.kingdom))
		{
			Kingdom kingdom = World.world.kingdoms_wild.get(asset.kingdom);
			setKingdom(kingdom);
		}
		if (!isUnderConstruction())
		{
			int num = -1;
			if (pData != null)
			{
				num = pData.frameID;
			}
			initAnimationData();
			if (num != -1)
			{
				setAnimData(num);
			}
		}
		checkMaterial();
		setPositionDirty();
		updatePosition();
		if (pAsset.storage && data.resources == null)
		{
			data.resources = new CityResources();
		}
		if (pAsset.book_slots > 0 && data.books == null)
		{
			data.books = new StorageBooks();
		}
		if (pAsset.smoke)
		{
			addComponent<BuildingSmokeEffect>();
		}
		if (pAsset.building_type == BuildingType.Building_Poops)
		{
			batch.c_poop.Add(this);
		}
		if (pAsset.spread)
		{
			switch (pAsset.flora_type)
			{
			case FloraType.Fungi:
				batch.c_spread_fungi.Add(this);
				break;
			case FloraType.Plant:
				batch.c_spread_plants.Add(this);
				break;
			case FloraType.Tree:
				batch.c_spread_trees.Add(this);
				break;
			}
		}
		if (pAsset.produce_biome_food)
		{
			component_food_producer = addComponent<BuildingBiomeFoodProducer>();
		}
		if (pAsset.spawn_drops)
		{
			addComponent<BuildingEffectSpawnDrop>();
		}
		if (pAsset.id == "monolith")
		{
			component_monolith = addComponent<BuildingMonolith>();
		}
		if (pAsset.waypoint)
		{
			component_waypoint = pAsset.kingdom switch
			{
				"alien_mold" => addComponent<BuildingWaypointAlienMold>(), 
				"computer" => addComponent<BuildingWaypointComputer>(), 
				"golden_egg" => addComponent<BuildingWaypointGoldenEgg>(), 
				"harp" => addComponent<BuildingWaypointHarp>(), 
				_ => throw new ArgumentOutOfRangeException(pAsset.kingdom + " is not a valid kingdom for a waypoint"), 
			};
		}
		if (pAsset.grow_creep)
		{
			addComponent<BuildingCreepHUB>();
		}
		if (pAsset.wheat)
		{
			component_wheat = addComponent<Wheat>();
		}
		if (pAsset.building_type == BuildingType.Building_Fruits)
		{
			component_fruit_growth = addComponent<BuildingFruitGrowth>();
		}
		if (pAsset.ice_tower)
		{
			addComponent<IceTower>();
		}
		if (pAsset.id == "poop")
		{
			addComponent<Poop>();
		}
		if (pAsset.spawn_units)
		{
			component_unit_spawner = addComponent<UnitSpawner>();
		}
		if (pAsset.spread_biome)
		{
			component_biome_spreader = addComponent<BuildingSpreadBiome>();
		}
		if (pAsset.beehive)
		{
			component_beehive = addComponent<Beehive>();
		}
		if (pAsset.docks)
		{
			component_docks = addComponent<Docks>();
		}
		if (pAsset.tower)
		{
			addComponent<BuildingTower>();
		}
		if (pData == null && !pAsset.city_building)
		{
			setAnimationState(BuildingAnimationState.Normal);
			this.setScaleTween();
		}
		if (isRuin())
		{
			makeRuins();
		}
		else if (asset.city_building && hasCity())
		{
			setKingdom(current_tile.zone_city.kingdom);
		}
		else if (asset.city_building && !hasCity() && isAbandoned())
		{
			makeAbandoned();
		}
	}

	private void debugCheckResourcesOnSpawn(BuildingAsset pAsset)
	{
	}

	public override void setStatsDirty()
	{
		base.setStatsDirty();
		if (isAlive())
		{
			batch.c_stats_dirty.Add(this);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void setPositionDirty()
	{
		positionDirty = true;
		batch.c_position_dirty.Add(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override BaseObjectData getData()
	{
		return data;
	}

	public void setData(BuildingData pData)
	{
		data = pData;
	}

	public void loadData(BuildingData pData)
	{
		setData(pData);
		pData.load();
	}

	public void loadBuilding(BuildingData pData)
	{
		if (!isUnderConstruction())
		{
			setAnimData(pData.frameID);
		}
		if (data.resources != null)
		{
			resources.loadFromSave();
		}
	}

	internal void setHaveResourcesToCollect(bool pValue)
	{
		if (pValue)
		{
			data.addFlag("has_resources");
		}
		else
		{
			data.removeFlag("has_resources");
		}
	}

	public bool hasResourcesToCollect()
	{
		if (asset.has_resources_grown_to_collect)
		{
			return data.hasFlag("has_resources");
		}
		if (chopped)
		{
			return false;
		}
		return asset.has_resources_to_collect;
	}

	internal bool canBeUpgraded()
	{
		if (isUnderConstruction())
		{
			return false;
		}
		if (asset.city_building && !isCiv())
		{
			return false;
		}
		return asset.can_be_upgraded;
	}

	internal bool upgradeBuilding()
	{
		if (!canBeUpgraded())
		{
			return false;
		}
		BuildingAsset buildingAsset = AssetManager.buildings.get(asset.upgrade_to);
		if ((buildingAsset.fundament.left != asset.fundament.left || buildingAsset.fundament.right != asset.fundament.right || buildingAsset.fundament.top != asset.fundament.top || buildingAsset.fundament.bottom != asset.fundament.bottom) && !checkTilesForUpgrade(current_tile, buildingAsset))
		{
			return false;
		}
		makeZoneDirty();
		setTemplate(buildingAsset);
		initAnimationData();
		updateStats();
		setMaxHealth();
		fillTiles();
		return true;
	}

	private void setTemplate(BuildingAsset pTemplate)
	{
		asset = pTemplate;
		data.asset_id = asset.id;
		asset.buildings.Add(this);
		if (asset.canBeOccupied())
		{
			World.world.buildings.occupied_buildings.Add(this);
		}
		asset.checkSpritesAreLoaded();
	}

	internal void setMaterial(string pMaterialID)
	{
		material = LibraryMaterials.instance.dict[pMaterialID];
	}

	internal void setKingdomCiv(Kingdom pKingdom)
	{
		if (kingdom != pKingdom || !hasKingdom())
		{
			setKingdom(pKingdom);
		}
	}

	internal void makeRuins()
	{
		setKingdom(World.world.kingdoms_wild.get("ruins"));
		setState(BuildingState.Ruins);
	}

	public void makeAbandoned()
	{
		setKingdom(WildKingdomsManager.abandoned);
		if (isUnderConstruction())
		{
			startDestroyBuilding();
		}
		else if (!asset.can_be_abandoned)
		{
			if (asset.has_ruin_state)
			{
				startMakingRuins();
			}
			else
			{
				startDestroyBuilding();
			}
		}
	}

	public void setKingdom(Kingdom pKingdom)
	{
		if (kingdom != pKingdom)
		{
			if (kingdom != pKingdom)
			{
				makeZoneDirty();
			}
			checkKingdom();
			kingdom = pKingdom;
			checkKingdom();
			if (isKingdomCiv())
			{
				setOwnershipState(BuildingOwnershipState.Civilization);
			}
			else
			{
				setOwnershipState(BuildingOwnershipState.World);
			}
			setTilesDirty();
			World.world.sim_object_zones.setBuildingsDirty(base.chunk);
		}
	}

	private void checkKingdom()
	{
		if (hasKingdom())
		{
			if (kingdom.wild)
			{
				World.world.kingdoms_wild.setDirtyBuildings();
			}
			else
			{
				World.world.kingdoms.setDirtyBuildings();
			}
		}
	}

	public bool hasHousingLogic()
	{
		if (asset.canBeOccupied())
		{
			return true;
		}
		return false;
	}

	private void setState(BuildingState pState)
	{
		if (hasHousingLogic())
		{
			World.world.buildings.event_houses = true;
		}
		if (isRemoved())
		{
			return;
		}
		if (pState == BuildingState.Ruins && !isRuin())
		{
			bool flag = false;
			if (flag)
			{
				foreach (WorldTile tile in tiles)
				{
					if (tile.Type.lava)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				setHealth(getMaxHealthPercent(0.5f));
			}
			else
			{
				setMaxHealth();
			}
			stats["health"] = getHealth();
		}
		data.state = pState;
		checkAutoRemove();
		checkMaterial();
		clearZones();
		if (!isRemoved())
		{
			fillTiles();
		}
		setTilesDirty();
		World.world.sim_object_zones.setBuildingsDirty(base.chunk);
	}

	public void checkMaterial()
	{
		if (data.state == BuildingState.Ruins)
		{
			setMaterial(BuildingRendererSettings.cur_default_material);
		}
		else if (BuildingRendererSettings.wobbly_material_enabled)
		{
			setMaterial(asset.material);
		}
		else
		{
			setMaterial(BuildingRendererSettings.cur_default_material);
		}
	}

	internal void updateKingdomColors()
	{
		setTilesDirty();
	}

	internal bool checkTilesForUpgrade(WorldTile pTile, BuildingAsset pTemplate)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		WorldTile worldTile = null;
		Vector2Int pos = pTile.pos;
		int num = ((Vector2Int)(ref pos)).x - pTemplate.fundament.left;
		pos = pTile.pos;
		int num2 = ((Vector2Int)(ref pos)).y - pTemplate.fundament.bottom;
		int num3 = pTemplate.fundament.right + pTemplate.fundament.left + 1;
		int num4 = pTemplate.fundament.top + pTemplate.fundament.bottom + 1;
		for (int i = 0; i < num3; i++)
		{
			for (int j = 0; j < num4; j++)
			{
				worldTile = World.world.GetTile(num + i, num2 + j);
				if (worldTile == null)
				{
					return false;
				}
				if (!worldTile.Type.can_build_on)
				{
					return false;
				}
				if (worldTile.zone.city != city)
				{
					return false;
				}
				Building building = worldTile.building;
				if (building != null && building != this)
				{
					if (building.asset.priority >= asset.priority)
					{
						return false;
					}
					if (building.asset.upgrade_level >= asset.upgrade_level)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	internal void debugConstructions()
	{
		if (!((Object)(object)asset.building_sprites.construction == (Object)null))
		{
			setUnderConstruction();
		}
	}

	private void initAnimationData()
	{
		asset.checkSpritesAreLoaded();
		int num = Randy.randomInt(0, asset.building_sprites.animation_data.Count);
		setAnimData(num);
		if (asset.random_flip && !asset.shadow)
		{
			flip_x = Randy.randomBool();
		}
		this.setScaleTween();
	}

	private void fillTiles()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (tiles.Count != 0)
		{
			clearTiles();
		}
		Vector2Int pos = current_tile.pos;
		int num = ((Vector2Int)(ref pos)).x - asset.fundament.left;
		pos = current_tile.pos;
		int num2 = ((Vector2Int)(ref pos)).y - asset.fundament.bottom;
		int num3 = asset.fundament.right + asset.fundament.left + 1;
		int num4 = asset.fundament.top + asset.fundament.bottom + 1;
		int num5 = 0;
		for (int i = 0; i < num3; i++)
		{
			for (int j = num5; j < num4; j++)
			{
				WorldTile tile = World.world.GetTile(num + i, num2 + j);
				if (tile != null)
				{
					setBuildingTile(tile, i, j);
				}
			}
		}
		setTilesDirty();
	}

	internal void checkDirtyTiles()
	{
		if (tiles_dirty)
		{
			tiles_dirty = false;
			for (int i = 0; i < tiles.Count; i++)
			{
				WorldTile tileDirty = tiles[i];
				World.world.setTileDirty(tileDirty);
			}
			batch?.c_tiles_dirty.Remove(this);
		}
	}

	private void setTilesDirty()
	{
		tiles_dirty = true;
		batch?.c_tiles_dirty.Add(this);
	}

	private void forceUpdateTilesDirty()
	{
		setTilesDirty();
		checkDirtyTiles();
	}

	private void setBuildingTile(WorldTile pTile, int pX, int pY)
	{
		if (pTile.hasBuilding() && pTile.building != this)
		{
			pTile.building.startDestroyBuilding();
		}
		pTile.building = this;
		pTile.minimap_building_x = pX;
		pTile.minimap_building_y = pY;
		if (!tiles.Contains(pTile))
		{
			tiles.Add(pTile);
			if (!zones.Contains(pTile.zone))
			{
				zones.Add(pTile.zone);
			}
		}
		TileType tileType = null;
		TopTileType topTileType = null;
		if (asset.transform_tiles_to_tile_type != null)
		{
			tileType = AssetManager.tiles.get(asset.transform_tiles_to_tile_type);
		}
		if (asset.transform_tiles_to_top_tiles != null)
		{
			topTileType = AssetManager.top_tiles.get(asset.transform_tiles_to_top_tiles);
		}
		if (tileType != null || topTileType != null)
		{
			if (tileType == null)
			{
				tileType = pTile.main_type;
			}
			if (tileType.can_be_biome)
			{
				MapAction.terraformTile(pTile, tileType, topTileType, TerraformLibrary.nothing);
			}
		}
	}

	public void setOwnershipState(BuildingOwnershipState pState)
	{
		if (state_ownership != pState)
		{
			makeZoneDirty();
		}
		state_ownership = pState;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isRuin()
	{
		return data.state == BuildingState.Ruins;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool isRemoved()
	{
		return data.state == BuildingState.Removed;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isNormal()
	{
		return data.state == BuildingState.Normal;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isAbandoned()
	{
		if (state_ownership == BuildingOwnershipState.World)
		{
			return asset.city_building;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isCiv()
	{
		return state_ownership == BuildingOwnershipState.Civilization;
	}

	public void prepareForSave()
	{
		if (hasCity())
		{
			data.cityID = city.data.id;
		}
		else
		{
			data.cityID = -1L;
		}
		resources?.save();
		data.frameID = animData_index;
		data.save();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isUsable()
	{
		if (!isAlive())
		{
			return false;
		}
		if (isRuin())
		{
			return false;
		}
		if (isOnRemove())
		{
			return false;
		}
		if (isRemoved())
		{
			return false;
		}
		return true;
	}

	internal void startDestroyBuilding()
	{
		if (!isOnRemove())
		{
			if (asset.has_ruins_graphics && !isUnderConstruction())
			{
				setState(BuildingState.Ruins);
			}
			startRemove();
		}
	}

	private void clearZones()
	{
		zones.Clear();
	}

	internal void kill()
	{
		if (!isAlive())
		{
			return;
		}
		clearZones();
		setAlive(pValue: false);
		if (asset.city_building)
		{
			World.world.map_stats.housesDestroyed++;
		}
		if (!hasBooks())
		{
			return;
		}
		foreach (long list_book in data.books.list_books)
		{
			Book pBook = World.world.books.get(list_book);
			World.world.books.burnBook(pBook);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override City getCity()
	{
		return city;
	}

	internal override void updateStats()
	{
		base.updateStats();
		stats.clear();
		stats.mergeStats(asset.base_stats);
		if (getHealth() > getMaxHealth())
		{
			setMaxHealth();
		}
		batch.c_stats_dirty.Remove(this);
	}

	internal void chopTree()
	{
		if (!chopped && ((!asset.become_alive_when_chopped && !WorldLawLibrary.world_law_bark_bites_back.isEnabled()) || !Randy.randomChance(0.2f) || !ActionLibrary.tryToMakeFloraAlive(this)))
		{
			finishAllStatusEffects();
			MusicBox.playSound("event:/SFX/NATURE/TreeFall", current_tile, pGameViewOnly: true, pVisibleOnly: true);
			chopped = true;
			setHaveResourcesToCollect(pValue: false);
			float pTargetAngle = (Randy.randomBool() ? 90 : (-90));
			scale_helper.doRotateTween(pTargetAngle, 1f, finishChop);
			batch.c_angle.Add(this);
		}
	}

	private void finishChop()
	{
		startRemove();
	}

	private void startRemove()
	{
		if (!isOnRemove())
		{
			if (!isUnderConstruction() && asset.has_sound_destroyed)
			{
				MusicBox.playSound(asset.sound_destroyed, current_tile, pGameViewOnly: true, pVisibleOnly: true);
			}
			setAnimationState(BuildingAnimationState.OnRemove);
			clearTiles();
			clearComponents();
			setHaveResourcesToCollect(pValue: false);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isAnimationState(BuildingAnimationState pState)
	{
		return animation_state == pState;
	}

	internal void startMakingRuins()
	{
		if (!asset.has_ruin_state)
		{
			startRemove();
		}
		else if (!isAnimationState(BuildingAnimationState.OnRuin) && data.state != BuildingState.Ruins)
		{
			setAnimationState(BuildingAnimationState.OnRuin);
			makeRuins();
		}
	}

	internal void removeBuildingFinal()
	{
		setState(BuildingState.Removed);
		clearZones();
		clearTiles();
		kill();
		current_tile.zone.removeBuildingMain(this);
		World.world.buildings.scheduleDestroyOnPlay(this);
	}

	internal void clearTiles()
	{
		forceUpdateTilesDirty();
		for (int i = 0; i < tiles.Count; i++)
		{
			tiles[i].building = null;
		}
		tiles.Clear();
	}

	private void clearComponents()
	{
		if (asset.flora_type == FloraType.Tree)
		{
			batch.c_spread_trees.Remove(this);
		}
		if (asset.flora_type == FloraType.Fungi)
		{
			batch.c_spread_fungi.Remove(this);
		}
		if (asset.flora_type == FloraType.Plant)
		{
			batch.c_spread_plants.Remove(this);
		}
		if (asset.building_type == BuildingType.Building_Poops)
		{
			batch.c_poop.Remove(this);
		}
		if (components_list != null)
		{
			batch.c_components.Remove(this);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isOnRemove()
	{
		return animation_state == BuildingAnimationState.OnRemove;
	}

	internal void setAnimationState(BuildingAnimationState pState)
	{
		if (!isOnRemove())
		{
			animation_state = pState;
			this.checkTweens();
		}
	}

	internal void completeMakingRuin()
	{
		setState(BuildingState.Ruins);
		setAnimationState(BuildingAnimationState.Normal);
		this.setScaleTween();
	}

	private void checkAutoRemove()
	{
		if (batch != null)
		{
			if (asset.auto_remove_ruin && isRuin() && !isCiv())
			{
				batch.c_auto_remove.Add(this);
			}
			else
			{
				batch.c_auto_remove.Remove(this);
			}
		}
	}

	internal void updateAutoRemove(float pElapsed)
	{
		if (_auto_remove_timer < 300f)
		{
			_auto_remove_timer += pElapsed;
			return;
		}
		_auto_remove_timer = 0f;
		batch.c_auto_remove.Remove(this);
		startDestroyBuilding();
	}

	internal void updateTimerShakeResources(float pElapsed)
	{
		if (_timer_shake_resource > 0f)
		{
			_timer_shake_resource -= pElapsed;
			if (_timer_shake_resource <= 0f)
			{
				batch.c_resource_shaker.Remove(this);
			}
		}
	}

	internal void updateComponents(float pElapsed)
	{
		for (int i = 0; i < components_list.Count; i++)
		{
			components_list[i].update(pElapsed);
		}
	}

	public void updatePosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (positionDirty)
		{
			positionDirty = false;
			batch.c_position_dirty.Remove(this);
			cur_transform_position = current_tile.posV3;
			if (cur_transform_position.z < 0f)
			{
				cur_transform_position.z = 0f;
			}
			cur_transform_position.x += _shake_offset.x;
			cur_transform_position.y += _shake_offset.y;
			cur_transform_position.z = -0.2f + asset.bonus_z;
		}
	}

	internal void spawnBurstSpecial(int pAmount = 1)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		MapBox world = World.world;
		Vector2Int pos = current_tile.pos;
		int x = ((Vector2Int)(ref pos)).x;
		pos = current_tile.pos;
		WorldTile tile = world.GetTile(x, ((Vector2Int)(ref pos)).y);
		if (tile == null)
		{
			tile = current_tile;
		}
		for (int i = 0; i < pAmount; i++)
		{
			World.world.drop_manager.spawnParabolicDrop(tile, asset.spawn_drop_id, asset.spawn_drop_start_height, asset.spawn_drop_min_height, asset.spawn_drop_max_height, asset.spawn_drop_min_radius, asset.spawn_drop_max_radius);
		}
	}

	internal bool updateBuild(int pProgress = 1)
	{
		data.change("construction_progress", pProgress);
		startShake(0.3f);
		bool result = false;
		if (getConstructionProgress() > asset.construction_progress_needed)
		{
			result = true;
			completeConstruction();
			if (asset.has_sound_built)
			{
				MusicBox.playSound(asset.sound_built, current_tile, pGameViewOnly: true, pVisibleOnly: true);
			}
			initAnimationData();
			this.setScaleTween(0.25f);
		}
		else
		{
			this.setScaleTween(0.75f);
		}
		return result;
	}

	private void makeZoneDirty()
	{
		current_tile.zone.setDirty(pValue: true);
		if (hasHousingLogic())
		{
			World.world.buildings.event_houses = true;
		}
	}

	public bool hasResidentSlots()
	{
		if (!asset.hasHousingSlots())
		{
			return false;
		}
		if (asset.housing_slots > countResidents())
		{
			return true;
		}
		return false;
	}

	public int countResidents()
	{
		return residents.Count;
	}

	public bool hasResidents()
	{
		return countResidents() > 0;
	}

	public void startShake(float pDuration, float pIntensityX = 0.1f, float pIntensityY = 0.1f)
	{
		_shake_timer = pDuration;
		_shake_intensity_x = pIntensityX;
		_shake_intensity_y = pIntensityY;
		batch?.c_shake.Add(this);
	}

	internal void resourceGathering(float pElapsed)
	{
		if (!(_timer_shake_resource > 0f))
		{
			batch.c_resource_shaker.Add(this);
			startShake(0.3f);
			_timer_shake_resource = 1f;
		}
	}

	public void updateShake(float pElapsed)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (_shake_timer > 0f)
		{
			_shake_timer -= pElapsed;
			if (_shake_timer < 0f)
			{
				_shake_offset = Vector2.zero;
				batch.c_shake.Remove(this);
			}
			else
			{
				_shake_offset.x = ((Random)(ref batch.rnd)).NextFloat(0f - _shake_intensity_x, _shake_intensity_x);
				_shake_offset.y = ((Random)(ref batch.rnd)).NextFloat(0f - _shake_intensity_y, _shake_intensity_y);
			}
			setPositionDirty();
		}
	}

	internal override void getHitFullHealth(AttackType pAttackType)
	{
		getHit(getHealth(), pFlash: false, pAttackType, null, pSkipIfShake: false, pMetallicWeapon: false, pCheckDamageReduction: false);
	}

	internal override void getHit(float pDamage, bool pFlash = true, AttackType pAttackType = AttackType.Other, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
	{
		if (!isAnimationState(BuildingAnimationState.Normal))
		{
			return;
		}
		changeHealth((int)(0f - pDamage));
		if (pAttackType == AttackType.Weapon && asset.has_sound_hit)
		{
			MusicBox.playSound(asset.sound_hit, current_tile, pGameViewOnly: true, pVisibleOnly: true);
		}
		startShake(0.3f);
		if (!hasHealth())
		{
			if (data.state == BuildingState.Ruins)
			{
				startDestroyBuilding();
			}
			else
			{
				startMakingRuins();
			}
		}
		else
		{
			this.setScaleTween(0.75f);
		}
	}

	internal void extractResources(Actor pBy)
	{
		this.setScaleTween(0.75f);
		switch (asset.building_type)
		{
		case BuildingType.Building_Wheat:
		case BuildingType.Building_Plant:
			startDestroyBuilding();
			break;
		case BuildingType.Building_Tree:
			chopTree();
			break;
		case BuildingType.Building_Poops:
		case BuildingType.Building_Mineral:
			startRemove();
			break;
		case BuildingType.Building_Fruits:
			component_fruit_growth.reset();
			setHaveResourcesToCollect(pValue: false);
			if (Randy.randomChance(0.2f))
			{
				startDestroyBuilding();
			}
			break;
		case BuildingType.Building_Hives:
			component_beehive.honey = 0;
			setHaveResourcesToCollect(pValue: false);
			break;
		}
	}

	internal Color32 getColorForMinimap(WorldTile pTile)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (Config.EVERYTHING_MAGIC_COLOR)
		{
			return Toolbox.EVERYTHING_MAGIC_COLOR32;
		}
		return asset.building_sprites.map_icon.getColor(pTile.minimap_building_x, pTile.minimap_building_y, this);
	}

	public WorldTile getConstructionTile()
	{
		if (asset.docks)
		{
			var (array, pLength) = Toolbox.getAllZonesFromTile(current_tile);
			foreach (TileZone item in array.LoopRandom(pLength))
			{
				using IEnumerator<WorldTile> enumerator2 = checkZoneForDockConstruction(item).GetEnumerator();
				if (enumerator2.MoveNext())
				{
					return enumerator2.Current;
				}
			}
		}
		return Randy.getRandom(tiles);
	}

	public int getConstructionProgress()
	{
		data.get("construction_progress", out var pResult, 0);
		return pResult;
	}

	public void completeConstruction()
	{
		data.removeInt("construction_progress");
		data.removeFlag("under_construction");
		makeZoneDirty();
	}

	public bool isUnderConstruction()
	{
		if (!asset.has_sprite_construction)
		{
			return false;
		}
		return data.hasFlag("under_construction");
	}

	public void setUnderConstruction()
	{
		if (asset.has_sprite_construction)
		{
			data.addFlag("under_construction");
		}
	}

	public bool canRemoveForFarms()
	{
		return asset.flora;
	}

	internal IEnumerable<WorldTile> checkZoneForDockConstruction(TileZone pZone)
	{
		if (pZone.city == null || pZone.city != city)
		{
			yield break;
		}
		foreach (WorldTile item in pZone.tiles.LoopRandom())
		{
			if (item.Type.ground && Toolbox.SquaredDistTile(current_tile, item) <= 49)
			{
				yield return item;
			}
		}
	}

	internal void checkStartSpawnAnimation()
	{
		Sprite[] spawn = animData.spawn;
		if (spawn != null && spawn.Length != 0)
		{
			check_spawn_animation = true;
		}
	}

	public Sprite calculateMainSprite()
	{
		bool flag = true;
		Sprite[] array = null;
		bool flag2 = isRuin();
		if (flag2)
		{
			flag = false;
		}
		if (isUnderConstruction())
		{
			last_main_sprite = asset.building_sprites.construction;
			return last_main_sprite;
		}
		if (asset.has_special_animation_state)
		{
			array = ((!hasResourcesToCollect()) ? animData.special : animData.main);
		}
		else if (flag2 && asset.has_ruins_graphics)
		{
			flag = false;
			array = animData.ruins;
		}
		else if (asset.spawn_drops && data.hasFlag("stop_spawn_drops"))
		{
			array = animData.main_disabled;
		}
		else if (asset.can_be_abandoned && isAbandoned())
		{
			Sprite[] main_disabled = animData.main_disabled;
			array = ((main_disabled == null || main_disabled.Length == 0) ? animData.main : animData.main_disabled);
			flag = false;
		}
		else
		{
			array = animData.main;
			if (asset.get_override_sprites_main != null)
			{
				Sprite[] array2 = asset.get_override_sprites_main(this);
				if (array2 != null)
				{
					array = array2;
				}
			}
		}
		Sprite val = null;
		if (check_spawn_animation)
		{
			return getSpawnFrameSprite();
		}
		if (!flag || array.Length == 1)
		{
			return array[0];
		}
		return AnimationHelper.getSpriteFromList(GetHashCode(), array, asset.animation_speed);
	}

	public bool isColoredSpriteNeedsCheck(Sprite pMainSprite)
	{
		if (last_main_sprite == null || ((object)last_main_sprite).GetHashCode() != ((object)pMainSprite).GetHashCode() || _last_color_asset != kingdom.getColor())
		{
			return true;
		}
		return false;
	}

	public Sprite calculateColoredSprite(Sprite pMainSprite)
	{
		if (isColoredSpriteNeedsCheck(pMainSprite))
		{
			_last_colored_sprite = DynamicSprites.getRecoloredBuilding(pMainSprite, kingdom.getColor(), asset.atlas_asset);
			last_main_sprite = pMainSprite;
			_last_color_asset = kingdom.getColor();
		}
		return _last_colored_sprite;
	}

	public Sprite getLastColoredSprite()
	{
		return _last_colored_sprite;
	}

	public void clearSprites()
	{
		last_main_sprite = null;
		_last_colored_sprite = null;
		_last_color_asset = null;
	}

	public Sprite checkSpriteToRender()
	{
		Sprite pMainSprite = calculateMainSprite();
		return calculateColoredSprite(pMainSprite);
	}

	public Vector3 getCurrentScale()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float tweenBuildingsValue = World.world.quality_changer.getTweenBuildingsValue();
		float num = current_scale.y * tweenBuildingsValue;
		float num2 = current_scale.x * tweenBuildingsValue;
		if (_last_scale.y != num || _last_scale.x != num2)
		{
			((Vector3)(ref _last_scale)).Set(num2, num, 1f);
		}
		return _last_scale;
	}

	public bool isFullyGrown()
	{
		if (!asset.can_be_grown)
		{
			return true;
		}
		if (asset.wheat)
		{
			return component_wheat.isMaxLevel();
		}
		return false;
	}

	private Sprite getSpawnFrameSprite()
	{
		Sprite[] spawn = animData.spawn;
		float worldTimeElapsedSince = World.world.getWorldTimeElapsedSince(data.created_time);
		float num = (float)spawn.Length * asset.animation_speed / 60f;
		Sprite result;
		if (num > worldTimeElapsedSince)
		{
			int num2 = (int)(worldTimeElapsedSince / num * (float)spawn.Length);
			result = spawn[num2];
		}
		else
		{
			result = spawn.Last();
			check_spawn_animation = false;
		}
		return result;
	}

	public int takeResource(string pResourceID, int pAmount)
	{
		return resources.change(pResourceID, -pAmount);
	}

	public int getResourcesAmount(string pResourceID)
	{
		return resources.get(pResourceID);
	}

	public int addResources(string pResourceID, int pAmount)
	{
		return resources.change(pResourceID, pAmount);
	}

	public bool hasSpaceForResource(ResourceAsset pResourceAsset)
	{
		return resources.hasSpaceForResource(pResourceAsset);
	}

	public bool hasResourcesForNewItems()
	{
		return resources.hasResourcesForNewItems();
	}

	public int countFood()
	{
		return resources.countFood();
	}

	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies, string pFavoriteFood = null)
	{
		return resources.getRandomSuitableFood(pSubspecies, pFavoriteFood);
	}

	public override void Dispose()
	{
		kingdom = null;
		_last_colored_sprite = null;
		_last_color_asset = null;
		last_main_sprite = null;
		batch = null;
		data = null;
		asset = null;
		tiles.Clear();
		animData = null;
		zones.Clear();
		if (components_list != null)
		{
			for (int i = 0; i < components_list.Count; i++)
			{
				BaseBuildingComponent baseBuildingComponent = components_list[i];
				baseBuildingComponent.Dispose();
				World.world.buildings.component_pool.release(baseBuildingComponent);
			}
			components_list.Clear();
			components_list.Dispose();
			components_list = null;
		}
		component_docks = null;
		component_wheat = null;
		component_fruit_growth = null;
		component_unit_spawner = null;
		component_biome_spreader = null;
		component_monolith = null;
		component_waypoint = null;
		component_food_producer = null;
		component_beehive = null;
		scale_helper.reset();
		base.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Building pObject)
	{
		return GetHashCode() == pObject.GetHashCode();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int CompareTo(Building pTarget)
	{
		return GetHashCode().CompareTo(pTarget.GetHashCode());
	}

	public void checkVegetationSpread(float pElapsed)
	{
		BuildingAsset buildingAsset = asset;
		if (Randy.randomChance(buildingAsset.spread_chance))
		{
			WorldTile random = current_tile.neighboursAll.GetRandom();
			for (int i = 0; (float)i < buildingAsset.spread_steps; i++)
			{
				random = random.neighboursAll.GetRandom();
			}
			string random2 = buildingAsset.spread_ids.GetRandom();
			BuildingAsset pAsset = AssetManager.buildings.get(random2);
			tryToGrowOnTile(random, pAsset);
		}
	}

	private bool tryToGrowOnTile(WorldTile pTile, BuildingAsset pAsset, bool pCheckLimit = true)
	{
		if (pCheckLimit && pTile.zone.hasReachedBuildingLimit(pTile, pAsset))
		{
			return false;
		}
		if (!World.world.buildings.canBuildFrom(pTile, pAsset, null, BuildPlacingType.New, pFloraGrowth: true))
		{
			return false;
		}
		World.world.buildings.addBuilding(pAsset, pTile);
		if (pAsset.flora_type == FloraType.Tree)
		{
			World.world.game_stats.data.treesGrown++;
		}
		else if (pAsset.flora_type == FloraType.Plant || pAsset.flora_type == FloraType.Fungi)
		{
			World.world.game_stats.data.floraGrown++;
		}
		return true;
	}
}
// --- End of File: Building.cs ---



// --- Start of File: BuildingActions.cs ---
public static class BuildingActions
{
	public static void tryGrowVegetationRandom(WorldTile pTile, VegetationType pType, bool pOnStart = false, bool pCheckLimit = true, bool pCheckRandom = true)
	{
		BiomeAsset biome_asset = pTile.Type.biome_asset;
		if (biome_asset == null || !biome_asset.grow_vegetation_auto)
		{
			return;
		}
		BuildingAsset buildingAsset = null;
		switch (pType)
		{
		case VegetationType.Plants:
			if (biome_asset.grow_type_selector_plants != null)
			{
				buildingAsset = biome_asset.grow_type_selector_plants(pTile);
			}
			break;
		case VegetationType.Trees:
			if (biome_asset.grow_type_selector_trees != null)
			{
				buildingAsset = biome_asset.grow_type_selector_trees(pTile);
			}
			break;
		case VegetationType.Bushes:
			if (biome_asset.grow_type_selector_bushes != null)
			{
				buildingAsset = biome_asset.grow_type_selector_bushes(pTile);
			}
			break;
		}
		if (buildingAsset == null)
		{
			return;
		}
		if (buildingAsset.limit_in_radius > 0)
		{
			pCheckLimit = true;
		}
		if ((!pCheckLimit || !pTile.zone.hasReachedBuildingLimit(pTile, buildingAsset)) && (!pCheckRandom || !(buildingAsset.vegetation_random_chance < Randy.random())) && World.world.buildings.canBuildFrom(pTile, buildingAsset, null))
		{
			World.world.buildings.addBuilding(buildingAsset, pTile);
			if (buildingAsset.flora_type == FloraType.Tree)
			{
				World.world.game_stats.data.treesGrown++;
			}
			else if (buildingAsset.flora_type == FloraType.Plant || buildingAsset.flora_type == FloraType.Fungi)
			{
				World.world.game_stats.data.floraGrown++;
			}
			if (buildingAsset.has_sound_spawn)
			{
				MusicBox.playSound(buildingAsset.sound_spawn, pTile, pGameViewOnly: true, pVisibleOnly: true);
			}
		}
	}

	public static void tryGrowMineralRandom(WorldTile pTile, bool pOnStart = false, bool pCheckLimit = true)
	{
		BiomeAsset biome = pTile.getBiome();
		if (biome != null && biome.grow_minerals_auto && (!pTile.hasBuilding() || !pTile.building.isUsable()))
		{
			BuildingAsset buildingAsset = biome.grow_type_selector_minerals(pTile);
			if (buildingAsset != null && (!pCheckLimit || !pTile.zone.hasReachedBuildingLimit(pTile, buildingAsset)) && World.world.buildings.canBuildFrom(pTile, buildingAsset, null))
			{
				World.world.buildings.addBuilding(buildingAsset, pTile);
			}
		}
	}

	public static Building tryGrowVegetation(WorldTile pTile, string pTemplateID, bool pSfx = false, bool pCheckLimit = true)
	{
		BuildingAsset buildingAsset = AssetManager.buildings.get(pTemplateID);
		if (pTile.hasBuilding() && pTile.building.isUsable())
		{
			return null;
		}
		if (buildingAsset == null)
		{
			return null;
		}
		if (pCheckLimit && pTile.zone.hasReachedBuildingLimit(pTile, buildingAsset))
		{
			return null;
		}
		if (!World.world.buildings.canBuildFrom(pTile, buildingAsset, null))
		{
			return null;
		}
		Building result = World.world.buildings.addBuilding(buildingAsset, pTile, pCheckForBuild: false, pSfx);
		World.world.game_stats.data.floraGrown++;
		return result;
	}

	public static void spawnBeehives(int pAmount)
	{
		for (int i = 0; i < pAmount; i++)
		{
			WorldTile random = World.world.tiles_list.GetRandom();
			if (random.Type.grass)
			{
				World.world.buildings.addBuilding("beehive", random, pCheckForBuild: true);
			}
		}
	}

	public static void spawnResource(int pAmount, string pType, bool pRandomSize = true)
	{
		for (int i = 0; i < pAmount; i++)
		{
			WorldTile random = World.world.tiles_list.GetRandom();
			if (random.Type.ground)
			{
				World.world.buildings.addBuilding(pType, random, pCheckForBuild: true);
			}
		}
	}
}
// --- End of File: BuildingActions.cs ---



// --- Start of File: BuildingAnimationData.cs ---
using UnityEngine;

public class BuildingAnimationData
{
	public bool animated;

	public ListPool<Sprite> list_spawn;

	public ListPool<Sprite> list_main;

	public ListPool<Sprite> list_main_disabled;

	public ListPool<Sprite> list_ruins;

	public ListPool<Sprite> list_special;

	public Sprite[] main;

	public Sprite[] main_disabled;

	public Sprite[] spawn;

	public Sprite[] ruins;

	public Sprite[] special;
}
// --- End of File: BuildingAnimationData.cs ---



// --- Start of File: BuildingAnimationState.cs ---
using System;

[Serializable]
public enum BuildingAnimationState
{
	Normal,
	OnRuin,
	OnRemove
}
// --- End of File: BuildingAnimationState.cs ---



// --- Start of File: BuildingAsset.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine;

[Serializable]
public class BuildingAsset : Asset
{
	[NonSerialized]
	public bool sprites_are_initiated;

	public Vector3 scale_base = new Vector3(0.25f, 0.25f, 0.25f);

	[DefaultValue("")]
	public string kingdom = string.Empty;

	[DefaultValue("")]
	public string civ_kingdom = string.Empty;

	public BuildingFundament fundament;

	[DefaultValue("building")]
	public string material = "building";

	[DefaultValue("buildings")]
	public string atlas_id = "buildings";

	[DefaultValue("buildings")]
	public string atlas_id_fallback_when_not_wobbly = "buildings";

	[NonSerialized]
	public DynamicSpritesAsset atlas_asset;

	public bool prevent_freeze;

	public float bonus_z;

	public bool removed_by_sponge;

	[DefaultValue("")]
	public string sprite_path = string.Empty;

	[DefaultValue("buildings/")]
	public string main_path = "buildings/";

	public bool grow_creep;

	[DefaultValue(CreepWorkerMovementType.RandomNeighbourAll)]
	public CreepWorkerMovementType grow_creep_movement_type;

	[DefaultValue("")]
	public string grow_creep_type = string.Empty;

	public bool draw_light_area;

	public float draw_light_area_offset_x;

	public float draw_light_area_offset_y;

	[DefaultValue(0.5f)]
	public float draw_light_size = 0.5f;

	public int grow_creep_steps_max;

	public float grow_creep_step_interval;

	[DefaultValue(1)]
	public int grow_creep_workers = 1;

	public bool grow_creep_direction_random_position;

	public bool grow_creep_random_new_direction;

	public bool grow_creep_flash;

	public int construction_progress_needed;

	public bool grow_creep_redraw_tile;

	[DefaultValue(7)]
	public int grow_creep_steps_before_new_direction = 7;

	[DefaultValue(true)]
	public bool has_ruins_graphics = true;

	public bool has_special_animation_state;

	[DefaultValue(6f)]
	public float animation_speed = 6f;

	[DefaultValue(BuildingType.Building_None)]
	public BuildingType building_type;

	public bool sparkle_effect;

	public List<ResourceContainer> resources_given;

	public bool can_be_grown;

	[DefaultValue(0.5f)]
	public float vegetation_random_chance = 0.5f;

	public bool has_kingdom_color;

	public bool city_building;

	public bool can_be_abandoned;

	public bool mini_civ_auto_load;

	public bool destroy_on_liquid;

	public bool can_be_upgraded;

	[DefaultValue("")]
	public string upgrade_to = string.Empty;

	[DefaultValue("")]
	public string upgraded_from = string.Empty;

	public int upgrade_level;

	[DefaultValue("")]
	public string type = string.Empty;

	public bool gatherable;

	public bool wheat;

	public bool produce_biome_food;

	public float growth_time;

	public int loot_generation;

	public string[] boat_types;

	public string boat_type_fishing;

	public string boat_type_trading;

	public string boat_type_transport;

	public bool waypoint;

	public int priority;

	public BuildingStepAction step_action;

	[NonSerialized]
	public bool has_step_action;

	[DefaultValue(true)]
	public bool shadow = true;

	public Vector2 shadow_bound = new Vector2(0.5f, 0.8f);

	[DefaultValue(0.2f)]
	public float shadow_distortion = 0.2f;

	public bool auto_remove_ruin;

	public bool ice_tower;

	public bool spawn_units;

	public bool beehive;

	[DefaultValue("-")]
	public string spawn_units_asset = "-";

	public bool tower;

	[DefaultValue("")]
	public string tower_projectile = string.Empty;

	public float tower_projectile_offset;

	[DefaultValue(false)]
	public bool tower_attack_buildings;

	[DefaultValue(3f)]
	public float tower_projectile_reload = 3f;

	[DefaultValue(1)]
	public int tower_projectile_amount = 1;

	public bool ignore_other_buildings_for_upgrade;

	public bool random_flip;

	public ConstructionCost cost;

	public BaseStats base_stats;

	public bool ignored_by_cities;

	public bool remove_buildings_when_dropped;

	public bool remove_civ_buildings;

	public bool ignore_same_building_id;

	public bool build_road_to;

	public bool can_be_damaged_by_tornado;

	public bool can_be_placed_on_liquid;

	public bool can_be_placed_on_blocks;

	public bool damaged_by_rain;

	public bool only_build_tiles;

	public bool build_place_borders;

	public bool build_place_single;

	public bool build_place_center;

	public bool needs_farms_ground;

	public bool build_place_batch;

	public bool build_prefer_replace_house;

	public bool check_for_close_building;

	public bool ignore_buildings;

	public bool can_be_demolished;

	public bool burnable;

	public bool affected_by_lava;

	public bool affected_by_acid;

	public bool can_units_live_here;

	public int housing_slots;

	public int housing_happiness;

	public int max_houses;

	public bool storage;

	public bool storage_only_food;

	[DefaultValue(true)]
	public bool can_be_living_house = true;

	[DefaultValue(true)]
	public bool can_be_living_plant = true;

	[DefaultValue(true)]
	public bool remove_ruins = true;

	[DefaultValue(true)]
	public bool has_ruin_state = true;

	public bool has_resources_to_collect;

	public bool has_resources_grown_to_collect;

	public bool has_resources_grown_to_collect_on_spawn;

	public bool can_be_chopped_down;

	public int book_slots;

	public BuildingOverrideMainSprites get_override_sprites_main;

	public BuildingOverrideMainSprite get_override_sprite_main;

	public bool is_vegetation;

	public bool is_stockpile;

	public Vector2 stockpile_top_left_offset;

	public Vector2 stockpile_center_offset;

	public int limit_per_zone;

	public bool become_alive_when_chopped;

	public int limit_in_radius;

	public int limit_global;

	public bool docks;

	[NonSerialized]
	public bool has_biome_tags;

	public HashSet<BiomeTag> biome_tags_growth;

	[NonSerialized]
	public bool has_biome_tags_spread;

	public HashSet<BiomeTag> biome_tags_spread;

	public bool spread_biome;

	public string spread_biome_id;

	[DefaultValue("")]
	public string group = string.Empty;

	public bool affected_by_drought;

	public bool affected_by_cold_temperature;

	public bool smoke;

	[DefaultValue(0.5f)]
	public float smoke_interval = 0.5f;

	public Vector2Int smoke_offset;

	public bool spawn_drops;

	[DefaultValue("")]
	public string spawn_drop_id = "";

	public float spawn_drop_interval;

	public float spawn_drop_start_height;

	public float spawn_drop_min_height;

	public float spawn_drop_max_height;

	public float spawn_drop_min_radius;

	public float spawn_drop_max_radius;

	public string transform_tiles_to_tile_type;

	public string transform_tiles_to_top_tiles;

	public string sound_spawn;

	public string sound_idle;

	public string sound_hit;

	public string sound_built;

	public string sound_destroyed;

	public int nutrition_restore;

	public bool spawn_rats;

	public bool flora;

	public FloraSize flora_size;

	public bool spread;

	public float spread_chance;

	public float spread_steps;

	public FloraType flora_type;

	public string[] spread_ids;

	public bool has_sprites_spawn;

	public bool has_sprites_main;

	public bool has_sprites_main_disabled;

	public bool has_sprites_ruin;

	public bool has_sprites_special;

	public bool has_sprite_construction;

	public bool check_for_adaptation_tags;

	public GetColorForMapIcon get_map_icon_color;

	public bool has_get_map_icon_color;

	[NonSerialized]
	public BuildingSprites building_sprites;

	[NonSerialized]
	public HashSet<Building> buildings = new HashSet<Building>();

	[JsonIgnore]
	public bool has_sound_spawn => sound_spawn != null;

	[JsonIgnore]
	public bool has_sound_idle => sound_idle != null;

	[JsonIgnore]
	public bool has_sound_hit => sound_hit != null;

	[JsonIgnore]
	public bool has_sound_built => sound_built != null;

	[JsonIgnore]
	public bool has_sound_destroyed => sound_destroyed != null;

	public bool setSpread(FloraType pType, int pSpreadSteps = 1, float pSpreadChance = 1f)
	{
		if (pType == FloraType.None)
		{
			spread = false;
			return false;
		}
		spread = true;
		flora_type = pType;
		spread_steps = pSpreadSteps;
		spread_chance = pSpreadChance;
		return true;
	}

	public void setAtlasID(string pAtlasID, string pFallbackID = null)
	{
		if (pFallbackID == null)
		{
			pFallbackID = pAtlasID;
		}
		atlas_id = pAtlasID;
		atlas_id_fallback_when_not_wobbly = pFallbackID;
	}

	public void setShadow(float pBoundX, float pBoundY, float pDistortion)
	{
		shadow = true;
		shadow_bound.x = pBoundX;
		shadow_bound.y = pBoundY;
		shadow_distortion = pDistortion;
	}

	public bool isOverlaysBiomeTags(TileTypeBase pTileType)
	{
		if (!has_biome_tags)
		{
			return true;
		}
		return pTileType.overlapsBiomeTags(biome_tags_growth);
	}

	public bool isOverlaysBiomeSpreadTags(TileTypeBase pTileType)
	{
		if (!has_biome_tags_spread)
		{
			return false;
		}
		return pTileType.overlapsBiomeTags(biome_tags_spread);
	}

	public void checkLimits(Building pBuildingToIgnore = null)
	{
		if (limit_global == 0 || buildings.Count < limit_global)
		{
			return;
		}
		int num = buildings.Count - limit_global;
		foreach (Building building in buildings)
		{
			if (num == 0)
			{
				break;
			}
			if ((pBuildingToIgnore == null || pBuildingToIgnore != building) && building.isAlive())
			{
				building.startDestroyBuilding();
				num--;
			}
		}
	}

	public bool canBeOccupied()
	{
		if (!hasHousingSlots() && !docks)
		{
			return spawn_units;
		}
		return true;
	}

	public void addResource(string pID, int pAmount, bool pNewList = false)
	{
		if (resources_given == null || pNewList)
		{
			resources_given = new List<ResourceContainer>();
		}
		resources_given.Add(new ResourceContainer(pID, pAmount));
	}

	public bool hasResourceGiven(string pID)
	{
		if (resources_given == null)
		{
			return false;
		}
		foreach (ResourceContainer item in resources_given)
		{
			if (item.id == pID)
			{
				return true;
			}
		}
		return false;
	}

	public ActorAsset getRandomBoatAssetToBuild(City pCity)
	{
		string random = boat_types.GetRandom();
		string boatAssetIDFromType = getBoatAssetIDFromType(random, pCity);
		if (string.IsNullOrEmpty(boatAssetIDFromType))
		{
			return null;
		}
		return AssetManager.actor_library.get(boatAssetIDFromType);
	}

	public void setHousingSlots(int pValue)
	{
		can_units_live_here = true;
		housing_slots = pValue;
	}

	public bool hasHousingSlots()
	{
		return housing_slots > 0;
	}

	private string getBoatAssetIDFromType(string pSpeciesBoat, City pCity)
	{
		if (pCity == null)
		{
			return "boat_fishing";
		}
		ArchitectureAsset architecture_asset = pCity.getActorAsset().architecture_asset;
		return pSpeciesBoat switch
		{
			"boat_type_fishing" => architecture_asset.actor_asset_id_boat_fishing, 
			"boat_type_trading" => architecture_asset.actor_asset_id_trading, 
			"boat_type_transport" => architecture_asset.actor_asset_id_transport, 
			_ => architecture_asset.actor_asset_id_boat_fishing, 
		};
	}

	public void checkSpritesAreLoaded()
	{
		if (!sprites_are_initiated)
		{
			sprites_are_initiated = true;
			loadBuildingSprites();
		}
	}

	public void loadBuildingSprites()
	{
		Sprite[] array = loadBuildingSpriteList();
		PreloadHelpers.total_building_sprites += array.Length;
		PreloadHelpers.all_preloaded_sprites_buildings.AddRange(array);
		BuildingSprites buildingSprites = (building_sprites = new BuildingSprites());
		PreloadHelpers.total_building_sprite_containers++;
		foreach (Sprite val in array)
		{
			string[] array2 = ((Object)val).name.Split('_');
			string text = array2[0];
			int num = int.Parse(array2[1]);
			while (buildingSprites.animation_data.Count < num + 1)
			{
				buildingSprites.animation_data.Add(null);
			}
			if (buildingSprites.animation_data[num] == null)
			{
				buildingSprites.animation_data[num] = new BuildingAnimationData();
			}
			BuildingAnimationData buildingAnimationData = building_sprites.animation_data[num];
			bool pIsContructionSprite = false;
			switch (text)
			{
			case "main":
			{
				BuildingAnimationData buildingAnimationData2 = buildingAnimationData;
				if (buildingAnimationData2.list_main == null)
				{
					buildingAnimationData2.list_main = new ListPool<Sprite>();
				}
				buildingAnimationData.list_main.Add(val);
				if (buildingAnimationData.list_main.Count > 1)
				{
					buildingAnimationData.animated = true;
				}
				break;
			}
			case "disabled":
			{
				BuildingAnimationData buildingAnimationData2 = buildingAnimationData;
				if (buildingAnimationData2.list_main_disabled == null)
				{
					buildingAnimationData2.list_main_disabled = new ListPool<Sprite>();
				}
				buildingAnimationData.list_main_disabled.Add(val);
				if (buildingAnimationData.list_main_disabled.Count > 1)
				{
					buildingAnimationData.animated = true;
				}
				break;
			}
			case "spawn":
			{
				BuildingAnimationData buildingAnimationData2 = buildingAnimationData;
				if (buildingAnimationData2.list_spawn == null)
				{
					buildingAnimationData2.list_spawn = new ListPool<Sprite>();
				}
				buildingAnimationData.list_spawn.Add(val);
				if (buildingAnimationData.list_spawn.Count > 1)
				{
					buildingAnimationData.animated = true;
				}
				break;
			}
			case "ruin":
			{
				BuildingAnimationData buildingAnimationData2 = buildingAnimationData;
				if (buildingAnimationData2.list_ruins == null)
				{
					buildingAnimationData2.list_ruins = new ListPool<Sprite>();
				}
				buildingAnimationData.list_ruins.Add(val);
				break;
			}
			case "construction":
				building_sprites.construction = val;
				pIsContructionSprite = true;
				break;
			case "special":
			{
				BuildingAnimationData buildingAnimationData2 = buildingAnimationData;
				if (buildingAnimationData2.list_special == null)
				{
					buildingAnimationData2.list_special = new ListPool<Sprite>();
				}
				buildingAnimationData.list_special.Add(val);
				break;
			}
			case "mini":
				building_sprites.map_icon = new BuildingMapIcon(val);
				break;
			}
			if (shadow)
			{
				DynamicSpriteCreator.createBuildingShadow(this, val, pIsContructionSprite);
			}
		}
		foreach (BuildingAnimationData animation_datum in building_sprites.animation_data)
		{
			animation_datum.main = animation_datum.list_main?.ToArray();
			animation_datum.spawn = animation_datum.list_spawn?.ToArray();
			animation_datum.main_disabled = animation_datum.list_main_disabled?.ToArray();
			animation_datum.ruins = animation_datum.list_ruins?.ToArray();
			animation_datum.special = animation_datum.list_special?.ToArray();
			animation_datum.list_main?.Dispose();
			animation_datum.list_spawn?.Dispose();
			animation_datum.list_main_disabled?.Dispose();
			animation_datum.list_ruins?.Dispose();
			animation_datum.list_special?.Dispose();
			animation_datum.list_main = null;
			animation_datum.list_spawn = null;
			animation_datum.list_main_disabled = null;
			animation_datum.list_ruins = null;
			animation_datum.list_special = null;
		}
	}

	public Sprite[] loadBuildingSpriteList()
	{
		string text = sprite_path;
		if (string.IsNullOrEmpty(text))
		{
			text = main_path + id;
		}
		return SpriteTextureLoader.getSpriteList(text);
	}
}
// --- End of File: BuildingAsset.cs ---



// --- Start of File: BuildingAssetElementPlace.cs ---
public class BuildingAssetElementPlace : BaseAssetElementPlace<BuildingAsset, BuildingDebugAssetElement>
{
}
// --- End of File: BuildingAssetElementPlace.cs ---



// --- Start of File: BuildingAssetWindow.cs ---
using UnityEngine;

public class BuildingAssetWindow : BaseDebugAssetWindow<BuildingAsset, BuildingDebugAssetElement>
{
	public void clickRandomKingdomColor()
	{
		AssetsDebugManager.setRandomKingdomColor(asset.civ_kingdom);
		asset_debug_element.setData(asset);
	}

	protected override void initSprites()
	{
		base.initSprites();
		string text = asset.sprite_path;
		if (string.IsNullOrEmpty(text))
		{
			text = asset.main_path + asset.id;
		}
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList(text);
		foreach (Sprite val in spriteList)
		{
			SpriteElement spriteElement = Object.Instantiate<SpriteElement>(sprite_element_prefab, sprite_elements_parent);
			spriteElement.image.sprite = val;
			spriteElement.text_name.text = ((Object)val).name;
		}
	}

	public static void reloadSprites()
	{
		BaseDebugAssetWindow<BuildingAsset, BuildingDebugAssetElement>.current_element.setData(BaseDebugAssetWindow<BuildingAsset, BuildingDebugAssetElement>.current_element.asset);
	}
}
// --- End of File: BuildingAssetWindow.cs ---



// --- Start of File: BuildingBiomeFoodProducer.cs ---
public class BuildingBiomeFoodProducer : BaseBuildingComponent
{
	private const float FOOD_INTERVAL = 90f;

	private float timer = 90f;

	public override void update(float pElapsed)
	{
		if (building.city == null || !building.isUsable())
		{
			return;
		}
		if (timer > 0f)
		{
			timer -= pElapsed;
			return;
		}
		timer = 90f;
		WorldTile random = building.tiles.GetRandom();
		string food_resource = random.Type.food_resource;
		if (string.IsNullOrEmpty(food_resource))
		{
			food_resource = random.main_type.food_resource;
		}
		if (!string.IsNullOrEmpty(food_resource) && building.city.getResourcesAmount(food_resource) < 10)
		{
			building.city.addResourcesToRandomStockpile(food_resource);
		}
	}
}
// --- End of File: BuildingBiomeFoodProducer.cs ---



// --- Start of File: BuildingColorPixel.cs ---
using UnityEngine;

public readonly struct BuildingColorPixel
{
	public readonly Color32 color;

	public readonly Color32 color_abandoned;

	public readonly Color32 color_ruin;

	public BuildingColorPixel(Color32 pColor, Color32 pColorAbandoned, Color32 pColorRuin)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		color = pColor;
		color_abandoned = pColorAbandoned;
		color_ruin = pColorRuin;
	}
}
// --- End of File: BuildingColorPixel.cs ---



// --- Start of File: BuildingContainer.cs ---
public class BuildingContainer : ObjectContainer<Building>
{
}
// --- End of File: BuildingContainer.cs ---



// --- Start of File: BuildingCreepHUB.cs ---
public class BuildingCreepHUB : BaseBuildingComponent
{
	private float _interval = 0.1f;

	private float _timer;

	private ListPool<BuildingCreepWorker> _workers;

	internal override void create(Building pBuilding)
	{
		_workers = new ListPool<BuildingCreepWorker>();
		base.create(pBuilding);
		for (int i = 0; i < building.asset.grow_creep_workers; i++)
		{
			_workers.Add(new BuildingCreepWorker(this));
		}
		_interval = building.asset.grow_creep_step_interval;
		_timer = _interval;
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		if (_timer > 0f)
		{
			_timer -= pElapsed;
			return;
		}
		_timer = _interval;
		ListPool<BuildingCreepWorker> workers = _workers;
		for (int i = 0; i < workers.Count; i++)
		{
			workers[i].update();
		}
	}

	public override void Dispose()
	{
		for (int i = 0; i < _workers.Count; i++)
		{
			_workers[i].Dispose();
		}
		_workers.Dispose();
		_workers = null;
		base.Dispose();
	}
}
// --- End of File: BuildingCreepHUB.cs ---



// --- Start of File: BuildingCreepWorker.cs ---
using System;
using UnityEngine;

public class BuildingCreepWorker : IDisposable
{
	private int steps_max;

	private WorldTile cur_tile;

	private ActorDirection cur_direction;

	private BuildingCreepHUB _parent;

	private int _total_step_counter;

	private BiomeAsset _this_creep_biome;

	private int _direction_step_amount;

	public BuildingCreepWorker(BuildingCreepHUB pParent)
	{
		_parent = pParent;
		_this_creep_biome = AssetManager.biome_library.get(_parent.building.asset.grow_creep_type);
		steps_max = _parent.building.asset.grow_creep_steps_max;
	}

	public void update()
	{
		if (cur_tile == null)
		{
			_total_step_counter = 0;
			cur_tile = _parent.building.current_tile;
			cur_direction = Randy.getRandom(Toolbox.directions);
		}
		checkRandomDirectionChange();
		updateMovement(cur_tile);
		if (_total_step_counter > steps_max)
		{
			cur_tile = null;
		}
	}

	private void checkRandomDirectionChange()
	{
		if (_parent.building.asset.grow_creep_random_new_direction)
		{
			if (_direction_step_amount >= _parent.building.asset.grow_creep_steps_before_new_direction)
			{
				cur_direction = Randy.getRandom(Toolbox.directions);
				_direction_step_amount = 0;
			}
			_direction_step_amount++;
		}
	}

	private void creepFlash(int pVal = 15)
	{
		if (_parent.building.asset.grow_creep_flash)
		{
			World.world.flash_effects.flashPixel(cur_tile, pVal);
		}
		if (_parent.building.asset.grow_creep_redraw_tile)
		{
			World.world.redrawRenderedTile(cur_tile);
		}
	}

	private void updateMovement(WorldTile pNextTile)
	{
		cur_tile = pNextTile;
		if (canPlaceWorkerOn(cur_tile))
		{
			makeCreep(cur_tile);
			creepFlash();
			_total_step_counter++;
		}
		else if (cur_tile.Type.biome_asset == _this_creep_biome)
		{
			creepFlash();
			pNextTile = getNextRandomTile(cur_tile);
			if (pNextTile == null)
			{
				cur_tile = null;
			}
			else if (canPlaceWorkerOn(pNextTile))
			{
				cur_tile = pNextTile;
			}
			else if (pNextTile.Type.biome_asset == _this_creep_biome)
			{
				cur_tile = pNextTile;
			}
			else if (pNextTile.Type.biome_asset != _this_creep_biome)
			{
				creepFlash(30);
				cur_tile = pNextTile;
			}
			else if (pNextTile.getCreepTileRank() == TileRank.Nothing)
			{
				pNextTile = cur_tile;
				cur_direction = Randy.getRandom(Toolbox.directions);
			}
		}
		else
		{
			cur_tile = null;
		}
	}

	private bool canPlaceWorkerOn(WorldTile pTile)
	{
		if (pTile.getCreepTileRank() == TileRank.Nothing)
		{
			return false;
		}
		if (pTile.Type.creep && pTile.Type.biome_asset == _this_creep_biome)
		{
			return false;
		}
		return true;
	}

	private void makeCreep(WorldTile pTile)
	{
		TopTileType tile = AssetManager.biome_library.get(_parent.building.asset.grow_creep_type).getTile(pTile);
		if (tile != null)
		{
			MapAction.terraformTop(pTile, tile, TerraformLibrary.flash);
		}
	}

	private WorldTile getNextRandomTile(WorldTile pTile)
	{
		return _parent.building.asset.grow_creep_movement_type switch
		{
			CreepWorkerMovementType.Direction => getDirectionTile(pTile, _parent.building.asset.grow_creep_direction_random_position), 
			CreepWorkerMovementType.RandomNeighbour => pTile.neighbours.GetRandom(), 
			CreepWorkerMovementType.RandomNeighbourAll => pTile.neighboursAll.GetRandom(), 
			_ => pTile.neighboursAll.GetRandom(), 
		};
	}

	private WorldTile getDirectionTile(WorldTile pTile, bool pAddRandom = true)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		Vector2Int pos = pTile.pos;
		int num = ((Vector2Int)(ref pos)).x;
		pos = pTile.pos;
		int num2 = ((Vector2Int)(ref pos)).y;
		switch (cur_direction)
		{
		case ActorDirection.Up:
			if (pAddRandom)
			{
				num += Randy.randomInt(-1, 2);
			}
			num2++;
			break;
		case ActorDirection.Right:
			num++;
			if (pAddRandom)
			{
				num2 += Randy.randomInt(-1, 2);
			}
			break;
		case ActorDirection.Down:
			if (pAddRandom)
			{
				num += Randy.randomInt(-1, 2);
			}
			num2--;
			break;
		case ActorDirection.Left:
			num--;
			if (pAddRandom)
			{
				num2 += Randy.randomInt(-1, 2);
			}
			break;
		}
		return World.world.GetTile(num, num2);
	}

	public void Dispose()
	{
		_parent = null;
		cur_tile = null;
		_this_creep_biome = null;
	}
}
// --- End of File: BuildingCreepWorker.cs ---



// --- Start of File: BuildingData.cs ---
using System;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine.Scripting;

[Serializable]
public class BuildingData : BaseObjectData
{
	[DefaultValue(BuildingState.Normal)]
	public BuildingState state = BuildingState.Normal;

	public int mainX;

	public int mainY;

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string asset_id;

	[DefaultValue(-1L)]
	public long cityID = -1L;

	public float grow_time;

	public CityResources resources;

	public StorageBooks books;

	[DefaultValue(-1)]
	public int frameID = -1;

	[Preserve]
	[Obsolete("use .id instead", true)]
	public long objectID
	{
		set
		{
			if (value.hasValue() && !base.id.hasValue())
			{
				base.id = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .asset_id instead", true)]
	public string templateID
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(asset_id))
			{
				asset_id = value;
			}
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		resources?.Dispose();
		resources = null;
		books?.Dispose();
		books = null;
	}
}
// --- End of File: BuildingData.cs ---



// --- Start of File: BuildingDebugAnimationElement.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class BuildingDebugAnimationElement : BaseDebugAnimationElement<BuildingAsset>
{
	public BuildingDebugAnimationVariation variation_prefab;

	public Sprite no_animation_sprite;

	public Transform variations_transform;

	private List<BuildingDebugAnimationVariation> _variations;

	private bool _has_baby;

	public override void update()
	{
		if (!is_playing)
		{
			return;
		}
		foreach (BuildingDebugAnimationVariation variation in _variations)
		{
			variation.update(Time.deltaTime);
		}
		frame_number_text.text = _variations[0].sprite_animation.currentFrameIndex.ToString();
	}

	public override void setData(BuildingAsset pAsset)
	{
		base.setData(pAsset);
		_variations = new List<BuildingDebugAnimationVariation>();
		for (int i = 0; i < pAsset.building_sprites.animation_data.Count; i++)
		{
			BuildingDebugAnimationVariation buildingDebugAnimationVariation = Object.Instantiate<BuildingDebugAnimationVariation>(variation_prefab, variations_transform);
			setAnimationSettings(buildingDebugAnimationVariation.sprite_animation, buildingDebugAnimationVariation.image);
			setAnimationSettings(buildingDebugAnimationVariation.shadow_animation, buildingDebugAnimationVariation.shadow);
			_variations.Add(buildingDebugAnimationVariation);
		}
	}

	private void setAnimationSettings(SpriteAnimation pAnimation, Image pImage)
	{
		pAnimation.create();
		pAnimation.useOnSpriteRenderer = false;
		pAnimation.image = pImage;
		pAnimation.timeBetweenFrames = 1f / asset.animation_speed;
	}

	public void setFrames(List<DebugAnimatedVariation> pVariations, bool pShouldHaveSprites)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		if (pVariations.Count != _variations.Count)
		{
			throw new ArgumentOutOfRangeException();
		}
		bool flag = false;
		for (int i = 0; i < pVariations.Count; i++)
		{
			BuildingDebugAnimationVariation buildingDebugAnimationVariation = _variations[i];
			if (!pShouldHaveSprites)
			{
				((Graphic)buildingDebugAnimationVariation.image).color = Color.clear;
				((Graphic)buildingDebugAnimationVariation.shadow).color = Color.clear;
				continue;
			}
			DebugAnimatedVariation debugAnimatedVariation = pVariations[i];
			Sprite[] frames = debugAnimatedVariation.frames;
			if (frames == null || frames.Length == 0)
			{
				buildingDebugAnimationVariation.image.sprite = no_animation_sprite;
				((Graphic)buildingDebugAnimationVariation.shadow).color = Color.clear;
				((Behaviour)buildingDebugAnimationVariation).enabled = false;
				Debug.LogError((object)("Missing sprites for Building asset " + asset.id));
				continue;
			}
			if (!debugAnimatedVariation.animated)
			{
				Sprite val = frames[0];
				buildingDebugAnimationVariation.image.sprite = val;
				if (asset.shadow)
				{
					DynamicSpriteCreator.createBuildingShadow(asset, val, pIsContructionSprite: false);
					buildingDebugAnimationVariation.shadow.sprite = DynamicSprites.getShadowBuilding(asset, val);
				}
				else
				{
					((Graphic)buildingDebugAnimationVariation.shadow).color = Color.clear;
				}
				((Behaviour)buildingDebugAnimationVariation).enabled = false;
				continue;
			}
			buildingDebugAnimationVariation.sprite_animation.setFrames(frames);
			Sprite[] array = (Sprite[])(object)new Sprite[frames.Length];
			for (int j = 0; j < frames.Length; j++)
			{
				Sprite pSprite = frames[j];
				if (asset.shadow)
				{
					DynamicSpriteCreator.createBuildingShadow(asset, pSprite, pIsContructionSprite: false);
					array[j] = DynamicSprites.getShadowBuilding(asset, pSprite);
				}
				else
				{
					((Graphic)buildingDebugAnimationVariation.shadow).color = Color.clear;
				}
			}
			buildingDebugAnimationVariation.shadow_animation.setFrames(array);
			flag = true;
		}
		if (flag)
		{
			startAnimations();
		}
	}

	protected override void clear()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in variations_transform)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
	}

	public override void stopAnimations()
	{
		base.stopAnimations();
		foreach (BuildingDebugAnimationVariation variation in _variations)
		{
			variation.toggleAnimation(pState: false);
		}
		frame_number_text.text = _variations[0].sprite_animation.currentFrameIndex.ToString();
	}

	public override void startAnimations()
	{
		base.startAnimations();
		foreach (BuildingDebugAnimationVariation variation in _variations)
		{
			variation.toggleAnimation(pState: true);
		}
	}

	protected override void clickNextFrame()
	{
		if (is_playing)
		{
			return;
		}
		SpriteAnimation sprite_animation = _variations[0].sprite_animation;
		int num = sprite_animation.frames.Length;
		int num2 = sprite_animation.currentFrameIndex++;
		if (num2 > num - 1)
		{
			num2 = 0;
		}
		frame_number_text.text = num2.ToString();
		foreach (BuildingDebugAnimationVariation variation in _variations)
		{
			variation.setFrame(num2);
		}
	}
}
// --- End of File: BuildingDebugAnimationElement.cs ---



// --- Start of File: BuildingDebugAnimationVariation.cs ---
using UnityEngine.UI;

public class BuildingDebugAnimationVariation : DebugAnimationVariation
{
	public Image shadow;

	public SpriteAnimation shadow_animation;

	public void update(float pElapsed)
	{
		sprite_animation.update(pElapsed);
		shadow_animation.update(pElapsed);
	}

	public void toggleAnimation(bool pState)
	{
		if (pState)
		{
			sprite_animation.isOn = true;
			shadow_animation.isOn = true;
		}
		else
		{
			sprite_animation.stopAnimations();
			shadow_animation.stopAnimations();
		}
	}

	public void setFrame(int pIndex)
	{
		sprite_animation.currentFrameIndex = pIndex;
		sprite_animation.updateFrame();
		shadow_animation.currentFrameIndex = pIndex;
		shadow_animation.updateFrame();
	}
}
// --- End of File: BuildingDebugAnimationVariation.cs ---



// --- Start of File: BuildingDebugAssetElement.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class BuildingDebugAssetElement : BaseDebugAssetElement<BuildingAsset>
{
	public BuildingDebugAnimationElement spawn;

	public BuildingDebugAnimationElement main;

	public BuildingDebugAnimationElement disabled;

	public BuildingDebugAnimationElement ruin;

	public BuildingDebugAnimationElement special;

	public Image construction;

	public Image mini;

	public override void setData(BuildingAsset pAsset)
	{
		asset = pAsset;
		title.text = asset.id;
		initAnimations();
		initStats();
	}

	protected override void initAnimations()
	{
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		BuildingSprites building_sprites = asset.building_sprites;
		spawn.setData(asset);
		main.setData(asset);
		disabled.setData(asset);
		ruin.setData(asset);
		special.setData(asset);
		List<DebugAnimatedVariation> list = new List<DebugAnimatedVariation>();
		List<DebugAnimatedVariation> list2 = new List<DebugAnimatedVariation>();
		List<DebugAnimatedVariation> list3 = new List<DebugAnimatedVariation>();
		List<DebugAnimatedVariation> list4 = new List<DebugAnimatedVariation>();
		List<DebugAnimatedVariation> list5 = new List<DebugAnimatedVariation>();
		foreach (BuildingAnimationData animation_datum in asset.building_sprites.animation_data)
		{
			list.Add(new DebugAnimatedVariation(getBuildingColoredSprites(animation_datum.spawn), animation_datum.animated));
			list2.Add(new DebugAnimatedVariation(getBuildingColoredSprites(animation_datum.main), animation_datum.animated));
			list3.Add(new DebugAnimatedVariation(getBuildingColoredSprites(animation_datum.main_disabled), animation_datum.animated));
			list4.Add(new DebugAnimatedVariation(getBuildingColoredSprites(animation_datum.ruins), animation_datum.animated));
			list5.Add(new DebugAnimatedVariation(getBuildingColoredSprites(animation_datum.special), animation_datum.animated));
		}
		spawn.setFrames(list, asset.has_sprites_spawn);
		main.setFrames(list2, asset.has_sprites_main);
		disabled.setFrames(list3, asset.has_sprites_main_disabled);
		ruin.setFrames(list4, asset.has_sprites_ruin);
		special.setFrames(list5, asset.has_sprites_special);
		if ((Object)(object)building_sprites.construction != (Object)null)
		{
			construction.sprite = building_sprites.construction;
		}
		else if (asset.has_sprite_construction)
		{
			construction.sprite = no_animation;
		}
		else
		{
			((Graphic)construction).color = Color.clear;
		}
		mini.sprite = loadMini();
	}

	private Sprite loadMini()
	{
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Expected O, but got Unknown
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		string text = asset.sprite_path;
		if (string.IsNullOrEmpty(text))
		{
			text = asset.main_path + asset.id;
		}
		text += "/mini_0";
		Sprite sprite = SpriteTextureLoader.getSprite(text);
		if ((Object)(object)sprite == (Object)null)
		{
			Debug.LogError((object)("Not found mini sprite for building: " + asset.id));
			return sprite;
		}
		KingdomAsset kingdomAsset = AssetManager.kingdoms.get("mad");
		if (!asset.has_kingdom_color)
		{
			return sprite;
		}
		ColorAsset debug_color_asset = kingdomAsset.debug_color_asset;
		Texture2D val = new Texture2D(((Texture)sprite.texture).width, ((Texture)sprite.texture).height);
		((Texture)val).filterMode = ((Texture)sprite.texture).filterMode;
		for (int i = 0; i < ((Texture)val).width; i++)
		{
			for (int j = 0; j < ((Texture)val).height; j++)
			{
				Color pixel = sprite.texture.GetPixel(i, j);
				Color val2 = Color32.op_Implicit(getColor(pixel, debug_color_asset));
				val.SetPixel(i, j, val2);
			}
		}
		val.Apply();
		return Sprite.Create(val, new Rect(Vector2.zero, new Vector2((float)((Texture)val).width, (float)((Texture)val).height)), new Vector2(0.5f, 0.5f), 1f);
	}

	private Color32 getColor(Color pOrigColor, ColorAsset pKingdomColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (Toolbox.areColorsEqual(Color32.op_Implicit(pOrigColor), Toolbox.color_magenta_0))
		{
			pOrigColor = Color32.op_Implicit(pKingdomColor.k_color_0);
		}
		else if (Toolbox.areColorsEqual(Color32.op_Implicit(pOrigColor), Toolbox.color_magenta_1))
		{
			pOrigColor = Color32.op_Implicit(pKingdomColor.k_color_1);
		}
		else if (Toolbox.areColorsEqual(Color32.op_Implicit(pOrigColor), Toolbox.color_magenta_2))
		{
			pOrigColor = Color32.op_Implicit(pKingdomColor.k_color_2);
		}
		else if (Toolbox.areColorsEqual(Color32.op_Implicit(pOrigColor), Toolbox.color_magenta_3))
		{
			pOrigColor = Color32.op_Implicit(pKingdomColor.k_color_3);
		}
		else if (Toolbox.areColorsEqual(Color32.op_Implicit(pOrigColor), Toolbox.color_magenta_4))
		{
			pOrigColor = Color32.op_Implicit(pKingdomColor.k_color_4);
		}
		return Color32.op_Implicit(pOrigColor);
	}

	public override void update()
	{
		if (((Component)this).gameObject.activeSelf)
		{
			spawn.update();
			main.update();
			disabled.update();
			ruin.update();
			special.update();
		}
	}

	public override void stopAnimations()
	{
		spawn.stopAnimations();
		main.stopAnimations();
		disabled.stopAnimations();
		ruin.stopAnimations();
		special.stopAnimations();
	}

	public override void startAnimations()
	{
		spawn.startAnimations();
		main.startAnimations();
		disabled.startAnimations();
		ruin.startAnimations();
		special.startAnimations();
	}

	private Sprite[] getBuildingColoredSprites(Sprite[] pSprites)
	{
		if (pSprites == null)
		{
			return (Sprite[])(object)new Sprite[0];
		}
		Sprite[] array = (Sprite[])(object)new Sprite[pSprites.Length];
		for (int i = 0; i < pSprites.Length; i++)
		{
			array[i] = getBuildingColoredSprite(pSprites[i]);
		}
		return array;
	}

	private Sprite getBuildingColoredSprite(Sprite pMainSprite)
	{
		ColorAsset pColor = null;
		if (asset.has_kingdom_color)
		{
			pColor = AssetManager.kingdoms.get("mad").debug_color_asset;
		}
		return DynamicSprites.getRecoloredBuilding(pMainSprite, pColor, asset.atlas_asset);
	}

	protected override void initStats()
	{
		base.initStats();
		showStat("health", asset.base_stats["health"]);
		showStat("damage", asset.base_stats["damage"]);
		showStat("targets", asset.base_stats["targets"]);
		showStat("area_of_effect", asset.base_stats["area_of_effect"]);
	}

	protected override void showAssetWindow()
	{
		base.showAssetWindow();
		ScrollWindow.showWindow("building_asset");
	}
}
// --- End of File: BuildingDebugAssetElement.cs ---



// --- Start of File: BuildingDebugAssetsComponent.cs ---
using System.Collections.Generic;

public class BuildingDebugAssetsComponent : BaseDebugAssetsComponent<BuildingAsset, BuildingDebugAssetElement, BuildingAssetElementPlace>
{
	protected override List<BuildingAsset> getAssetsList()
	{
		return AssetManager.buildings.list;
	}

	protected override void init()
	{
		sorting_tab.addButton("ui/Icons/iconHealth", "sort_by_health", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByHealth);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/iconDamage", "sort_by_damage", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByDamage);
			checkReverseSort();
		});
		sorting_tab.addButton("ui/Icons/iconPopulationAttackers", "sort_by_targets", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByTargets);
			checkReverseSort();
		});
		sorting_tab.addButton("effects/circle132", "sort_by_area_of_effect", base.setDataResorted, delegate
		{
			list_assets_sorted = list_assets_sorting;
			list_assets_sorted.Sort(sortByAreaOfEffect);
			checkReverseSort();
		});
		base.init();
	}

	private int sortByHealth(BuildingAsset pObject1, BuildingAsset pObject2)
	{
		return -pObject1.base_stats["health"].CompareTo(pObject2.base_stats["health"]);
	}

	private int sortByDamage(BuildingAsset pObject1, BuildingAsset pObject2)
	{
		return -pObject1.base_stats["damage"].CompareTo(pObject2.base_stats["damage"]);
	}

	private int sortByTargets(BuildingAsset pObject1, BuildingAsset pObject2)
	{
		return -pObject1.base_stats["targets"].CompareTo(pObject2.base_stats["targets"]);
	}

	private int sortByAreaOfEffect(BuildingAsset pObject1, BuildingAsset pObject2)
	{
		return -pObject1.base_stats["area_of_effect"].CompareTo(pObject2.base_stats["area_of_effect"]);
	}

	protected override List<BuildingAsset> getListCivsSort()
	{
		bool flag = sorting_tab.getCurrentButton().getState() == SortButtonState.Up;
		List<BuildingAsset> list = new List<BuildingAsset>();
		foreach (BuildingAsset assets in getAssetsList())
		{
			bool flag2 = string.IsNullOrEmpty(assets.civ_kingdom);
			if (!(flag2 && flag) && (flag2 || flag))
			{
				list.Add(assets);
			}
		}
		return list;
	}
}
// --- End of File: BuildingDebugAssetsComponent.cs ---



// --- Start of File: BuildingEffectSpawnDrop.cs ---
using UnityEngine;

public class BuildingEffectSpawnDrop : BaseBuildingComponent
{
	private float _timer;

	public override void update(float pElapsed)
	{
		if (building.data.hasFlag("stop_spawn_drops"))
		{
			return;
		}
		if (_timer >= 0f)
		{
			_timer -= pElapsed;
			return;
		}
		int num = Mathf.CeilToInt(0f - _timer / building.asset.spawn_drop_interval);
		if (num < 1)
		{
			num = 1;
		}
		_timer = building.asset.spawn_drop_interval;
		building.spawnBurstSpecial(num);
	}
}
// --- End of File: BuildingEffectSpawnDrop.cs ---



// --- Start of File: BuildingFruitGrowth.cs ---
public class BuildingFruitGrowth : BaseBuildingComponent
{
	private float _resource_reset_time;

	public override void update(float pElapsed)
	{
		if (building.isNormal() && !building.hasResourcesToCollect())
		{
			if (_resource_reset_time > 0f)
			{
				_resource_reset_time -= pElapsed;
				return;
			}
			building.setHaveResourcesToCollect(pValue: true);
			building.setScaleTween(0.75f);
		}
	}

	public void reset()
	{
		_resource_reset_time = 90f;
	}
}
// --- End of File: BuildingFruitGrowth.cs ---



// --- Start of File: BuildingFundament.cs ---
using System;

[Serializable]
public class BuildingFundament
{
	public readonly int left;

	public readonly int right;

	public readonly int top;

	public readonly int bottom;

	public readonly int width;

	public readonly int height;

	public BuildingFundament(int pLeft, int pRight, int pTop, int pBottom)
	{
		left = pLeft;
		right = pRight;
		top = pTop;
		bottom = pBottom;
		width = right + left + 1;
		height = top + bottom + 1;
	}
}
// --- End of File: BuildingFundament.cs ---



// --- Start of File: BuildingHelper.cs ---
using System.Collections.Generic;

public static class BuildingHelper
{
	private static List<WorldTile> _list_tiles = new List<WorldTile>();

	public static void tryToBuildNear(WorldTile pTile, string pAssetID)
	{
		BuildingAsset buildingAsset = AssetManager.buildings.get(pAssetID);
		if (buildingAsset != null)
		{
			if (World.world.buildings.canBuildFrom(pTile, buildingAsset, null))
			{
				World.world.buildings.addBuilding(buildingAsset, pTile);
			}
			else
			{
				tryToBuildNear(pTile, buildingAsset);
			}
		}
	}

	public static bool tryToBuildNear(WorldTile pTile, BuildingAsset pAsset)
	{
		List<WorldTile> list_tiles = _list_tiles;
		fillEmptyTilesAroundMine(pTile, list_tiles);
		bool result = tryToPlaceBuilding(pAsset, list_tiles);
		list_tiles.Clear();
		return result;
	}

	private static void fillEmptyTilesAroundMine(WorldTile pTile, List<WorldTile> pList)
	{
		pList.Clear();
		int num = 4;
		int num2 = pTile.x - num;
		int num3 = pTile.y - num;
		for (int i = 0; i < num * 2; i++)
		{
			for (int j = 0; j < num * 2; j++)
			{
				WorldTile tile = World.world.GetTile(i + num2, j + num3);
				if (tile != null && (!tile.hasBuilding() || !tile.building.isUsable() || !tile.building.asset.city_building))
				{
					pList.Add(tile);
				}
			}
		}
	}

	private static bool tryToPlaceBuilding(BuildingAsset pAsset, List<WorldTile> pList)
	{
		foreach (WorldTile item in pList.LoopRandom())
		{
			if (World.world.buildings.canBuildFrom(item, pAsset, null))
			{
				if (World.world.buildings.addBuilding(pAsset, item) != null)
				{
					return true;
				}
				break;
			}
		}
		return false;
	}
}
// --- End of File: BuildingHelper.cs ---



// --- Start of File: BuildingLibrary.cs ---
using System.Collections.Generic;
using System.Reflection;
using Beebyte.Obfuscator;
using UnityEngine;
using strings;

[ObfuscateLiterals]
public class BuildingLibrary : AssetLibrary<BuildingAsset>
{
	public static readonly Vector2 shadow_under_construction_bound = new Vector2(0f, 0.61f);

	public static readonly float shadow_under_construction_distortion = 0.19f;

	private const string TEMPLATE_CREEP = "$building_creep$";

	private const string TEMPLATE_RESOURCE = "$resource$";

	private const string TEMPLATE_MINERAL = "$mineral$";

	private const string TEMPLATE_FLORA_SMALL = "$flora_small$";

	private const string TEMPLATE_BUILDING = "$building$";

	private const string TEMPLATE_WAYPOINT = "$waypoint$";

	private const string TEMPLATE_DROP_SPREADER = "$drop_spreader$";

	private const string TEMPLATE_CITY_BUILDING = "$city_building$";

	private const string TEMPLATE_CITY_COLORED_BUILDING = "$city_colored_building$";

	private const string TEMPLATE_WINDMILL_BASE = "$windmill_base$";

	private const string TEMPLATE_WINDMILL_0 = "$windmill_0$";

	private const string TEMPLATE_WINDMILL_1 = "$windmill_1$";

	private const string TEMPLATE_BUILDING_CIV_HUMAN = "$building_civ_human$";

	private const string TEMPLATE_BUILDING_CIV_ORC = "$building_civ_orc$";

	private const string TEMPLATE_BUILDING_CIV_DWARF = "$building_civ_dwarf$";

	private const string TEMPLATE_BUILDING_CIV_ELF = "$building_civ_elf$";

	public override void init()
	{
		base.init();
		addTrees();
		addVegetation();
		addMinerals();
		addPoop();
		addGrownResources();
		addGeneralCityBuildings();
		addNatureBuildings();
		addMobBuildings();
		addCreeps();
		addHumans();
		addOrcs();
		addElves();
		addDwarves();
	}

	public override void post_init()
	{
		base.post_init();
		initBuildingsFromArchitectures();
	}

	public override void linkAssets()
	{
		base.linkAssets();
		checkAtlasLink(pWobbleTreesSettingIsActive: true);
		foreach (BuildingAsset item in list)
		{
			if (item.step_action != null)
			{
				item.has_step_action = true;
			}
			if (item.get_map_icon_color != null)
			{
				item.has_get_map_icon_color = true;
			}
			HashSet<BiomeTag> biome_tags_growth = item.biome_tags_growth;
			item.has_biome_tags = biome_tags_growth != null && biome_tags_growth.Count > 0;
			HashSet<BiomeTag> biome_tags_spread = item.biome_tags_spread;
			item.has_biome_tags_spread = biome_tags_spread != null && biome_tags_spread.Count > 0;
		}
	}

	public void checkAtlasLink(bool pWobbleTreesSettingIsActive)
	{
		foreach (BuildingAsset item in list)
		{
			if (!pWobbleTreesSettingIsActive)
			{
				item.atlas_asset = AssetManager.dynamic_sprites_library.get(item.atlas_id_fallback_when_not_wobbly);
			}
			else
			{
				item.atlas_asset = AssetManager.dynamic_sprites_library.get(item.atlas_id);
			}
		}
	}

	private void initBuildingsFromArchitectures()
	{
		foreach (ArchitectureAsset item in AssetManager.architecture_library.list)
		{
			if (item.isTemplateAsset() || !item.generate_buildings)
			{
				continue;
			}
			string text = item.id;
			string[] styled_building_orders = item.styled_building_orders;
			foreach (string text2 in styled_building_orders)
			{
				string pNew = item.building_ids_for_construction[text2];
				string generation_target = item.generation_target;
				BuildingAsset building = AssetManager.architecture_library.get(generation_target).getBuilding(text2);
				BuildingAsset buildingAsset = clone(pNew, building.id);
				buildingAsset.group = "civ_building";
				buildingAsset.mini_civ_auto_load = true;
				buildingAsset.civ_kingdom = text;
				buildingAsset.main_path = "buildings/civ_main/" + text + "/";
				buildingAsset.can_be_upgraded = false;
				buildingAsset.has_sprite_construction = true;
				if (item.spread_biome)
				{
					buildingAsset.spread_biome = true;
					buildingAsset.spread_biome_id = item.spread_biome_id;
				}
				buildingAsset.material = item.material;
				if (buildingAsset.material == "jelly")
				{
					buildingAsset.setAtlasID("buildings_wobbly", "buildings");
				}
				buildingAsset.shadow = item.has_shadows;
				buildingAsset.burnable = item.burnable_buildings;
				buildingAsset.affected_by_acid = item.acid_affected_buildings;
				switch (text2)
				{
				case "order_tent":
					buildingAsset.fundament = new BuildingFundament(2, 2, 2, 0);
					break;
				case "order_hall_0":
					buildingAsset.fundament = new BuildingFundament(3, 3, 4, 0);
					break;
				case "order_temple":
					buildingAsset.fundament = new BuildingFundament(2, 2, 3, 0);
					break;
				case "order_watch_tower":
					buildingAsset.fundament = new BuildingFundament(1, 1, 1, 0);
					if (!string.IsNullOrEmpty(item.projectile_id))
					{
						buildingAsset.tower_projectile = item.projectile_id;
					}
					break;
				case "order_library":
					buildingAsset.fundament = new BuildingFundament(2, 2, 2, 0);
					break;
				case "order_docks_0":
				{
					string upgrade_to = "docks_" + text;
					buildingAsset.upgrade_to = upgrade_to;
					buildingAsset.can_be_upgraded = true;
					break;
				}
				case "order_docks_1":
				{
					string upgraded_from = "fishing_docks_" + text;
					buildingAsset.upgraded_from = upgraded_from;
					buildingAsset.has_sprites_main_disabled = false;
					break;
				}
				case "order_windmill_0":
					buildingAsset.fundament = new BuildingFundament(2, 2, 2, 0);
					if (buildingAsset.shadow)
					{
						buildingAsset.setShadow(0.4f, 0.38f, 0.47f);
					}
					break;
				}
			}
		}
	}

	private void addTrees()
	{
		add(new BuildingAsset
		{
			id = "tree_green_1",
			fundament = new BuildingFundament(1, 1, 1, 0),
			building_type = BuildingType.Building_Tree,
			type = "type_tree",
			destroy_on_liquid = true,
			random_flip = true,
			ignored_by_cities = true,
			burnable = true,
			affected_by_acid = true,
			affected_by_lava = true,
			flora = true,
			flora_size = FloraSize.Big,
			can_be_damaged_by_tornado = true,
			group = "nature",
			kingdom = "nature",
			check_for_close_building = false,
			biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(default(BiomeTag)),
			material = "tree",
			affected_by_drought = true,
			affected_by_cold_temperature = true,
			main_path = "buildings/trees/",
			can_be_chopped_down = true,
			has_resources_to_collect = true,
			is_vegetation = true
		});
		t.setAtlasID("buildings_trees", "buildings");
		t.nutrition_restore = 40;
		t.sound_spawn = "event:/SFX/NATURE/BaseFloraSpawn";
		t.remove_ruins = false;
		t.setSpread(FloraType.Tree, 10, 0.5f);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_1");
		t.setShadow(0.5f, 0.14f, 0.08f);
		t.limit_per_zone = 3;
		t.can_be_living_plant = true;
		t.base_stats["health"] = 10f;
		t.addResource("wood", 5);
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("tree_green_2", "tree_green_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_2");
		clone("tree_green_3", "tree_green_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_3");
		clone("corrupted_tree", "tree_green_1");
		t.become_alive_when_chopped = true;
		t.limit_per_zone = 4;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Corrupted);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_tree", "corrupted_tree_big");
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCorruptedTree";
		t.affected_by_cold_temperature = false;
		clone("corrupted_tree_big", "corrupted_tree");
		t.become_alive_when_chopped = true;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Corrupted);
		t.fundament = new BuildingFundament(2, 2, 1, 0);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_tree", "corrupted_tree_big");
		clone("enchanted_tree", "tree_green_1");
		t.limit_per_zone = 4;
		t.draw_light_area = true;
		t.draw_light_size = 0.2f;
		t.draw_light_area_offset_y = 2f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Enchanted);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Green, BiomeTag.Clover, BiomeTag.Flower, BiomeTag.Garlic, BiomeTag.Maple, BiomeTag.Birch, BiomeTag.Enchanted);
		t.setShadow(0.5f, 0.03f, 0.12f);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("enchanted_tree");
		clone("swamp_tree", "tree_green_1");
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.limit_per_zone = 2;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Swamp);
		t.can_be_placed_on_liquid = true;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_tree");
		clone("savanna_tree_1", "tree_green_1");
		t.limit_per_zone = 3;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Savanna);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_1", "savanna_tree_big_1");
		clone("savanna_tree_2", "savanna_tree_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_2", "savanna_tree_big_2");
		clone("savanna_tree_big_1", "savanna_tree_1");
		t.fundament = new BuildingFundament(2, 2, 1, 0);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_1", "savanna_tree_big_1");
		clone("savanna_tree_big_2", "savanna_tree_big_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_2", "savanna_tree_big_2");
		clone("mushroom_tree", "tree_green_1");
		t.limit_per_zone = 2;
		t.setSpread(FloraType.Fungi, 10, 0.45f);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Mushroom, BiomeTag.Green);
		t.addResource("mushrooms", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_tree");
		clone("jungle_tree", "tree_green_1");
		t.limit_per_zone = 8;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Jungle);
		t.addResource("bananas", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_tree");
		clone("infernal_tree", "tree_green_1");
		t.draw_light_area = true;
		t.draw_light_size = 0.05f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Infernal);
		t.burnable = false;
		t.affected_by_drought = false;
		t.setShadow(0.1f, 0.31f, 0.33f);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		t.affected_by_cold_temperature = false;
		clone("infernal_tree_small", "infernal_tree");
		t.fundament = new BuildingFundament(0, 0, 1, 0);
		t.setShadow(0.5f, 0.31f, 0.33f);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		clone("infernal_tree_big", "infernal_tree");
		t.fundament = new BuildingFundament(2, 2, 1, 0);
		t.draw_light_area = true;
		t.draw_light_size = 0.1f;
		t.setShadow(0.37f, 0.16f, 0.2f);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		clone("cacti_tree", "tree_green_1");
		t.affected_by_drought = false;
		t.vegetation_random_chance = 0.2f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Sand);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("cacti_tree");
		clone("palm_tree", "tree_green_1");
		t.vegetation_random_chance = 0.1f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Sand);
		t.setShadow(0.37f, 0.16f, 0f);
		t.addResource("coconut", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("palm_tree");
		clone("desert_tree", "tree_green_1");
		t.affected_by_drought = false;
		t.limit_per_zone = 1;
		t.vegetation_random_chance = 0.1f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Desert);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("desert_tree");
		clone("crystal_tree", "tree_green_1");
		t.affected_by_drought = false;
		t.burnable = false;
		t.draw_light_area = true;
		t.draw_light_size = 0.1f;
		t.limit_per_zone = 1;
		t.vegetation_random_chance = 0.1f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Crystal, BiomeTag.Rocklands);
		t.material = "building";
		t.setAtlasID("buildings");
		t.sparkle_effect = true;
		t.addResource("wood", 5, pNewList: true);
		t.addResource("stone", 1);
		t.addResource("gems", 1);
		t.addResource("common_metals", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("crystal_tree");
		t.affected_by_cold_temperature = false;
		clone("wasteland_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Soil, BiomeTag.Wasteland);
		t.affected_by_acid = false;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("wasteland_tree");
		clone("candy_tree", "tree_green_1");
		t.limit_per_zone = 1;
		t.vegetation_random_chance = 0.1f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Candy);
		t.addResource("candy", 3);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("candy_tree");
		t.affected_by_cold_temperature = false;
		clone("lemon_tree", "tree_green_1");
		t.limit_per_zone = 1;
		t.vegetation_random_chance = 0.1f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Lemon, BiomeTag.Green);
		t.addResource("lemons", 3);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("lemon_tree");
		t.affected_by_cold_temperature = false;
		clone("pine_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Soil, BiomeTag.Green, BiomeTag.Permafrost);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("pine_tree");
		t.addResource("pine_cones", 3);
		t.affected_by_cold_temperature = false;
		clone("birch_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Green, BiomeTag.Birch);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("birch_tree");
		clone("maple_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Green, BiomeTag.Maple);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("maple_tree");
		clone("garlic_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Garlic);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("garlic_tree");
		clone("flower_tree_1", "tree_green_1");
		t.setSpread(FloraType.Plant, 10, 0.3f);
		t.vegetation_random_chance = 0.5f;
		t.flora_size = FloraSize.Big;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Flower);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_1");
		clone("flower_tree_2", "flower_tree_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_2");
		clone("flower_tree_3", "flower_tree_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_3");
		clone("rocklands_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.material = "building";
		t.setAtlasID("buildings");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Rocklands);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("rocklands_tree");
		t.limit_in_radius = 6;
		t.affected_by_cold_temperature = false;
		clone("celestial_tree", "tree_green_1");
		t.can_be_living_plant = false;
		t.ignored_by_cities = false;
		t.can_be_chopped_down = false;
		t.material = "tree_celestial";
		t.setAtlasID("buildings_trees_big");
		t.vegetation_random_chance = 0.5f;
		t.setShadow(0.5f, 0.03f, 0.05f);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Celestial);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_tree");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.limit_per_zone = 1;
		t.limit_in_radius = 30;
		t.affected_by_cold_temperature = false;
		t.draw_light_area = true;
		t.draw_light_size = 1f;
		t.addResource("celestial_avocado", 3);
		t.addResource("wood", 100);
		clone("celestial_tree_small", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.material = "building";
		t.setAtlasID("buildings_trees", "buildings");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Celestial);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_tree_small");
		t.limit_in_radius = 6;
		t.limit_per_zone = 15;
		t.affected_by_cold_temperature = false;
		t.draw_light_area = true;
		t.draw_light_size = 0.2f;
		t.addResource("celestial_avocado", 1);
		clone("singularity_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.limit_per_zone = 1;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Singularity);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("singularity_tree");
		t.affected_by_cold_temperature = false;
		clone("clover_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Clover);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("clover_tree");
		clone("paradox_tree", "tree_green_1");
		t.vegetation_random_chance = 0.5f;
		t.limit_per_zone = 1;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Paradox);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("paradox_tree");
		t.affected_by_cold_temperature = false;
	}

	private void addVegetation()
	{
		add(new BuildingAsset
		{
			id = "$flora_small$",
			fundament = new BuildingFundament(0, 0, 0, 0),
			has_ruins_graphics = false,
			destroy_on_liquid = true,
			random_flip = true,
			ignored_by_cities = true,
			burnable = true,
			affected_by_acid = true,
			affected_by_lava = true,
			flora = true,
			flora_size = FloraSize.Tiny,
			affected_by_cold_temperature = true,
			group = "nature",
			kingdom = "nature",
			building_type = BuildingType.Building_Plant,
			material = "tree",
			main_path = "buildings/vegetation/",
			is_vegetation = true
		});
		t.setAtlasID("buildings_trees", "buildings");
		t.has_ruin_state = false;
		t.remove_ruins = false;
		t.setSpread(FloraType.Plant, 5, 0.3f);
		t.type = "type_vegetation";
		t.nutrition_restore = 10;
		t.limit_per_zone = 5;
		t.priority = -1;
		t.can_be_placed_on_blocks = false;
		t.base_stats["health"] = 10f;
		t.sound_spawn = "event:/SFX/NATURE/BaseFloraSpawn";
		t.shadow = false;
		t.addResource("herbs", 1);
		t.has_sprites_main = true;
		clone("desert_plant", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Desert);
		t.limit_per_zone = 3;
		t.addResource("desert_berries", 1, pNewList: true);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("desert_plant");
		clone("crystal_plant", "$flora_small$");
		t.limit_per_zone = 2;
		t.setShadow(0.19f, 0.03f, 0.09f);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Crystal);
		t.material = "building";
		t.setAtlasID("buildings");
		t.burnable = false;
		t.sparkle_effect = true;
		t.addResource("gems", 1, pNewList: true);
		t.addResource("crystal_salt", 1);
		t.addResource("common_metals", 2);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("crystal_plant");
		t.affected_by_cold_temperature = false;
		clone("candy_plant", "$flora_small$");
		t.setShadow(0.19f, 0.03f, 0.09f);
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Candy);
		t.addResource("candy", 1, pNewList: true);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("candy_plant");
		t.affected_by_cold_temperature = false;
		clone("snow_plant", "$flora_small$");
		t.limit_per_zone = 4;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Permafrost);
		t.addResource("snow_cucumbers", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("snow_plant");
		t.affected_by_cold_temperature = false;
		clone("green_herb", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Green, BiomeTag.Lemon, BiomeTag.Jungle);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("green_herb");
		clone("corrupted_plant", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Corrupted);
		t.addResource("evil_beets", 1, pNewList: true);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_plant");
		t.affected_by_cold_temperature = false;
		clone("jungle_plant", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Jungle);
		t.limit_per_zone = 6;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_plant");
		clone("savanna_plant", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Savanna);
		t.addResource("wheat", 1);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_plant");
		clone("mushroom_red", "$flora_small$");
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.limit_per_zone = 9;
		t.setSpread(FloraType.Fungi, 4, 0.5f);
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Lemon, BiomeTag.Green, BiomeTag.Mushroom);
		t.biome_tags_spread = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Hills);
		t.addResource("mushrooms", 1, pNewList: true);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_red");
		clone("mushroom_green", "mushroom_red");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_green");
		clone("mushroom_teal", "mushroom_red");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_teal");
		clone("mushroom_white", "mushroom_red");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_white");
		clone("mushroom_yellow", "mushroom_red");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_yellow");
		clone("flower", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Lemon, BiomeTag.Green, BiomeTag.Mushroom, BiomeTag.Enchanted);
		t.type = "type_flower";
		t.nutrition_restore = 15;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower");
		clone("flame_flower", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Infernal);
		t.burnable = false;
		t.addResource("peppers", 1, pNewList: true);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flame_flower");
		t.affected_by_cold_temperature = false;
		clone("jungle_flower", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Jungle);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_flower");
		clone("wasteland_flower", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Wasteland);
		t.affected_by_acid = false;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("wasteland_flower");
		clone("swamp_plant", "$flora_small$");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Swamp);
		t.fundament = new BuildingFundament(0, 0, 0, 0);
		t.can_be_placed_on_liquid = true;
		t.limit_per_zone = 4;
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_plant", "swamp_plant_big");
		clone("swamp_plant_big", "swamp_plant");
		t.limit_per_zone = 4;
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_plant", "swamp_plant_big");
		clone("birch_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Birch, BiomeTag.Green);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("birch_plant");
		clone("maple_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Maple, BiomeTag.Green);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("maple_plant");
		clone("flower_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Flower, BiomeTag.Green);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_plant");
		clone("garlic_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Garlic, BiomeTag.Green);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("garlic_plant");
		clone("rocklands_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Rocklands);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("rocklands_plant");
		t.affected_by_cold_temperature = false;
		clone("celestial_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Celestial);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_plant");
		t.affected_by_cold_temperature = false;
		clone("singularity_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Singularity);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("singularity_plant");
		t.affected_by_cold_temperature = false;
		clone("clover_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Clover, BiomeTag.Green);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("clover_plant");
		clone("paradox_plant", "flower");
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Paradox);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("paradox_plant");
		t.affected_by_cold_temperature = false;
	}

	private void addMinerals()
	{
		add(new BuildingAsset
		{
			id = "$resource$",
			fundament = new BuildingFundament(1, 1, 1, 0),
			has_resources_to_collect = true,
			has_ruins_graphics = false,
			destroy_on_liquid = true,
			random_flip = true,
			ignored_by_cities = false,
			burnable = false,
			affected_by_acid = true,
			affected_by_lava = true,
			group = "nature",
			kingdom = "nature",
			main_path = "buildings/minerals/"
		});
		t.setAtlasID("buildings");
		t.remove_ruins = false;
		t.can_be_placed_on_blocks = false;
		t.base_stats["health"] = 10f;
		clone("$mineral$", "$resource$");
		t.type = "type_mineral";
		t.has_ruin_state = false;
		t.remove_ruins = true;
		t.ignore_buildings = false;
		t.ignored_by_cities = true;
		t.ignore_same_building_id = true;
		t.building_type = BuildingType.Building_Mineral;
		t.vegetation_random_chance = 0.1f;
		t.limit_per_zone = 1;
		t.setShadow(0.19f, 0.03f, 0.09f);
		t.has_sprites_main = true;
		t.nutrition_restore = 30;
		clone("mineral_bones", "$mineral$");
		t.addResource("bones", 3);
		t.addResource("stone", 1);
		clone("mineral_adamantine", "$mineral$");
		t.draw_light_area = true;
		t.draw_light_size = 0.15f;
		t.sparkle_effect = true;
		t.nutrition_restore = 60;
		t.addResource("adamantine", 1);
		t.addResource("stone", 1);
		clone("mineral_mythril", "$mineral$");
		t.draw_light_area = true;
		t.draw_light_size = 0.1f;
		t.sparkle_effect = true;
		t.nutrition_restore = 40;
		t.addResource("mythril", 1);
		t.addResource("stone", 1);
		clone("mineral_gems", "$mineral$");
		t.sparkle_effect = true;
		t.nutrition_restore = 70;
		t.addResource("gems", 1);
		t.addResource("stone", 1);
		clone("mineral_stone", "$mineral$");
		t.addResource("stone", 3);
		clone("mineral_metals", "$mineral$");
		t.sparkle_effect = true;
		t.addResource("common_metals", 2);
		t.addResource("stone", 1);
		clone("mineral_gold", "$mineral$");
		t.sparkle_effect = true;
		t.addResource("gold", 20);
		t.addResource("stone", 20);
		clone("mineral_silver", "$mineral$");
		t.sparkle_effect = true;
		t.addResource("silver", 1);
		t.addResource("stone", 1);
	}

	private void addPoop()
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		add(new BuildingAsset
		{
			id = "poop",
			building_type = BuildingType.Building_Poops,
			fundament = new BuildingFundament(0, 0, 0, 0),
			has_ruins_graphics = false,
			has_ruin_state = false,
			destroy_on_liquid = true,
			random_flip = true,
			ignored_by_cities = true,
			burnable = true,
			affected_by_acid = true,
			affected_by_lava = true,
			flora = true,
			flora_size = FloraSize.Tiny,
			group = "nature",
			kingdom = "nature",
			main_path = "buildings/nature/",
			removed_by_sponge = true
		});
		t.scale_base = new Vector3(0.1f, 0.1f, 0.1f);
		t.type = "type_poop";
		t.remove_ruins = true;
		t.addResource("fertilizer", 1);
		t.base_stats["health"] = 10f;
	}

	private void addGrownResources()
	{
		clone("fruit_bush", "$resource$");
		t.main_path = "buildings/nature/";
		t.has_ruin_state = false;
		t.can_be_living_plant = true;
		t.building_type = BuildingType.Building_Fruits;
		t.is_vegetation = true;
		t.has_special_animation_state = true;
		t.addResource("berries", 3);
		t.nutrition_restore = 30;
		t.type = "type_fruits";
		t.burnable = true;
		t.flora = true;
		t.can_be_damaged_by_tornado = true;
		t.ignored_by_cities = true;
		t.vegetation_random_chance = 0.2f;
		t.limit_per_zone = 1;
		t.biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Lemon, BiomeTag.Green, BiomeTag.Mushroom, BiomeTag.Enchanted, BiomeTag.Jungle, BiomeTag.Savanna, BiomeTag.Maple, BiomeTag.Birch, BiomeTag.Flower, BiomeTag.Garlic, BiomeTag.Clover);
		t.setSpread(FloraType.Plant, 10);
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("fruit_bush");
		t.material = "tree";
		t.setAtlasID("buildings_trees", "buildings");
		t.setShadow(0.19f, 0.03f, 0.09f);
		t.has_sprites_main = true;
		t.has_sprites_special = true;
		t.gatherable = true;
		t.has_resources_grown_to_collect = true;
		t.has_resources_grown_to_collect_on_spawn = true;
		add(new BuildingAsset
		{
			id = "wheat",
			fundament = new BuildingFundament(0, 0, 0, 0),
			type = "type_crops",
			building_type = BuildingType.Building_Wheat,
			destroy_on_liquid = true,
			random_flip = true,
			ignored_by_cities = true,
			burnable = true,
			affected_by_acid = true,
			affected_by_lava = true,
			flora = true,
			can_be_damaged_by_tornado = true,
			group = "nature",
			kingdom = "nature",
			shadow = false,
			biome_tags_growth = AssetLibrary<BuildingAsset>.h<BiomeTag>(BiomeTag.Field),
			has_ruins_graphics = false,
			material = "tree",
			wheat = true,
			growth_time = 50f,
			main_path = "buildings/nature/",
			can_be_living_plant = true,
			can_be_grown = true
		});
		t.setAtlasID("buildings_trees", "buildings");
		t.nutrition_restore = 20;
		t.has_ruin_state = false;
		t.addResource("wheat", 1);
		t.base_stats["health"] = 10f;
		t.has_sprites_main = true;
		t.get_map_icon_color = delegate(Building pBuilding)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			int animData_index = pBuilding.animData_index;
			return Color32.op_Implicit(Toolbox.colors_wheat[animData_index]);
		};
	}

	private void addGeneralCityBuildings()
	{
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		add(new BuildingAsset
		{
			id = "$building$",
			fundament = new BuildingFundament(3, 3, 2, 0),
			burnable = true,
			destroy_on_liquid = true,
			build_road_to = true,
			affected_by_acid = true,
			affected_by_lava = true,
			can_be_damaged_by_tornado = true,
			only_build_tiles = true,
			check_for_close_building = true,
			sound_hit = "event:/SFX/HIT/HitGeneric",
			main_path = "buildings/nature/",
			can_be_demolished = true
		});
		t.base_stats["health"] = 1500f;
		t.setShadow(0.5f, 0.35f, 0.53f);
		clone("$city_building$", "$building$");
		t.building_type = BuildingType.Building_Civ;
		t.has_sprite_construction = true;
		t.main_path = "buildings/civ_general/";
		t.construction_progress_needed = 50;
		t.city_building = true;
		t.can_be_abandoned = true;
		t.build_place_batch = true;
		t.setShadow(0.5f, 0.37f, 0.28f);
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.check_for_adaptation_tags = true;
		clone("$city_colored_building$", "$city_building$");
		t.has_kingdom_color = true;
		clone("bonfire", "$city_building$");
		t.burnable = false;
		t.draw_light_area = true;
		t.draw_light_size = 0.8f;
		t.can_be_abandoned = false;
		t.priority = 120;
		t.type = "type_bonfire";
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.construction_progress_needed = 30;
		t.cost = new ConstructionCost();
		t.smoke = true;
		t.smoke_interval = 2.5f;
		t.smoke_offset = new Vector2Int(2, 3);
		t.can_be_living_house = false;
		t.build_place_batch = false;
		t.build_prefer_replace_house = true;
		t.check_for_close_building = false;
		t.max_houses = 3;
		t.produce_biome_food = true;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBonfire";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		t.setShadow(0.19f, 0.5f, 0.27f);
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.check_for_adaptation_tags = false;
		clone("well", "$city_building$");
		t.priority = 21;
		t.type = "type_well";
		t.fundament = new BuildingFundament(2, 2, 1, 0);
		t.cost = new ConstructionCost(0, 20, 1, 5);
		t.construction_progress_needed = 200;
		t.burnable = false;
		t.max_houses = 3;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWell";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("training_dummy", "$city_building$");
		t.priority = 23;
		t.type = "type_training_dummies";
		t.fundament = new BuildingFundament(0, 0, 0, 0);
		t.cost = new ConstructionCost(5, 0, 0, 5);
		t.construction_progress_needed = 100;
		t.burnable = true;
		t.max_houses = 3;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBarracks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.has_sprite_construction = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.setShadow(0.6f, 0.27f, 0.23f);
		clone("stockpile", "$city_building$");
		t.priority = 100;
		t.is_stockpile = true;
		t.shadow = false;
		t.stockpile_top_left_offset = new Vector2(-2f, 3.5f);
		t.stockpile_center_offset = new Vector2(0f, 1.5f);
		t.storage = true;
		t.type = "type_stockpile";
		t.fundament = new BuildingFundament(3, 3, 5, 0);
		t.cost = new ConstructionCost();
		t.bonus_z = -5f;
		t.construction_progress_needed = 10;
		t.burnable = true;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("stockpile_fireproof", "stockpile");
		t.burnable = false;
		clone("stockpile_acidproof", "stockpile");
		t.affected_by_acid = false;
		clone("statue", "$city_building$");
		t.priority = 27;
		t.type = "type_statue";
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.cost = new ConstructionCost(0, 5, 0, 25);
		t.burnable = false;
		t.max_houses = 3;
		t.setShadow(0.5f, 0.17f, 0.26f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleStatue";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("mine", "$city_building$");
		t.priority = 50;
		t.type = "type_mine";
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.cost = new ConstructionCost(0, 0, 0, 15);
		t.construction_progress_needed = 300;
		t.burnable = false;
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.build_place_single = true;
		t.build_place_batch = false;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleMine";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("$windmill_base$", "$city_colored_building$");
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.priority = 23;
		t.burnable = false;
		t.storage = true;
		t.storage_only_food = true;
		t.type = "type_windmill";
		t.needs_farms_ground = true;
		t.build_place_center = true;
		t.build_place_single = true;
		t.build_place_batch = false;
		t.setShadow(0.5f, 0.23f, 0.27f);
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWindmill";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		clone("$windmill_0$", "$windmill_base$");
		t.cost = new ConstructionCost(5, 0, 0, 5);
		t.can_be_upgraded = true;
		t.sound_hit = "event:/SFX/HIT/HitWood";
		clone("$windmill_1$", "$windmill_base$");
		t.cost = new ConstructionCost(0, 5, 5, 30);
		t.can_be_upgraded = false;
		t.has_sprite_construction = false;
	}

	private void addNatureBuildings()
	{
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		clone("golden_brain", "$building$");
		t.building_type = BuildingType.Building_Nature;
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.base_stats["health"] = 10000f;
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.group = "golden_brain";
		t.kingdom = "golden_brain";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleGoldenBrain";
		t.setShadow(0.56f, 0.23f, 0.28f);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("$waypoint$", "$building$");
		t.waypoint = true;
		t.building_type = BuildingType.Building_Nature;
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.base_stats["health"] = 10000f;
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.group = "nature";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.limit_global = 1;
		t.setShadow(0.56f, 0.23f, 0.28f);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("waypoint_alien_mold", "$waypoint$");
		t.kingdom = "alien_mold";
		clone("waypoint_computer", "$waypoint$");
		t.kingdom = "computer";
		clone("waypoint_golden_egg", "$waypoint$");
		t.kingdom = "golden_egg";
		clone("waypoint_harp", "$waypoint$");
		t.kingdom = "harp";
		clone("corrupted_brain", "$building$");
		t.building_type = BuildingType.Building_Nature;
		t.draw_light_area = true;
		t.draw_light_size = 0.5f;
		t.base_stats["health"] = 10000f;
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.group = "corrupted_brain";
		t.kingdom = "corrupted_brain";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.tower = true;
		t.tower_attack_buildings = false;
		t.tower_projectile = "madness_ball";
		t.tower_projectile_offset = 6f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCorruptedBrain";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.setShadow(0.44f, 0.38f, 0.37f);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("monolith", "$building$");
		t.building_type = BuildingType.Building_Nature;
		t.draw_light_area = true;
		t.ignored_by_cities = false;
		t.draw_light_size = 1f;
		t.base_stats["health"] = 50000f;
		t.fundament = new BuildingFundament(2, 2, 3, 0);
		t.group = "nature";
		t.kingdom = "nature";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.setShadow(0.56f, 0.23f, 0.28f);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.has_sprites_special = true;
		clone("beehive", "$building$");
		t.building_type = BuildingType.Building_Hives;
		t.base_stats["health"] = 100f;
		t.fundament = new BuildingFundament(1, 0, 1, 0);
		t.group = "nature";
		t.kingdom = "neutral_animals";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = true;
		t.housing_slots = 5;
		t.beehive = true;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBeehive";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingGeneric";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.has_special_animation_state = true;
		t.addResource("honey", 1);
		t.type = "type_hive";
		t.gatherable = true;
		t.has_resources_grown_to_collect = true;
		t.has_resources_grown_to_collect_on_spawn = false;
		clone("$drop_spreader$", "$building$");
		t.building_type = BuildingType.Building_Nature;
		t.group = "nature";
		t.kingdom = "nature";
		t.burnable = false;
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.can_be_placed_on_blocks = true;
		t.destroy_on_liquid = false;
		t.ignored_by_cities = false;
		t.affected_by_lava = false;
		t.can_be_placed_on_liquid = true;
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		t.has_sprites_main_disabled = true;
		t.can_be_damaged_by_tornado = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = false;
		t.spawn_drops = true;
		clone("volcano", "$drop_spreader$");
		t.draw_light_area = true;
		t.draw_light_size = 0.8f;
		t.transform_tiles_to_tile_type = "lava3";
		t.smoke = true;
		t.smoke_interval = 1.5f;
		t.smoke_offset = new Vector2Int(2, 2);
		t.spawn_drop_id = "lava";
		t.spawn_drop_start_height = 1.8f;
		t.spawn_drop_min_height = 5f;
		t.spawn_drop_max_height = 30f;
		t.spawn_drop_interval = 0.1f;
		t.spawn_drop_min_radius = 2f;
		t.spawn_drop_max_radius = 8f;
		t.step_action = delegate(Actor pActor, Building pBuilding)
		{
			if (pActor.asset.die_in_lava && !pActor.isUnderDamageCooldown() && !pBuilding.isRuin())
			{
				pActor.getHit(200f, pFlash: true, AttackType.Fire);
				if (!pActor.isAlive())
				{
					CursedSacrifice.checkGoodForSacrifice(pActor);
					pActor.skipUpdates();
				}
			}
		};
		t.setShadow(0.4f, 0f, 0.7f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleVolcano";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("geyser", "$drop_spreader$");
		t.smoke = true;
		t.smoke_interval = 2.5f;
		t.spawn_drop_id = "rain";
		t.spawn_drop_start_height = 2.5f;
		t.spawn_drop_min_height = 10f;
		t.spawn_drop_max_height = 40f;
		t.spawn_drop_min_radius = 2f;
		t.spawn_drop_max_radius = 17f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleGeyser";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("geyser_acid", "$drop_spreader$");
		t.smoke = true;
		t.smoke_interval = 3.5f;
		t.spawn_drop_id = "acid";
		t.affected_by_acid = false;
		t.spawn_drop_start_height = 2f;
		t.spawn_drop_min_height = 5f;
		t.spawn_drop_max_height = 36f;
		t.spawn_drop_min_radius = 2f;
		t.spawn_drop_max_radius = 15f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleAcidGeyser";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
	}

	private void addMobBuildings()
	{
		clone("flame_tower", "$building$");
		t.building_type = BuildingType.Building_Mob;
		t.main_path = "buildings/mobs/";
		t.draw_light_area = true;
		t.draw_light_size = 0.5f;
		t.draw_light_area_offset_y = 8f;
		t.base_stats["health"] = 1000f;
		t.fundament = new BuildingFundament(2, 2, 3, 0);
		t.group = "demon";
		t.kingdom = "demon";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.spawn_units = true;
		t.spawn_units_asset = "demon";
		t.housing_slots = 5;
		t.tower = true;
		t.tower_attack_buildings = true;
		t.tower_projectile = "fireball";
		t.tower_projectile_offset = 10f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleFlameTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("ice_tower", "$building$");
		t.building_type = BuildingType.Building_Mob;
		t.main_path = "buildings/mobs/";
		t.base_stats["health"] = 1000f;
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.group = "cold_one";
		t.kingdom = "cold_one";
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.ice_tower = true;
		t.spawn_units = true;
		t.spawn_units_asset = "cold_one";
		t.housing_slots = 5;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleIceTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("angle_tower", "$building$");
		t.building_type = BuildingType.Building_Mob;
		t.main_path = "buildings/mobs/";
		t.base_stats["health"] = 1000f;
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.group = "angle";
		t.kingdom = "angle";
		t.housing_slots = 5;
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = true;
		t.burnable = false;
		t.spawn_units = true;
		t.spawn_units_asset = "angle";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
	}

	private void addCreeps()
	{
		clone("$building_creep$", "$building$");
		t.main_path = "buildings/creeps/";
		t.building_type = BuildingType.Building_Creep;
		t.has_sprites_spawn = true;
		t.has_sprites_main = true;
		t.has_sprites_ruin = true;
		clone("tumor", "$building_creep$");
		t.material = "jelly";
		t.setAtlasID("buildings_wobbly", "buildings");
		t.transform_tiles_to_top_tiles = "tumor_low";
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.group = "tumor";
		t.kingdom = "tumor";
		t.can_be_placed_on_blocks = false;
		t.can_be_placed_on_liquid = false;
		t.ignore_buildings = true;
		t.check_for_close_building = false;
		t.can_be_living_house = false;
		t.spawn_units = true;
		t.spawn_units_asset = "tumor_monster_animal";
		t.housing_slots = 5;
		setGrowBiomeAround("biome_tumor", 5, 2, 0.1f, CreepWorkerMovementType.Direction);
		t.grow_creep_direction_random_position = true;
		t.grow_creep_flash = true;
		t.grow_creep_redraw_tile = true;
		t.setShadow(0.2f, 0.08f, 0.66f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleTumor";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		clone("biomass", "tumor");
		t.group = "biomass";
		t.kingdom = "biomass";
		t.spawn_units_asset = "bioblob";
		t.housing_slots = 5;
		t.transform_tiles_to_top_tiles = "biomass_low";
		setGrowBiomeAround("biome_biomass", 10, 4, 0.7f, CreepWorkerMovementType.RandomNeighbourAll);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBiomass";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		clone("super_pumpkin", "tumor");
		t.group = "super_pumpkin";
		t.kingdom = "super_pumpkin";
		t.spawn_units_asset = "lil_pumpkin";
		t.housing_slots = 5;
		t.transform_tiles_to_top_tiles = "pumpkin_low";
		setGrowBiomeAround("biome_pumpkin", 10, 3, 0.2f, CreepWorkerMovementType.Direction);
		t.grow_creep_direction_random_position = true;
		t.grow_creep_random_new_direction = true;
		t.grow_creep_steps_before_new_direction = 20;
		t.grow_creep_flash = true;
		t.grow_creep_redraw_tile = true;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleSuperPumpkin";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		clone("cybercore", "tumor");
		t.group = "assimilators";
		t.draw_light_area = true;
		t.draw_light_size = 0.2f;
		t.draw_light_area_offset_y = 2f;
		t.kingdom = "assimilators";
		t.spawn_units_asset = "assimilator";
		t.housing_slots = 5;
		t.transform_tiles_to_top_tiles = "cybertile_low";
		setGrowBiomeAround("biome_cybertile", 20, 6, 2f, CreepWorkerMovementType.Direction);
		t.grow_creep_steps_before_new_direction = 7;
		t.grow_creep_direction_random_position = false;
		t.grow_creep_random_new_direction = true;
		t.damaged_by_rain = true;
		t.burnable = false;
		t.material = "building";
		t.setAtlasID("buildings");
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCybercore";
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingRobotic";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingRobotic";
	}

	private void addHumans()
	{
		clone("$building_civ_human$", "$city_colored_building$");
		t.main_path = "buildings/civ_main/human/";
		t.group = "human";
		t.civ_kingdom = "human";
		clone("fishing_docks_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.2f;
		t.draw_light_area_offset_y = 2f;
		t.sprite_path = "buildings/civ_general/fishing_dock";
		t.priority = 20;
		t.type = "type_docks";
		t.fundament = new BuildingFundament(2, 2, 4, 0);
		t.cost = new ConstructionCost(10);
		t.burnable = false;
		t.docks = true;
		t.can_be_placed_on_liquid = true;
		t.destroy_on_liquid = false;
		t.build_road_to = false;
		t.only_build_tiles = false;
		t.auto_remove_ruin = true;
		t.max_houses = 1;
		t.can_be_upgraded = true;
		t.upgrade_level = 1;
		t.upgrade_to = "docks_human";
		t.boat_types = new string[1] { "boat_type_fishing" };
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleFishingDocks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.setShadow(0.5f, 0.55f, 0.63f);
		clone("watch_tower_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.5f;
		t.base_stats["health"] = 3000f;
		t.base_stats["targets"] = 1f;
		t.base_stats["area_of_effect"] = 1f;
		t.base_stats["damage"] = 50f;
		t.base_stats["knockback"] = 1f;
		t.priority = 22;
		t.type = "type_watch_tower";
		t.fundament = new BuildingFundament(1, 1, 1, 0);
		t.cost = new ConstructionCost(0, 20, 1, 5);
		t.burnable = false;
		t.tower = true;
		t.tower_attack_buildings = true;
		t.tower_projectile = "arrow";
		t.tower_projectile_offset = 4f;
		t.tower_projectile_amount = 6;
		t.build_place_borders = true;
		t.build_place_batch = false;
		t.build_place_single = true;
		t.setShadow(0.5f, 0.23f, 0.27f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWatchTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("docks_human", "fishing_docks_human");
		t.sprite_path = string.Empty;
		t.cost = new ConstructionCost(10, 6);
		t.draw_light_area = true;
		t.draw_light_size = 0.5f;
		t.draw_light_area_offset_y = 8f;
		t.can_be_upgraded = false;
		t.upgraded_from = "fishing_docks_human";
		t.boat_types = new string[3] { "boat_type_fishing", "boat_type_trading", "boat_type_transport" };
		t.setShadow(0.5f, 0.55f, 0.63f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleDocks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprites_main_disabled = true;
		clone("barracks_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.5f;
		t.priority = 22;
		t.burnable = false;
		t.type = "type_barracks";
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.cost = new ConstructionCost(0, 5, 2, 15);
		t.setShadow(0.56f, 0.41f, 0.43f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBarracks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("temple_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.draw_light_area_offset_y = 3f;
		t.priority = 26;
		t.type = "type_temple";
		t.fundament = new BuildingFundament(2, 2, 3, 0);
		t.cost = new ConstructionCost(0, 10, 2, 30);
		t.burnable = false;
		t.group = "human";
		t.max_houses = 2;
		t.setShadow(0.56f, 0.41f, 0.43f);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleTemple";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("library_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.draw_light_area_offset_y = 3f;
		t.priority = 26;
		t.type = "type_library";
		t.fundament = new BuildingFundament(2, 2, 3, 0);
		t.cost = new ConstructionCost(0, 10, 2, 30);
		t.burnable = false;
		t.group = "human";
		t.book_slots = 5;
		t.setShadow(0.56f, 0.41f, 0.43f);
		clone("market_human", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.3f;
		t.draw_light_area_offset_y = 3f;
		t.priority = 26;
		t.type = "type_market";
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.cost = new ConstructionCost(10, 5, 2, 100);
		t.burnable = true;
		t.group = "human";
		t.setShadow(0.56f, 0.41f, 0.43f);
		clone("windmill_human_0", "$windmill_0$");
		t.group = "human";
		t.main_path = "buildings/civ_main/human/";
		t.upgrade_to = "windmill_human_1";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.civ_kingdom = "human";
		clone("windmill_human_1", "$windmill_1$");
		t.group = "human";
		t.main_path = "buildings/civ_main/human/";
		t.upgraded_from = "windmill_human_0";
		t.civ_kingdom = "human";
		clone("tent_human", "$building_civ_human$");
		t.type = "type_house";
		t.cost = new ConstructionCost(1);
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.can_be_upgraded = true;
		t.setHousingSlots(3);
		t.loot_generation = 1;
		t.housing_happiness = 5;
		t.burnable = true;
		t.upgrade_to = "house_human_0";
		t.base_stats["health"] = 50f;
		t.build_place_batch = true;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingGeneric";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		clone("house_human_0", "$building_civ_human$");
		t.draw_light_area = true;
		t.draw_light_size = 0.2f;
		t.type = "type_house";
		t.cost = new ConstructionCost(5);
		t.setHousingSlots(3);
		t.loot_generation = 1;
		t.housing_happiness = 6;
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.can_be_upgraded = true;
		t.burnable = true;
		t.upgrade_to = "house_human_1";
		t.upgraded_from = "tent_human";
		t.base_stats["health"] = 100f;
		t.has_sprite_construction = false;
		t.group = "human";
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		clone("house_human_1", "house_human_0");
		t.cost = new ConstructionCost(4);
		t.setHousingSlots(4);
		t.loot_generation = 2;
		t.housing_happiness = 7;
		t.upgrade_level = 1;
		t.upgrade_to = "house_human_2";
		t.upgraded_from = "house_human_0";
		t.base_stats["health"] = 150f;
		t.group = "human";
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		clone("house_human_2", "house_human_1");
		t.cost = new ConstructionCost(0, 5);
		t.upgrade_level = 2;
		t.loot_generation = 3;
		t.burnable = false;
		t.upgrade_to = "house_human_3";
		t.upgraded_from = "house_human_1";
		t.base_stats["health"] = 200f;
		t.group = "human";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("house_human_3", "house_human_2");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.cost = new ConstructionCost(0, 10);
		t.setHousingSlots(5);
		t.loot_generation = 4;
		t.housing_happiness = 9;
		t.upgrade_level = 3;
		t.upgrade_to = "house_human_4";
		t.upgraded_from = "house_human_2";
		t.base_stats["health"] = 250f;
		t.group = "human";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("house_human_4", "house_human_3");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.cost = new ConstructionCost(0, 15);
		t.setHousingSlots(6);
		t.loot_generation = 5;
		t.housing_happiness = 10;
		t.upgrade_level = 4;
		t.upgrade_to = "house_human_5";
		t.upgraded_from = "house_human_3";
		t.base_stats["health"] = 350f;
		t.group = "human";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("house_human_5", "house_human_4");
		t.cost = new ConstructionCost(0, 20, 2, 10);
		t.setHousingSlots(7);
		t.loot_generation = 6;
		t.housing_happiness = 11;
		t.upgrade_level = 5;
		t.can_be_upgraded = false;
		t.upgrade_to = string.Empty;
		t.upgraded_from = "house_human_4";
		t.base_stats["health"] = 400f;
		t.group = "human";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("hall_human_0", "house_human_0");
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.priority = 100;
		t.storage = true;
		t.type = "type_hall";
		t.cost = new ConstructionCost(10, 5);
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.can_be_upgraded = true;
		t.base_stats["health"] = 200f;
		t.burnable = true;
		t.setHousingSlots(5);
		t.housing_happiness = 10;
		t.loot_generation = 3;
		t.upgrade_to = "hall_human_1";
		t.ignore_other_buildings_for_upgrade = true;
		t.group = "human";
		t.build_place_batch = true;
		t.max_houses = 2;
		t.produce_biome_food = true;
		t.setShadow(0.56f, 0.41f, 0.43f);
		t.draw_light_size = 0.3f;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.book_slots = 3;
		t.has_sprite_construction = true;
		clone("hall_human_1", "hall_human_0");
		t.cost = new ConstructionCost(0, 10, 1, 20);
		t.setHousingSlots(8);
		t.loot_generation = 5;
		t.housing_happiness = 15;
		t.upgrade_level = 1;
		t.burnable = false;
		t.upgrade_to = "hall_human_2";
		t.upgraded_from = "hall_human_0";
		t.base_stats["health"] = 400f;
		t.group = "human";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.draw_light_size = 0.4f;
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprite_construction = false;
		clone("hall_human_2", "hall_human_1");
		t.cost = new ConstructionCost(0, 15, 1, 100);
		t.setHousingSlots(12);
		t.loot_generation = 10;
		t.housing_happiness = 20;
		t.upgrade_level = 2;
		t.can_be_upgraded = false;
		t.upgraded_from = "hall_human_1";
		t.upgrade_to = string.Empty;
		t.base_stats["health"] = 600f;
		t.group = "human";
		t.draw_light_size = 0.5f;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
	}

	private void addOrcs()
	{
		clone("$building_civ_orc$", "$city_colored_building$");
		t.main_path = "buildings/civ_main/orc/";
		t.group = "orc";
		t.civ_kingdom = "orc";
		clone("watch_tower_orc", "watch_tower_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("fishing_docks_orc", "fishing_docks_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.upgrade_to = "docks_orc";
		t.civ_kingdom = "orc";
		clone("docks_orc", "docks_human");
		t.main_path = "buildings/civ_main/orc/";
		t.group = "orc";
		t.draw_light_area_offset_y = 8f;
		t.draw_light_area_offset_x = -1f;
		t.upgraded_from = "fishing_docks_orc";
		t.civ_kingdom = "orc";
		clone("barracks_orc", "barracks_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("temple_orc", "temple_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("library_orc", "library_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("market_orc", "market_human");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("windmill_orc_0", "$windmill_0$");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.upgrade_to = "windmill_orc_1";
		t.civ_kingdom = "orc";
		clone("windmill_orc_1", "$windmill_1$");
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.upgraded_from = "windmill_orc_0";
		t.civ_kingdom = "orc";
		clone("tent_orc", "tent_human");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_orc_0";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_0", "house_human_0");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_orc_1";
		t.upgraded_from = "tent_orc";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_1", "house_human_1");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_orc_2";
		t.upgraded_from = "house_orc_0";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_2", "house_human_2");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_orc_3";
		t.upgraded_from = "house_orc_1";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_3", "house_human_3");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_orc_4";
		t.upgraded_from = "house_orc_2";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_4", "house_human_4");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.upgrade_to = "house_orc_5";
		t.upgraded_from = "house_orc_3";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("house_orc_5", "house_human_5");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.upgraded_from = "house_orc_4";
		t.civ_kingdom = "orc";
		clone("hall_orc_0", "hall_human_0");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_orc_1";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("hall_orc_1", "hall_human_1");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_orc_2";
		t.upgraded_from = "hall_orc_0";
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.civ_kingdom = "orc";
		clone("hall_orc_2", "hall_human_2");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.group = "orc";
		t.main_path = "buildings/civ_main/orc/";
		t.upgraded_from = "hall_orc_1";
		t.civ_kingdom = "orc";
	}

	private void addElves()
	{
		clone("$building_civ_elf$", "$city_colored_building$");
		t.main_path = "buildings/civ_main/elf/";
		t.group = "elf";
		t.civ_kingdom = "elf";
		clone("watch_tower_elf", "watch_tower_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("fishing_docks_elf", "fishing_docks_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.upgrade_to = "docks_elf";
		t.civ_kingdom = "elf";
		clone("docks_elf", "docks_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.draw_light_area_offset_y = 6f;
		t.draw_light_area_offset_x = -2f;
		t.upgraded_from = "fishing_docks_elf";
		t.civ_kingdom = "elf";
		clone("barracks_elf", "barracks_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("temple_elf", "temple_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("library_elf", "library_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("market_elf", "market_human");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("windmill_elf_0", "$windmill_0$");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.upgrade_to = "windmill_elf_1";
		t.civ_kingdom = "elf";
		clone("windmill_elf_1", "$windmill_1$");
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.upgraded_from = "windmill_elf_0";
		t.civ_kingdom = "elf";
		clone("tent_elf", "tent_human");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_elf_0";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_0", "house_human_0");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_elf_1";
		t.upgraded_from = "tent_human";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_1", "house_human_1");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_elf_2";
		t.upgraded_from = "house_elf_0";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_2", "house_human_2");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_elf_3";
		t.upgraded_from = "house_elf_1";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_3", "house_human_3");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_elf_4";
		t.upgraded_from = "house_elf_2";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_4", "house_human_4");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.upgrade_to = "house_elf_5";
		t.upgraded_from = "house_elf_3";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("house_elf_5", "house_human_5");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.upgraded_from = "house_elf_4";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("hall_elf_0", "hall_human_0");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_elf_1";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("hall_elf_1", "hall_human_1");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_elf_2";
		t.upgraded_from = "hall_elf_0";
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.civ_kingdom = "elf";
		clone("hall_elf_2", "hall_human_2");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.group = "elf";
		t.main_path = "buildings/civ_main/elf/";
		t.upgraded_from = "hall_elf_1";
		t.civ_kingdom = "elf";
	}

	private void addDwarves()
	{
		clone("$building_civ_dwarf$", "$city_colored_building$");
		t.main_path = "buildings/civ_main/dwarf/";
		t.group = "dwarf";
		t.civ_kingdom = "dwarf";
		clone("watch_tower_dwarf", "watch_tower_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("fishing_docks_dwarf", "fishing_docks_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.upgrade_to = "docks_dwarf";
		t.civ_kingdom = "dwarf";
		clone("docks_dwarf", "docks_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.draw_light_area_offset_y = 10f;
		t.upgraded_from = "fishing_docks_dwarf";
		t.civ_kingdom = "dwarf";
		clone("barracks_dwarf", "barracks_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("temple_dwarf", "temple_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("library_dwarf", "library_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("market_dwarf", "market_human");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("windmill_dwarf_0", "$windmill_0$");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.upgrade_to = "windmill_dwarf_1";
		t.civ_kingdom = "dwarf";
		clone("windmill_dwarf_1", "$windmill_1$");
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.upgraded_from = "windmill_dwarf_0";
		t.civ_kingdom = "dwarf";
		clone("tent_dwarf", "tent_human");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_dwarf_0";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_0", "house_human_0");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_dwarf_1";
		t.upgraded_from = "tent_dwarf";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_1", "house_human_1");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_dwarf_2";
		t.upgraded_from = "house_dwarf_0";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_2", "house_human_2");
		t.fundament = new BuildingFundament(1, 1, 2, 0);
		t.upgrade_to = "house_dwarf_3";
		t.upgraded_from = "house_dwarf_1";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_3", "house_human_3");
		t.fundament = new BuildingFundament(2, 2, 2, 0);
		t.upgrade_to = "house_dwarf_4";
		t.upgraded_from = "house_dwarf_2";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.setHousingSlots(6);
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_4", "house_human_4");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.upgrade_to = "house_dwarf_5";
		t.upgraded_from = "house_dwarf_3";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.setHousingSlots(8);
		t.civ_kingdom = "dwarf";
		clone("house_dwarf_5", "house_human_5");
		t.fundament = new BuildingFundament(3, 3, 2, 0);
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.upgraded_from = "house_dwarf_4";
		t.setHousingSlots(10);
		t.civ_kingdom = "dwarf";
		clone("hall_dwarf_0", "hall_human_0");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_dwarf_1";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("hall_dwarf_1", "hall_human_1");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.upgrade_to = "hall_dwarf_2";
		t.upgraded_from = "hall_dwarf_0";
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.civ_kingdom = "dwarf";
		clone("hall_dwarf_2", "hall_human_2");
		t.fundament = new BuildingFundament(3, 3, 4, 0);
		t.group = "dwarf";
		t.main_path = "buildings/civ_main/dwarf/";
		t.upgraded_from = "1hall_dwarf";
		t.civ_kingdom = "dwarf";
	}

	public void setGrowBiomeAround(string pID, int pMaxSteps, int pWorkers, float pStepInterval, CreepWorkerMovementType pMovementType)
	{
		t.grow_creep = true;
		t.grow_creep_type = pID;
		t.grow_creep_steps_max = pMaxSteps;
		t.grow_creep_workers = pWorkers;
		t.grow_creep_step_interval = pStepInterval;
		t.grow_creep_movement_type = pMovementType;
	}

	public override void editorDiagnostic()
	{
		foreach (BuildingAsset item in list)
		{
			if (!item.mini_civ_auto_load && typeof(SB).GetField(item.id, BindingFlags.Static | BindingFlags.Public) == null)
			{
				BaseAssetLibrary.logAssetError("BuildingLibrary: SB class does not have property", item.id);
			}
			if (!(item.type == "") && typeof(S_BuildingType).GetField(item.type, BindingFlags.Static | BindingFlags.Public) == null)
			{
				BaseAssetLibrary.logAssetError("BuildingLibrary: SB class does not have type property", item.type);
			}
		}
		base.editorDiagnostic();
	}

	public void clear()
	{
		for (int i = 0; i < list.Count; i++)
		{
			list[i].buildings.Clear();
		}
	}

	public override BuildingAsset add(BuildingAsset pAsset)
	{
		BuildingAsset buildingAsset = base.add(pAsset);
		if (buildingAsset.base_stats == null)
		{
			buildingAsset.base_stats = new BaseStats();
			buildingAsset.base_stats["health"] = 100f;
			buildingAsset.base_stats["size"] = 2f;
		}
		return buildingAsset;
	}

	public string addToGameplayReport()
	{
		string text = "##### Buildings: \n\n";
		text += "\nAsset ID                           | type                             | building_type                    | health                           | size                             | city_building                    | can_be_upgraded                  | upgrade_from                     | upgrade_to\n";
		int num = 35;
		int num2 = 35;
		foreach (BuildingAsset item in list)
		{
			int num3 = 0;
			string text2 = "> " + item.id;
			string type = item.type;
			string pText = item.building_type.ToString();
			string pText2 = item.base_stats["health"].ToString();
			string pText3 = item.base_stats["size"].ToString();
			string pText4 = item.city_building.ToString();
			string pText5 = item.can_be_upgraded.ToString();
			string upgraded_from = item.upgraded_from;
			string upgrade_to = item.upgrade_to;
			string pLineInfo = text2;
			addLine(ref pLineInfo, type, num + num2 * num3++);
			addLine(ref pLineInfo, pText, num + num2 * num3++);
			addLine(ref pLineInfo, pText2, num + num2 * num3++);
			addLine(ref pLineInfo, pText3, num + num2 * num3++);
			addLine(ref pLineInfo, pText4, num + num2 * num3++);
			addLine(ref pLineInfo, pText5, num + num2 * num3++);
			addLine(ref pLineInfo, upgraded_from, num + num2 * num3++);
			addLine(ref pLineInfo, upgrade_to, num + num2 * num3++);
			pLineInfo += "\n";
			text += pLineInfo;
		}
		text += "\n## END OF BUILDINGS REPORT\n";
		text = text + Toolbox.getRepeatedString('=', 100) + "\n\n";
		return text + "\n\n";
	}

	private void addLine(ref string pLineInfo, string pText, int pSize)
	{
		pLineInfo = Toolbox.fillRight(pLineInfo, pSize);
		pLineInfo = pLineInfo + "| " + pText;
	}
}
// --- End of File: BuildingLibrary.cs ---



// --- Start of File: BuildingList.cs ---
public enum BuildingList
{
	Abandoned,
	Civs,
	Ruins,
	Food,
	Flora,
	Trees,
	Wheat,
	Minerals,
	Hives,
	Poops
}
// --- End of File: BuildingList.cs ---



// --- Start of File: BuildingManager.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using tools;

public class BuildingManager : SimSystemManager<Building, BuildingData>
{
	private List<WorldTile> _temp_list_tiles = new List<WorldTile>();

	private JobManagerBuildings _job_manager;

	private Building[] _array_visible_buildings = new Building[0];

	private int _visible_buildings_count;

	public BuildingRenderData render_data = new BuildingRenderData(4096);

	public HashSet<Building> occupied_buildings = new HashSet<Building>();

	public List<Building> visible_stockpiles = new List<Building>();

	public List<Building> sparkles = new List<Building>();

	public MultiStackPool<BaseBuildingComponent> component_pool = new MultiStackPool<BaseBuildingComponent>();

	private bool _need_normal_check;

	public BuildingManager()
	{
		type_id = "building";
		_job_manager = new JobManagerBuildings("buildings");
	}

	public override void clear()
	{
		_job_manager.clear();
		Array.Clear(_array_visible_buildings, 0, _array_visible_buildings.Length);
		_temp_list_tiles.Clear();
		occupied_buildings.Clear();
		checkContainer();
		scheduleDestroyAllOnWorldClear();
		checkObjectsToDestroy();
		base.clear();
	}

	protected override void destroyObject(Building pBuilding)
	{
		base.destroyObject(pBuilding);
		if (pBuilding.hasHousingLogic())
		{
			event_houses = true;
		}
		pBuilding.setAlive(pValue: false);
		pBuilding.asset.buildings.Remove(pBuilding);
		occupied_buildings.Remove(pBuilding);
		removeObject(pBuilding);
		_job_manager.removeObject(pBuilding, pBuilding.batch);
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		Bench.bench("buildings", "game_total");
		checkContainer();
		_job_manager.updateBase(pElapsed);
		checkContainer();
		Bench.benchEnd("buildings", "game_total", pSaveCounter: false, 0L);
	}

	public override void loadFromSave(List<BuildingData> pList)
	{
		base.loadFromSave(pList);
		checkContainer();
	}

	internal Building addBuilding(string pID, WorldTile pTile, bool pCheckForBuild = false, bool pSfx = false, BuildPlacingType pType = BuildPlacingType.New)
	{
		BuildingAsset pAsset = AssetManager.buildings.get(pID);
		return addBuilding(pAsset, pTile, pCheckForBuild, pSfx, pType);
	}

	internal Building addBuilding(BuildingAsset pAsset, WorldTile pTile, bool pCheckForBuild = false, bool pSfx = false, BuildPlacingType pType = BuildPlacingType.New)
	{
		if (pCheckForBuild && !canBuildFrom(pTile, pAsset, null, pType))
		{
			return null;
		}
		Building building = newObject();
		building.create();
		building.setBuilding(pTile, pAsset, null);
		building.checkStartSpawnAnimation();
		if (building.asset.city_building)
		{
			World.world.map_stats.housesBuilt++;
		}
		return building;
	}

	protected override void addObject(Building pObject)
	{
		base.addObject(pObject);
		_job_manager.addNewObject(pObject);
	}

	public override Building loadObject(BuildingData pData)
	{
		if (pData.state == BuildingState.Removed)
		{
			return null;
		}
		BuildingAsset buildingAsset = AssetManager.buildings.get(pData.asset_id);
		if (buildingAsset == null)
		{
			return null;
		}
		WorldTile tileSimple = World.world.GetTileSimple(pData.mainX, pData.mainY);
		if (!canBuildFrom(tileSimple, buildingAsset, null, BuildPlacingType.Load))
		{
			return null;
		}
		Building building = base.loadObject(pData);
		building.create();
		building.setBuilding(tileSimple, buildingAsset, pData);
		building.loadBuilding(pData);
		return building;
	}

	internal bool canBuildFrom(WorldTile pTile, BuildingAsset pNewBuildingAsset, City pCity, BuildPlacingType pType = BuildPlacingType.New, bool pFloraGrowth = false)
	{
		Subspecies subspecies = pCity?.getMainSubspecies();
		bool flag = subspecies != null && pNewBuildingAsset.city_building && pNewBuildingAsset.check_for_adaptation_tags;
		if (flag && pTile.Type.is_biome)
		{
			string only_allowed_to_build_with_tag = pTile.Type.only_allowed_to_build_with_tag;
			if (only_allowed_to_build_with_tag != null && !subspecies.hasMetaTag(only_allowed_to_build_with_tag))
			{
				return false;
			}
		}
		BuildingFundament fundament = pNewBuildingAsset.fundament;
		int num = pTile.x - fundament.left;
		int num2 = pTile.y - fundament.bottom;
		int width = fundament.width;
		int height = fundament.height;
		bool flag2 = false;
		bool flag3 = false;
		bool docks = pNewBuildingAsset.docks;
		List<WorldTile> temp_list_tiles = _temp_list_tiles;
		temp_list_tiles.Clear();
		bool flag4 = !WorldLawLibrary.world_law_roots_without_borders.isEnabled();
		WorldTile worldTile = pCity?.getTile();
		if (pCity != null && worldTile == null)
		{
			return false;
		}
		bool flag5 = pType == BuildPlacingType.New && Randy.randomChance(0.1f);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				WorldTile tile = World.world.GetTile(num + i, num2 + j);
				if (tile == null)
				{
					return false;
				}
				if (flag)
				{
					string only_allowed_to_build_with_tag2 = tile.Type.only_allowed_to_build_with_tag;
					if (only_allowed_to_build_with_tag2 != null && !subspecies.hasMetaTag(only_allowed_to_build_with_tag2))
					{
						return false;
					}
				}
				temp_list_tiles.Add(tile);
				Building building = tile.building;
				TileTypeBase type = tile.Type;
				if (docks)
				{
					if (type.ocean && OceanHelper.goodForNewDock(tile))
					{
						flag3 = true;
					}
					if (type.ground)
					{
						flag2 = true;
					}
				}
				if (pCity != null)
				{
					if (!docks && !tile.isSameIsland(worldTile))
					{
						return false;
					}
					if (!tile.isSameCityHere(pCity))
					{
						return false;
					}
					if (pNewBuildingAsset.only_build_tiles && !type.can_build_on)
					{
						return false;
					}
				}
				if ((pType != BuildPlacingType.Load || (!(type.id == "frozen_low") && !(type.id == "frozen_high"))) && flag4 && !pNewBuildingAsset.isOverlaysBiomeTags(type))
				{
					if (!pFloraGrowth)
					{
						return false;
					}
					if (!pNewBuildingAsset.isOverlaysBiomeSpreadTags(type))
					{
						return false;
					}
				}
				if (pNewBuildingAsset.flora && building != null)
				{
					if (!building.asset.flora)
					{
						return false;
					}
					if (pNewBuildingAsset.flora_size <= building.asset.flora_size)
					{
						if (flag5 && building.asset.flora_size == FloraSize.Tiny && building.asset.flora_size == pNewBuildingAsset.flora_size)
						{
							if (building.asset == pNewBuildingAsset)
							{
								return false;
							}
						}
						else if (!building.isRuin())
						{
							return false;
						}
					}
					if (!tile.canGrow())
					{
						return false;
					}
				}
				if (type.liquid && !pNewBuildingAsset.can_be_placed_on_liquid)
				{
					return false;
				}
				if (pNewBuildingAsset.destroy_on_liquid && type.ocean)
				{
					return false;
				}
				if (!tile.canBuildOn(pNewBuildingAsset))
				{
					return false;
				}
				if (!pNewBuildingAsset.check_for_close_building || pType != 0)
				{
					continue;
				}
				if (i == 0)
				{
					if (isBuildingNearby(tile.tile_left))
					{
						return false;
					}
				}
				else if (i == width - 1 && isBuildingNearby(tile.tile_right))
				{
					return false;
				}
				if (j == 0)
				{
					if (isBuildingNearby(tile.tile_down))
					{
						return false;
					}
					if (tile.has_tile_down && isBuildingNearby(tile.tile_down.tile_down))
					{
						return false;
					}
				}
				else if (j == height - 1)
				{
					if (isBuildingNearby(tile.tile_up))
					{
						return false;
					}
					if (tile.has_tile_up && isBuildingNearby(tile.tile_up.tile_up))
					{
						return false;
					}
				}
			}
		}
		if (docks && pType == BuildPlacingType.New)
		{
			if (flag3 && !flag2)
			{
				for (int k = 0; k < temp_list_tiles.Count; k++)
				{
					WorldTile worldTile2 = temp_list_tiles[k];
					for (int l = 0; l < worldTile2.neighbours.Length; l++)
					{
						WorldTile worldTile3 = worldTile2.neighbours[l];
						if (worldTile3.Type.ground && worldTile3.region.island == worldTile?.region.island)
						{
							return true;
						}
					}
				}
			}
			return false;
		}
		return true;
	}

	private bool isBuildingNearby(WorldTile pTile)
	{
		if (pTile == null)
		{
			return true;
		}
		Building building = pTile.building;
		if (building != null && building.isUsable() && building.asset.city_building)
		{
			return true;
		}
		return false;
	}

	public Building getNearbyBuildingToLive(Actor pActor, bool pOnlyBuilt)
	{
		foreach (Building buildingFromZone in getBuildingFromZones(pActor.current_tile, 10f))
		{
			if (!buildingFromZone.asset.hasHousingSlots() || !buildingFromZone.current_tile.isSameIsland(pActor.current_tile) || !buildingFromZone.hasResidentSlots())
			{
				continue;
			}
			if (pOnlyBuilt)
			{
				if (buildingFromZone.isUnderConstruction())
				{
					continue;
				}
			}
			else if (!buildingFromZone.isUnderConstruction())
			{
				continue;
			}
			if (buildingFromZone.kingdom == pActor.kingdom)
			{
				return buildingFromZone;
			}
		}
		return null;
	}

	public IEnumerable<Building> getBuildingFromZones(WorldTile pTile, float pRadius)
	{
		foreach (Building item in checkZoneForBuilding(pTile, pTile.zone, pRadius))
		{
			yield return item;
		}
		float num = pRadius / 8f;
		int tSize = (int)num + 1;
		int startX = pTile.zone.x - tSize;
		int startY = pTile.zone.y - tSize;
		for (int iX = 0; iX < tSize * 2; iX++)
		{
			for (int iY = 0; iY < tSize * 2; iY++)
			{
				TileZone zone = World.world.zone_calculator.getZone(iX + startX, iY + startY);
				if (zone == null)
				{
					continue;
				}
				foreach (Building item2 in checkZoneForBuilding(pTile, zone, pRadius))
				{
					yield return item2;
				}
			}
		}
	}

	private IEnumerable<Building> checkZoneForBuilding(WorldTile pTile, TileZone pZone, float pRadius)
	{
		if (!pZone.buildings_all.Any())
		{
			yield break;
		}
		float tRadius = pRadius * pRadius;
		foreach (Building item in pZone.buildings_all)
		{
			if ((tRadius == 0f || !((float)Toolbox.SquaredDistTile(item.current_tile, pTile) > tRadius)) && !item.isRuin() && item.current_tile.isSameIsland(pTile))
			{
				yield return item;
			}
		}
	}

	public void debugJobManager(DebugTool pTool)
	{
		_job_manager.debug(pTool);
	}

	private void prepareLists()
	{
		_array_visible_buildings = Toolbox.checkArraySize(_array_visible_buildings, Count);
		render_data.checkSize(Count);
		visible_stockpiles.Clear();
		sparkles.Clear();
		checkContainer();
	}

	internal void calculateVisibleBuildings()
	{
		Bench.bench("buildings_prepare", "game_total");
		prepareLists();
		_visible_buildings_count = 0;
		Bench.benchEnd("buildings_prepare", "game_total", pSaveCounter: false, 0L);
		if (!World.world.quality_changer.shouldRenderBuildings())
		{
			Bench.clearBenchmarkEntrySkipMultiple("game_total", "buildings_render_data_parallel_256", "buildings_fill_visible", "buildings_render_data_normal");
			return;
		}
		Bench.bench("buildings_fill_visible", "game_total");
		fillVisibleObjects();
		Bench.benchEnd("buildings_fill_visible", "game_total", pSaveCounter: false, 0L);
		Bench.bench("buildings_render_data_parallel_256", "game_total");
		precalculateRenderDataParallel();
		Bench.benchEnd("buildings_render_data_parallel_256", "game_total", pSaveCounter: false, 0L);
		Bench.bench("buildings_render_data_normal", "game_total");
		precalculateRenderDataNormal();
		Bench.benchEnd("buildings_render_data_normal", "game_total", pSaveCounter: false, 0L);
	}

	private void fillVisibleObjects()
	{
		Building[] array_visible_buildings = _array_visible_buildings;
		List<TileZone> visibleZones = World.world.zone_camera.getVisibleZones();
		int count = visibleZones.Count;
		int num = 0;
		for (int i = 0; i < count; i++)
		{
			List<Building> buildings_render_list = visibleZones[i].buildings_render_list;
			int count2 = buildings_render_list.Count;
			buildings_render_list.CopyTo(array_visible_buildings, num);
			num += count2;
		}
		_visible_buildings_count = num;
	}

	private void precalculateRenderDataParallel()
	{
		Building[] tArrayVisibleBuildings = _array_visible_buildings;
		bool tNeedShadows = World.world.quality_changer.shouldRenderBuildingShadows();
		int tTotalVisibleObjects = _visible_buildings_count;
		Vector3[] tRenderScales = render_data.scales;
		Vector3[] tRenderPositions = render_data.positions;
		Vector3[] tRenderRotations = render_data.rotations;
		Material[] tRenderMaterials = render_data.materials;
		bool[] tRenderFlipXStates = render_data.flip_x_states;
		Color[] tRenderColors = render_data.colors;
		Sprite[] tRenderMainSprites = render_data.main_sprites;
		Sprite[] tRenderColoredSprites = render_data.colored_sprites;
		bool[] tRenderShadows = render_data.shadows;
		Sprite[] tRenderShadowSprites = render_data.shadow_sprites;
		int tDynamicBatchSize = 256;
		int toExclusive = ParallelHelper.calcTotalBatches(tTotalVisibleObjects, tDynamicBatchSize);
		bool tNeedNormalCheck = false;
		Parallel.For(0, toExclusive, World.world.parallel_options, delegate(int pBatchIndex)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			int num = ParallelHelper.calculateBatchBeg(pBatchIndex, tDynamicBatchSize);
			int num2 = ParallelHelper.calculateBatchEnd(num, tDynamicBatchSize, tTotalVisibleObjects);
			for (int i = num; i < num2; i++)
			{
				Building building = tArrayVisibleBuildings[i];
				BuildingAsset asset = building.asset;
				tRenderScales[i] = building.getCurrentScale();
				tRenderPositions[i] = building.cur_transform_position;
				tRenderRotations[i] = building.current_rotation;
				tRenderMaterials[i] = building.material;
				tRenderFlipXStates[i] = building.flip_x;
				tRenderColors[i] = building.kingdom.asset.color_building;
				Sprite val = building.calculateMainSprite();
				tRenderMainSprites[i] = val;
				if (building.isColoredSpriteNeedsCheck(val))
				{
					tRenderColoredSprites[i] = null;
					tNeedNormalCheck = true;
				}
				else
				{
					tRenderColoredSprites[i] = building.getLastColoredSprite();
				}
				if (tNeedShadows)
				{
					tRenderShadows[i] = asset.shadow && !building.chopped;
					tRenderShadowSprites[i] = DynamicSprites.getShadowBuilding(building.asset, tRenderMainSprites[i]);
				}
				if (asset.is_stockpile)
				{
					tNeedNormalCheck = true;
				}
				if (asset.sparkle_effect)
				{
					tNeedNormalCheck = true;
				}
			}
		});
		_need_normal_check = tNeedNormalCheck;
	}

	private void precalculateRenderDataNormal()
	{
		if (!_need_normal_check)
		{
			return;
		}
		BuildingRenderData buildingRenderData = render_data;
		int visible_buildings_count = _visible_buildings_count;
		Sprite[] colored_sprites = buildingRenderData.colored_sprites;
		Sprite[] main_sprites = buildingRenderData.main_sprites;
		for (int i = 0; i < visible_buildings_count; i++)
		{
			Building building = _array_visible_buildings[i];
			if (building.asset.is_stockpile)
			{
				visible_stockpiles.Add(building);
			}
			if (building.asset.sparkle_effect)
			{
				sparkles.Add(building);
			}
			if (colored_sprites[i] == null)
			{
				colored_sprites[i] = building.calculateColoredSprite(main_sprites[i]);
			}
		}
	}

	public Building[] getVisibleBuildings()
	{
		return _array_visible_buildings;
	}

	public int countVisibleBuildings()
	{
		return _visible_buildings_count;
	}

	public void checkWobblySetting()
	{
		bool flag = PlayerConfig.optionEnabled("tree_wind", OptionType.Bool);
		foreach (DynamicSpritesAsset item in AssetManager.dynamic_sprites_library.list)
		{
			if (item.check_wobbly_setting)
			{
				item.big_atlas = !flag;
			}
		}
		foreach (DynamicSpritesAsset item2 in AssetManager.dynamic_sprites_library.list)
		{
			if (item2.buildings)
			{
				item2.resetAtlas();
			}
		}
		AssetManager.buildings.checkAtlasLink(flag);
		using IEnumerator<Building> enumerator2 = GetEnumerator();
		while (enumerator2.MoveNext())
		{
			Building current3 = enumerator2.Current;
			current3.checkMaterial();
			current3.clearSprites();
		}
	}

	public JobManagerBuildings getJobManager()
	{
		return _job_manager;
	}
}
// --- End of File: BuildingManager.cs ---



// --- Start of File: BuildingMapIcon.cs ---
using UnityEngine;

public class BuildingMapIcon
{
	private BuildingColorPixel[][] _tex;

	private BuildingColorPixel _clear_color_pixel = new BuildingColorPixel(Toolbox.clear, Toolbox.clear, Toolbox.clear);

	private int _width;

	private int _height;

	public BuildingMapIcon(Sprite sprite)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		_width = ((Texture)sprite.texture).width;
		_height = ((Texture)sprite.texture).height;
		_tex = new BuildingColorPixel[_height][];
		for (int i = 0; i < _height; i++)
		{
			BuildingColorPixel[] array = new BuildingColorPixel[_width];
			for (int j = 0; j < _width; j++)
			{
				Color32 val = Color32.op_Implicit(sprite.texture.GetPixel(j, i));
				if (val.a == 0)
				{
					array[j] = _clear_color_pixel;
					continue;
				}
				Color val2 = Toolbox.makeDarkerColor(Color32.op_Implicit(val), 0.9f);
				Color val3 = Toolbox.makeDarkerColor(Color32.op_Implicit(val), 0.6f);
				array[j] = new BuildingColorPixel(val, Color32.op_Implicit(val2), Color32.op_Implicit(val3));
			}
			_tex[i] = array;
		}
	}

	internal Color32 getColor(int pX, int pY, Building pBuilding)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (pX >= _width || pY >= _height)
		{
			return Toolbox.clear;
		}
		BuildingColorPixel buildingColorPixel = _tex[pY][pX];
		Color32 val = buildingColorPixel.color;
		bool flag = false;
		ColorAsset color = pBuilding.kingdom.getColor();
		if (color != null)
		{
			if (Toolbox.areColorsEqual(val, Toolbox.color_magenta_0))
			{
				val = color.k_color_0;
				flag = true;
			}
			else if (Toolbox.areColorsEqual(val, Toolbox.color_magenta_1))
			{
				val = color.k_color_1;
				flag = true;
			}
			else if (Toolbox.areColorsEqual(val, Toolbox.color_magenta_2))
			{
				val = color.k_color_2;
				flag = true;
			}
			else if (Toolbox.areColorsEqual(val, Toolbox.color_magenta_3))
			{
				val = color.k_color_3;
				flag = true;
			}
			else if (Toolbox.areColorsEqual(val, Toolbox.color_magenta_4))
			{
				val = color.k_color_4;
				flag = true;
			}
		}
		if (pBuilding.asset.has_get_map_icon_color && Toolbox.areColorsEqual(val, Toolbox.color_map_icon_green))
		{
			val = pBuilding.asset.get_map_icon_color(pBuilding);
			flag = true;
		}
		if (!flag)
		{
			if (pBuilding.isAbandoned())
			{
				val = buildingColorPixel.color_abandoned;
			}
			else if (pBuilding.isRuin())
			{
				val = buildingColorPixel.color_ruin;
			}
		}
		return val;
	}
}
// --- End of File: BuildingMapIcon.cs ---



// --- Start of File: BuildingMonolith.cs ---
using UnityEngine;

public class BuildingMonolith : BaseBuildingComponent
{
	private const float ACTION_INTERVAL = 10f;

	private float _action_timer = 10f;

	public override void update(float pElapsed)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		base.update(pElapsed);
		if (Date.isMonolithMonth() && building.is_visible && building.isNormal() && Time.frameCount % 30 == 0)
		{
			EffectsLibrary.spawnAt("fx_monolith_glow_2", building.current_tile.posV3, building.current_scale.y);
		}
		if (_action_timer > 0f)
		{
			_action_timer -= pElapsed;
		}
		else if (Date.isMonolithMonth())
		{
			_action_timer = 10f;
			doMonolithAction(building.current_tile);
		}
	}

	internal void doMonolithAction(WorldTile pFromTile, bool pForce = false)
	{
		if (!WorldLawLibrary.world_law_evolution_events.isEnabled())
		{
			return;
		}
		spawnMainEffect();
		World.world.applyForceOnTile(building.current_tile, 10, 3f);
		int num = 3;
		int num2 = 0;
		foreach (Actor item in Finder.getUnitsFromChunk(pFromTile, 1, 0f, pRandom: true))
		{
			if (!item.hasStatus("confused") && item.hasSubspecies() && (Date.isMonolithMonth() || pForce))
			{
				if (ActionLibrary.tryToEvolveUnitViaMonolith(item))
				{
					num2++;
				}
				if (num2 >= num)
				{
					break;
				}
			}
		}
	}

	public void spawnMainEffect()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		EffectsLibrary.spawnAt("fx_monolith_launch_bottom", building.current_tile.posV3, building.current_scale.y);
		EffectsLibrary.spawnAt("fx_monolith_launch", building.current_tile.posV3, building.current_scale.y);
	}
}
// --- End of File: BuildingMonolith.cs ---



// --- Start of File: BuildingOverrideMainSprite.cs ---
using UnityEngine;

public delegate Sprite BuildingOverrideMainSprite(Building pBuilding);
// --- End of File: BuildingOverrideMainSprite.cs ---



// --- Start of File: BuildingOverrideMainSprites.cs ---
using UnityEngine;

public delegate Sprite[] BuildingOverrideMainSprites(Building pBuilding);
// --- End of File: BuildingOverrideMainSprites.cs ---



// --- Start of File: BuildingOwnershipState.cs ---
using System;

[Serializable]
public enum BuildingOwnershipState
{
	None,
	World,
	Civilization
}
// --- End of File: BuildingOwnershipState.cs ---



// --- Start of File: BuildingRenderData.cs ---
using UnityEngine;

public class BuildingRenderData
{
	public Vector3[] positions;

	public Vector3[] scales;

	public Vector3[] rotations;

	public Sprite[] colored_sprites;

	public Sprite[] main_sprites;

	public Material[] materials;

	public bool[] flip_x_states;

	public Color[] colors;

	public bool[] shadows;

	public Sprite[] shadow_sprites;

	public BuildingRenderData(int pCapacity)
	{
		checkSize(pCapacity);
	}

	public void checkSize(int pTargetSize)
	{
		if (positions == null || positions.Length < pTargetSize)
		{
			positions = Toolbox.checkArraySize(positions, pTargetSize);
			scales = Toolbox.checkArraySize(scales, pTargetSize);
			rotations = Toolbox.checkArraySize(rotations, pTargetSize);
			colored_sprites = Toolbox.checkArraySize(colored_sprites, pTargetSize);
			main_sprites = Toolbox.checkArraySize(main_sprites, pTargetSize);
			materials = Toolbox.checkArraySize(materials, pTargetSize);
			flip_x_states = Toolbox.checkArraySize(flip_x_states, pTargetSize);
			colors = Toolbox.checkArraySize(colors, pTargetSize);
			shadows = Toolbox.checkArraySize(shadows, pTargetSize);
			shadow_sprites = Toolbox.checkArraySize(shadow_sprites, pTargetSize);
		}
	}
}
// --- End of File: BuildingRenderData.cs ---



// --- Start of File: BuildingRendererSettings.cs ---
public static class BuildingRendererSettings
{
	private const string material_building = "building";

	public static bool wobbly_material_enabled = true;

	public static string cur_default_material = "building";
}
// --- End of File: BuildingRendererSettings.cs ---



// --- Start of File: BuildingSmokeEffect.cs ---
using UnityEngine;

public class BuildingSmokeEffect : BaseBuildingComponent
{
	private float smokeTimer;

	private Vector3 centerTopVec;

	internal override void create(Building pBuilding)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		base.create(pBuilding);
		Sprite val = building.asset.building_sprites.animation_data[0].main[0];
		centerTopVec = default(Vector3);
		ref Vector3 reference = ref centerTopVec;
		Vector2Int pos = building.current_tile.pos;
		reference.x = ((Vector2Int)(ref pos)).x;
		ref Vector3 reference2 = ref centerTopVec;
		pos = building.current_tile.pos;
		float num = ((Vector2Int)(ref pos)).y;
		Rect rect = val.rect;
		reference2.y = num + ((Rect)(ref rect)).height * building.asset.scale_base.y;
	}

	public override void update(float pElapsed)
	{
		if (building.asset.smoke && !building.isUnderConstruction())
		{
			if (smokeTimer > 0f)
			{
				smokeTimer -= Time.deltaTime;
				return;
			}
			smokeTimer = building.asset.smoke_interval;
			World.world.particles_smoke.spawn(centerTopVec.x, centerTopVec.y, pRemoveCooldown: true);
		}
	}
}
// --- End of File: BuildingSmokeEffect.cs ---



// --- Start of File: BuildingSpreadBiome.cs ---
public class BuildingSpreadBiome : BaseBuildingComponent
{
	private const float SPREAD_INTERVAL_MIN = 8f;

	private const float SPREAD_INTERVAL_MAX = 16f;

	private const int SPREAD_RANGE = 2;

	private BiomeAsset _biome_asset;

	private float _spread_timer = 1f;

	internal override void create(Building pBuilding)
	{
		base.create(pBuilding);
		_biome_asset = AssetManager.biome_library.get(pBuilding.asset.spread_biome_id);
	}

	public override void update(float pElapsed)
	{
		if (WorldLawLibrary.world_law_terramorphing.isEnabled())
		{
			base.update(pElapsed);
			if (_spread_timer > 0f)
			{
				_spread_timer -= pElapsed;
				return;
			}
			_spread_timer = Randy.randomFloat(8f, 16f);
			spreadBiome();
		}
	}

	private void spreadBiome()
	{
		TileTypeBase tileHigh = _biome_asset.getTileHigh();
		WorldTile pAroundTile = ((building.current_tile.Type.biome_asset == tileHigh.biome_asset) ? Toolbox.getRandomTileWithinDistance(building.current_tile, 2) : building.current_tile);
		WorldBehaviourActionBiomes.trySpreadBiomeAround(pAroundTile, tileHigh, pCheckRoad: false, pCheckBonuses: false, pForce: false, pSkipEraCheck: true);
	}

	public override void Dispose()
	{
		_biome_asset = null;
		base.Dispose();
	}
}
// --- End of File: BuildingSpreadBiome.cs ---



// --- Start of File: BuildingSprites.cs ---
using System.Collections.Generic;
using UnityEngine;

public class BuildingSprites
{
	public Sprite construction;

	public BuildingMapIcon map_icon;

	public readonly List<BuildingAnimationData> animation_data = new List<BuildingAnimationData>();
}
// --- End of File: BuildingSprites.cs ---



// --- Start of File: BuildingState.cs ---
using System;

[Serializable]
public enum BuildingState
{
	[Obsolete]
	None,
	Normal,
	[Obsolete]
	CivKingdom,
	[Obsolete]
	CivAbandoned,
	Ruins,
	Removed
}
// --- End of File: BuildingState.cs ---



// --- Start of File: BuildingStepAction.cs ---
public delegate void BuildingStepAction(Actor pActor, Building pBuilding);
// --- End of File: BuildingStepAction.cs ---



// --- Start of File: BuildingTower.cs ---
using UnityEngine;

public class BuildingTower : BaseBuildingComponent
{
	protected float _check_targets_timeout = 1f;

	private bool _test_shooting;

	protected int _shooting_amount;

	private bool _shooting_active;

	protected BaseSimObject _shooting_target;

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		if (!building.isUnderConstruction())
		{
			updateTestShooting();
			updateTower(pElapsed);
		}
	}

	protected void updateTestShooting()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (_test_shooting && Input.GetMouseButtonDown(2))
		{
			Vector3 pLaunchPosition = default(Vector3);
			((Vector3)(ref pLaunchPosition))._002Ector(building.current_tile.posV3.x, building.current_tile.posV3.y);
			pLaunchPosition.y += building.asset.tower_projectile_offset;
			World.world.projectiles.spawn(building, null, building.asset.tower_projectile, pLaunchPosition, World.world.getMouseTilePos().posV3);
		}
	}

	protected virtual void updateTower(float pElapsed)
	{
		if (_shooting_active)
		{
			shootAtTarget();
		}
		else
		{
			updateCheckTargets(pElapsed);
		}
	}

	protected virtual void updateCheckTargets(float pElapsed)
	{
		if (_check_targets_timeout > 0f)
		{
			_check_targets_timeout -= pElapsed;
		}
		else
		{
			checkTargets();
		}
	}

	protected virtual void resetTimeout()
	{
		_check_targets_timeout = building.asset.tower_projectile_reload + Randy.randomFloat(0f, building.asset.tower_projectile_reload);
	}

	protected virtual void shootAtTarget()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (_shooting_target == null || !_shooting_target.isAlive())
		{
			_shooting_active = false;
			return;
		}
		_shooting_amount--;
		if (_shooting_amount <= 0)
		{
			_shooting_active = false;
		}
		Vector3 pLaunchPosition = default(Vector3);
		((Vector3)(ref pLaunchPosition))._002Ector(building.current_tile.posV3.x, building.current_tile.posV3.y);
		pLaunchPosition.y += building.asset.tower_projectile_offset;
		Vector3 posV = _shooting_target.current_tile.posV3;
		posV.x += Randy.randomFloat(0f - (_shooting_target.stats["size"] + 1f), _shooting_target.stats["size"] + 1f);
		posV.y += Randy.randomFloat(0f - _shooting_target.stats["size"], _shooting_target.stats["size"]);
		float pTargetZ = 0f;
		if (_shooting_target.isInAir())
		{
			pTargetZ = _shooting_target.getHeight();
		}
		projectileStarted();
		World.world.projectiles.spawn(building, _shooting_target, building.asset.tower_projectile, pLaunchPosition, posV, pTargetZ);
	}

	protected virtual void projectileStarted()
	{
	}

	protected virtual void checkTargets()
	{
		resetTimeout();
		_shooting_target = null;
		_shooting_active = false;
		_shooting_amount = 0;
		BaseSimObject baseSimObject = findTarget();
		if (baseSimObject != null)
		{
			_shooting_active = true;
			_shooting_target = baseSimObject;
			_shooting_amount = building.asset.tower_projectile_amount;
		}
	}

	protected virtual BaseSimObject findTarget()
	{
		return building.findEnemyObjectTarget(building.asset.tower_attack_buildings);
	}

	public override void Dispose()
	{
		_shooting_target = null;
		base.Dispose();
	}
}
// --- End of File: BuildingTower.cs ---



// --- Start of File: BuildingTweenExtension.cs ---
using System;
using UnityEngine;

public static class BuildingTweenExtension
{
	internal static void checkTweens(this Building pBuilding)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected O, but got Unknown
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Expected O, but got Unknown
		switch (pBuilding.animation_state)
		{
		case BuildingAnimationState.OnRuin:
			pBuilding.setScaleTween(1f, 0.1f, 0f, pBuilding.completeMakingRuin, new EasingFunction(iTween.easeInCubic));
			break;
		case BuildingAnimationState.OnRemove:
		{
			EasingFunction pEase = new EasingFunction(iTween.easeInBack);
			if (pBuilding.chopped)
			{
				pEase = new EasingFunction(iTween.easeInCubic);
				pBuilding.scale_helper.scale_use_x = true;
			}
			pBuilding.setScaleTween(1f, 0.5f, 0f, pBuilding.removeBuildingFinal, pEase, 1);
			if (pBuilding.asset.city_building)
			{
				pBuilding.startShake(0.5f);
			}
			break;
		}
		}
	}

	internal static void setScaleTween(this Building pBuilding, float pFrom = 0f, float pDuration = 0.2f, float pTarget = 1f, Action pActionOnComplete = null, EasingFunction pEase = null, int pPriority = 0)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Expected O, but got Unknown
		BuildingTweenScaleHelper scale_helper = pBuilding.scale_helper;
		if (!scale_helper.active || scale_helper.scale_final_action == null || !(scale_helper.scale_last_priority >= (float)pPriority))
		{
			if (pEase == null)
			{
				pEase = new EasingFunction(iTween.easeOutBack);
			}
			scale_helper.active = true;
			scale_helper.scale_start = pFrom;
			scale_helper.scale_target = pTarget;
			scale_helper.scale_time = World.world.getCurSessionTime() + (double)pDuration;
			scale_helper.scale_duration = pDuration;
			scale_helper.scale_final_action = pActionOnComplete;
			scale_helper.scale_ease = pEase;
			if (scale_helper.scale_use_x)
			{
				pBuilding.current_scale.x = pBuilding.asset.scale_base.x * pFrom;
			}
			else
			{
				pBuilding.current_scale.y = pBuilding.asset.scale_base.y * pFrom;
			}
			pBuilding.batch.c_scale.Add(pBuilding);
		}
	}

	public static void checkFinalAction(this Building pBuilding)
	{
		pBuilding.scale_helper.scale_final_action?.Invoke();
		pBuilding.scale_helper.scale_final_action = null;
		pBuilding.scale_helper.angle_final_action?.Invoke();
		pBuilding.scale_helper.angle_final_action = null;
	}

	internal static void finishScaleTween(this Building pBuilding)
	{
		pBuilding.setAnimationState(BuildingAnimationState.Normal);
		BuildingTweenScaleHelper scale_helper = pBuilding.scale_helper;
		scale_helper.scale_time = World.world.getCurSessionTime() + (double)scale_helper.scale_duration;
	}

	internal static void updateAngle(this Building pBuilding, float pElapsed)
	{
		if (pBuilding.current_rotation.z != pBuilding.scale_helper.angle_target)
		{
			BuildingTweenScaleHelper scale_helper = pBuilding.scale_helper;
			scale_helper.angle_time += pElapsed;
			if (scale_helper.angle_time >= 1f)
			{
				scale_helper.angle_time = 1f;
				pBuilding.batch.c_angle.Remove(pBuilding);
				pBuilding.batch.actions_to_run.Add(pBuilding.checkFinalAction);
			}
			float num = iTween.easeInExpo(0f, 1f, scale_helper.angle_time);
			((Vector3)(ref pBuilding.current_rotation)).Set(0f, 0f, num * pBuilding.scale_helper.angle_target);
		}
	}

	internal static void updateScale(this Building pBuilding)
	{
		if (pBuilding.scale_helper.active)
		{
			BuildingTweenScaleHelper scale_helper = pBuilding.scale_helper;
			double num = scale_helper.scale_time - World.world.getCurSessionTime();
			float num2 = 1f;
			if (num <= 0.0)
			{
				scale_helper.scale_time = World.world.getCurSessionTime() + (double)scale_helper.scale_duration;
				scale_helper.active = false;
				pBuilding.batch.actions_to_run.Add(pBuilding.checkFinalAction);
				pBuilding.batch.c_scale.Remove(pBuilding);
				num2 = scale_helper.scale_target;
			}
			else
			{
				float num3 = (float)(((double)scale_helper.scale_duration - num) / (double)scale_helper.scale_duration);
				num2 = scale_helper.scale_ease.Invoke(scale_helper.scale_start, scale_helper.scale_target, num3);
			}
			if (scale_helper.scale_use_x)
			{
				pBuilding.current_scale.x = pBuilding.asset.scale_base.x * num2;
			}
			else
			{
				pBuilding.current_scale.y = pBuilding.asset.scale_base.y * num2;
			}
		}
	}
}
// --- End of File: BuildingTweenExtension.cs ---



// --- Start of File: BuildingTweenScaleHelper.cs ---
using System;

public class BuildingTweenScaleHelper
{
	internal bool active;

	internal float scale_start;

	internal float scale_target = 1f;

	internal double scale_time;

	internal float scale_duration = 1f;

	internal float scale_last_priority;

	internal bool scale_use_x;

	internal Action scale_final_action;

	internal EasingFunction scale_ease;

	public float angle_target;

	public float angle_duration;

	public float angle_time;

	internal Action angle_final_action;

	public void doRotateTween(float pTargetAngle, float pDuration, Action pAction)
	{
		angle_target = pTargetAngle;
		angle_duration = pDuration;
		angle_final_action = pAction;
		angle_time = 0f;
	}

	public void reset()
	{
		active = false;
		scale_start = 0f;
		scale_target = 1f;
		scale_time = 0.0;
		scale_duration = 1f;
		scale_last_priority = 0f;
		scale_use_x = false;
		scale_final_action = null;
		scale_ease = null;
		angle_target = 0f;
		angle_duration = 0f;
		angle_time = 0f;
		angle_final_action = null;
	}
}
// --- End of File: BuildingTweenScaleHelper.cs ---



// --- Start of File: BuildingType.cs ---
public enum BuildingType
{
	Building_None,
	Building_Tree,
	Building_Fruits,
	Building_Hives,
	Building_Poops,
	Building_Wheat,
	Building_Plant,
	Building_Mineral,
	Building_Nature,
	Building_Mob,
	Building_Creep,
	Building_Civ
}
// --- End of File: BuildingType.cs ---



// --- Start of File: BuildingWaypoint.cs ---
public abstract class BuildingWaypoint : BaseBuildingComponent
{
	private const int UNITS_AFFECTED_PER_ACTION = 5;

	private const float ACTION_INTERVAL = 20f;

	private float _action_timer = 20f;

	protected abstract string effect_id { get; }

	protected abstract string trait_id { get; }

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		if (_action_timer > 0f)
		{
			_action_timer -= pElapsed;
			return;
		}
		_action_timer = 20f;
		doAction(building.current_tile);
	}

	internal void doAction(WorldTile pFromTile)
	{
		spawnMainEffect();
		World.world.applyForceOnTile(building.current_tile, 10, 3f);
		int num = 0;
		foreach (Actor item in Finder.getUnitsFromChunk(pFromTile, 1, 0f, pRandom: true))
		{
			if (!item.hasTrait(trait_id))
			{
				if (item.addTrait(trait_id))
				{
					num++;
				}
				if (num >= 5)
				{
					break;
				}
			}
		}
	}

	public void spawnMainEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		EffectsLibrary.spawnAt(effect_id, building.current_tile.posV3, building.current_scale.y);
	}
}
// --- End of File: BuildingWaypoint.cs ---



// --- Start of File: BuildingWaypointAlienMold.cs ---
public class BuildingWaypointAlienMold : BuildingWaypoint
{
	protected override string effect_id => "fx_waypoint_alien_mold_launch_bottom";

	protected override string trait_id => "desire_alien_mold";
}
// --- End of File: BuildingWaypointAlienMold.cs ---



// --- Start of File: BuildingWaypointComputer.cs ---
public class BuildingWaypointComputer : BuildingWaypoint
{
	protected override string effect_id => "fx_waypoint_computer_launch_bottom";

	protected override string trait_id => "desire_computer";
}
// --- End of File: BuildingWaypointComputer.cs ---



// --- Start of File: BuildingWaypointGoldenEgg.cs ---
public class BuildingWaypointGoldenEgg : BuildingWaypoint
{
	protected override string effect_id => "fx_waypoint_golden_egg_launch_bottom";

	protected override string trait_id => "desire_golden_egg";
}
// --- End of File: BuildingWaypointGoldenEgg.cs ---



// --- Start of File: BuildingWaypointHarp.cs ---
public class BuildingWaypointHarp : BuildingWaypoint
{
	protected override string effect_id => "fx_waypoint_harp_launch_bottom";

	protected override string trait_id => "desire_harp";
}
// --- End of File: BuildingWaypointHarp.cs ---



// --- Start of File: BuildingZonesSystem.cs ---
using System.Collections.Generic;

public class BuildingZonesSystem
{
	private static bool _dirty;

	public static void setDirty()
	{
		_dirty = true;
	}

	public static void update()
	{
		if (!_dirty)
		{
			return;
		}
		_dirty = false;
		List<TileZone> zones = World.world.zone_calculator.zones;
		using ListPool<TileZone> listPool = new ListPool<TileZone>();
		for (int i = 0; i < zones.Count; i++)
		{
			TileZone tileZone = zones[i];
			if (tileZone.isDirty())
			{
				listPool.Add(tileZone);
			}
		}
		for (int j = 0; j < listPool.Count; j++)
		{
			TileZone tileZone2 = listPool[j];
			tileZone2.clearBuildingLists();
			tileZone2.setDirty(pValue: false);
			foreach (Building item in tileZone2.buildings_all)
			{
				if (item.isOnRemove() || item.isRemoved())
				{
					continue;
				}
				if (item.current_tile.zone == tileZone2)
				{
					tileZone2.buildings_render_list.Add(item);
				}
				tileZone2.addBuildingToSet(item);
				if (item.asset.city_building && !tileZone2.hasCity())
				{
					if (item.isCiv())
					{
						item.makeAbandoned();
					}
					else
					{
						item.makeAbandoned();
					}
				}
			}
		}
	}
}
// --- End of File: BuildingZonesSystem.cs ---



// --- Start of File: BuildOrder.cs ---
using System;

[Serializable]
public class BuildOrder : Asset
{
	public int required_pop;

	public int required_buildings;

	public int limit_type;

	public bool check_full_village;

	public bool check_house_limit;

	public int min_zones;

	public bool upgrade;

	public string[] requirements_orders;

	public string[] requirements_types;

	public BuildingAsset getBuildingAsset(City pCity, string pOrderID = null)
	{
		if (string.IsNullOrEmpty(pOrderID))
		{
			pOrderID = id;
		}
		return pCity.getActorAsset().architecture_asset.getBuilding(pOrderID);
	}
}
// --- End of File: BuildOrder.cs ---



// --- Start of File: BuildOrderLibrary.cs ---
public class BuildOrderLibrary : AssetLibrary<CityBuildOrderAsset>
{
	public static BuildOrder b;

	public override void init()
	{
		base.init();
		initCivsBasic();
		initCivsBasic2();
		initCivsAdvanced();
	}

	private void initCivsBasic()
	{
		add(new CityBuildOrderAsset
		{
			id = "build_order_basic"
		});
		t.addBuilding("order_bonfire", 1);
		t.addBuilding("order_stockpile", 1);
		t.addBuilding("order_hall_0", 1);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_house_0", 0, 0, 0, pCheckFullVillage: false, pCheckHouseLimit: true);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_watch_tower", 1, 30, 10);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		t.addBuilding("order_temple", 1, 90, 20, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0", "order_statue");
		t.addBuilding("order_statue", 1, 70, 15);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		t.addBuilding("order_well", 1, 20, 10);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		t.addBuilding("order_mine", 1, 20, 10);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_library", 1, 50, 15);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_docks_0", 5, 0, 2);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addUpgrade("order_docks_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		t.addBuilding("order_windmill_0", 1, 6, 5);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_barracks", 1, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_training_dummy", 3, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
	}

	private void initCivsBasic2()
	{
		add(new CityBuildOrderAsset
		{
			id = "build_order_basic_2"
		});
		t.addBuilding("order_bonfire", 1);
		t.addBuilding("order_stockpile", 1);
		t.addBuilding("order_hall_0", 1);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_house_0", 0, 0, 0, pCheckFullVillage: false, pCheckHouseLimit: true);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_watch_tower", 1, 30, 10);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		t.addBuilding("order_temple", 1, 90, 20, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		t.addBuilding("order_mine", 1, 20, 10);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_library", 1, 50, 15);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_docks_0", 5, 0, 2);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addUpgrade("order_docks_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		t.addBuilding("order_windmill_0", 1, 6, 5);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_barracks", 1, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_training_dummy", 3, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
	}

	private void initCivsAdvanced()
	{
		add(new CityBuildOrderAsset
		{
			id = "build_order_advanced"
		});
		t.addBuilding("order_hall_0", 1);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_bonfire", 1);
		t.addBuilding("order_stockpile", 1);
		t.addBuilding("order_house_0", 0, 0, 0, pCheckFullVillage: false, pCheckHouseLimit: true);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addBuilding("order_tent", 0, 0, 0, pCheckFullVillage: false, pCheckHouseLimit: true);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addUpgrade("order_tent");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_tent");
		t.addUpgrade("order_house_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_0", "order_house_0");
		t.addUpgrade("order_house_1");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1", "order_house_1");
		t.addUpgrade("order_house_2");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1", "order_house_2");
		t.addUpgrade("order_house_3");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_2", "order_house_3");
		t.addUpgrade("order_house_4");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_2", "order_house_4");
		t.addUpgrade("order_hall_0", 0, 30, 8);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_house_1");
		t.addUpgrade("order_hall_1", 0, 100, 20);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_statue", "order_mine", "order_barracks");
		t.addBuilding("order_windmill_0", 1, 6, 5);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addUpgrade("order_windmill_0", 0, 40, 10);
		t.addBuilding("order_docks_0", 5, 0, 2);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		t.addUpgrade("order_docks_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		t.addBuilding("order_well", 1, 20, 10);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		t.addBuilding("order_mine", 1, 20, 10);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		t.addBuilding("order_barracks", 1, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1");
		t.addBuilding("order_training_dummy", 3, 50, 16, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
		t.addBuilding("order_watch_tower", 1, 30, 10);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		t.addBuilding("order_temple", 1, 90, 20, pCheckFullVillage: false, pCheckHouseLimit: false, 20);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_1", "order_statue");
		t.addBuilding("order_statue", 1, 70, 15);
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1");
		t.addBuilding("order_library", 1, 50, 15);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		t.addBuilding("order_market", 1, 60, 15);
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
	}

	public override void linkAssets()
	{
		base.linkAssets();
		foreach (CityBuildOrderAsset item in list)
		{
			item.prepareForAssetGeneration();
		}
	}
}
// --- End of File: BuildOrderLibrary.cs ---



// --- Start of File: BuildPlacingType.cs ---
public enum BuildPlacingType
{
	New,
	Load
}
// --- End of File: BuildPlacingType.cs ---



// --- Start of File: BurnedTilesLayer.cs ---
using UnityEngine;

public class BurnedTilesLayer : MapLayer
{
	public Color color;

	private WorldBehaviour worldBehaviour;

	internal override void create()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		colorValues = new Color(color.r, color.g, color.b, 0.5f);
		colors_amount = 15;
		autoDisable = false;
		base.create();
		((Behaviour)this).enabled = true;
	}

	public void setTileDirty(WorldTile pTile)
	{
		if (!pixels_to_update.Contains(pTile))
		{
			pixels_to_update.Add(pTile);
		}
	}

	protected override void UpdateDirty(float pElapsed)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (pixels_to_update.Count <= 0)
		{
			return;
		}
		foreach (WorldTile item in pixels_to_update)
		{
			if (item.burned_stages > 0)
			{
				pixels[item.data.tile_id] = colors[item.burned_stages - 1];
			}
			else
			{
				pixels[item.data.tile_id] = Toolbox.clear;
			}
		}
		pixels_to_update.Clear();
		updatePixels();
	}
}
// --- End of File: BurnedTilesLayer.cs ---



// --- Start of File: ButtonAnimation.cs ---
using System.Collections;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;

public class ButtonAnimation : MonoBehaviour
{
	public static float scaleTime = 0.1f;

	private IEnumerator newAnim()
	{
		((Component)this).gameObject.transform.localScale = new Vector3(0.9f, 0.9f, 0.9f);
		yield return CoroutineHelper.wait_for_0_01_s;
		TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(((Component)this).gameObject.transform, 1f, scaleTime), (Ease)28);
	}

	public void clickAnimation()
	{
		if (((Component)this).gameObject.activeSelf)
		{
			((MonoBehaviour)this).StartCoroutine(newAnim());
		}
	}
}
// --- End of File: ButtonAnimation.cs ---



// --- Start of File: ButtonClickMaptemplate.cs ---
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ButtonClickMaptemplate : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class _003C_003Ec
	{
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();

		public static UnityAction _003C_003E9__2_1;

		internal void _003CAwake_003Eb__2_1()
		{
			if (InputHelpers.mouseSupported)
			{
				Tooltip.hideTooltip();
			}
		}
	}

	private Button _button;

	private MapGenTemplate _template;

	private void Awake()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Expected O, but got Unknown
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Expected O, but got Unknown
		string name = ((Object)((Component)this).transform).name;
		_button = ((Component)this).GetComponent<Button>();
		((UnityEvent)_button.onClick).AddListener(new UnityAction(click));
		if (Input.mousePresent)
		{
			_button.OnHover((UnityAction)delegate
			{
				if (InputHelpers.mouseSupported)
				{
					showTooltip();
				}
			});
			Button button = _button;
			object obj = _003C_003Ec._003C_003E9__2_1;
			if (obj == null)
			{
				UnityAction val = delegate
				{
					if (InputHelpers.mouseSupported)
					{
						Tooltip.hideTooltip();
					}
				};
				_003C_003Ec._003C_003E9__2_1 = val;
				obj = (object)val;
			}
			button.OnHoverOut((UnityAction)obj);
		}
		_template = AssetManager.map_gen_templates.get(name);
		((Component)((Component)this).transform.Find("preview_icon")).GetComponent<Image>().sprite = SpriteTextureLoader.getSprite(_template.path_icon);
	}

	private void showTooltip()
	{
		Tooltip.show(((Component)_button).gameObject, "normal", new TooltipData
		{
			tip_name = _template.getLocaleID(),
			tip_description = _template.getDescriptionID()
		});
	}

	public void click()
	{
		if (!InputHelpers.mouseSupported)
		{
			if (!Tooltip.isShowingFor(((Component)_button).gameObject))
			{
				showTooltip();
				return;
			}
			Tooltip.hideTooltipNow();
		}
		Config.current_map_template = _template.id;
		ScrollWindow.showWindow("new_world_templates_2");
	}
}
// --- End of File: ButtonClickMaptemplate.cs ---



// --- Start of File: ButtonDestroyer.cs ---
using UnityEngine;

public class ButtonDestroyer : MonoBehaviour
{
	private void Awake()
	{
		if (Globals.specialAbstudio)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
		}
	}
}
// --- End of File: ButtonDestroyer.cs ---



// --- Start of File: ButtonEmail.cs ---
using System;
using UnityEngine;
using UnityEngine.Networking;

public class ButtonEmail : MonoBehaviour
{
	public void SendEmail()
	{
		string text = "supworldbox@gmail.com";
		string text2 = convert("WorldBox Feedback ( " + Application.version + " )");
		string text3 = convert("Yo!\r\n");
		Application.OpenURL("mailto:" + text + "?subject=" + text2 + "&body=" + text3);
		Analytics.LogEvent("clicked_send_email");
	}

	public void SendEmailLogs()
	{
		string text = "supworldbox+errors@gmail.com";
		string text2 = convert("WorldBox Error Logs ( " + Application.version + " )");
		string text3 = convert("Please take a look at this error :\r\n" + LogHandler.log.Substring(Math.Max(0, LogHandler.log.Length - 4000)));
		Application.OpenURL("mailto:" + text + "?subject=" + text2 + "&body=" + text3);
		Analytics.LogEvent("clicked_send_error_email");
	}

	private string convert(string url)
	{
		return UnityWebRequest.EscapeURL(url).Replace("+", "%20");
	}
}
// --- End of File: ButtonEmail.cs ---



// --- Start of File: ButtonEvent.cs ---
using System;
using UnityEngine;

public class ButtonEvent : MonoBehaviour
{
	public static int premium_restore_opened;

	public static int premium_restore_action_pressed;

	public static int premium_more_help_pressed;

	public void clickGenerateMap(string pValue)
	{
		World.world.clickGenerateNewMap();
	}

	public void clickPremiumButton()
	{
		ScrollWindow.showWindow("steam");
	}

	public void clickPossess()
	{
		using ListPool<Actor> listPool = new ListPool<Actor>(SelectedUnit.getAllSelected().Count);
		foreach (Actor item in SelectedUnit.getAllSelected())
		{
			if (item.asset.allow_possession)
			{
				listPool.Add(item);
			}
		}
		if (listPool.Count != 0)
		{
			ControllableUnit.setControllableCreatures(listPool);
			ScrollWindow.hideAllEvent();
		}
	}

	public void openUnitTabTraitsEditor()
	{
		ActionLibrary.openUnitWindow(SelectedUnit.unit);
		ScrollWindow.getCurrentWindow().tabs.showTab("Traits");
	}

	public void openUnitTabEquipmentEditor()
	{
		ActionLibrary.openUnitWindow(SelectedUnit.unit);
		ScrollWindow.getCurrentWindow().tabs.showTab("Equipment");
	}

	public void openUnitTabMind()
	{
		ActionLibrary.openUnitWindow(SelectedUnit.unit);
		ScrollWindow.getCurrentWindow().tabs.showTab("Mind");
	}

	public void openUnitTabGenealogy()
	{
		ActionLibrary.openUnitWindow(SelectedUnit.unit);
		ScrollWindow.getCurrentWindow().tabs.showTab("Genealogy");
	}

	public void openUnitTabPlot()
	{
		ActionLibrary.openUnitWindow(SelectedUnit.unit);
		ScrollWindow.getCurrentWindow().tabs.showTab("Plots");
	}

	public void openUnitSpectate()
	{
		World.world.followUnit(SelectedUnit.unit);
		ScrollWindow.hideAllEvent();
	}

	public void openSettings()
	{
		ScrollWindow.showWindow("settings");
	}

	public void openSavesList()
	{
		ScrollWindow.showWindow("saves_list");
	}

	public void openPremiumHelp()
	{
		premium_restore_opened++;
		ScrollWindow.showWindow("premium_help");
	}

	public void openPremiumHelpFaq()
	{
		premium_more_help_pressed++;
		if (Config.isAndroid || Config.isEditor)
		{
			Application.OpenURL("https://www.superworldbox.com/faq#i-purchased-the-premium-on-android-but-haven-t-received-it-or-you-trying-to-play-on-new-another-android-device-with-the-same-account");
		}
		else if (Config.isIos)
		{
			Application.OpenURL("https://www.superworldbox.com/faq#i-purchased-the-premium-on-ios-and-later-got-a-new-apple-device-how-do-i-restore-premium");
		}
	}

	public void openPatchNotes()
	{
		ScrollWindow.showWindow("patch_log");
		Analytics.LogEvent("open_link_changelog");
	}

	public void clickRewardAds()
	{
		if (!ScrollWindow.isCurrentWindow("reward_ads"))
		{
			ScrollWindow.showWindow("reward_ads");
		}
	}

	public void showWindow(string pID)
	{
		ScrollWindow.showWindow(pID);
	}

	public void locateSelectedVillage()
	{
		World.world.locateSelectedVillage();
	}

	public void locateSelectedUnit()
	{
		World.world.followUnit(SelectedUnit.unit);
		ScrollWindow.hideAllEvent();
	}

	public void locateSelectedArmy()
	{
		Army selected_army = SelectedMetas.selected_army;
		Actor pActor = ((!selected_army.hasCaptain()) ? selected_army.units.GetRandom() : selected_army.getCaptain());
		World.world.followUnit(pActor);
		ScrollWindow.hideAllEvent();
	}

	public void startLoadSaveSlot()
	{
		AutoSaveManager.autoSave(pSkipDelete: true);
		World.world.save_manager.startLoadSlot();
	}

	public void clickSaveSlot()
	{
		AutoSaveManager.resetAutoSaveTimer();
		World.world.save_manager.clickSaveSlot();
	}

	public void confirmDeleteWorld()
	{
		SaveManager.deleteCurrentSave();
	}

	public void startTutorialBear()
	{
		World.world.tutorial.startTutorial();
	}

	public void showRewardedAd()
	{
		PlayerConfig.instance.data.powerReward = string.Empty;
		if (Config.isMobile || Config.isEditor)
		{
			RewardedAds.instance.ShowRewardedAd("gift");
		}
	}

	public void showRewardedSaveSlotAd()
	{
		PlayerConfig.instance.data.powerReward = "saveslots";
		if (Config.isMobile || Config.isEditor)
		{
			RewardedAds.instance.ShowRewardedAd("save_slot");
		}
	}

	public void hideRewardWindowAndHighlightPower()
	{
		if (!ScrollWindow.isCurrentWindow("reward_ads_received"))
		{
			return;
		}
		ScrollWindow.get("reward_ads_received").clickHide();
		if (!(PlayerConfig.instance.data.lastReward != string.Empty))
		{
			return;
		}
		if (PlayerConfig.instance.data.lastReward.StartsWith("saveslots", StringComparison.Ordinal))
		{
			ScrollWindow.showWindow("saves_list");
		}
		else
		{
			PowerButton powerButton = PowerButton.get(PlayerConfig.instance.data.lastReward);
			if ((Object)(object)powerButton == (Object)null)
			{
				return;
			}
			powerButton.selectPowerTab();
		}
		PlayerConfig.instance.data.lastReward = string.Empty;
	}

	public void clickUnHideUI()
	{
		Config.ui_main_hidden = false;
	}

	public void closeActivePowerBar()
	{
		PowersTab.unselect();
	}

	public void clickOpenMain()
	{
		PowerTabAsset asset = PowersTab.getActiveTab().getAsset();
		asset.on_main_info_click(asset);
	}

	public void clickBackTab()
	{
		if (!SelectedTabsHistory.showPreviousTab())
		{
			PowerTabController.showMainTab();
		}
	}

	public void restorePurchases()
	{
		premium_restore_action_pressed++;
		InAppManager.instance.RestorePurchases();
	}

	public void debugUnlockAll()
	{
		GameProgress.instance.debugUnlockAll();
		PowerButton.checkActorSpawnButtons();
	}

	public void debugClearAllProgress()
	{
		GameProgress.instance.debugClearAll();
		PowerButton.checkActorSpawnButtons();
	}

	public void debugClearAchievements()
	{
		GameProgress.instance.debugClearAllAchievements();
		PowerButton.checkActorSpawnButtons();
	}

	public void debugUnlockAllAchievements()
	{
		GameProgress.instance.unlockAllAchievements();
		PowerButton.checkActorSpawnButtons();
	}

	public void debugClearBannedSignals()
	{
		foreach (SignalAsset item in AssetManager.signals.list)
		{
			item.unban();
		}
	}
}
// --- End of File: ButtonEvent.cs ---



// --- Start of File: ButtonExtensions.cs ---
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.UI;

public static class ButtonExtensions
{
	public static void TriggerHover(this Button button)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		if (Input.mousePresent)
		{
			EventTrigger val = ((Component)button).gameObject.GetComponent<EventTrigger>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)button).gameObject.AddComponent<EventTrigger>();
			}
			val.OnPointerEnter(new PointerEventData(EventSystem.current));
		}
	}

	public static void OnHover(this Button button, UnityAction call)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.mousePresent)
		{
			EventTrigger val = ((Component)button).gameObject.GetComponent<EventTrigger>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)button).gameObject.AddComponent<EventTrigger>();
			}
			Entry val2 = new Entry();
			val2.eventID = (EventTriggerType)0;
			((UnityEvent<BaseEventData>)(object)val2.callback).AddListener((UnityAction<BaseEventData>)delegate
			{
				call.Invoke();
			});
			val.triggers.Add(val2);
		}
	}

	public static void OnHoverOut(this Button button, UnityAction call)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.mousePresent)
		{
			EventTrigger val = ((Component)button).gameObject.GetComponent<EventTrigger>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)button).gameObject.AddComponent<EventTrigger>();
			}
			Entry val2 = new Entry();
			val2.eventID = (EventTriggerType)1;
			((UnityEvent<BaseEventData>)(object)val2.callback).AddListener((UnityAction<BaseEventData>)delegate
			{
				call.Invoke();
			});
			val.triggers.Add(val2);
		}
	}

	public static void OnHover(this Slider slider, UnityAction call)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.mousePresent)
		{
			EventTrigger val = ((Component)slider).gameObject.GetComponent<EventTrigger>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)slider).gameObject.AddComponent<EventTrigger>();
			}
			Entry val2 = new Entry();
			val2.eventID = (EventTriggerType)0;
			((UnityEvent<BaseEventData>)(object)val2.callback).AddListener((UnityAction<BaseEventData>)delegate
			{
				call.Invoke();
			});
			val.triggers.Add(val2);
		}
	}

	public static void OnHoverOut(this Slider slider, UnityAction call)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.mousePresent)
		{
			EventTrigger val = ((Component)slider).gameObject.GetComponent<EventTrigger>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)slider).gameObject.AddComponent<EventTrigger>();
			}
			Entry val2 = new Entry();
			val2.eventID = (EventTriggerType)1;
			((UnityEvent<BaseEventData>)(object)val2.callback).AddListener((UnityAction<BaseEventData>)delegate
			{
				call.Invoke();
			});
			val.triggers.Add(val2);
		}
	}
}
// --- End of File: ButtonExtensions.cs ---



// --- Start of File: ButtonGraphCategory.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ButtonGraphCategory : MonoBehaviour
{
	public Sprite sprite_on;

	public Sprite sprite_off;

	public Sprite sprite_on_light;

	private Image _button_graphics;

	private Image _icon;

	public bool is_on;

	private GraphCategoriesContainer _main_container;

	private Text _text;

	private Image _colored_circle;

	private Image _background_circle;

	private TipButton _tip_button;

	private HistoryDataAsset _asset;

	private bool _initialized;

	private void Awake()
	{
		init();
	}

	public void init()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		if (_initialized)
		{
			return;
		}
		_initialized = true;
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener(new UnityAction(switchCategory));
		_tip_button = ((Component)this).GetComponent<TipButton>();
		_button_graphics = ((Component)this).GetComponent<Image>();
		_icon = ((Component)((Component)this).transform.FindRecursive("Icon")).GetComponent<Image>();
		_main_container = ((Component)this).GetComponentInParent<GraphCategoriesContainer>();
		_text = ((Component)((Component)this).transform.FindRecursive("Title")).GetComponent<Text>();
		_colored_circle = ((Component)((Component)this).transform.FindRecursive("Colored Circle")).GetComponent<Image>();
		_background_circle = ((Component)((Component)this).transform.FindRecursive("Background Circle")).GetComponent<Image>();
		_tip_button.hoverAction = delegate
		{
			if (InputHelpers.mouseSupported)
			{
				showTooltip();
			}
		};
		checkSpriteStatus();
	}

	public void setAsset(HistoryDataAsset pAsset)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (pAsset != null)
		{
			_asset = pAsset;
			((Graphic)_colored_circle).color = pAsset.getColorMain();
			_icon.sprite = SpriteTextureLoader.getSprite(pAsset.path_icon);
		}
	}

	private void Update()
	{
		checkSpriteStatus();
	}

	private void checkSpriteStatus()
	{
		if (is_on)
		{
			_button_graphics.sprite = sprite_on;
			((Component)_background_circle).gameObject.SetActive(true);
		}
		else
		{
			_button_graphics.sprite = sprite_off;
			((Component)_background_circle).gameObject.SetActive(false);
		}
	}

	private void switchCategory()
	{
		if (!InputHelpers.mouseSupported && !Tooltip.isShowingFor(this))
		{
			showTooltip();
		}
		is_on = !is_on;
		_main_container.setCategoryEnabled(((Object)this).name, is_on);
	}

	private void showTooltip()
	{
		TooltipData pData = new TooltipData
		{
			tip_name = _asset.getLocaleID(),
			tip_description = _asset.getDescriptionID(),
			tip_description_2 = "graph_tip"
		};
		Tooltip.show(this, "tip", pData);
	}

	public void turnOff()
	{
		is_on = false;
	}

	public void turnOn()
	{
		is_on = true;
	}
}
// --- End of File: ButtonGraphCategory.cs ---



// --- Start of File: ButtonGraphListCompare.cs ---
using UnityEngine;

public class ButtonGraphListCompare : MonoBehaviour
{
	public void compareListItems()
	{
		ScrollWindow currentWindow = ScrollWindow.getCurrentWindow();
		IComponentList componentInChildren = ((Component)currentWindow).GetComponentInChildren<IComponentList>(true);
		if (componentInChildren == null)
		{
			Debug.LogError((object)("IComponentList missing in " + ((Object)((Component)currentWindow).gameObject).name), (Object)(object)((Component)currentWindow).gameObject);
			return;
		}
		using ListPool<NanoObject> listPool = componentInChildren.getElements();
		if (listPool.Count > 0)
		{
			Config.selected_objects_graph.Clear();
			for (int i = 0; i < listPool.Count && i < 3; i++)
			{
				NanoObject pObject = listPool[i];
				Config.selected_objects_graph.Add(pObject);
			}
		}
		ScrollWindow.showWindow("chart_comparer");
	}
}
// --- End of File: ButtonGraphListCompare.cs ---



// --- Start of File: ButtonGraphScale.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ButtonGraphScale : MonoBehaviour
{
	public Sprite sprite_on;

	public Sprite sprite_off;

	public GraphTimeScale button_scale;

	private GraphTimeScaleContainer _main_container;

	private GraphController _graph_controller;

	private Image _image;

	private void Awake()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener(new UnityAction(setScale));
		_image = ((Component)this).GetComponent<Image>();
		_main_container = ((Component)this).GetComponentInParent<GraphTimeScaleContainer>();
		_graph_controller = ((Component)((Component)this).transform.parent.parent).GetComponentInChildren<GraphController>();
		checkSpriteStatus();
	}

	private void Update()
	{
		checkSpriteStatus();
	}

	private void checkSpriteStatus()
	{
		if (_main_container.current_scale == button_scale)
		{
			_image.sprite = sprite_on;
		}
		else
		{
			_image.sprite = sprite_off;
		}
	}

	public void setScale()
	{
		_main_container.setTimeScale(button_scale);
		_graph_controller.forceUpdateGraph();
	}
}
// --- End of File: ButtonGraphScale.cs ---



// --- Start of File: ButtonGraphScalePlusMinus.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ButtonGraphScalePlusMinus : MonoBehaviour
{
	public ButtonGraphScaleType button_scale_type;

	private GraphTimeScaleContainer _main_container;

	private GraphController _graph_controller;

	private void Awake()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener(new UnityAction(setScale));
		_main_container = ((Component)this).GetComponentInParent<GraphTimeScaleContainer>();
		_graph_controller = ((Component)((Component)this).transform.parent.parent).GetComponentInChildren<GraphController>();
	}

	public void setScale()
	{
		if (button_scale_type == ButtonGraphScaleType.Plus)
		{
			_main_container.timeScaleMinus();
		}
		else
		{
			_main_container.timeScalePlus();
		}
		_graph_controller.forceUpdateGraph();
	}
}
// --- End of File: ButtonGraphScalePlusMinus.cs ---



// --- Start of File: ButtonGraphScaleType.cs ---
public enum ButtonGraphScaleType
{
	Plus,
	Minus
}
// --- End of File: ButtonGraphScaleType.cs ---



// --- Start of File: ButtonPremium.cs ---
using UnityEngine;

public class ButtonPremium : MonoBehaviour
{
	public void clickPremium()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		PlayerConfig.setFirebaseProp("clicked_buy_premium", "yes");
		Analytics.LogEvent("clicked_buy_premium");
		if ((int)Application.internetReachability == 0)
		{
			ScrollWindow.showWindow("premium_purchase_error");
		}
		else
		{
			InAppManager.instance.buyPremium();
		}
	}
}
// --- End of File: ButtonPremium.cs ---



// --- Start of File: ButtonResource.cs ---
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ButtonResource : MonoBehaviour
{
	public Text textAmount;

	public ResourceAsset asset;

	public static float scaleTime = 0.1f;

	private void Start()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		Button component = ((Component)this).GetComponent<Button>();
		((UnityEvent)component.onClick).AddListener(new UnityAction(showTooltip));
		component.OnHover(new UnityAction(showHoverTooltip));
		component.OnHoverOut(new UnityAction(Tooltip.hideTooltip));
	}

	internal void load(ResourceAsset pAsset, int pAmount)
	{
		asset = pAsset;
		if (asset != null)
		{
			((Component)this).GetComponent<Image>().sprite = pAsset.getSpriteIcon();
			textAmount.text = pAmount.ToString() ?? "";
		}
	}

	private void showHoverTooltip()
	{
		if (Config.tooltips_active)
		{
			showTooltip();
		}
	}

	private void showTooltip()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		string tooltip = asset.tooltip;
		Tooltip.show(this, tooltip, new TooltipData
		{
			resource = asset
		});
		((Component)this).transform.localScale = new Vector3(1f, 1f, 1f);
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
		TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(((Component)this).transform, 0.8f, scaleTime), (Ease)26);
	}

	private void OnDestroy()
	{
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
	}
}
// --- End of File: ButtonResource.cs ---



// --- Start of File: ButtonSfx.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof(Button))]
public class ButtonSfx : MonoBehaviour
{
	private Button _button;

	private void Start()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Expected O, but got Unknown
		_button = ((Component)this).GetComponent<Button>();
		((UnityEvent)_button.onClick).AddListener(new UnityAction(playSound));
	}

	private void playSound()
	{
		SoundBox.click();
		((Behaviour)_button).enabled = false;
		((Behaviour)_button).enabled = true;
	}
}
// --- End of File: ButtonSfx.cs ---



// --- Start of File: ButtonSocial.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ButtonSocial : MonoBehaviour
{
	[SerializeField]
	private SocialType _social_type;

	[SerializeField]
	private Text _text;

	private void Awake()
	{
		switch (_social_type)
		{
		case SocialType.Discord:
			_text.text = 560 + "k+";
			break;
		case SocialType.Facebook:
			_text.text = 82 + "k+";
			break;
		case SocialType.Twitter:
			_text.text = 56 + "k+";
			break;
		case SocialType.Reddit:
			_text.text = 140 + "k+";
			break;
		}
	}

	public void openFacebook()
	{
		Analytics.LogEvent("open_link_facebook");
		Application.OpenURL("https://www.facebook.com/superworldbox");
	}

	public void openTwitter()
	{
		Analytics.LogEvent("open_link_twitter");
		Application.OpenURL("http://twitter.com/mixamko");
	}

	public void openDiscord()
	{
		Analytics.LogEvent("open_link_discord");
		Application.OpenURL("https://discordapp.com/invite/worldbox");
		AchievementLibrary.social_network.check();
	}

	public void openLinkReddit()
	{
		Analytics.LogEvent("open_link_reddit");
		Application.OpenURL("https://www.reddit.com/r/worldbox");
	}

	public void openLinkMoonBox()
	{
		Analytics.LogEvent("open_link_moonbox");
		if (Config.isIos)
		{
			Application.OpenURL("https://bit.ly/moonbox_wb_ap");
		}
		else
		{
			Application.OpenURL("https://bit.ly/moonbox_wb");
		}
	}

	public void openLinkSteam()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Analytics.LogEvent("open_link_steam");
		string text = string.Concat($"https://store.steampowered.com/app/{1206560u}/" + "?utm_source=game_bar", "&utm_campaign=get_wishlists");
		RuntimePlatform platform = Application.platform;
		Application.OpenURL(text + "&utm_medium=" + ((object)(RuntimePlatform)(ref platform)).ToString());
	}
}
// --- End of File: ButtonSocial.cs ---



// --- Start of File: ButtonsViewer.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ButtonsViewer : MonoBehaviour
{
	private List<PowerButton> buttons;

	private Transform content;

	private float lastX;

	private float lastY;

	private Canvas canvas;

	private void Start()
	{
		content = ((Component)this).transform.parent;
		canvas = CanvasMain.instance.canvas_ui;
		buttons = new List<PowerButton>();
		_ = ((Component)this).transform.childCount;
		for (int i = 0; i < ((Component)this).transform.childCount; i++)
		{
			GameObject gameObject = ((Component)((Component)this).transform.GetChild(i)).gameObject;
			if (gameObject.HasComponent<PowerButton>() && gameObject.activeSelf)
			{
				buttons.Add(gameObject.GetComponent<PowerButton>());
			}
			else if (!gameObject.HasComponent<Image>() || !gameObject.activeSelf)
			{
				Object.Destroy((Object)(object)gameObject);
			}
		}
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (lastX == content.position.x && lastY == content.position.y)
		{
			return;
		}
		lastX = content.position.x;
		lastY = content.position.y;
		int num = 0;
		int num2 = 0;
		bool flag = false;
		for (int i = 0; i < buttons.Count; i++)
		{
			PowerButton powerButton = buttons[i];
			if (flag)
			{
				num2++;
				((Component)powerButton).gameObject.SetActive(false);
				continue;
			}
			num++;
			Vector3[] array = (Vector3[])(object)new Vector3[4];
			powerButton.rect_transform.GetWorldCorners(array);
			float num3 = Mathf.Max(new float[4]
			{
				array[0].x,
				array[1].x,
				array[2].x,
				array[3].x
			});
			float num4 = Mathf.Min(new float[4]
			{
				array[0].x,
				array[1].x,
				array[2].x,
				array[3].x
			});
			if (num3 < 0f || num4 > (float)Screen.width)
			{
				((Component)powerButton).gameObject.SetActive(false);
				if (num4 > (float)Screen.width)
				{
					flag = true;
				}
			}
			else
			{
				((Component)powerButton).gameObject.SetActive(true);
			}
		}
	}
}
// --- End of File: ButtonsViewer.cs ---



// --- Start of File: ButtonTipLoader.cs ---
using UnityEngine;

public delegate void ButtonTipLoader(Transform pButton, BaseUnlockableAsset pAsset);
// --- End of File: ButtonTipLoader.cs ---



// --- Start of File: ButtonTooltipLoader.cs ---
using UnityEngine;

public delegate TooltipData ButtonTooltipLoader(Transform pButton, BaseUnlockableAsset pAsset);
// --- End of File: ButtonTooltipLoader.cs ---



// --- Start of File: ButtonTranslate.cs ---
using UnityEngine;

public class ButtonTranslate : MonoBehaviour
{
	public void openLink()
	{
		Analytics.LogEvent("click_translate");
		Application.OpenURL("https://docs.google.com/forms/d/e/1FAIpQLSeL8sirqSFbHa_dHipgu-2QiRSNHqEn2l7ApodM8qD5xm010A/viewform");
	}
}
// --- End of File: ButtonTranslate.cs ---



// --- Start of File: ButtonTrigger.cs ---
using UnityEngine.EventSystems;
using UnityEngine.UI;

public struct ButtonTrigger
{
	public Button button { get; }

	public Entry entry { get; }

	public int index { get; }

	public ButtonTrigger(Button pButton, Entry pEntry, int pIndex)
	{
		button = pButton;
		entry = pEntry;
		index = pIndex;
	}
}
// --- End of File: ButtonTrigger.cs ---



// --- Start of File: ButtonTwitter.cs ---
using UnityEngine;

public class ButtonTwitter : MonoBehaviour
{
	public void openLink()
	{
		Analytics.LogEvent("open_link_twitter");
		Application.OpenURL("http://twitter.com/mixamko");
	}
}
// --- End of File: ButtonTwitter.cs ---



// --- Start of File: ButtonUtil.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof(Button))]
public class ButtonUtil : MonoBehaviour
{
	private Button _button;

	public void ResetState()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected O, but got Unknown
		if ((Object)(object)_button == (Object)null)
		{
			_button = ((Component)this).GetComponent<Button>();
			((UnityEvent)_button.onClick).AddListener(new UnityAction(playSound));
		}
		((Behaviour)_button).enabled = false;
		((Behaviour)_button).enabled = true;
	}

	private void playSound()
	{
		SoundBox.click();
	}
}
// --- End of File: ButtonUtil.cs ---



// --- Start of File: ButtonVersionUpdate.cs ---
using UnityEngine;

public class ButtonVersionUpdate : MonoBehaviour
{
	public void openLink()
	{
		Analytics.LogEvent("open_link_version");
		Application.OpenURL("https://www.superworldbox.com/");
	}
}
// --- End of File: ButtonVersionUpdate.cs ---



// --- Start of File: ButtonVote.cs ---
using UnityEngine;

public class ButtonVote : MonoBehaviour
{
	public void openLink()
	{
		Analytics.LogEvent("click_vote");
		if (Config.isAndroid)
		{
			Application.OpenURL("https://play.google.com/store/apps/details?id=com.mkarpenko.worldbox");
		}
		else if (Config.isIos)
		{
			Application.OpenURL("https://itunes.apple.com/app/id1450941371");
		}
	}
}
// --- End of File: ButtonVote.cs ---



// --- Start of File: ButtonWebsite.cs ---
using UnityEngine;

public class ButtonWebsite : MonoBehaviour
{
	public void openLink()
	{
		Analytics.LogEvent("open_link_website");
		Application.OpenURL("https://www.superworldbox.com/");
	}

	public void openLinkLSFLW2()
	{
		Analytics.LogEvent("open_link_lsflw2");
		Application.OpenURL("https://apps.apple.com/app/apple-store/id1397453494?pt=117120454&ct=worldbox&mt=8");
	}

	public void openPatchLog()
	{
		Analytics.LogEvent("open_link_changelog");
		Application.OpenURL("https://www.superworldbox.com/changelog");
	}
}
// --- End of File: ButtonWebsite.cs ---



// --- Start of File: ButtonWorldnet.cs ---
using UnityEngine;

public class ButtonWorldnet : MonoBehaviour
{
	public void clickWorldNet()
	{
	}

	public void clickCancel()
	{
	}
}
// --- End of File: ButtonWorldnet.cs ---



// --- Start of File: CameraRender.cs ---
using UnityEngine;

public class CameraRender : MonoBehaviour
{
	public Material PostProcessMaterial;

	public Camera BackgroundCamera;

	public Camera MainCamera;

	private RenderTexture mainRenderTexture;

	private void Start()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected O, but got Unknown
		mainRenderTexture = new RenderTexture(Screen.width, Screen.height, 16, (RenderTextureFormat)0);
		mainRenderTexture.Create();
		BackgroundCamera.targetTexture = mainRenderTexture;
		MainCamera.targetTexture = mainRenderTexture;
	}

	private void Update()
	{
	}

	private void OnPostRender()
	{
		Graphics.Blit((Texture)(object)mainRenderTexture, PostProcessMaterial);
	}
}
// --- End of File: CameraRender.cs ---



// --- Start of File: CancelButton.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CancelButton : MonoBehaviour
{
	public Image powerIcon;

	public bool goUp;

	public bool goDown;

	private bool _going_down;

	private bool _going_up;

	private RectTransform _rect;

	private float _timer;

	private const float Y_TOP_TARGET = 90f;

	private void Awake()
	{
		_rect = ((Component)this).GetComponent<RectTransform>();
	}

	public void setIconFrom(PowerButton pButton)
	{
		if (pButton.godPower != null && !((Object)(object)pButton.icon == (Object)null))
		{
			powerIcon.sprite = pButton.icon.sprite;
		}
	}

	private void Update()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		if (goDown != _going_down)
		{
			_going_down = goDown;
			_timer = 0f;
			if (goDown)
			{
				_timer = 0.95f;
			}
		}
		if (goUp != _going_up)
		{
			_going_up = goUp;
			_timer = -1f;
		}
		if (_timer < 1f)
		{
			_timer += Time.deltaTime / 2f;
			_timer = Mathf.Clamp(_timer, 0f, 1f);
			float num = (_going_down ? iTween.easeInOutCirc(0f, -90f, _timer) : ((!_going_up) ? iTween.easeInOutCirc(_rect.anchoredPosition.y, 0f, _timer) : iTween.easeInQuart(0f, 90f, _timer)));
			_rect.anchoredPosition = Vector2.op_Implicit(new Vector3(_rect.anchoredPosition.x, num));
		}
	}
}
// --- End of File: CancelButton.cs ---



// --- Start of File: CanvasMain.cs ---
using System;
using UnityEngine;
using UnityEngine.UI;

public class CanvasMain : MonoBehaviour
{
	public static CanvasMain instance;

	public static float tooltip_show_timeout;

	public Canvas canvas_ui;

	public Canvas canvas_windows;

	public Canvas canvas_map_names;

	public Canvas canvas_tooltip;

	public Image blocker;

	private ScreenOrientation screenOrientation;

	private CanvasScaler scaler_main_ui;

	private CanvasScaler scaler_windows_ui;

	private CanvasScaler scaler_tooltip;

	private CanvasScaler scaler_map_names;

	public Transform transformWindows;

	private float last_width = -1f;

	private float last_height = -1f;

	private const int REFERENCE_SIZE_X = 285;

	private const int REFERENCE_SIZE_Y = 420;

	private ResizeAction _on_resize;

	private ResizeUIAction _on_resize_ui;

	private void Awake()
	{
		instance = this;
		scaler_main_ui = ((Component)canvas_ui).GetComponent<CanvasScaler>();
		scaler_windows_ui = ((Component)canvas_windows).GetComponent<CanvasScaler>();
		scaler_tooltip = ((Component)canvas_tooltip).GetComponent<CanvasScaler>();
		scaler_map_names = ((Component)canvas_map_names).GetComponent<CanvasScaler>();
	}

	public bool setMainUiEnabled(bool pEnabled)
	{
		if (((Behaviour)canvas_ui).enabled == pEnabled)
		{
			return false;
		}
		((Behaviour)canvas_ui).enabled = pEnabled;
		return true;
	}

	public float getLastWidth()
	{
		return last_width;
	}

	public float getLastHeight()
	{
		return last_height;
	}

	public void addCallbackResize(ResizeAction pAction)
	{
		_on_resize = (ResizeAction)Delegate.Combine(_on_resize, pAction);
	}

	public void removeCallbackResize(ResizeAction pAction)
	{
		_on_resize = (ResizeAction)Delegate.Remove(_on_resize, pAction);
	}

	public void addCallbackResizeUI(ResizeUIAction pAction)
	{
		_on_resize_ui = (ResizeUIAction)Delegate.Combine(_on_resize_ui, pAction);
	}

	public void removeCallbackResizeUI(ResizeUIAction pAction)
	{
		_on_resize_ui = (ResizeUIAction)Delegate.Remove(_on_resize_ui, pAction);
	}

	private void checkResize(float pWidth, float pHeight)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		last_width = pWidth;
		last_height = pHeight;
		screenOrientation = Screen.orientation;
		resizeMainUI();
		resizeWindowsUI();
		resizeTooltipUI();
		_on_resize?.Invoke(pWidth, pHeight);
	}

	public void resizeWindowsUI()
	{
		changeCanvasSize(scaler_windows_ui, "ui_size_windows", 285f, 420f);
		float pUISize = (float)PlayerConfig.getIntValue("ui_size_windows") / 100f;
		_on_resize_ui?.Invoke(pUISize);
	}

	public void resizeTooltipUI()
	{
		changeCanvasSize(scaler_tooltip, "ui_size_tooltips", 285f, 420f);
	}

	public void resizeMapNames()
	{
		changeCanvasSize(scaler_map_names, "ui_size_map_names", 285f, 420f);
	}

	public void resizeMainUI()
	{
		changeCanvasSize(pReferenceHeight: (Screen.height <= Screen.width) ? 500f : 360f, pScaler: scaler_main_ui, pSizeOption: "ui_size_main", pReferenceWidth: 285f);
	}

	private void changeCanvasSize(CanvasScaler pScaler, string pSizeOption, float pReferenceWidth, float pReferenceHeight)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		pScaler.uiScaleMode = (ScaleMode)1;
		float num = 1f;
		num = (float)PlayerConfig.getIntValue(pSizeOption) / 100f;
		float num2 = 2f - num;
		pScaler.referenceResolution = new Vector2(pReferenceWidth, pReferenceHeight * num2);
	}

	private void Start()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		screenOrientation = Screen.orientation;
	}

	private void Update()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (tooltip_show_timeout > 0f)
		{
			tooltip_show_timeout -= Time.deltaTime;
		}
		if ((float)Screen.width != last_width || (float)Screen.height != last_height)
		{
			checkResize(Screen.width, Screen.height);
		}
		if (screenOrientation != Screen.orientation)
		{
			screenOrientation = Screen.orientation;
			if (ScrollWindow.isWindowActive())
			{
				ScrollWindow.hideAllEvent();
			}
		}
		if (Config.lockGameControls || ((Object)(object)World.world?.stack_effects != (Object)null && World.world.stack_effects.isLocked()))
		{
			((Component)blocker).gameObject.SetActive(true);
		}
		else
		{
			((Component)blocker).gameObject.SetActive(false);
		}
	}

	public static void addTooltipShowTimeout(float pTime)
	{
		tooltip_show_timeout = pTime;
		Tooltip.hideTooltipNow();
	}

	public static bool isBottomBarShowing()
	{
		if (ScrollWindow.isWindowActive())
		{
			return false;
		}
		if (ControllableUnit.isControllingUnit())
		{
			return false;
		}
		if (MoveCamera.inSpectatorMode())
		{
			return false;
		}
		if (Config.ui_main_hidden)
		{
			return false;
		}
		if (SmoothLoader.isLoading())
		{
			return false;
		}
		if (SaveManager.isLoadingSaveAnimationActive())
		{
			return false;
		}
		return true;
	}

	public static bool isNameplatesAllowed()
	{
		if (SmoothLoader.isLoading())
		{
			return false;
		}
		if (SaveManager.isLoadingSaveAnimationActive())
		{
			return false;
		}
		return true;
	}
}
// --- End of File: CanvasMain.cs ---



// --- Start of File: CanvasNotch.cs ---
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(RectTransform))]
public class CanvasNotch : MonoBehaviour
{
	private bool screenChangeVarsInitialized;

	private bool ranFirstTime;

	private ScreenOrientation lastOrientation = (ScreenOrientation)5;

	private Vector2 lastResolution = Vector2.zero;

	private Rect lastSafeArea = Rect.zero;

	private Rect lastCanvasRect = Rect.zero;

	private RectTransform safeAreaTransform;

	private Canvas _canvas;

	private void Awake()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		_canvas = ((Component)((Component)this).gameObject.transform).GetComponentInParent<Canvas>();
		safeAreaTransform = ((Component)this).GetComponent<RectTransform>();
		if (!screenChangeVarsInitialized)
		{
			lastOrientation = Screen.orientation;
			lastResolution.x = Screen.width;
			lastResolution.y = Screen.height;
			lastSafeArea = Screen.safeArea;
			screenChangeVarsInitialized = true;
		}
	}

	private void Start()
	{
		ApplySafeArea();
	}

	private void Update()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isMobilePlatform && Screen.orientation != lastOrientation)
		{
			OrientationChanged();
		}
		if (Screen.safeArea != lastSafeArea)
		{
			SafeAreaChanged();
		}
		if ((Object)(object)_canvas != (Object)null && _canvas.pixelRect != lastCanvasRect)
		{
			CanvasChanged();
		}
		if ((float)Screen.width != lastResolution.x || (float)Screen.height != lastResolution.y)
		{
			ResolutionChanged();
		}
		if (!ranFirstTime)
		{
			ApplySafeArea();
		}
	}

	private void ApplySafeArea()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)_canvas == (Object)null) && !((Object)(object)safeAreaTransform == (Object)null))
		{
			ranFirstTime = true;
			Rect safeArea = Screen.safeArea;
			Rect val = default(Rect);
			((Rect)(ref val))._002Ector(0f, 0f, (float)Screen.width, (float)Screen.height);
			Vector2 val2 = ((Rect)(ref safeArea)).min - ((Rect)(ref val)).min;
			Vector2 val3 = ((Rect)(ref safeArea)).max - ((Rect)(ref val)).max;
			((Rect)(ref safeArea)).min = ((Rect)(ref safeArea)).min - val3;
			((Rect)(ref safeArea)).max = ((Rect)(ref safeArea)).max - val2;
			Vector2 position = ((Rect)(ref safeArea)).position;
			Vector2 anchorMax = ((Rect)(ref safeArea)).position + ((Rect)(ref safeArea)).size;
			ref float x = ref position.x;
			float num = x;
			Rect pixelRect = _canvas.pixelRect;
			x = num / ((Rect)(ref pixelRect)).width;
			ref float y = ref position.y;
			float num2 = y;
			pixelRect = _canvas.pixelRect;
			y = num2 / ((Rect)(ref pixelRect)).height;
			ref float x2 = ref anchorMax.x;
			float num3 = x2;
			pixelRect = _canvas.pixelRect;
			x2 = num3 / ((Rect)(ref pixelRect)).width;
			ref float y2 = ref anchorMax.y;
			float num4 = y2;
			pixelRect = _canvas.pixelRect;
			y2 = num4 / ((Rect)(ref pixelRect)).height;
			safeAreaTransform.anchorMin = position;
			safeAreaTransform.anchorMax = anchorMax;
		}
	}

	private void OrientationChanged()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		lastOrientation = Screen.orientation;
		lastResolution.x = Screen.width;
		lastResolution.y = Screen.height;
		ApplySafeArea();
	}

	private void ResolutionChanged()
	{
		lastResolution.x = Screen.width;
		lastResolution.y = Screen.height;
		ApplySafeArea();
	}

	private void SafeAreaChanged()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		lastSafeArea = Screen.safeArea;
		ApplySafeArea();
	}

	private void CanvasChanged()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastCanvasRect = _canvas.pixelRect;
		ApplySafeArea();
	}

	private void debugConsole()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		Dictionary<string, Rect> dictionary = new Dictionary<string, Rect>();
		Debug.Log((object)("amount of cutouts: " + Screen.cutouts.Length));
		dictionary["screen"] = new Rect(0f, 0f, (float)Screen.width, (float)Screen.height);
		dictionary["safearea"] = Screen.safeArea;
		Rect val;
		foreach (string key in dictionary.Keys)
		{
			string[] obj = new string[10] { "[o] ", key, ": x:", null, null, null, null, null, null, null };
			val = dictionary[key];
			obj[3] = ((Rect)(ref val)).x.ToString();
			obj[4] = ", y:";
			val = dictionary[key];
			obj[5] = ((Rect)(ref val)).y.ToString();
			obj[6] = ", w:";
			val = dictionary[key];
			obj[7] = ((Rect)(ref val)).width.ToString();
			obj[8] = ", h:";
			val = dictionary[key];
			obj[9] = ((Rect)(ref val)).height.ToString();
			Debug.Log((object)string.Concat(obj));
		}
		if ((Object)(object)_canvas == (Object)null)
		{
			Debug.Log((object)"canvas not ready");
			return;
		}
		foreach (string key2 in dictionary.Keys)
		{
			string[] obj2 = new string[10] { "[c] ", key2, ": x:", null, null, null, null, null, null, null };
			val = dictionary[key2];
			obj2[3] = (((Rect)(ref val)).x / _canvas.scaleFactor).ToString();
			obj2[4] = ", y:";
			val = dictionary[key2];
			obj2[5] = (((Rect)(ref val)).y / _canvas.scaleFactor).ToString();
			obj2[6] = ", w:";
			val = dictionary[key2];
			obj2[7] = (((Rect)(ref val)).width / _canvas.scaleFactor).ToString();
			obj2[8] = ", h:";
			val = dictionary[key2];
			obj2[9] = (((Rect)(ref val)).height / _canvas.scaleFactor).ToString();
			Debug.Log((object)string.Concat(obj2));
		}
	}
}
// --- End of File: CanvasNotch.cs ---



// --- Start of File: CapturingZonesCalculator.cs ---
using System.Collections.Generic;

public class CapturingZonesCalculator
{
	private static int _zoneTicks = 0;

	private static Queue<TileZone> _currentWave = new Queue<TileZone>();

	private static Queue<TileZone> _nextWave = new Queue<TileZone>();

	private static HashSet<TileZone> _waveChecked = new HashSet<TileZone>();

	public static void getListToDraw(City pCity, int pTicks, ListPool<TileZone> pResults)
	{
		pResults.Clear();
		TileZone tileZone = pCity.getTile()?.zone;
		if (tileZone == null)
		{
			tileZone = pCity.zones[0];
		}
		Queue<TileZone> queue = _currentWave;
		queue.Enqueue(tileZone);
		_zoneTicks = pTicks;
		while (queue.Count > 0 && _zoneTicks != 0)
		{
			TileZone tileZone2 = queue.Dequeue();
			check(tileZone2, pCity);
			pResults.Add(tileZone2);
			if (queue.Count == 0)
			{
				Queue<TileZone> nextWave = queue;
				queue = _nextWave;
				_nextWave = nextWave;
			}
		}
		_nextWave.Clear();
		_waveChecked.Clear();
		queue.Clear();
	}

	private static void check(TileZone pTargetZone, City pCity)
	{
		_zoneTicks--;
		_waveChecked.Add(pTargetZone);
		TileZone[] neighbours = pTargetZone.neighbours;
		foreach (TileZone tileZone in neighbours)
		{
			if (tileZone.city == pCity && !_waveChecked.Contains(tileZone))
			{
				_waveChecked.Add(tileZone);
				_nextWave.Enqueue(tileZone);
			}
		}
	}
}
// --- End of File: CapturingZonesCalculator.cs ---



// --- Start of File: CastEntity.cs ---
public enum CastEntity
{
	UnitsOnly,
	BuildingsOnly,
	Both,
	Tile
}
// --- End of File: CastEntity.cs ---



// --- Start of File: CastTarget.cs ---
public enum CastTarget
{
	Enemy,
	Himself,
	Region,
	Friendly
}
// --- End of File: CastTarget.cs ---



// --- Start of File: CategoryData.cs ---
using System;
using System.Collections.Generic;
using UnityPools;

public class CategoryData : IDisposable
{
	private LinkedList<Dictionary<string, long>> _data = new LinkedList<Dictionary<string, long>>();

	internal ListPool<object> db_list;

	public LinkedListNode<Dictionary<string, long>> Last => _data.Last;

	public int Count => _data.Count;

	public LinkedListNode<Dictionary<string, long>> AddLast(Dictionary<string, long> pDict)
	{
		return _data.AddLast(pDict);
	}

	public void Clear()
	{
		foreach (Dictionary<string, long> datum in _data)
		{
			UnsafeCollectionPool<Dictionary<string, long>, KeyValuePair<string, long>>.Release(datum);
		}
		_data.Clear();
		db_list?.Dispose();
		db_list = null;
	}

	public void Dispose()
	{
		Clear();
		_data = null;
	}
}
// --- End of File: CategoryData.cs ---



// --- Start of File: CenterTipCaller.cs ---
using UnityEngine;

public class CenterTipCaller : MonoBehaviour
{
	public string tip_title;

	public string tip_id;

	public void Show()
	{
		Tooltip.show(this, "normal", new TooltipData
		{
			tip_name = tip_title,
			tip_description = tip_id
		});
	}
}
// --- End of File: CenterTipCaller.cs ---



// --- Start of File: ChainElement.cs ---
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(CanvasGroup))]
public class ChainElement : TraitButton<GeneAsset>
{
	public Image chain_left;

	public Image chain_right;

	public Image chain_up;

	public Image chain_down;

	internal int locus_index = -1;

	protected GeneAsset gene => augmentation_asset;

	public GeneAsset getGeneAsset()
	{
		return gene;
	}

	public override void load(GeneAsset pAsset)
	{
		base.load(pAsset);
		((Object)((Component)this).gameObject).name = gene.id;
		colorChains();
	}

	public void colorChains()
	{
		if (!gene.show_genepool_nucleobases)
		{
			hideChains();
			return;
		}
		showChain(chain_left, pShow: true, gene.genetic_code_left);
		showChain(chain_right, pShow: true, gene.genetic_code_right);
		showChain(chain_up, pShow: true, gene.genetic_code_up);
		showChain(chain_down, pShow: true, gene.genetic_code_down);
	}

	protected void hideChains()
	{
		hideChain(chain_left);
		hideChain(chain_right);
		hideChain(chain_up);
		hideChain(chain_down);
	}

	protected void showChain(Image pChainImage, bool pShow, char pGeneticCode, Color? pColor = null)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		((Component)pChainImage).gameObject.SetActive(pShow);
		if (pColor.HasValue)
		{
			colorChain(pChainImage, pColor.Value);
		}
		else if (pShow)
		{
			colorChain(pChainImage, NucleobaseHelper.getColor(pGeneticCode));
		}
	}

	protected void hideChain(Image pChain)
	{
		((Component)pChain).gameObject.SetActive(false);
	}

	protected void colorChain(Image pChain, Color pColor)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)pChain).color = pColor;
	}
}
// --- End of File: ChainElement.cs ---



// --- Start of File: ChangeTextInHindi.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ChangeTextInHindi : MonoBehaviour
{
	private void Start()
	{
		string text = ((Component)this).gameObject.GetComponent<Text>().text;
		((Component)this).gameObject.GetComponent<Text>().SetHindiText(text);
	}
}
// --- End of File: ChangeTextInHindi.cs ---



// --- Start of File: Character.cs ---
using UnityEngine;

public class Character : ScriptableObject
{
	public string name_first;

	public string name_last;

	public string name_nickname;

	public int age;

	public object religion;

	public object preferences;

	public object perks;
}
// --- End of File: Character.cs ---



// --- Start of File: CheckActorHasMeta.cs ---
public delegate bool CheckActorHasMeta(Actor pActor);
// --- End of File: CheckActorHasMeta.cs ---



// --- Start of File: Chromosome.cs ---
using System.Collections.Generic;
using UnityEngine;

public class Chromosome
{
	private const string IMAGE_PATH_NORMAL = "chromosomes/normal/";

	private const string IMAGE_PATH_GOLD = "chromosomes/golden/";

	private const string STRING_UNKOWN = "???????";

	private const string COLOR_BOUND = "#444444";

	private const string COLORED_UNKOWN_TEXT = "<color=#444444>???????</color>";

	public readonly List<GeneAsset> genes = new List<GeneAsset>();

	private readonly BaseStats _merged_base_stats_male = new BaseStats();

	private readonly BaseStats _merged_base_stats_female = new BaseStats();

	private readonly BaseStats _merged_base_stats = new BaseStats();

	private readonly BaseStats _merged_base_stats_meta = new BaseStats();

	private static readonly (int, int)[] DIRECTIONS = new(int, int)[4]
	{
		(0, -1),
		(0, 1),
		(-1, 0),
		(1, 0)
	};

	private bool _dirty = true;

	private Sprite _cached_sprite;

	private int _cached_sprite_index = -1;

	public string chromosome_type;

	private readonly List<int> _loci_amplifiers = new List<int>();

	private readonly List<int> _loci_empty = new List<int>();

	private readonly BaseStats[] _base_stats_all = new BaseStats[4];

	private readonly int _columns;

	public Chromosome(string pType, bool pNew)
	{
		chromosome_type = pType;
		if (pNew)
		{
			int amount_loci = getAsset().amount_loci;
			GeneAsset item = AssetManager.gene_library.get("empty");
			for (int i = 0; i < amount_loci; i++)
			{
				genes.Add(item);
			}
			generateAmplifiers(pType);
		}
		_base_stats_all[0] = _merged_base_stats;
		_base_stats_all[1] = _merged_base_stats_meta;
		_base_stats_all[2] = _merged_base_stats_male;
		_base_stats_all[3] = _merged_base_stats_female;
		_columns = getAsset().amount_loci / 6;
	}

	public bool isLocusAmplifier(int pX, int pY)
	{
		int indexFrom = getIndexFrom(pX, pY);
		return isLocusAmplifier(indexFrom);
	}

	public bool isLocusAmplifier(int pLocusIndex)
	{
		return _loci_amplifiers.Contains(pLocusIndex);
	}

	public bool isVoidLocus(int pLocusIndex)
	{
		return _loci_empty.Contains(pLocusIndex);
	}

	public bool isSpecialLocusAt(int pX, int pY)
	{
		int indexFrom = getIndexFrom(pX, pY);
		return isSpecialLocus(indexFrom);
	}

	public bool isVoidLocusAt(int pX, int pY)
	{
		int indexFrom = getIndexFrom(pX, pY);
		return isVoidLocus(indexFrom);
	}

	public bool isAllSidesVoidLocus(int pX, int pY)
	{
		int num = countBounds(pX, pY);
		int num2 = 0;
		if (isVoidLocusAt(pX - 1, pY))
		{
			num2++;
		}
		if (isVoidLocusAt(pX + 1, pY))
		{
			num2++;
		}
		if (isVoidLocusAt(pX, pY + 1))
		{
			num2++;
		}
		if (isVoidLocusAt(pX, pY - 1))
		{
			num2++;
		}
		return num2 == num;
	}

	private bool isAmplifierLocusAt(int pX, int pY)
	{
		int indexFrom = getIndexFrom(pX, pY);
		return isLocusAmplifier(indexFrom);
	}

	private bool isForcedSynergyAt(int pX, int pY)
	{
		if (isAmplifierLocusAt(pX, pY))
		{
			return true;
		}
		if (getGeneAt(pX, pY).synergy_sides_always)
		{
			return true;
		}
		return false;
	}

	public bool isForcedSynergyLeft(int pX, int pY)
	{
		if (hasBoundLeft(pX, pY))
		{
			return false;
		}
		var (num, num2) = getDirectionOffset(GeneDirection.Left);
		return isForcedSynergyAt(pX + num, pY + num2);
	}

	public bool isForcedSynergyRight(int pX, int pY)
	{
		if (hasBoundRight(pX, pY))
		{
			return false;
		}
		var (num, num2) = getDirectionOffset(GeneDirection.Right);
		return isForcedSynergyAt(pX + num, pY + num2);
	}

	public bool isForcedSynergyUp(int pX, int pY)
	{
		if (hasBoundUp(pX, pY))
		{
			return false;
		}
		var (num, num2) = getDirectionOffset(GeneDirection.Up);
		return isForcedSynergyAt(pX + num, pY + num2);
	}

	public bool isForcedSynergyDown(int pX, int pY)
	{
		if (hasBoundDown(pX, pY))
		{
			return false;
		}
		var (num, num2) = getDirectionOffset(GeneDirection.Down);
		return isForcedSynergyAt(pX + num, pY + num2);
	}

	public LocusType getLocusType(int pLocusIndex)
	{
		if (isLocusAmplifier(pLocusIndex))
		{
			return LocusType.Amplifier;
		}
		if (isVoidLocus(pLocusIndex))
		{
			return LocusType.Empty;
		}
		return LocusType.Standard;
	}

	public void fillStatsForTooltip(LocusElement pLocus, BaseStats pStatsContainer)
	{
		int locus_index = pLocus.locus_index;
		if (!isVoidLocus(locus_index))
		{
			GeneAsset geneAsset = pLocus.getGeneAsset();
			if (geneAsset.is_bonus_male)
			{
				combineBonusesForSides(locus_index, pStatsContainer);
			}
			else if (geneAsset.is_bonus_female)
			{
				combineBonusesForSides(locus_index, pStatsContainer);
			}
			else
			{
				getBonusesFromGene(pLocus.locus_index, pStatsContainer, null, pCombineMeta: true);
			}
			pStatsContainer.normalize();
		}
	}

	private void generateAmplifiers(string pType)
	{
		ChromosomeTypeAsset chromosomeTypeAsset = AssetManager.chromosome_type_library.get(pType);
		using ListPool<int> listPool = new ListPool<int>();
		for (int i = 0; i < chromosomeTypeAsset.amount_loci; i++)
		{
			listPool.Add(i);
		}
		listPool.Shuffle();
		int num = Randy.randomInt(chromosomeTypeAsset.amount_loci_min_amplifier, chromosomeTypeAsset.amount_loci_max_amplifier);
		int num2 = Randy.randomInt(chromosomeTypeAsset.amount_loci_min_empty, chromosomeTypeAsset.amount_loci_max_empty);
		for (int j = 0; j < num; j++)
		{
			_loci_amplifiers.Add(listPool.Pop());
		}
		for (int k = 0; k < num2; k++)
		{
			_loci_empty.Add(listPool.Pop());
		}
	}

	public bool canAddGene(GeneAsset pAsset)
	{
		if (countEmpty() == 0)
		{
			return false;
		}
		return true;
	}

	public void setGene(GeneAsset pAsset, int pIndex)
	{
		genes[pIndex] = pAsset;
	}

	public GeneAsset getGene(int pIndex)
	{
		return genes[pIndex];
	}

	public ChromosomeTypeAsset getAsset()
	{
		return AssetManager.chromosome_type_library.get(chromosome_type);
	}

	public void load(ChromosomeData pData)
	{
		chromosome_type = pData.chromosome_type;
		foreach (string item in pData.loci)
		{
			GeneAsset geneAsset = AssetManager.gene_library.get(item);
			if (geneAsset != null)
			{
				genes.Add(geneAsset);
			}
		}
		_loci_amplifiers.AddRange(pData.super_loci);
		_loci_empty.AddRange(pData.void_loci);
	}

	public ChromosomeData getDataForSave()
	{
		ChromosomeData chromosomeData = new ChromosomeData();
		foreach (GeneAsset gene in genes)
		{
			chromosomeData.loci.Add(gene.id);
		}
		chromosomeData.super_loci.AddRange(_loci_amplifiers);
		chromosomeData.void_loci.AddRange(_loci_empty);
		chromosomeData.chromosome_type = chromosome_type;
		return chromosomeData;
	}

	public void addGene(GeneAsset pGeneAsset)
	{
		for (int i = 0; i < genes.Count; i++)
		{
			if (genes[i].is_empty && canAddToLocus(i))
			{
				genes[i] = pGeneAsset;
				break;
			}
		}
		setDirty();
	}

	public bool isSpecialLocus(int pIndex)
	{
		if (!_loci_amplifiers.Contains(pIndex))
		{
			return _loci_empty.Contains(pIndex);
		}
		return true;
	}

	public bool canAddToLocus(int pIndex)
	{
		if (_loci_amplifiers.Contains(pIndex))
		{
			return false;
		}
		if (_loci_empty.Contains(pIndex))
		{
			return false;
		}
		return true;
	}

	public int countNonEmpty()
	{
		int num = 0;
		for (int i = 0; i < genes.Count; i++)
		{
			if (!genes[i].is_empty && canAddToLocus(i))
			{
				num++;
			}
		}
		return num;
	}

	public int countEmpty()
	{
		int num = 0;
		for (int i = 0; i < genes.Count; i++)
		{
			if (genes[i].is_empty && canAddToLocus(i))
			{
				num++;
			}
		}
		return num;
	}

	public BaseStats getStats()
	{
		if (_dirty)
		{
			recalculate();
		}
		return _merged_base_stats;
	}

	public BaseStats getStatsMeta()
	{
		if (_dirty)
		{
			recalculate();
		}
		return _merged_base_stats_meta;
	}

	public BaseStats getStatsMale()
	{
		if (_dirty)
		{
			recalculate();
		}
		return _merged_base_stats_male;
	}

	public BaseStats getStatsFemale()
	{
		if (_dirty)
		{
			recalculate();
		}
		return _merged_base_stats_female;
	}

	public void setDirty()
	{
		_dirty = true;
	}

	public void recalculate()
	{
		if (!_dirty)
		{
			return;
		}
		_dirty = false;
		clearAllBaseStats();
		BaseStats merged_base_stats = _merged_base_stats;
		BaseStats merged_base_stats_meta = _merged_base_stats_meta;
		BaseStats merged_base_stats_male = _merged_base_stats_male;
		BaseStats merged_base_stats_female = _merged_base_stats_female;
		for (int i = 0; i < genes.Count; i++)
		{
			if (!isVoidLocus(i))
			{
				getBonusesFromGene(i, merged_base_stats, merged_base_stats_meta);
			}
		}
		for (int j = 0; j < genes.Count; j++)
		{
			GeneAsset geneAsset = genes[j];
			if (!isVoidLocus(j))
			{
				if (geneAsset.is_bonus_male)
				{
					combineBonusesForSides(j, merged_base_stats_male);
				}
				if (geneAsset.is_bonus_female)
				{
					combineBonusesForSides(j, merged_base_stats_female);
				}
			}
		}
	}

	private void combineBonusesForSides(int pLocusIndex, BaseStats pBaseStatsMain)
	{
		(int, int) xYFromIndex = getXYFromIndex(pLocusIndex);
		int item = xYFromIndex.Item1;
		int item2 = xYFromIndex.Item2;
		bool num = isNextToBad(pLocusIndex);
		getBonusesFromGene(item, item2 + 1, pBaseStatsMain);
		getBonusesFromGene(item, item2 - 1, pBaseStatsMain);
		getBonusesFromGene(item - 1, item2, pBaseStatsMain);
		getBonusesFromGene(item + 1, item2, pBaseStatsMain);
		if (num)
		{
			BaseStatsContainer[] array = pBaseStatsMain.getList().ToArray();
			foreach (BaseStatsContainer baseStatsContainer in array)
			{
				float value = ((!Mathf.Approximately(Mathf.Floor(baseStatsContainer.value), baseStatsContainer.value)) ? (baseStatsContainer.value * 0.5f) : Mathf.Floor(baseStatsContainer.value * 0.5f));
				pBaseStatsMain[baseStatsContainer.id] = value;
			}
			pBaseStatsMain.normalize();
		}
	}

	private void getBonusesFromGene(int pX, int pY, BaseStats pBaseStatsMain, BaseStats pBaseStatsMeta = null, bool pCombineMeta = false)
	{
		if (getGeneAt(pX, pY) != null)
		{
			int indexFrom = getIndexFrom(pX, pY);
			getBonusesFromGene(indexFrom, pBaseStatsMain, pBaseStatsMeta, pCombineMeta);
		}
	}

	private void getBonusesFromGene(int pLocusIndex, BaseStats pBaseStatsMain, BaseStats pBaseStatsMeta = null, bool pCombineMeta = false)
	{
		GeneAsset geneAsset = genes[pLocusIndex];
		bool flag = hasFullSynergy(pLocusIndex);
		bool num = isNextToBad(pLocusIndex);
		if (num)
		{
			flag = false;
		}
		if (num)
		{
			pBaseStatsMain.mergeStats(geneAsset.getHalfStats());
			if (pCombineMeta)
			{
				pBaseStatsMain.mergeStats(geneAsset.getHalfStatsMeta());
			}
			else
			{
				pBaseStatsMeta?.mergeStats(geneAsset.getHalfStatsMeta());
			}
			return;
		}
		pBaseStatsMain.mergeStats(geneAsset.base_stats);
		if (pCombineMeta)
		{
			pBaseStatsMain.mergeStats(geneAsset.base_stats_meta);
		}
		pBaseStatsMeta?.mergeStats(geneAsset.base_stats_meta);
		if (flag && !geneAsset.synergy_sides_always)
		{
			pBaseStatsMain.mergeStats(geneAsset.base_stats);
			if (pCombineMeta)
			{
				pBaseStatsMain.mergeStats(geneAsset.base_stats_meta);
			}
			else
			{
				pBaseStatsMeta?.mergeStats(geneAsset.base_stats_meta);
			}
		}
	}

	private void clearAllBaseStats()
	{
		BaseStats[] base_stats_all = _base_stats_all;
		for (int i = 0; i < base_stats_all.Length; i++)
		{
			base_stats_all[i].clear();
		}
	}

	public bool hasFullSynergyAt(int pX, int pY)
	{
		int num = 0;
		if (isAllSidesVoidLocus(pX, pY))
		{
			return false;
		}
		if (isNextToBad(pX, pY))
		{
			return false;
		}
		if (isNextToBadAmplifier(pX, pY))
		{
			return false;
		}
		if (hasSynergyConnectionLeft(pX, pY))
		{
			num++;
		}
		if (hasSynergyConnectionRight(pX, pY))
		{
			num++;
		}
		if (hasSynergyConnectionUp(pX, pY))
		{
			num++;
		}
		if (hasSynergyConnectionDown(pX, pY))
		{
			num++;
		}
		int num2 = 0;
		if (!hasBoundLeft(pX, pY))
		{
			num2++;
		}
		if (!hasBoundRight(pX, pY))
		{
			num2++;
		}
		if (!hasBoundUp(pX, pY))
		{
			num2++;
		}
		if (!hasBoundDown(pX, pY))
		{
			num2++;
		}
		return num == num2;
	}

	public bool hasFullSynergy(int pLocusIndex)
	{
		var (pX, pY) = getXYFromIndex(pLocusIndex);
		return hasFullSynergyAt(pX, pY);
	}

	public bool hasAnySynergy(int pLocusIndex)
	{
		var (pFromX, pFromY) = getXYFromIndex(pLocusIndex);
		if (hasSynergyConnectionLeft(pFromX, pFromY))
		{
			return true;
		}
		if (hasSynergyConnectionRight(pFromX, pFromY))
		{
			return true;
		}
		if (hasSynergyConnectionUp(pFromX, pFromY))
		{
			return true;
		}
		if (hasSynergyConnectionDown(pFromX, pFromY))
		{
			return true;
		}
		return false;
	}

	public string getSynergyTooltipText(int pLocusIndex)
	{
		(int, int) xYFromIndex = getXYFromIndex(pLocusIndex);
		int item = xYFromIndex.Item1;
		int item2 = xYFromIndex.Item2;
		GeneAsset geneAt = getGeneAt(item, item2);
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		bool flag = isBadAt(item, item2);
		if (hasAnySynergy(pLocusIndex) && !flag)
		{
			stringBuilderPool.Append(Toolbox.coloredString(LocalizedTextManager.getText("sequence_synergy"), "#FFFFAA"));
		}
		else
		{
			stringBuilderPool.Append(LocalizedTextManager.getText("sequence_synergy"));
		}
		stringBuilderPool.Append("\n");
		bool num = hasSynergyConnectionLeft(item, item2);
		bool flag2 = hasSynergyConnectionRight(item, item2);
		bool num2 = hasSynergyConnectionUp(item, item2);
		bool flag3 = hasSynergyConnectionDown(item, item2);
		GeneAsset geneLeft = getGeneLeft(item, item2);
		GeneAsset geneRight = getGeneRight(item, item2);
		GeneAsset geneUp = getGeneUp(item, item2);
		GeneAsset geneDown = getGeneDown(item, item2);
		bool flag4 = isForcedSynergyAt(item, item2);
		if (num2)
		{
			if (flag || isBadAt(item, item2 - 1) || hasAmplifierBad(item, item2 - 1))
			{
				stringBuilderPool.Append(getBadConnectionString());
			}
			else if (flag4)
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneUp.genetic_code_down));
			}
			else
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneAt.genetic_code_up));
			}
		}
		else if (hasBoundUp(item, item2) || isConnectionDeniedUp(item, item2))
		{
			stringBuilderPool.Append("<color=#444444>???????</color>");
		}
		else
		{
			stringBuilderPool.Append(getNotConnectedText(geneAt.genetic_code_up, World.world.getCurSessionTime()));
		}
		stringBuilderPool.Append("\n");
		if (num)
		{
			if (flag || isBadAt(item - 1, item2) || hasAmplifierBad(item - 1, item2))
			{
				stringBuilderPool.Append(getBadConnectionString());
			}
			else if (flag4)
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneLeft.genetic_code_right));
			}
			else
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneAt.genetic_code_left));
			}
		}
		else if (hasBoundLeft(item, item2) || isConnectionDeniedLeft(item, item2))
		{
			stringBuilderPool.Append("<color=#444444>???????</color>");
		}
		else
		{
			stringBuilderPool.Append(getNotConnectedText(geneAt.genetic_code_left, World.world.getCurSessionTime()));
		}
		stringBuilderPool.Append(" ... ");
		if (flag2)
		{
			if (flag || isBadAt(item + 1, item2) || hasAmplifierBad(item + 1, item2))
			{
				stringBuilderPool.Append(getBadConnectionString());
			}
			else if (flag4)
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneRight.genetic_code_left));
			}
			else
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneAt.genetic_code_right));
			}
		}
		else if (hasBoundRight(item, item2) || isConnectionDeniedRight(item, item2))
		{
			stringBuilderPool.Append("<color=#444444>???????</color>");
		}
		else
		{
			stringBuilderPool.Append(getNotConnectedText(geneAt.genetic_code_right, World.world.getCurSessionTime()));
		}
		stringBuilderPool.Append("\n");
		if (flag3)
		{
			if (flag || isBadAt(item, item2 + 1) || hasAmplifierBad(item, item2 + 1))
			{
				stringBuilderPool.Append(getBadConnectionString());
			}
			else if (flag4)
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneDown.genetic_code_up));
			}
			else
			{
				stringBuilderPool.Append(NucleobaseHelper.getColoredNucleobaseFull(geneAt.genetic_code_down));
			}
		}
		else if (hasBoundDown(item, item2) || isConnectionDeniedDown(item, item2))
		{
			stringBuilderPool.Append("<color=#444444>???????</color>");
		}
		else
		{
			stringBuilderPool.Append(getNotConnectedText(geneAt.genetic_code_down, World.world.getCurSessionTime()));
		}
		stringBuilderPool.Append("\n");
		stringBuilderPool.Append("\n");
		return stringBuilderPool.ToString();
	}

	private string getBadConnectionString()
	{
		return InsultStringGenerator.getBadConnectionString();
	}

	private string getNotConnectedText(char pChar, double pTime)
	{
		string fullNucleobaseName = NucleobaseHelper.getFullNucleobaseName(pChar);
		string colorHex = NucleobaseHelper.getColorHex(pChar, pDark: true);
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		for (int i = 0; i < fullNucleobaseName.Length; i++)
		{
			stringBuilderPool.Append(fullNucleobaseName[i]);
		}
		int num = pChar * 100;
		int index = (int)((pTime + (double)num) * 8.0 % (double)fullNucleobaseName.Length);
		stringBuilderPool[index] = '?';
		return Toolbox.coloredString(stringBuilderPool.ToString(), colorHex);
	}

	private int getIndexFrom(int pX, int pY)
	{
		return pX + pY * 6;
	}

	public (int, int) getXYFromIndex(int pIndex)
	{
		int item = pIndex % 6;
		int item2 = pIndex / 6;
		return (item, item2);
	}

	public Sprite getSpriteNormal()
	{
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList("chromosomes/normal/");
		if (_cached_sprite_index == -1)
		{
			_cached_sprite_index = Randy.randomInt(0, spriteList.Length - 1);
		}
		_cached_sprite = spriteList[_cached_sprite_index];
		return _cached_sprite;
	}

	public Sprite getSpriteGolden()
	{
		Sprite[] spriteList = SpriteTextureLoader.getSpriteList("chromosomes/golden/");
		if (_cached_sprite_index == -1)
		{
			_cached_sprite_index = Randy.randomInt(0, spriteList.Length - 1);
		}
		_cached_sprite = spriteList[_cached_sprite_index];
		return _cached_sprite;
	}

	public void cloneFrom(Chromosome pParentChromosome)
	{
		genes.AddRange(pParentChromosome.genes);
		_loci_empty.AddRange(pParentChromosome._loci_empty);
		_loci_amplifiers.AddRange(pParentChromosome._loci_amplifiers);
		setDirty();
	}

	public void mutateRandomGene()
	{
		using ListPool<int> listPool = new ListPool<int>();
		for (int i = 0; i < genes.Count; i++)
		{
			if (!isSpecialLocus(i))
			{
				listPool.Add(i);
			}
		}
		int random = listPool.GetRandom();
		GeneAsset randomGeneForMutation = AssetManager.gene_library.getRandomGeneForMutation();
		setGene(randomGeneForMutation, random);
		setDirty();
	}

	public bool hasGene(GeneAsset pAsset)
	{
		return genes?.Contains(pAsset) ?? false;
	}

	public GeneAsset getGeneAtDirectionFrom(int pFromX, int pFromY, GeneDirection pDirection)
	{
		(int, int) directionOffset = getDirectionOffset(pDirection);
		int item = directionOffset.Item1;
		int item2 = directionOffset.Item2;
		int pX = pFromX + item;
		int pY = pFromY + item2;
		if (!isCoordinatesValid(pX, pY))
		{
			return null;
		}
		int indexFrom = getIndexFrom(pFromX + item, pFromY + item2);
		return genes[indexFrom];
	}

	public GeneAsset getGeneAt(int pFromX, int pFromY)
	{
		if (!isCoordinatesValid(pFromX, pFromY))
		{
			return null;
		}
		int indexFrom = getIndexFrom(pFromX, pFromY);
		if (!isIndexValid(indexFrom))
		{
			return null;
		}
		return genes[indexFrom];
	}

	public GeneAsset getGeneLeft(int pFromX, int pFromY)
	{
		return getGeneAtDirectionFrom(pFromX, pFromY, GeneDirection.Left);
	}

	public GeneAsset getGeneRight(int pFromX, int pFromY)
	{
		return getGeneAtDirectionFrom(pFromX, pFromY, GeneDirection.Right);
	}

	public GeneAsset getGeneUp(int pFromX, int pFromY)
	{
		return getGeneAtDirectionFrom(pFromX, pFromY, GeneDirection.Up);
	}

	public GeneAsset getGeneDown(int pFromX, int pFromY)
	{
		return getGeneAtDirectionFrom(pFromX, pFromY, GeneDirection.Down);
	}

	private bool isIndexValid(int pIndex)
	{
		if (pIndex < 0)
		{
			return false;
		}
		if (pIndex >= genes.Count)
		{
			return false;
		}
		return true;
	}

	private bool isCoordinatesValid(int pX, int pY)
	{
		if (pX < 0)
		{
			return false;
		}
		if (pY < 0)
		{
			return false;
		}
		if (pX >= 6)
		{
			return false;
		}
		if (pY >= _columns)
		{
			return false;
		}
		return true;
	}

	public (int, int) getDirectionOffset(GeneDirection pDirection)
	{
		return pDirection switch
		{
			GeneDirection.Up => DIRECTIONS[0], 
			GeneDirection.Down => DIRECTIONS[1], 
			GeneDirection.Left => DIRECTIONS[2], 
			GeneDirection.Right => DIRECTIONS[3], 
			_ => (0, 0), 
		};
	}

	public bool canBeConnectedTo(int pFromX, int pFromY, int pToX, int pToY)
	{
		GeneAsset geneAt = getGeneAt(pFromX, pFromY);
		GeneAsset geneAt2 = getGeneAt(pToX, pToY);
		if (geneAt == null || geneAt2 == null)
		{
			return false;
		}
		if (!geneAt.is_empty)
		{
			_ = geneAt2.is_empty;
		}
		return false;
	}

	public int countBounds(int pX, int pY)
	{
		int num = 0;
		if (isCoordinatesValid(pX - 1, pY))
		{
			num++;
		}
		if (isCoordinatesValid(pX + 1, pY))
		{
			num++;
		}
		if (isCoordinatesValid(pX, pY - 1))
		{
			num++;
		}
		if (isCoordinatesValid(pX, pY + 1))
		{
			num++;
		}
		return num;
	}

	public bool hasSynergyConnectionLeft(int pFromX, int pFromY)
	{
		if (hasBoundLeft(pFromX, pFromY))
		{
			return false;
		}
		return hasSynergyConnection(pFromX, pFromY, GeneDirection.Left);
	}

	public bool hasSynergyConnectionRight(int pFromX, int pFromY)
	{
		if (hasBoundRight(pFromX, pFromY))
		{
			return false;
		}
		return hasSynergyConnection(pFromX, pFromY, GeneDirection.Right);
	}

	public bool hasSynergyConnectionUp(int pFromX, int pFromY)
	{
		if (hasBoundUp(pFromX, pFromY))
		{
			return false;
		}
		return hasSynergyConnection(pFromX, pFromY, GeneDirection.Up);
	}

	public bool hasSynergyConnectionDown(int pFromX, int pFromY)
	{
		if (hasBoundDown(pFromX, pFromY))
		{
			return false;
		}
		return hasSynergyConnection(pFromX, pFromY, GeneDirection.Down);
	}

	public bool isAllLociSynergy()
	{
		int num = -1;
		foreach (GeneAsset gene in genes)
		{
			num++;
			if (!gene.is_empty && !gene.synergy_sides_always)
			{
				if (gene.is_bad)
				{
					return false;
				}
				var (pFromX, pFromY) = getXYFromIndex(num);
				if (!hasAllSynergiesAt(pFromX, pFromY, pCheckBounds: false))
				{
					return false;
				}
			}
		}
		return true;
	}

	public bool hasAllSynergiesAt(int pFromX, int pFromY, bool pCheckBounds = true)
	{
		if (isAllSidesVoidLocus(pFromX, pFromY))
		{
			return false;
		}
		bool num = (pCheckBounds ? hasSynergyConnectionLeft(pFromX, pFromY) : (hasBoundLeft(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Left)));
		bool flag = (pCheckBounds ? hasSynergyConnectionRight(pFromX, pFromY) : (hasBoundRight(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Right)));
		bool flag2 = (pCheckBounds ? hasSynergyConnectionUp(pFromX, pFromY) : (hasBoundUp(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Up)));
		bool flag3 = (pCheckBounds ? hasSynergyConnectionDown(pFromX, pFromY) : (hasBoundDown(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Down)));
		return num && flag && flag2 && flag3;
	}

	public bool hasSynergyConnection(int pFromX, int pFromY, GeneDirection pDirection)
	{
		GeneAsset geneAt = getGeneAt(pFromX, pFromY);
		bool flag = isAmplifierLocusAt(pFromX, pFromY);
		bool flag2 = false;
		if (geneAt.synergy_sides_always)
		{
			flag = true;
		}
		if (geneAt.is_bad)
		{
			flag2 = true;
		}
		if (!flag && geneAt.is_empty)
		{
			return false;
		}
		(int, int) directionOffset = getDirectionOffset(pDirection);
		int item = directionOffset.Item1;
		int item2 = directionOffset.Item2;
		GeneAsset geneAt2 = getGeneAt(pFromX + item, pFromY + item2);
		bool flag3 = isAmplifierLocusAt(pFromX + item, pFromY + item2);
		if (geneAt2 != null && geneAt2.synergy_sides_always)
		{
			flag3 = true;
		}
		if (geneAt2 != null && geneAt2.is_bad)
		{
			flag2 = true;
		}
		if (!flag3)
		{
			if (geneAt2 == null)
			{
				return false;
			}
			if (geneAt2.is_empty)
			{
				return false;
			}
		}
		if (!flag2 && flag && flag3)
		{
			return false;
		}
		switch (pDirection)
		{
		case GeneDirection.Up:
			if (flag || flag3)
			{
				return true;
			}
			if (geneAt.genetic_code_up == geneAt2.genetic_code_down)
			{
				return true;
			}
			break;
		case GeneDirection.Down:
			if (flag || flag3)
			{
				return true;
			}
			if (geneAt.genetic_code_down == geneAt2.genetic_code_up)
			{
				return true;
			}
			break;
		case GeneDirection.Left:
			if (flag || flag3)
			{
				return true;
			}
			if (geneAt.genetic_code_left == geneAt2.genetic_code_right)
			{
				return true;
			}
			break;
		case GeneDirection.Right:
			if (flag || flag3)
			{
				return true;
			}
			if (geneAt.genetic_code_right == geneAt2.genetic_code_left)
			{
				return true;
			}
			break;
		}
		return false;
	}

	public bool isConnectionDeniedUp(int pFromX, int pFromY)
	{
		if (hasBoundAt(pFromX, pFromY - 1))
		{
			return true;
		}
		if (isForcedSynergyUp(pFromX, pFromY) && isForcedSynergyAt(pFromX, pFromY))
		{
			return true;
		}
		return false;
	}

	public bool isConnectionDeniedDown(int pFromX, int pFromY)
	{
		if (hasBoundAt(pFromX, pFromY + 1))
		{
			return true;
		}
		if (isForcedSynergyDown(pFromX, pFromY) && isForcedSynergyAt(pFromX, pFromY))
		{
			return true;
		}
		return false;
	}

	public bool isConnectionDeniedLeft(int pFromX, int pFromY)
	{
		if (hasBoundAt(pFromX - 1, pFromY))
		{
			return true;
		}
		if (isForcedSynergyLeft(pFromX, pFromY) && isForcedSynergyAt(pFromX, pFromY))
		{
			return true;
		}
		return false;
	}

	public bool isConnectionDeniedRight(int pFromX, int pFromY)
	{
		if (hasBoundAt(pFromX + 1, pFromY))
		{
			return true;
		}
		if (isForcedSynergyRight(pFromX, pFromY) && isForcedSynergyAt(pFromX, pFromY))
		{
			return true;
		}
		return false;
	}

	public bool hasBoundAt(int pX, int pY)
	{
		if (!isCoordinatesValid(pX, pY))
		{
			return true;
		}
		if (isVoidLocusAt(pX, pY))
		{
			return true;
		}
		return false;
	}

	public bool hasBoundLeft(int pX, int pY)
	{
		return hasBoundAt(pX - 1, pY);
	}

	public bool hasBoundRight(int pX, int pY)
	{
		return hasBoundAt(pX + 1, pY);
	}

	public bool hasBoundUp(int pX, int pY)
	{
		return hasBoundAt(pX, pY - 1);
	}

	public bool hasBoundDown(int pX, int pY)
	{
		return hasBoundAt(pX, pY + 1);
	}

	public void fillEmptyLoci()
	{
		for (int i = 0; i < genes.Count; i++)
		{
			GeneAsset geneAsset = genes[i];
			if (!isSpecialLocus(i) && geneAsset.is_empty)
			{
				GeneAsset randomSimpleGene = AssetManager.gene_library.getRandomSimpleGene();
				setGene(randomSimpleGene, i);
			}
		}
	}

	public bool isNextToBad(int pLocusIndex)
	{
		var (pX, pY) = getXYFromIndex(pLocusIndex);
		return isNextToBad(pX, pY);
	}

	public bool isNextToBad(int pX, int pY)
	{
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
		{
			var (num, num2) = dIRECTIONS[i];
			if (isBadAt(pX + num, pY + num2))
			{
				return true;
			}
		}
		return false;
	}

	public bool hasGenesAround(int pIndex)
	{
		var (pX, pY) = getXYFromIndex(pIndex);
		return hasGenesAround(pX, pY);
	}

	public bool hasGenesAround(int pX, int pY)
	{
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
		{
			(int, int) tuple = dIRECTIONS[i];
			int item = tuple.Item1;
			int item2 = tuple.Item2;
			int num = pX + item;
			int num2 = pY + item2;
			if (isAmplifierLocusAt(num, num2))
			{
				return true;
			}
			GeneAsset geneAt = getGeneAt(num, num2);
			if (geneAt != null && !geneAt.is_empty)
			{
				return true;
			}
		}
		return false;
	}

	public bool isNextToBadAmplifier(int pX, int pY)
	{
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
		{
			var (num, num2) = dIRECTIONS[i];
			if (hasAmplifierBad(pX + num, pY + num2))
			{
				return true;
			}
		}
		return false;
	}

	public bool isBadAt(int pX, int pY)
	{
		if (isVoidLocusAt(pX, pY))
		{
			return false;
		}
		GeneAsset geneAt = getGeneAt(pX, pY);
		if (geneAt == null)
		{
			return false;
		}
		if (geneAt.is_bad)
		{
			return true;
		}
		return false;
	}

	public bool hasAmplifierBad(int pX, int pY)
	{
		if (!isLocusAmplifier(pX, pY))
		{
			return false;
		}
		if (isNextToBad(pX, pY))
		{
			return true;
		}
		return false;
	}

	public void shuffleGenes()
	{
		GeneAsset gene_for_generation = GeneLibrary.gene_for_generation;
		using ListPool<GeneAsset> listPool = new ListPool<GeneAsset>();
		for (int i = 0; i < genes.Count; i++)
		{
			GeneAsset geneAsset = genes[i];
			if (!geneAsset.is_empty)
			{
				listPool.Add(geneAsset);
				genes[i] = gene_for_generation;
			}
		}
		listPool.Shuffle();
		for (int j = 0; j < genes.Count; j++)
		{
			if (listPool.Count == 0)
			{
				break;
			}
			if (genes[j].for_generation)
			{
				genes[j] = listPool.Pop();
			}
		}
		setDirty();
	}
}
// --- End of File: Chromosome.cs ---



// --- Start of File: ChromosomeClickEvent.cs ---
public delegate void ChromosomeClickEvent(Chromosome pChromosome);
// --- End of File: ChromosomeClickEvent.cs ---



// --- Start of File: ChromosomeData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;

[Serializable]
public class ChromosomeData
{
	public List<string> loci = new List<string>();

	public List<int> super_loci = new List<int>();

	public List<int> void_loci = new List<int>();

	[DefaultValue("chromosome_medium")]
	public string chromosome_type = "chromosome_medium";
}
// --- End of File: ChromosomeData.cs ---



// --- Start of File: ChromosomeElement.cs ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ChromosomeElement : MonoBehaviour
{
	private static readonly Color color_synergy_gold = Toolbox.makeColor("#FFF841");

	private static readonly Color color_normal_blue = Toolbox.makeColor("#00B0FF");

	internal Chromosome chromosome;

	private ChromosomeClickEvent _click_event;

	public Image image;

	private void Start()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		setupTooltip();
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener(new UnityAction(clickChromosome));
		DraggableLayoutElement draggableLayoutElement = default(DraggableLayoutElement);
		if (((Component)this).TryGetComponent<DraggableLayoutElement>(ref draggableLayoutElement))
		{
			DraggableLayoutElement draggableLayoutElement2 = draggableLayoutElement;
			draggableLayoutElement2.start_being_dragged = (Action<DraggableLayoutElement>)Delegate.Combine(draggableLayoutElement2.start_being_dragged, new Action<DraggableLayoutElement>(onStartDrag));
		}
	}

	protected virtual void onStartDrag(DraggableLayoutElement pOriginalElement)
	{
		ChromosomeElement component = ((Component)pOriginalElement).GetComponent<ChromosomeElement>();
		show(component.chromosome, null);
	}

	private void clickChromosome()
	{
		_click_event?.Invoke(chromosome);
	}

	public void show(Chromosome pChromosome, ChromosomeClickEvent pClickEvent)
	{
		chromosome = pChromosome;
		_click_event = pClickEvent;
		if (pChromosome.isAllLociSynergy())
		{
			image.sprite = chromosome.getSpriteGolden();
		}
		else
		{
			image.sprite = chromosome.getSpriteNormal();
		}
	}

	protected virtual void setupTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			tipButton.setHoverAction(tooltipAction);
		}
	}

	protected void tooltipAction()
	{
		Tooltip.show(this, "chromosome", new TooltipData
		{
			chromosome = chromosome
		});
	}
}
// --- End of File: ChromosomeElement.cs ---



// --- Start of File: ChromosomeTypeAsset.cs ---
using System;

[Serializable]
public class ChromosomeTypeAsset : Asset, IDescriptionAsset, ILocalizedAsset
{
	public int amount_loci;

	public int amount_loci_min_amplifier;

	public int amount_loci_max_amplifier;

	public int amount_loci_min_empty;

	public int amount_loci_max_empty;

	public string name;

	public string description;

	public string getLocaleID()
	{
		return id;
	}

	public string getDescriptionID()
	{
		return id + "_description";
	}
}
// --- End of File: ChromosomeTypeAsset.cs ---



// --- Start of File: ChromosomeTypeLibrary.cs ---
public class ChromosomeTypeLibrary : AssetLibrary<ChromosomeTypeAsset>
{
	public const int LOCI_PER_ROW = 6;

	public override void init()
	{
		base.init();
		add(new ChromosomeTypeAsset
		{
			id = "chromosome_big",
			amount_loci_min_amplifier = 1,
			amount_loci_max_amplifier = 4,
			amount_loci_min_empty = 4,
			amount_loci_max_empty = 8,
			amount_loci = 30,
			name = "chromosome_big",
			description = "some chromosome"
		});
		add(new ChromosomeTypeAsset
		{
			id = "chromosome_medium",
			amount_loci_min_amplifier = 1,
			amount_loci_max_amplifier = 3,
			amount_loci_min_empty = 3,
			amount_loci_max_empty = 5,
			amount_loci = 24,
			name = "chromosome_medium",
			description = "some chromosome"
		});
		add(new ChromosomeTypeAsset
		{
			id = "chromosome_small",
			amount_loci_min_amplifier = 1,
			amount_loci_max_amplifier = 3,
			amount_loci_min_empty = 2,
			amount_loci_max_empty = 4,
			amount_loci = 18,
			name = "chromosome_small",
			description = "some chromosome"
		});
		add(new ChromosomeTypeAsset
		{
			id = "chromosome_tiny",
			amount_loci_min_amplifier = 0,
			amount_loci_max_amplifier = 2,
			amount_loci_min_empty = 1,
			amount_loci_max_empty = 3,
			amount_loci = 12,
			name = "chromosome_tiny",
			description = "some chromosome"
		});
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (ChromosomeTypeAsset item in list)
		{
			checkLocale(item, item.getLocaleID());
			checkLocale(item, item.getDescriptionID());
		}
	}
}
// --- End of File: ChromosomeTypeLibrary.cs ---



// --- Start of File: ChunkObjectContainer.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public class ChunkObjectContainer : IDisposable
{
	public readonly List<long> kingdoms = new List<long>();

	public readonly List<Actor> units_all = new List<Actor>();

	public readonly List<Building> buildings_all = new List<Building>();

	private readonly HashSet<long> _hash_kingdoms = new HashSet<long>();

	private readonly Dictionary<long, List<Actor>> _dict_units = new Dictionary<long, List<Actor>>();

	private readonly Dictionary<long, List<Building>> _dict_buildings = new Dictionary<long, List<Building>>();

	private int _total_units;

	private int _total_buildings;

	public int total_units => _total_units;

	public int total_buildings => _total_buildings;

	public void reset(bool pClearBuildings)
	{
		if ((_total_units == 0 && _total_buildings == 0) || (_total_units == 0 && !pClearBuildings))
		{
			return;
		}
		foreach (List<Actor> value in _dict_units.Values)
		{
			value.Clear();
		}
		units_all.Clear();
		_total_units = 0;
		kingdoms.Clear();
		_hash_kingdoms.Clear();
		if (pClearBuildings)
		{
			buildings_all.Clear();
			_total_buildings = 0;
			{
				foreach (List<Building> value2 in _dict_buildings.Values)
				{
					value2.Clear();
				}
				return;
			}
		}
		if (_dict_buildings.Count <= 0)
		{
			return;
		}
		foreach (long key in _dict_buildings.Keys)
		{
			kingdoms.Add(key);
		}
		_hash_kingdoms.UnionWith(kingdoms);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public List<Building> getBuildings(long pKingdom)
	{
		return _dict_buildings[pKingdom];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public List<Actor> getUnits(long pKingdom)
	{
		return _dict_units[pKingdom];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isEmpty()
	{
		return kingdoms.Count == 0;
	}

	public void addActor(Actor pActor)
	{
		long id = pActor.kingdom.id;
		if (_hash_kingdoms.Add(id))
		{
			if (!_dict_units.TryGetValue(id, out var value))
			{
				value = new List<Actor>();
				_dict_units[id] = value;
				_dict_buildings[id] = new List<Building>();
			}
			value.Add(pActor);
			kingdoms.Add(id);
			_total_units++;
		}
		else
		{
			_dict_units[id].Add(pActor);
			_total_units++;
		}
		units_all.Add(pActor);
	}

	public void addBuilding(Building pBuilding)
	{
		long id = pBuilding.kingdom.id;
		if (_hash_kingdoms.Add(id))
		{
			if (!_dict_buildings.TryGetValue(id, out var value))
			{
				value = new List<Building>();
				_dict_buildings[id] = value;
				_dict_units[id] = new List<Actor>();
			}
			value.Add(pBuilding);
			_total_buildings++;
			kingdoms.Add(id);
		}
		else
		{
			_dict_buildings[id].Add(pBuilding);
			_total_buildings++;
		}
		buildings_all.Add(pBuilding);
	}

	public void Dispose()
	{
		reset(pClearBuildings: true);
		_dict_units.Clear();
		_dict_buildings.Clear();
		units_all.Clear();
		buildings_all.Clear();
		_total_units = 0;
		_total_buildings = 0;
	}

	public Dictionary<long, List<Building>>.ValueCollection getDebugBuildings()
	{
		return _dict_buildings.Values;
	}

	public Dictionary<long, List<Actor>>.ValueCollection getDebugUnits()
	{
		return _dict_units.Values;
	}
}
// --- End of File: ChunkObjectContainer.cs ---



// --- Start of File: CircleIconShaderMod.cs ---
using UnityEngine;

public class CircleIconShaderMod : MonoBehaviour
{
	public Material prefab_radial_fill;

	private Material _instance_material;

	public SpriteRenderer sprite_renderer_with_mat;

	private void Awake()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		_instance_material = new Material(prefab_radial_fill);
		((Renderer)sprite_renderer_with_mat).material = _instance_material;
	}

	public void setShaderVal(float pVal)
	{
		if (!((Object)(object)sprite_renderer_with_mat == (Object)null))
		{
			float num = Mathf.PingPong(pVal, 1f);
			_instance_material.SetFloat("_FillAmount", num);
		}
	}
}
// --- End of File: CircleIconShaderMod.cs ---



// --- Start of File: CitiesBannersContainer.cs ---
using System.Collections.Generic;

public class CitiesBannersContainer : BannersMetaContainer<CityBanner, City, CityData>
{
	protected override IEnumerable<City> getMetaList(IMetaObject pMeta)
	{
		return pMeta.getCities();
	}
}
// --- End of File: CitiesBannersContainer.cs ---



// --- Start of File: CitiesKingdomsContainersController.cs ---
using UnityEngine;

public class CitiesKingdomsContainersController : MonoBehaviour
{
	[SerializeField]
	private CitiesBannersContainer _banners_cities;

	[SerializeField]
	private GameObject _line_cities;

	[SerializeField]
	private KingdomsBannersContainer _banners_kingdoms;

	[SerializeField]
	private GameObject _line_kingdoms;

	public void update(NanoObject pNano)
	{
		_banners_cities.update(pNano);
		_banners_kingdoms.update(pNano);
		IMetaObject obj = (IMetaObject)pNano;
		bool active = obj.hasCities();
		((Component)_banners_cities).gameObject.SetActive(active);
		_line_cities.SetActive(active);
		bool active2 = obj.hasKingdoms();
		((Component)_banners_kingdoms).gameObject.SetActive(active2);
		_line_kingdoms.SetActive(active2);
	}
}
// --- End of File: CitiesKingdomsContainersController.cs ---



// --- Start of File: CitiesMetaContainer.cs ---
using System;
using System.Collections.Generic;

public class CitiesMetaContainer : ListMetaContainer<CityListElement, City, CityData>
{
	protected override IEnumerable<City> getMetaList()
	{
		return getMeta().getCities();
	}

	protected override Comparison<City> getSorting()
	{
		return ComponentListBase<CityListElement, City, CityData, CityListComponent>.sortByPopulation;
	}
}
// --- End of File: CitiesMetaContainer.cs ---



// --- Start of File: CitiesNoItems.cs ---
public class CitiesNoItems : MetaListNoItems
{
	protected override bool hasMetas()
	{
		return base.meta_object.hasCities();
	}
}
// --- End of File: CitiesNoItems.cs ---



// --- Start of File: CitizenJobAsset.cs ---
using System;
using System.ComponentModel;

[Serializable]
public class CitizenJobAsset : Asset
{
	public string path_icon;

	public int priority;

	public int priority_no_food;

	[DefaultValue(true)]
	public bool common_job = true;

	[DefaultValue(true)]
	public bool ok_for_king = true;

	[DefaultValue(true)]
	public bool ok_for_leader = true;

	public bool only_leaders;

	public CitizenJobCondition should_be_assigned;

	public string unit_job_default;

	public DebugOption debug_option;
}
// --- End of File: CitizenJobAsset.cs ---



// --- Start of File: CitizenJobCondition.cs ---
public delegate bool CitizenJobCondition(Actor pActor);
// --- End of File: CitizenJobCondition.cs ---



// --- Start of File: CitizenJobLibrary.cs ---
using System.Collections.Generic;

public class CitizenJobLibrary : AssetLibrary<CitizenJobAsset>
{
	public List<CitizenJobAsset> list_priority_normal;

	public List<CitizenJobAsset> list_priority_high;

	public List<CitizenJobAsset> list_priority_high_food;

	public static CitizenJobAsset builder;

	public static CitizenJobAsset gatherer_bushes;

	public static CitizenJobAsset gatherer_herbs;

	public static CitizenJobAsset gatherer_honey;

	public static CitizenJobAsset farmer;

	public static CitizenJobAsset hunter;

	public static CitizenJobAsset woodcutter;

	public static CitizenJobAsset miner;

	public static CitizenJobAsset miner_deposit;

	public static CitizenJobAsset road_builder;

	public static CitizenJobAsset cleaner;

	public static CitizenJobAsset manure_cleaner;

	public static CitizenJobAsset attacker;

	public override void init()
	{
		base.init();
		builder = add(new CitizenJobAsset
		{
			id = "builder",
			priority = 9,
			debug_option = DebugOption.CitizenJobBuilder,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobBuilder"
		});
		gatherer_bushes = add(new CitizenJobAsset
		{
			id = "gatherer_bushes",
			priority_no_food = 10,
			debug_option = DebugOption.CitizenJobGathererBushes,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobGathererBushes"
		});
		gatherer_herbs = add(new CitizenJobAsset
		{
			id = "gatherer_herbs",
			priority_no_food = 10,
			debug_option = DebugOption.CitizenJobGathererHerbs,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobGathererHerbs"
		});
		gatherer_honey = add(new CitizenJobAsset
		{
			id = "gatherer_honey",
			priority_no_food = 10,
			debug_option = DebugOption.CitizenJobGathererHoney,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobGathererHoney"
		});
		farmer = add(new CitizenJobAsset
		{
			id = "farmer",
			ok_for_king = false,
			ok_for_leader = false,
			debug_option = DebugOption.CitizenJobFarmer,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobFarmer"
		});
		hunter = add(new CitizenJobAsset
		{
			id = "hunter",
			debug_option = DebugOption.CitizenJobHunter,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobHunter"
		});
		woodcutter = add(new CitizenJobAsset
		{
			id = "woodcutter",
			debug_option = DebugOption.CitizenJobWoodcutter,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobWoodcutter"
		});
		miner = add(new CitizenJobAsset
		{
			id = "miner",
			ok_for_king = false,
			ok_for_leader = false,
			debug_option = DebugOption.CitizenJobMiner,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobMiner"
		});
		miner_deposit = add(new CitizenJobAsset
		{
			id = "miner_deposit",
			ok_for_king = false,
			ok_for_leader = false,
			debug_option = DebugOption.CitizenJobMinerDeposit,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobMinerDeposit"
		});
		road_builder = add(new CitizenJobAsset
		{
			id = "road_builder",
			debug_option = DebugOption.CitizenJobRoadBuilder,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobRoadBuilder"
		});
		cleaner = add(new CitizenJobAsset
		{
			id = "cleaner",
			debug_option = DebugOption.CitizenJobCleaner,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobCleaner"
		});
		manure_cleaner = add(new CitizenJobAsset
		{
			id = "manure_cleaner",
			debug_option = DebugOption.CitizenJobManureCleaner,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobManureCleaner"
		});
		attacker = add(new CitizenJobAsset
		{
			id = "attacker",
			debug_option = DebugOption.CitizenJobAttacker,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenJobAttacker",
			common_job = false
		});
	}

	public override void post_init()
	{
		base.post_init();
		foreach (CitizenJobAsset item in list)
		{
			if (item.common_job)
			{
				item.unit_job_default = item.id;
			}
		}
	}

	public override void linkAssets()
	{
		base.linkAssets();
		list_priority_normal = new List<CitizenJobAsset>();
		list_priority_high = new List<CitizenJobAsset>();
		list_priority_high_food = new List<CitizenJobAsset>();
		foreach (CitizenJobAsset item in list)
		{
			if (item.common_job)
			{
				if (item.priority_no_food > 0)
				{
					list_priority_high_food.Add(item);
				}
				if (item.priority > 0)
				{
					list_priority_high.Add(item);
				}
				else
				{
					list_priority_normal.Add(item);
				}
			}
		}
	}
}
// --- End of File: CitizenJobLibrary.cs ---



// --- Start of File: CitizenJobs.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

[Serializable]
public class CitizenJobs
{
	public Dictionary<CitizenJobAsset, int> jobs = new Dictionary<CitizenJobAsset, int>();

	public Dictionary<CitizenJobAsset, int> occupied = new Dictionary<CitizenJobAsset, int>();

	private int _total_tasks;

	public void clear()
	{
		jobs.Clear();
		occupied.Clear();
	}

	public int getTotalTasks()
	{
		return _total_tasks;
	}

	public bool hasAnyTask()
	{
		return _total_tasks > 0;
	}

	public void clearJobs()
	{
		_total_tasks = 0;
		jobs.Clear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void addToJob(CitizenJobAsset pJobAsset, int pValue)
	{
		_total_tasks += pValue;
		if (jobs.TryGetValue(pJobAsset, out var value))
		{
			jobs[pJobAsset] = value + pValue;
		}
		else
		{
			jobs.Add(pJobAsset, pValue);
		}
	}

	public bool continueJob(CitizenJobAsset pJobAsset)
	{
		return jobs.ContainsKey(pJobAsset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int countOccupied(CitizenJobAsset pJobAsset)
	{
		if (occupied.TryGetValue(pJobAsset, out var value))
		{
			return value;
		}
		return 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int countCurrentJobs(CitizenJobAsset pJobAsset)
	{
		if (jobs.TryGetValue(pJobAsset, out var value))
		{
			return value;
		}
		return 0;
	}

	public bool hasJob(CitizenJobAsset pJobAsset)
	{
		if (!jobs.TryGetValue(pJobAsset, out var value))
		{
			return false;
		}
		if (value == 0)
		{
			return false;
		}
		if (occupied.ContainsKey(pJobAsset) && occupied[pJobAsset] >= value)
		{
			return false;
		}
		return true;
	}

	public void takeJob(CitizenJobAsset pJobAsset)
	{
		if (!occupied.ContainsKey(pJobAsset))
		{
			occupied.Add(pJobAsset, 1);
		}
		else
		{
			occupied[pJobAsset]++;
		}
	}

	public void freeJob(CitizenJobAsset pJobAsset)
	{
		if (occupied.TryGetValue(pJobAsset, out var value))
		{
			if (value > 0)
			{
				occupied[pJobAsset]--;
			}
		}
		else
		{
			occupied.Add(pJobAsset, 0);
		}
	}
}
// --- End of File: CitizenJobs.cs ---



// --- Start of File: City.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;
using UnityEngine;
using db;

public class City : MetaObject<CityData>
{
	private static readonly HashSet<City> _connected_checked = new HashSet<City>();

	private static readonly HashSet<City> _connected_next_wave = new HashSet<City>();

	private static readonly HashSet<City> _connected_current_wave = new HashSet<City>();

	private readonly Dictionary<string, CityStorageSlot> _total_resource_slots = new Dictionary<string, CityStorageSlot>();

	private readonly Dictionary<UnitProfession, List<Actor>> _professions_dict = new Dictionary<UnitProfession, List<Actor>>();

	private readonly List<Actor> _boats = new List<Actor>();

	private readonly Dictionary<string, long> _species = new Dictionary<string, long>();

	public readonly List<Building> buildings = new List<Building>();

	public readonly Dictionary<string, List<Building>> buildings_dict_type = new Dictionary<string, List<Building>>();

	public readonly Dictionary<string, List<Building>> buildings_dict_id = new Dictionary<string, List<Building>>();

	public readonly CityTasksData tasks = new CityTasksData();

	public readonly CitizenJobs jobs = new CitizenJobs();

	public readonly CityStatus status = new CityStatus();

	public float mark_scale_effect;

	[NonSerialized]
	internal Kingdom kingdom;

	public Culture culture;

	public Language language;

	public Religion religion;

	public Actor leader;

	public Army army;

	internal readonly List<TileZone> zones = new List<TileZone>();

	internal readonly HashSet<TileZone> neighbour_zones = new HashSet<TileZone>();

	internal readonly HashSet<TileZone> border_zones = new HashSet<TileZone>();

	internal readonly HashSet<City> neighbours_cities = new HashSet<City>();

	internal readonly HashSet<City> neighbours_cities_kingdom = new HashSet<City>();

	internal readonly HashSet<Kingdom> neighbours_kingdoms = new HashSet<Kingdom>();

	internal Building under_construction_building;

	internal readonly List<Building> stockpiles = new List<Building>();

	internal readonly List<Building> storages = new List<Building>();

	internal float timer_build_boat;

	internal float timer_build;

	public float timer_action;

	private float _timer_capture;

	private float _timer_warrior;

	internal readonly List<WorldTile> road_tiles_to_build = new List<WorldTile>();

	private readonly List<WorldTile> tiles_to_remove = new List<WorldTile>();

	internal TileZone target_attack_zone;

	internal City target_attack_city;

	internal WorldTile _city_tile;

	internal string _debug_last_possible_build_orders;

	internal string _debug_last_possible_build_orders_no_resources;

	internal string _debug_last_build_order_try;

	internal Kingdom being_captured_by;

	private float _capture_ticks;

	public int last_visual_capture_ticks;

	private bool _dirty_citizens;

	private bool _dirty_city_status;

	private bool _dirty_abandoned_zones;

	internal Vector2 city_center;

	internal Vector2 last_city_center;

	public readonly WorldTileContainer calculated_place_for_farms = new WorldTileContainer();

	public readonly WorldTileContainer calculated_farm_fields = new WorldTileContainer();

	public readonly WorldTileContainer calculated_crops = new WorldTileContainer();

	public readonly WorldTileContainer calculated_grown_wheat = new WorldTileContainer();

	private readonly Dictionary<Kingdom, int> _capturing_units = new Dictionary<Kingdom, int>();

	internal readonly HashSet<TileZone> danger_zones = new HashSet<TileZone>();

	public AiSystemCity ai;

	private int _current_total_food;

	private int _last_checked_job_id;

	private double _loyalty_last_time;

	private int _loyalty_cached;

	private readonly List<long> _cached_book_ids = new List<long>();

	private readonly List<Building> _cached_buildings_with_book_slots = new List<Building>();

	public double timestamp_shrink;

	private int _storage_version;

	protected override MetaType meta_type => MetaType.City;

	public override BaseSystemManager manager => World.world.cities;

	protected override bool track_death_types => true;

	public int amount_wood => getResourcesAmount("wood");

	public int amount_gold => getResourcesAmount("gold");

	public int amount_stone => getResourcesAmount("stone");

	public int amount_common_metals => getResourcesAmount("common_metals");

	public int getStorageVersion()
	{
		return _storage_version;
	}

	public override void increaseBirths()
	{
		base.increaseBirths();
		addRenown(1);
	}

	public void increaseLeft()
	{
		if (isAlive())
		{
			data.left++;
		}
	}

	public void increaseJoined()
	{
		if (isAlive())
		{
			data.joined++;
			addRenown(1);
		}
	}

	public void increaseMoved()
	{
		if (isAlive())
		{
			data.moved++;
			addRenown(2);
		}
	}

	public void increaseMigrants()
	{
		if (isAlive())
		{
			data.migrated++;
		}
	}

	public long getTotalLeft()
	{
		return data.left;
	}

	public long getTotalJoined()
	{
		return data.joined;
	}

	public long getTotalMoved()
	{
		return data.moved;
	}

	public long getTotalMigrated()
	{
		return data.migrated;
	}

	public bool isZoneToClaimStillGood(Actor pActor, TileZone pZone, WorldTile pCityTile)
	{
		if (!pZone.canBeClaimedByCity(this))
		{
			return false;
		}
		if (!pZone.checkCanSettleInThisBiomes(pActor.subspecies))
		{
			return false;
		}
		TileZone[] neighbours = pZone.neighbours;
		foreach (TileZone tileZone in neighbours)
		{
			if (tileZone.hasCity() && tileZone.city == this)
			{
				return true;
			}
		}
		return false;
	}

	internal override void clearListUnits()
	{
		base.clearListUnits();
		_boats.Clear();
		_species.Clear();
	}

	public override ActorAsset getActorAsset()
	{
		if (hasLeader())
		{
			return leader.getActorAsset();
		}
		return getFounderSpecies();
	}

	public ActorAsset getFounderSpecies()
	{
		return AssetManager.actor_library.get(data.original_actor_asset);
	}

	public CityLayoutTilePlacement getTilePlacementFromZone()
	{
		if (hasCulture())
		{
			if (culture.hasTrait("city_layout_the_grand_arrangement"))
			{
				return CityLayoutTilePlacement.CenterTile;
			}
			if (culture.hasTrait("city_layout_tile_wobbly_pattern"))
			{
				return CityLayoutTilePlacement.CenterTileDrunk;
			}
			if (culture.hasTrait("city_layout_tile_moonsteps"))
			{
				return CityLayoutTilePlacement.Moonsteps;
			}
		}
		return CityLayoutTilePlacement.Random;
	}

	public string getSpecies()
	{
		return getActorAsset().id;
	}

	public override bool isReadyForRemoval()
	{
		if (zones.Count != 0)
		{
			return false;
		}
		return true;
	}

	public void clearBuildingList()
	{
		buildings.Clear();
		foreach (List<Building> value in buildings_dict_type.Values)
		{
			value.Clear();
		}
		foreach (List<Building> value2 in buildings_dict_id.Values)
		{
			value2.Clear();
		}
		stockpiles.Clear();
		storages.Clear();
		_cached_book_ids.Clear();
		_cached_buildings_with_book_slots.Clear();
	}

	public override void listUnit(Actor pActor)
	{
		if (pActor.asset.is_boat)
		{
			_boats.Add(pActor);
			return;
		}
		base.units.Add(pActor);
		if (pActor.hasSubspecies())
		{
			_species[pActor.asset.id] = pActor.subspecies.id;
		}
	}

	public Subspecies getSubspecies(string pSpeciesId)
	{
		long subspeciesId = getSubspeciesId(pSpeciesId);
		return World.world.subspecies.get(subspeciesId);
	}

	public long getSubspeciesId(string pSpeciesId)
	{
		if (_species.TryGetValue(pSpeciesId, out var value))
		{
			return value;
		}
		return -1L;
	}

	public bool hasFreeHouseSlots()
	{
		if (status.housing_free == 0)
		{
			return false;
		}
		return true;
	}

	public bool hasReachedWorldLawLimit()
	{
		if (WorldLawLibrary.world_law_civ_limit_population_100.isEnabled() && getPopulationPeople() >= 100)
		{
			return true;
		}
		return false;
	}

	public void listBuilding(Building pBuilding)
	{
		buildings.Add(pBuilding);
		BuildingAsset asset = pBuilding.asset;
		if (asset.type == "type_stockpile")
		{
			stockpiles.Add(pBuilding);
		}
		if (asset.storage)
		{
			storages.Add(pBuilding);
		}
		if (asset.book_slots > 0)
		{
			_cached_buildings_with_book_slots.Add(pBuilding);
			if (pBuilding.data.books != null)
			{
				_cached_book_ids.AddRange(pBuilding.data.books.list_books);
			}
		}
		setBuildingDictType(pBuilding);
		setBuildingDictID(pBuilding);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CanBeNull]
	public WorldTile getTile(bool pForceRecalc = false)
	{
		if (_city_tile == null || pForceRecalc)
		{
			recalculateCityTile();
		}
		return _city_tile;
	}

	internal void recalculateCityTile()
	{
		_city_tile = null;
		Building building = getBuildingOfType("type_bonfire");
		if (building != null)
		{
			_city_tile = building.current_tile;
			return;
		}
		foreach (Building item in buildings.LoopRandom())
		{
			if (!item.asset.docks && !item.current_tile.Type.ocean)
			{
				if (building == null)
				{
					building = item;
				}
				else if (item.asset.priority > building.asset.priority)
				{
					building = item;
				}
			}
		}
		if (building != null)
		{
			_city_tile = building.current_tile;
			return;
		}
		List<TileZone> list = zones;
		if (list.Count == 0)
		{
			return;
		}
		for (int i = 0; i < list.Count; i++)
		{
			TileZone tileZone = list[i];
			if (!tileZone.centerTile.Type.ocean)
			{
				_city_tile = tileZone.centerTile;
				break;
			}
		}
	}

	internal int countInHouses()
	{
		int num = 0;
		List<Actor> list = base.units;
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].is_inside_building)
			{
				num++;
			}
		}
		return num;
	}

	public int countBookSlots()
	{
		int num = 0;
		for (int i = 0; i < _cached_buildings_with_book_slots.Count; i++)
		{
			Building building = _cached_buildings_with_book_slots[i];
			num += building.asset.book_slots;
		}
		return num;
	}

	public bool hasBookSlots()
	{
		int num = countBookSlots();
		if (countBooks() >= num)
		{
			return false;
		}
		return true;
	}

	public Building getBuildingWithBookSlot()
	{
		foreach (Building cached_buildings_with_book_slot in _cached_buildings_with_book_slots)
		{
			if (cached_buildings_with_book_slot.hasFreeBookSlot())
			{
				return cached_buildings_with_book_slot;
			}
		}
		return null;
	}

	public int countBooks()
	{
		return _cached_book_ids.Count;
	}

	private void setKingdomTimestamp()
	{
		data.timestamp_kingdom = World.world.getCurWorldTime();
	}

	public override ColorAsset getColor()
	{
		return kingdom.getColor();
	}

	internal void setKingdom(Kingdom pKingdom, bool pFromLoad = false)
	{
		World.world.kingdoms.setDirtyCities();
		if (isCapitalCity())
		{
			kingdom.clearCapital();
		}
		kingdom = pKingdom;
		if (kingdom != null && kingdom != WildKingdomsManager.neutral)
		{
			data.last_kingdom_id = kingdom.id;
		}
		if (!pFromLoad)
		{
			checkArmyExistence();
			if (hasArmy())
			{
				army.checkCity();
			}
		}
	}

	internal void newForceKingdomEvent(List<Actor> pUnits, List<Actor> pBoats, Kingdom pKingdom, string pHappinessEvent)
	{
		setKingdomTimestamp();
		forceUnitsIntoThisKingdom(pUnits, pKingdom, pBoats: false, pHappinessEvent);
		forceUnitsIntoThisKingdom(pBoats, pKingdom, pBoats: true);
	}

	internal void forceBuildingsToKingdom(List<Building> pBuildings, Kingdom pKingdom)
	{
		for (int i = 0; i < pBuildings.Count; i++)
		{
			pBuildings[i].setKingdom(pKingdom);
		}
	}

	internal void forceUnitsIntoThisKingdom(List<Actor> pActors, Kingdom pKingdom, bool pBoats, string pHappinessEvent = null)
	{
		if (pBoats)
		{
			for (int i = 0; i < pActors.Count; i++)
			{
				Actor actor = pActors[i];
				if (!actor.isRekt())
				{
					actor.joinKingdom(pKingdom);
				}
			}
			return;
		}
		for (int j = 0; j < pActors.Count; j++)
		{
			Actor actor2 = pActors[j];
			if (actor2.isRekt())
			{
				continue;
			}
			if (actor2.isKing())
			{
				if (actor2.city != this || actor2.kingdom == pKingdom)
				{
					continue;
				}
				actor2.kingdom.kingLeftEvent();
			}
			actor2.joinKingdom(pKingdom);
			if (pHappinessEvent != null)
			{
				actor2.changeHappiness(pHappinessEvent);
			}
		}
	}

	internal Building getStorageNear(WorldTile pTile, bool pOnlyFood = false)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		Building result = null;
		int num = int.MaxValue;
		List<Building> list = storages;
		for (int i = 0; i < list.Count; i++)
		{
			Building building = list[i];
			if (!building.isUsable() || !building.current_tile.isSameIsland(pTile))
			{
				continue;
			}
			if (pOnlyFood && building.asset.storage_only_food)
			{
				result = building;
				continue;
			}
			int num2 = Toolbox.SquaredDistVec2(building.current_tile.pos, pTile.pos);
			if (num2 < num)
			{
				num = num2;
				result = building;
			}
		}
		return result;
	}

	internal Building getStorageWithFoodNear(WorldTile pTile)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Building result = null;
		int num = int.MaxValue;
		List<Building> list = storages;
		for (int i = 0; i < list.Count; i++)
		{
			Building building = list[i];
			if (building.isUsable() && building.current_tile.isSameIsland(pTile) && building.countFood() != 0)
			{
				int num2 = Toolbox.SquaredDistVec2(building.current_tile.pos, pTile.pos);
				if (num2 < num)
				{
					num = num2;
					result = building;
				}
			}
		}
		return result;
	}

	internal bool hasStorageBuilding()
	{
		List<Building> list = storages;
		for (int i = 0; i < list.Count; i++)
		{
			if (!list[i].isUnderConstruction())
			{
				return true;
			}
		}
		return false;
	}

	public WorldTile getRoadTileToBuild(Actor pBuilder)
	{
		tiles_to_remove.Clear();
		for (int i = 0; i < road_tiles_to_build.Count; i++)
		{
			WorldTile worldTile = road_tiles_to_build[i];
			if (worldTile.Type.road)
			{
				tiles_to_remove.Add(worldTile);
			}
		}
		for (int j = 0; j < tiles_to_remove.Count; j++)
		{
			WorldTile item = tiles_to_remove[j];
			road_tiles_to_build.Remove(item);
		}
		tiles_to_remove.Clear();
		if (road_tiles_to_build.Count > 0)
		{
			return road_tiles_to_build[0];
		}
		return null;
	}

	internal void init()
	{
		createAI();
		setStatusDirty();
	}

	private void createAI()
	{
		if (Globals.AI_TEST_ACTIVE)
		{
			if (ai == null)
			{
				ai = new AiSystemCity(this);
			}
			ai.next_job_delegate = getNextJob;
			ai.jobs_library = AssetManager.job_city;
			ai.task_library = AssetManager.tasks_city;
			ai.addSingleTask("build");
			ai.addSingleTask("check_loyalty");
			ai.addSingleTask("check_destruction");
		}
	}

	protected sealed override void setDefaultValues()
	{
		base.setDefaultValues();
		mark_scale_effect = 1f;
		timer_build_boat = 10f;
		timer_build = 0f;
		timer_action = 0f;
		_timer_capture = 0f;
		_timer_warrior = 0f;
		_capture_ticks = 0f;
		last_visual_capture_ticks = 0;
		_dirty_citizens = true;
		_dirty_city_status = false;
		_dirty_abandoned_zones = false;
		_current_total_food = 0;
		_last_checked_job_id = 0;
		_loyalty_last_time = -1.0;
		_loyalty_cached = -1;
	}

	private string getNextJob()
	{
		return "city";
	}

	public bool isValidTargetForWar()
	{
		if (!hasZones())
		{
			return false;
		}
		return true;
	}

	public bool hasZones()
	{
		return zones.Count > 0;
	}

	public bool needSettlers()
	{
		int populationPeople = getPopulationPeople();
		if (getAge() < 5)
		{
			return true;
		}
		if (populationPeople >= 22)
		{
			return false;
		}
		if (populationPeople < 22 && status.housing_free == 0 && getAge() > 10 && getHouseCurrent() > 2)
		{
			return false;
		}
		return true;
	}

	internal void generateName(Actor pActor)
	{
		string pName = pActor.generateName(MetaType.City, getID());
		setName(pName);
		data.name_culture_id = culture?.id ?? (-1);
	}

	public void loadLeader()
	{
		if (data.leaderID.hasValue())
		{
			Actor pActor = World.world.units.get(data.leaderID);
			setLeader(pActor, pNew: false);
		}
	}

	public void newCityEvent(Actor pActor)
	{
		recalculateCityTile();
		generateName(pActor);
	}

	private void loadCityZones(List<ZoneData> pZoneData)
	{
		if (pZoneData == null)
		{
			return;
		}
		for (int i = 0; i < pZoneData.Count; i++)
		{
			ZoneData zoneData = pZoneData[i];
			TileZone zone = World.world.zone_calculator.getZone(zoneData.x, zoneData.y);
			if (zone != null)
			{
				addZone(zone);
			}
		}
	}

	public void loadCity(CityData pData)
	{
		loadCityZones(pData.zones);
		setData(pData);
		if (data.id_culture.hasValue())
		{
			setCulture(World.world.cultures.get(data.id_culture));
		}
		if (data.id_language.hasValue())
		{
			setLanguage(World.world.languages.get(data.id_language));
		}
		if (data.id_religion.hasValue())
		{
			setReligion(World.world.religions.get(data.id_religion));
		}
		if (data.equipment == null)
		{
			data.equipment = new CityEquipment();
		}
		else
		{
			data.equipment.loadFromSave(this);
		}
		Kingdom pKingdom = ((!pData.kingdomID.hasValue() || pData.kingdomID == 0L) ? WildKingdomsManager.neutral : World.world.kingdoms.get(pData.kingdomID));
		setKingdom(pKingdom, pFromLoad: true);
	}

	public void forceDoChecks()
	{
		updateTotalFood();
		updateCitizens();
		updateCityStatus();
	}

	public void executeAllActionsForCity()
	{
		AssetManager.tasks_city.get("do_initial_load_check").executeAllActionsForCity(this);
	}

	public void eventUnitAdded(Actor pActor)
	{
		if (!pActor.asset.is_boat)
		{
			setCitizensDirty();
		}
		setStatusDirty();
	}

	public void eventUnitRemoved(Actor pActor)
	{
		setStatusDirty();
		setCitizensDirty();
		if (pActor.isCityLeader())
		{
			removeLeader();
		}
	}

	public void setAbandonedZonesDirty()
	{
		_dirty_abandoned_zones = true;
	}

	public void setCitizensDirty()
	{
		_dirty_citizens = true;
	}

	public void setStatusDirty()
	{
		_dirty_city_status = true;
	}

	private void sortZonesByDistanceToCenter()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		WorldTile tile = getTile();
		if (tile != null)
		{
			Vector2Int tCenterPos = tile.pos;
			zones.Sort(delegate(TileZone a, TileZone b)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				int num = Toolbox.SquaredDistVec2(a.centerTile.pos, tCenterPos);
				int value = Toolbox.SquaredDistVec2(b.centerTile.pos, tCenterPos);
				return num.CompareTo(value);
			});
		}
	}

	private void updateCityStatus()
	{
		_dirty_city_status = false;
		status.clear();
		recalculateCityTile();
		sortZonesByDistanceToCenter();
		recalculateNeighbourZones();
		recalculateNeighbourCities();
		List<Building> list = buildings;
		int num = countPopulationChildren();
		status.population = getPopulationPeople();
		status.population_adults = status.population - num;
		status.population_children = num;
		MetaObject<CityData>._family_counter.Clear();
		List<Actor> list2 = base.units;
		for (int i = 0; i < list2.Count; i++)
		{
			Actor actor = list2[i];
			if (actor.isHungry())
			{
				status.hungry++;
			}
			if (actor.isSexMale())
			{
				status.males++;
			}
			else
			{
				status.females++;
			}
			if (actor.hasFamily())
			{
				MetaObject<CityData>._family_counter.Add(actor.family);
			}
			if (actor.isSick())
			{
				status.sick++;
			}
			if (actor.hasHouse())
			{
				status.housed++;
			}
			else
			{
				status.homeless++;
			}
		}
		status.families = MetaObject<CityData>._family_counter.Count;
		MetaObject<CityData>._family_counter.Clear();
		for (int j = 0; j < list.Count; j++)
		{
			Building building = list[j];
			if (!building.isUnderConstruction() && building.asset.hasHousingSlots())
			{
				status.housing_total += building.asset.housing_slots;
			}
		}
		if (status.population > status.housing_total)
		{
			status.housing_occupied = status.housing_total;
		}
		else
		{
			status.housing_occupied = status.population;
		}
		status.housing_free = status.housing_total - status.housing_occupied;
		status.maximum_items = 15;
		recalculateMaxHouses();
		status.warrior_slots = jobs.countCurrentJobs(CitizenJobLibrary.attacker);
		status.warriors_current = countProfession(UnitProfession.Warrior);
		CityBehCheckFarms.check(this);
	}

	private void recalculateMaxHouses()
	{
		if (DebugConfig.isOn(DebugOption.CityUnlimitedHouses))
		{
			status.houses_max = 9999;
			return;
		}
		float num = zones.Count;
		if (hasCulture())
		{
			if (culture.hasTrait("dense_dwellings"))
			{
				num = zones.Count * 2;
			}
			if (culture.hasTrait("solitude_seekers"))
			{
				num = (float)zones.Count / 3f;
			}
			if (culture.hasTrait("hive_society"))
			{
				num = (float)zones.Count * 3f;
			}
		}
		foreach (Building building in buildings)
		{
			num += (float)building.asset.max_houses;
		}
		status.houses_max = (int)num;
	}

	public bool hasBooksToRead(Actor pActor)
	{
		if (pActor.hasTag("can_read_any_book"))
		{
			return countBooks() > 0;
		}
		if (!pActor.hasLanguage())
		{
			return false;
		}
		if (!hasBooksOfLanguage(pActor.language))
		{
			return false;
		}
		return true;
	}

	public bool hasBooksOfLanguage(Language pLanguage)
	{
		int i = 0;
		for (int num = countBooks(); i < num; i++)
		{
			long pID = _cached_book_ids[i];
			Book book = World.world.books.get(pID);
			if (!book.isRekt() && book.isReadyToBeRead())
			{
				Language language = book.getLanguage();
				if (language.id == pLanguage.id || language.hasTrait("magic_words"))
				{
					return true;
				}
			}
		}
		return false;
	}

	public Book getRandomBookOfLanguage(Language pLanguage)
	{
		using ListPool<Book> listPool = new ListPool<Book>();
		int i = 0;
		for (int num = countBooks(); i < num; i++)
		{
			long pID = _cached_book_ids[i];
			Book book = World.world.books.get(pID);
			if (!book.isRekt() && book.isReadyToBeRead())
			{
				Language language = book.getLanguage();
				if (language.id == pLanguage.id || language.hasTrait("magic_words"))
				{
					listPool.Add(book);
				}
			}
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	public Book getRandomBook()
	{
		using ListPool<Book> listPool = new ListPool<Book>();
		int i = 0;
		for (int num = countBooks(); i < num; i++)
		{
			long pID = _cached_book_ids[i];
			Book book = World.world.books.get(pID);
			if (!book.isRekt() && book.isReadyToBeRead())
			{
				listPool.Add(book);
			}
		}
		if (listPool.Count == 0)
		{
			return null;
		}
		return listPool.GetRandom();
	}

	public List<long> getBooks()
	{
		return _cached_book_ids;
	}

	public int getHouseCurrent()
	{
		return countBuildingsType("type_house", pCountOnlyFinished: false);
	}

	public int getHouseLimit()
	{
		return status.houses_max;
	}

	public bool isConnectedToCapital()
	{
		if (!kingdom.hasCapital())
		{
			return false;
		}
		recalculateNeighbourCities();
		if (neighbours_cities_kingdom.Contains(this))
		{
			return true;
		}
		kingdom.calculateNeighbourCities();
		_connected_checked.Clear();
		_connected_next_wave.Clear();
		_connected_current_wave.Clear();
		_connected_next_wave.UnionWith(kingdom.capital.neighbours_cities_kingdom);
		int num = 0;
		while (_connected_next_wave.Count > 0)
		{
			_connected_current_wave.UnionWith(_connected_next_wave);
			_connected_next_wave.Clear();
			num++;
			foreach (City item in _connected_current_wave)
			{
				if (item == this)
				{
					return true;
				}
				_connected_checked.Add(item);
				foreach (City item2 in item.neighbours_cities_kingdom)
				{
					if (!_connected_checked.Contains(item2))
					{
						_connected_next_wave.Add(item2);
					}
				}
			}
			if (num > 30)
			{
				break;
			}
		}
		return false;
	}

	public void recalculateNeighbourCities()
	{
		neighbours_cities.Clear();
		neighbours_cities_kingdom.Clear();
		neighbours_kingdoms.Clear();
		foreach (TileZone neighbour_zone in neighbour_zones)
		{
			City city = neighbour_zone.city;
			if (city != this && city != null)
			{
				neighbours_cities.Add(city);
				if (city.kingdom == kingdom)
				{
					neighbours_cities_kingdom.Add(city);
				}
				else
				{
					neighbours_kingdoms.Add(city.kingdom);
				}
			}
		}
	}

	public void recalculateNeighbourZones()
	{
		border_zones.Clear();
		neighbour_zones.Clear();
		List<TileZone> list = zones;
		for (int i = 0; i < list.Count; i++)
		{
			TileZone tileZone = list[i];
			TileZone[] neighbours_all = tileZone.neighbours_all;
			foreach (TileZone tileZone2 in neighbours_all)
			{
				if (tileZone2.city != this)
				{
					border_zones.Add(tileZone);
					neighbour_zones.Add(tileZone2);
				}
			}
		}
	}

	internal void setCulture(Culture pCulture)
	{
		if (culture != pCulture)
		{
			culture = pCulture;
			World.world.cultures.setDirtyCities();
		}
	}

	public Culture getCulture()
	{
		return culture;
	}

	public Language getLanguage()
	{
		return language;
	}

	public Religion getReligion()
	{
		return religion;
	}

	public void checkAbandon()
	{
		if (_dirty_abandoned_zones)
		{
			_dirty_abandoned_zones = false;
			World.world.city_zone_helper.city_abandon.check(this);
		}
	}

	public void update(float pElapsed)
	{
		if (timer_build > 0f)
		{
			timer_build -= pElapsed;
		}
		updateTotalFood();
		if (data.timer_supply > 0f)
		{
			data.timer_supply -= pElapsed;
		}
		if (data.timer_trade > 0f)
		{
			data.timer_trade -= pElapsed;
		}
		if (_timer_warrior > 0f)
		{
			_timer_warrior -= pElapsed;
		}
		if (isDirtyUnits())
		{
			return;
		}
		if (!kingdom.wild && !hasUnits())
		{
			turnCityToNeutral();
			return;
		}
		if (_dirty_city_status)
		{
			updateCityStatus();
		}
		if (_dirty_citizens)
		{
			updateCitizens();
		}
		if (World.world.isPaused())
		{
			return;
		}
		if (timer_build_boat > 0f)
		{
			timer_build_boat -= pElapsed;
		}
		if (ai != null)
		{
			if (timer_action > 0f)
			{
				timer_action -= pElapsed;
			}
			else
			{
				ai.update();
			}
			ai.updateSingleTasks(pElapsed);
		}
		updateCapture(pElapsed);
	}

	private void turnCityToNeutral()
	{
		makeBoatsAbandonCity();
		setKingdom(WildKingdomsManager.neutral);
		forceBuildingsToKingdom(buildings, WildKingdomsManager.neutral);
	}

	private void makeBoatsAbandonCity()
	{
		if (countBoats() == 0)
		{
			return;
		}
		foreach (Actor boat in _boats)
		{
			if (!boat.isRekt())
			{
				boat.setCity(null);
			}
		}
	}

	private void updateTotalFood()
	{
		_current_total_food = countFoodTotal();
	}

	private void updateCapture(float pElapsed)
	{
		if (last_visual_capture_ticks == 0 && !isGettingCaptured())
		{
			return;
		}
		if ((int)_capture_ticks != last_visual_capture_ticks)
		{
			if ((int)_capture_ticks > last_visual_capture_ticks)
			{
				last_visual_capture_ticks++;
			}
			else
			{
				last_visual_capture_ticks--;
			}
		}
		last_visual_capture_ticks = Mathf.Clamp(last_visual_capture_ticks, 0, 100);
		if (_timer_capture > 0f)
		{
			_timer_capture -= pElapsed;
			return;
		}
		_timer_capture = 0.1f;
		int num = countBuildingsType("type_watch_tower");
		if (num > 0)
		{
			addCapturePoints(this.kingdom, 10 * num);
		}
		Kingdom kingdom = null;
		foreach (Kingdom key in _capturing_units.Keys)
		{
			if (kingdom == null)
			{
				kingdom = key;
			}
			else if (_capturing_units[key] > _capturing_units[kingdom])
			{
				kingdom = key;
			}
		}
		if (kingdom == null)
		{
			_capture_ticks -= 0.5f;
			if (_capture_ticks <= 0f)
			{
				clearCapture();
			}
			return;
		}
		bool flag = false;
		if (_capturing_units.ContainsKey(this.kingdom) && _capturing_units[this.kingdom] > 0 && countWarriors() > 0)
		{
			flag = true;
		}
		if (being_captured_by != null && !being_captured_by.isAlive())
		{
			being_captured_by = null;
		}
		bool flag2 = false;
		if (this.kingdom == kingdom)
		{
			flag2 = true;
		}
		if (flag && _capturing_units.Count == 1)
		{
			flag2 = true;
		}
		if (flag2)
		{
			_capture_ticks -= 1f;
			if (_capture_ticks <= 0f)
			{
				clearCapture();
			}
		}
		else
		{
			if (!kingdom.isEnemy(this.kingdom) || (flag && !(_capture_ticks < 5f)))
			{
				return;
			}
			if (being_captured_by == null || being_captured_by == kingdom)
			{
				_capture_ticks += 1f + 1f * pElapsed;
				being_captured_by = kingdom;
				if (_capture_ticks >= 100f)
				{
					finishCapture(kingdom);
				}
			}
			else if (kingdom.isEnemy(being_captured_by))
			{
				_capture_ticks -= 0.5f;
				if (_capture_ticks <= 0f)
				{
					clearCapture();
				}
			}
			else
			{
				_capture_ticks += 1f + 1f * pElapsed;
				if (_capture_ticks >= 100f)
				{
					finishCapture(being_captured_by);
				}
			}
		}
	}

	public bool isGettingCaptured()
	{
		if (_capturing_units.Count == 0)
		{
			return false;
		}
		if (_capturing_units.Count == 1 && _capturing_units.ContainsKey(kingdom))
		{
			return false;
		}
		return true;
	}

	public bool isGettingCapturedBy(Kingdom pKingdom)
	{
		if (_capturing_units.TryGetValue(pKingdom, out var value) && value > 0)
		{
			return true;
		}
		return false;
	}

	public Kingdom getCapturingKingdom()
	{
		return being_captured_by;
	}

	private void clearCapture()
	{
		_capture_ticks = 0f;
		being_captured_by = null;
	}

	public float getCaptureTicks()
	{
		return _capture_ticks;
	}

	private void prepareProfessionDicts()
	{
		if (_professions_dict.Count == 0)
		{
			for (int i = 0; i < ProfessionLibrary.list_enum_profession_ids.Length; i++)
			{
				UnitProfession key = ProfessionLibrary.list_enum_profession_ids[i];
				_professions_dict.Add(key, new List<Actor>());
			}
		}
	}

	private void updateCitizens()
	{
		_dirty_citizens = false;
		prepareProfessionDicts();
		foreach (List<Actor> value in _professions_dict.Values)
		{
			value.Clear();
		}
		List<Actor> list = base.units;
		for (int i = 0; i < list.Count; i++)
		{
			Actor actor = list[i];
			if (actor != null && actor.isAlive())
			{
				_professions_dict[actor.getProfession()].Add(actor);
			}
		}
	}

	public bool canGrowZones()
	{
		if (!DebugConfig.isOn(DebugOption.SystemZoneGrowth))
		{
			return false;
		}
		if (_dirty_abandoned_zones)
		{
			return false;
		}
		if (getPopulationPeople() == 0)
		{
			return false;
		}
		return true;
	}

	internal int countProfession(UnitProfession pType)
	{
		if (_professions_dict.TryGetValue(pType, out var value))
		{
			return value.Count;
		}
		return 0;
	}

	public void destroyCity()
	{
		removeLeader();
		disbandArmy();
		foreach (TileZone zone in zones)
		{
			zone.setCity(null);
		}
		foreach (Actor unit in World.world.units)
		{
			if (unit.city == this)
			{
				unit.setCity(null);
			}
		}
		data.equipment.clearItems();
		base.units.Clear();
		_boats.Clear();
		zones.Clear();
		if (hasKingdom())
		{
			removeFromCurrentKingdom();
		}
	}

	public override void Dispose()
	{
		DBInserter.deleteData(getID(), "city");
		_connected_checked.Clear();
		_connected_next_wave.Clear();
		_connected_current_wave.Clear();
		stockpiles.Clear();
		storages.Clear();
		_cached_book_ids.Clear();
		_cached_buildings_with_book_slots.Clear();
		base.units.Clear();
		_boats.Clear();
		buildings.Clear();
		buildings_dict_id.Clear();
		buildings_dict_type.Clear();
		zones.Clear();
		road_tiles_to_build.Clear();
		calculated_place_for_farms.Clear();
		calculated_farm_fields.Clear();
		calculated_crops.Clear();
		calculated_grown_wheat.Clear();
		_professions_dict.Clear();
		neighbour_zones.Clear();
		border_zones.Clear();
		neighbours_cities.Clear();
		neighbours_cities_kingdom.Clear();
		neighbours_kingdoms.Clear();
		tiles_to_remove.Clear();
		danger_zones.Clear();
		_capturing_units.Clear();
		_city_tile = null;
		target_attack_zone = null;
		target_attack_city = null;
		army = null;
		tasks.clear();
		jobs.clear();
		status.clear();
		under_construction_building = null;
		culture = null;
		language = null;
		religion = null;
		kingdom = null;
		leader = null;
		being_captured_by = null;
		_debug_last_possible_build_orders = null;
		_debug_last_possible_build_orders_no_resources = null;
		_debug_last_build_order_try = null;
		timestamp_shrink = 0.0;
		ai.reset();
		base.Dispose();
	}

	public bool hasAttackZoneOrder()
	{
		return target_attack_zone != null;
	}

	internal void spendResourcesForBuildingAsset(ConstructionCost pCost)
	{
		takeResource("wood", pCost.wood);
		takeResource("gold", pCost.gold);
		takeResource("stone", pCost.stone);
		takeResource("common_metals", pCost.common_metals);
	}

	internal bool hasEnoughResourcesFor(ConstructionCost pCost)
	{
		if (DebugConfig.isOn(DebugOption.CityInfiniteResources))
		{
			return true;
		}
		if (amount_wood < pCost.wood)
		{
			return false;
		}
		if (amount_common_metals < pCost.common_metals)
		{
			return false;
		}
		if (amount_stone < pCost.stone)
		{
			return false;
		}
		if (amount_gold < pCost.gold)
		{
			return false;
		}
		return true;
	}

	internal Building getBuildingToBuild()
	{
		if (under_construction_building != null && (!under_construction_building.isAlive() || !under_construction_building.isUnderConstruction()))
		{
			under_construction_building = null;
		}
		return under_construction_building;
	}

	internal bool hasBuildingToBuild()
	{
		if (under_construction_building != null)
		{
			if (!under_construction_building.isAlive() || !under_construction_building.isUnderConstruction())
			{
				under_construction_building = null;
				return false;
			}
			return true;
		}
		return false;
	}

	internal void setBuildingDictType(Building pBuilding)
	{
		List<Building> list = getBuildingListOfType(pBuilding.asset.type);
		if (list == null)
		{
			list = new List<Building>();
			buildings_dict_type.Add(pBuilding.asset.type, list);
		}
		list.Add(pBuilding);
	}

	internal List<Building> getBuildingListOfID(string pBuildingID)
	{
		buildings_dict_id.TryGetValue(pBuildingID, out var value);
		return value;
	}

	public int countZones()
	{
		return zones.Count;
	}

	public int countBuildings()
	{
		return buildings.Count;
	}

	public int countBuildingsOfID(string pBuildingID)
	{
		return getBuildingListOfID(pBuildingID)?.Count ?? 0;
	}

	internal void setBuildingDictID(Building pBuilding)
	{
		if (!buildings_dict_id.TryGetValue(pBuilding.asset.id, out var value))
		{
			buildings_dict_id.Add(pBuilding.asset.id, value = new List<Building>());
		}
		value.Add(pBuilding);
	}

	public int countBuildingsType(string pBuildingTypeID, bool pCountOnlyFinished = true)
	{
		List<Building> buildingListOfType = getBuildingListOfType(pBuildingTypeID);
		if (buildingListOfType == null)
		{
			return 0;
		}
		if (pCountOnlyFinished)
		{
			int num = 0;
			{
				foreach (Building item in buildingListOfType)
				{
					if (!item.isUnderConstruction())
					{
						num++;
					}
				}
				return num;
			}
		}
		return buildingListOfType.Count;
	}

	internal bool hasBuildingType(string pBuildingTypeID, bool pCountOnlyFinished = true, TileIsland pLimitIsland = null)
	{
		List<Building> buildingListOfType = getBuildingListOfType(pBuildingTypeID);
		if (buildingListOfType == null)
		{
			return false;
		}
		if (buildingListOfType.Count == 0)
		{
			return false;
		}
		bool flag = pLimitIsland != null;
		foreach (Building item in buildingListOfType)
		{
			if ((!pCountOnlyFinished || (!item.isUnderConstruction() && item.isUsable())) && (!flag || item.current_island == pLimitIsland))
			{
				return true;
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal List<Building> getBuildingListOfType(string pType)
	{
		buildings_dict_type.TryGetValue(pType, out var value);
		return value;
	}

	internal Building getBuildingOfType(string pBuildingTypeID, bool pCountOnlyFinished = true, bool pRandom = false, bool pOnlyFreeTile = false, TileIsland pLimitIsland = null)
	{
		List<Building> buildingListOfType = getBuildingListOfType(pBuildingTypeID);
		if (buildingListOfType == null)
		{
			return null;
		}
		if (buildingListOfType.Count == 0)
		{
			return null;
		}
		bool flag = pLimitIsland != null;
		IEnumerable<Building> enumerable2;
		if (!pRandom)
		{
			IEnumerable<Building> enumerable = buildingListOfType;
			enumerable2 = enumerable;
		}
		else
		{
			enumerable2 = buildingListOfType.LoopRandom();
		}
		foreach (Building item in enumerable2)
		{
			if ((!pCountOnlyFinished || (!item.isUnderConstruction() && item.isUsable())) && (!pOnlyFreeTile || !item.current_tile.isTargeted()) && (!flag || item.current_island == pLimitIsland))
			{
				return item;
			}
		}
		return null;
	}

	public void addRoads(List<WorldTile> pTiles)
	{
		for (int i = 0; i < pTiles.Count; i++)
		{
			WorldTile worldTile = pTiles[i];
			if (!worldTile.Type.road && !road_tiles_to_build.Contains(worldTile))
			{
				road_tiles_to_build.Add(worldTile);
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool isArmyFull()
	{
		if (status.warriors_current >= status.warrior_slots)
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool isArmyOverLimit()
	{
		if (status.warriors_current > status.warrior_slots)
		{
			return true;
		}
		return false;
	}

	private bool tryToMakeWarrior(Actor pActor)
	{
		if (!checkCanMakeWarrior(pActor))
		{
			return false;
		}
		makeWarrior(pActor);
		_timer_warrior = 15f;
		if (hasLeader())
		{
			float num = leader.stats["warfare"] / 2f;
			_timer_warrior -= num;
			if (_timer_warrior < 1f)
			{
				_timer_warrior = 1f;
			}
		}
		if (hasBuildingType("type_barracks"))
		{
			_timer_warrior /= 2f;
		}
		return true;
	}

	public bool checkCanMakeWarrior(Actor pActor)
	{
		if (isArmyFull())
		{
			return false;
		}
		if (pActor.isBaby())
		{
			return false;
		}
		if (hasCulture())
		{
			if (pActor.isSexFemale() && culture.hasTrait("conscription_male_only"))
			{
				return false;
			}
			if (pActor.isSexMale() && culture.hasTrait("conscription_female_only"))
			{
				return false;
			}
		}
		return true;
	}

	public void makeWarrior(Actor pActor)
	{
		pActor.setProfession(UnitProfession.Warrior);
		if (pActor.equipment.weapon.isEmpty())
		{
			giveItem(pActor, getEquipmentList(EquipmentType.Weapon), this);
		}
		status.warriors_current++;
	}

	public bool checkIfWarriorStillOk(Actor pActor)
	{
		bool flag = true;
		if (isArmyOverLimit())
		{
			flag = false;
		}
		else if (!hasEnoughFoodForArmy())
		{
			flag = false;
		}
		if (!flag)
		{
			pActor.stopBeingWarrior();
			_timer_warrior = 30f;
		}
		return flag;
	}

	public void setCitizenJob(Actor pActor)
	{
		if ((!isGettingCaptured() && _timer_warrior <= 0f && pActor.isProfession(UnitProfession.Unit) && getResourcesAmount("gold") > 10 && hasEnoughFoodForArmy() && tryToMakeWarrior(pActor)) || checkCitizenJobList(AssetManager.citizen_job_library.list_priority_high, pActor) || (!hasAnyFood() && checkCitizenJobList(AssetManager.citizen_job_library.list_priority_high_food, pActor)))
		{
			return;
		}
		List<CitizenJobAsset> list_priority_normal = AssetManager.citizen_job_library.list_priority_normal;
		for (int i = 0; i < list_priority_normal.Count; i++)
		{
			_last_checked_job_id++;
			if (_last_checked_job_id > list_priority_normal.Count - 1)
			{
				_last_checked_job_id = 0;
			}
			CitizenJobAsset citizenJobAsset = list_priority_normal[_last_checked_job_id];
			if ((citizenJobAsset.ok_for_king || !pActor.isKing()) && (citizenJobAsset.ok_for_leader || !pActor.isCityLeader()) && checkCitizenJob(citizenJobAsset, this, pActor))
			{
				break;
			}
		}
	}

	private bool checkCitizenJobList(List<CitizenJobAsset> pList, Actor pActor)
	{
		for (int i = 0; i < pList.Count; i++)
		{
			CitizenJobAsset pJobAsset = pList[i];
			if (checkCitizenJob(pJobAsset, this, pActor))
			{
				return true;
			}
		}
		return false;
	}

	private bool checkCitizenJob(CitizenJobAsset pJobAsset, City pCity, Actor pActor)
	{
		if (pJobAsset.only_leaders && !pActor.isKing() && !pActor.isCityLeader())
		{
			return false;
		}
		if (pJobAsset.should_be_assigned != null && !pJobAsset.should_be_assigned(pActor))
		{
			return false;
		}
		if (jobs.hasJob(pJobAsset))
		{
			jobs.takeJob(pJobAsset);
			pActor.setCitizenJob(pJobAsset);
			return true;
		}
		return false;
	}

	public bool hasSuitableFood(Subspecies pSubspecies)
	{
		HashSet<string> allowedFoodByDiet = pSubspecies.getAllowedFoodByDiet();
		foreach (Building storage in storages)
		{
			if (!storage.isUsable())
			{
				continue;
			}
			foreach (string item in allowedFoodByDiet)
			{
				if (storage.getResourcesAmount(item) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	internal ResourceAsset getFoodItem(Subspecies pSubspecies, string pFavoriteFood = null)
	{
		if (!string.IsNullOrEmpty(pFavoriteFood) && getResourcesAmount(pFavoriteFood) > 0)
		{
			return AssetManager.resources.get(pFavoriteFood);
		}
		return getRandomSuitableFood(pSubspecies);
	}

	internal void eatFoodItem(string pItem)
	{
		if (pItem != null)
		{
			takeResource(pItem, 1);
			data.total_food_consumed++;
		}
	}

	internal void removeZone(TileZone pZone)
	{
		setAbandonedZonesDirty();
		if (zones.Remove(pZone))
		{
			pZone.setCity(null);
			World.world.city_zone_helper.city_place_finder.setDirty();
		}
		updateCityCenter();
		setStatusDirty();
	}

	internal void addZone(TileZone pZone)
	{
		if (!zones.Contains(pZone))
		{
			if (pZone.city != null)
			{
				pZone.city.removeZone(pZone);
			}
			zones.Add(pZone);
			pZone.setCity(this);
			updateCityCenter();
			if (World.world.city_zone_helper.city_place_finder.hasPossibleZones())
			{
				World.world.city_zone_helper.city_place_finder.setDirty();
			}
			setStatusDirty();
		}
	}

	public int getLoyalty(bool pForceRecalc = false)
	{
		if (kingdom.isNeutral())
		{
			_loyalty_cached = 0;
		}
		else if (World.world.getWorldTimeElapsedSince(_loyalty_last_time) > 3f || pForceRecalc)
		{
			_loyalty_cached = LoyaltyCalculator.calculate(this);
			_loyalty_last_time = World.world.getCurWorldTime();
		}
		return _loyalty_cached;
	}

	public int getCachedLoyalty()
	{
		return _loyalty_cached;
	}

	public bool isCapitalCity()
	{
		if (kingdom == null)
		{
			return false;
		}
		return this == kingdom.capital;
	}

	internal void updateAge()
	{
		if (hasLeader() && leader.hasClan())
		{
			leader.addRenown(1);
		}
	}

	private void updateCityCenter()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		if (!hasZones())
		{
			city_center = Globals.POINT_IN_VOID_2;
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = float.MaxValue;
		TileZone tileZone = null;
		for (int i = 0; i < zones.Count; i++)
		{
			TileZone tileZone2 = zones[i];
			num += tileZone2.centerTile.posV3.x;
			num2 += tileZone2.centerTile.posV3.y;
		}
		city_center.x = num / (float)zones.Count;
		city_center.y = num2 / (float)zones.Count;
		for (int j = 0; j < zones.Count; j++)
		{
			TileZone tileZone3 = zones[j];
			float num4 = Toolbox.SquaredDist(tileZone3.centerTile.x, tileZone3.centerTile.y, city_center.x, city_center.y);
			if (num4 < num3)
			{
				tileZone = tileZone3;
				num3 = num4;
			}
		}
		city_center.x = tileZone.centerTile.posV3.x;
		city_center.y = tileZone.centerTile.posV3.y + 2f;
		last_city_center = city_center;
	}

	internal void removeFromCurrentKingdom()
	{
		kingdom.checkClearCapital(this);
	}

	internal void switchedKingdom()
	{
		List<Building> list = buildings;
		for (int i = 0; i < list.Count; i++)
		{
			Building building = list[i];
			if (!building.isRemoved())
			{
				building.setKingdomCiv(kingdom);
			}
		}
		World.world.zone_calculator.setDrawnZonesDirty();
	}

	internal void useInspire(Actor pActor)
	{
		Kingdom pAttacker = kingdom;
		makeOwnKingdom(pActor, pRebellion: true);
		World.world.diplomacy.startWar(pAttacker, kingdom, WarTypeLibrary.inspire, pLog: false);
	}

	internal void clearCurrentCaptureAmounts()
	{
		_capturing_units.Clear();
	}

	internal void clearDangerZones()
	{
		danger_zones.Clear();
	}

	public bool isInDanger()
	{
		if (danger_zones.Count > 0)
		{
			return true;
		}
		return false;
	}

	internal void updateConquest(Actor pActor)
	{
		if (pActor.isKingdomCiv() && (pActor.kingdom == kingdom || pActor.kingdom.isEnemy(kingdom)))
		{
			addCapturePoints(pActor, 1);
		}
	}

	public void addCapturePoints(BaseSimObject pObject, int pValue)
	{
		addCapturePoints(pObject.kingdom, pValue);
	}

	public void addCapturePoints(Kingdom pKingdom, int pValue)
	{
		_capturing_units.TryGetValue(pKingdom, out var value);
		_capturing_units[pKingdom] = value + pValue;
	}

	public void debugCaptureUnits(DebugTool pTool)
	{
		pTool.setText("capture units:", _capturing_units.Count, 0f, pShowBar: false, 0L);
		pTool.setText("isGettingCaptured()", isGettingCaptured(), 0f, pShowBar: false, 0L);
		foreach (Kingdom key in _capturing_units.Keys)
		{
			pTool.setText("-" + key.name, _capturing_units[key], 0f, pShowBar: false, 0L);
		}
	}

	internal void finishCapture(Kingdom pNewKingdom)
	{
		if (this.kingdom.hasKing() && this.kingdom.king.city == this)
		{
			this.kingdom.kingFledCity();
		}
		if (World.world.cities.isLocked())
		{
			return;
		}
		clearCapture();
		recalculateNeighbourCities();
		pNewKingdom.increaseHappinessFromNewCityCapture();
		this.kingdom.decreaseHappinessFromLostCityCapture(this);
		using ListPool<War> pWars = new ListPool<War>(pNewKingdom.getWars());
		Kingdom kingdom = findKingdomToJoinAfterCapture(pNewKingdom, pWars);
		if (!checkRebelWar(kingdom, pWars))
		{
			kingdom.data.timestamp_new_conquest = World.world.getCurWorldTime();
		}
		removeSoldiers();
		joinAnotherKingdom(kingdom, pCaptured: true);
	}

	private Kingdom findKingdomToJoinAfterCapture(Kingdom pKingdom, ListPool<War> pWars)
	{
		Kingdom kingdom = null;
		for (int i = 0; i < pWars.Count; i++)
		{
			War war = pWars[i];
			if (war.isTotalWar() || !war.hasKingdom(this.kingdom) || !war.isInWarWith(pKingdom, this.kingdom))
			{
				continue;
			}
			if (war.isMainAttacker(pKingdom) || war.isMainDefender(pKingdom))
			{
				break;
			}
			if (war.isAttacker(this.kingdom))
			{
				Kingdom main_defender = war.main_defender;
				if (!main_defender.isRekt())
				{
					kingdom = ((!neighbours_kingdoms.Contains(main_defender)) ? ((!neighbours_kingdoms.Contains(pKingdom)) ? main_defender : pKingdom) : main_defender);
					break;
				}
			}
			if (war.isDefender(this.kingdom))
			{
				Kingdom main_attacker = war.main_attacker;
				if (!main_attacker.isRekt())
				{
					kingdom = ((!neighbours_kingdoms.Contains(main_attacker)) ? ((!neighbours_kingdoms.Contains(pKingdom)) ? main_attacker : pKingdom) : main_attacker);
					break;
				}
			}
		}
		if (kingdom == null)
		{
			kingdom = pKingdom;
		}
		else if (kingdom.getSpecies() != this.kingdom.getSpecies())
		{
			kingdom = pKingdom;
		}
		return kingdom;
	}

	private bool checkRebelWar(Kingdom pKingdomToJoin, ListPool<War> pWars)
	{
		foreach (ref War pWar in pWars)
		{
			War current = pWar;
			if (current.getAsset().rebellion && current.isMainAttacker(pKingdomToJoin) && current.isInWarWith(pKingdomToJoin, kingdom))
			{
				return true;
			}
		}
		return false;
	}

	private void removeSoldiers()
	{
		foreach (Actor item in _professions_dict[UnitProfession.Warrior])
		{
			item.setProfession(UnitProfession.Unit);
		}
		disbandArmy();
	}

	public void disbandArmy()
	{
		checkArmyExistence();
		if (hasArmy())
		{
			army.disband();
			checkArmyExistence();
		}
	}

	public void checkArmyExistence()
	{
		if (hasArmy() && (!army.isAlive() || army.countUnits() <= 0))
		{
			setArmy(null);
		}
	}

	public bool hasArmy()
	{
		return army != null;
	}

	public Army getArmy()
	{
		return army;
	}

	public void setArmy(Army pArmy)
	{
		if (army != null && army != pArmy)
		{
			army.clearCity();
		}
		army = pArmy;
	}

	public Actor getRandomWarrior()
	{
		return _professions_dict[UnitProfession.Warrior].GetRandom();
	}

	internal Kingdom makeOwnKingdom(Actor pActor, bool pRebellion = false, bool pFellApart = false)
	{
		string pHappinessEvent = null;
		if (pRebellion)
		{
			World.world.game_stats.data.citiesRebelled++;
			World.world.map_stats.citiesRebelled++;
			pHappinessEvent = "just_rebelled";
		}
		if (pFellApart)
		{
			pHappinessEvent = "kingdom_fell_apart";
		}
		Kingdom pKingdom = this.kingdom;
		removeFromCurrentKingdom();
		removeLeader();
		Kingdom kingdom = World.world.kingdoms.makeNewCivKingdom(pActor);
		setKingdom(kingdom);
		newForceKingdomEvent(base.units, _boats, kingdom, pHappinessEvent);
		switchedKingdom();
		kingdom.copyMetasFromOtherKingdom(pKingdom);
		kingdom.setCityMetas(this);
		return kingdom;
	}

	public override int getPopulationPeople()
	{
		return countUnits();
	}

	public int getPopulationMaximum()
	{
		if (WorldLawLibrary.world_law_civ_limit_population_100.isEnabled())
		{
			if (status.housing_total >= 100)
			{
				return 100;
			}
			return status.housing_total;
		}
		return status.housing_total;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getUnitsTotal()
	{
		return countUnits() + countBoats();
	}

	public int countPopulationChildren()
	{
		int num = 0;
		foreach (Actor unit in base.units)
		{
			if (unit.isAlive() && unit.isBaby())
			{
				num++;
			}
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int countBoats()
	{
		return _boats.Count;
	}

	public void joinAnotherKingdom(Kingdom pNewSetKingdom, bool pCaptured = false, bool pRebellion = false)
	{
		string pHappinessEvent = null;
		if (pCaptured)
		{
			World.world.game_stats.data.citiesConquered++;
			World.world.map_stats.citiesConquered++;
			pHappinessEvent = "was_conquered";
		}
		if (pRebellion)
		{
			World.world.game_stats.data.citiesRebelled++;
			World.world.map_stats.citiesRebelled++;
			pHappinessEvent = "just_rebelled";
		}
		Kingdom pKingdom = kingdom;
		removeFromCurrentKingdom();
		setKingdom(pNewSetKingdom);
		newForceKingdomEvent(base.units, _boats, pNewSetKingdom, pHappinessEvent);
		switchedKingdom();
		pNewSetKingdom.capturedFrom(pKingdom);
	}

	public int countWeapons()
	{
		return getEquipmentList(EquipmentType.Weapon).Count;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int countFoodTotal()
	{
		return countFood();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool hasEnoughFoodForArmy()
	{
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getTotalFood()
	{
		return _current_total_food;
	}

	public bool hasAnyFood()
	{
		return _current_total_food > 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int countWarriors()
	{
		return countProfession(UnitProfession.Warrior);
	}

	public bool hasAnyWarriors()
	{
		return countWarriors() > 0;
	}

	public bool isHappy()
	{
		if (getCachedLoyalty() >= 0)
		{
			return true;
		}
		return false;
	}

	public float getArmyMaxMultiplier()
	{
		float num = 0f + getActorAsset().civ_base_army_multiplier;
		float armyMaxLeaderMultiplier = getArmyMaxLeaderMultiplier();
		return num + armyMaxLeaderMultiplier;
	}

	public float getArmyMaxLeaderMultiplier()
	{
		float num = 0f;
		if (hasLeader())
		{
			num += leader.stats["army"];
			float num2 = leader.stats["warfare"] * 2f / 100f;
			num += num2;
		}
		return num;
	}

	public int getMaxWarriors()
	{
		return status.warrior_slots;
	}

	public void removeLeader()
	{
		leader = null;
		data.leaderID = -1L;
		rulerLeft();
	}

	public void setLeader(Actor pActor, bool pNew)
	{
		if (pActor != null && kingdom.king != pActor)
		{
			leader = pActor;
			leader.setProfession(UnitProfession.Leader);
			CityData cityData = data;
			long leaderID = (data.last_leader_id = pActor.data.id);
			cityData.leaderID = leaderID;
			if (pNew)
			{
				data.total_leaders++;
				leader.changeHappiness("become_leader");
				addRuler(pActor);
			}
		}
	}

	public void updateRulers()
	{
		if (data.past_rulers == null || data.past_rulers.Count == 0)
		{
			return;
		}
		foreach (LeaderEntry past_ruler in data.past_rulers)
		{
			Actor actor = World.world.units.get(past_ruler.id);
			if (!actor.isRekt())
			{
				past_ruler.name = actor.name;
			}
		}
	}

	public void addRuler(Actor pActor)
	{
		CityData cityData = data;
		if (cityData.past_rulers == null)
		{
			cityData.past_rulers = new List<LeaderEntry>();
		}
		rulerLeft();
		data.past_rulers.Add(new LeaderEntry
		{
			id = pActor.getID(),
			name = pActor.name,
			color_id = (pActor.kingdom?.data.color_id ?? (-1)),
			timestamp_ago = World.world.getCurWorldTime()
		});
		if (data.past_rulers.Count > 30)
		{
			data.past_rulers.Shift();
		}
	}

	public void rulerLeft()
	{
		if (data.past_rulers != null && data.past_rulers.Count != 0)
		{
			LeaderEntry leaderEntry = data.past_rulers.Last();
			if (!(leaderEntry.timestamp_end >= leaderEntry.timestamp_ago))
			{
				leaderEntry.timestamp_end = World.world.getCurWorldTime();
				updateRulers();
			}
		}
	}

	public static bool nearbyBorders(City pA, City pB)
	{
		City city;
		City city2;
		if (pA.zones.Count > pB.zones.Count)
		{
			city = pB;
			city2 = pA;
		}
		else
		{
			city = pA;
			city2 = pB;
		}
		for (int i = 0; i < city.zones.Count; i++)
		{
			TileZone[] neighbours_all = city.zones[i].neighbours_all;
			for (int j = 0; j < neighbours_all.Length; j++)
			{
				if (neighbours_all[j].city == city2)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool giveItem(Actor pActor, List<long> pItems, City pCity)
	{
		if (pItems.Count == 0)
		{
			return false;
		}
		if (!pActor.understandsHowToUseItems())
		{
			return false;
		}
		long random = pItems.GetRandom();
		Item item = World.world.items.get(random);
		EquipmentAsset asset = item.getAsset();
		ActorEquipmentSlot slot = pActor.equipment.getSlot(asset.equipment_type);
		if (!slot.isEmpty())
		{
			int value = slot.getItem().getValue();
			if (item.getValue() <= value)
			{
				return false;
			}
		}
		Item item2 = null;
		if (!slot.isEmpty())
		{
			item2 = slot.getItem();
			slot.takeAwayItem();
		}
		pItems.Remove(random);
		slot.setItem(item, pActor);
		pActor.setStatsDirty();
		if (item2 != null)
		{
			pCity.data.equipment.addItem(pCity, item2, pItems);
		}
		pCity._storage_version++;
		return true;
	}

	public int getLimitOfBuildingsType(BuildOrder pElement)
	{
		int num = pElement.limit_type;
		if (hasCulture())
		{
			string type = pElement.getBuildingAsset(this).type;
			if (!(type == "type_statue"))
			{
				if (type == "type_watch_tower")
				{
					if (culture.hasTrait("tower_lovers"))
					{
						num += CultureTraitLibrary.getValue("tower_lovers");
					}
					if (hasLeader())
					{
						num += (int)leader.stats["bonus_towers"];
					}
				}
			}
			else if (culture.hasTrait("statue_lovers"))
			{
				num += CultureTraitLibrary.getValue("statue_lovers");
			}
		}
		return num;
	}

	public Alliance getAlliance()
	{
		return kingdom.getAlliance();
	}

	public Clan getRoyalClan()
	{
		Clan clan = null;
		if (clan == null && hasLeader())
		{
			clan = leader.clan;
		}
		if (clan == null && kingdom.hasKing())
		{
			clan = kingdom.king.clan;
		}
		return clan;
	}

	public bool isOkToSendArmy()
	{
		if (!hasArmy())
		{
			return false;
		}
		float num = getMaxWarriors();
		return (float)army.countUnits() / num >= 0.7f;
	}

	public void tryToPutItem(Item pItem)
	{
		List<long> equipmentList = data.equipment.getEquipmentList(pItem.getAsset().equipment_type);
		if (equipmentList.Count >= status.maximum_items)
		{
			tryToPutItemInStorage(pItem);
			return;
		}
		data.equipment.addItem(this, pItem, equipmentList);
		_storage_version++;
	}

	public void tryToPutItems(IEnumerable<Item> pItems)
	{
		foreach (Item pItem in pItems)
		{
			tryToPutItem(pItem);
		}
	}

	private void tryToPutItemInStorage(Item pNewItem)
	{
		float num = pNewItem.getValue();
		EquipmentType equipment_type = pNewItem.getAsset().equipment_type;
		List<long> equipmentList = data.equipment.getEquipmentList(equipment_type);
		for (int i = 0; i < equipmentList.Count; i++)
		{
			long pID = equipmentList[i];
			Item item = World.world.items.get(pID);
			float num2 = item.getValue();
			if (num > num2)
			{
				item.clearCity();
				equipmentList[i] = pNewItem.id;
				pNewItem.setInCityStorage(this);
				_storage_version++;
				break;
			}
		}
	}

	public int getZoneRange(bool pAllowCheat = true)
	{
		if (pAllowCheat && DebugConfig.isOn(DebugOption.CityUnlimitedZoneRange))
		{
			return 999;
		}
		return 13;
	}

	public bool reachableFrom(City pCity)
	{
		WorldTile tile = getTile();
		if (tile == null)
		{
			return false;
		}
		WorldTile tile2 = pCity.getTile();
		if (tile2 == null)
		{
			return false;
		}
		return tile.reachableFrom(tile2);
	}

	public bool hasLeader()
	{
		if (leader == null)
		{
			return false;
		}
		if (!leader.isAlive())
		{
			removeLeader();
			return false;
		}
		return true;
	}

	public override void convertSameSpeciesAroundUnit(Actor pActorMain, bool pOverride = false)
	{
		foreach (Actor item in Finder.getUnitsFromChunk(pActorMain.current_tile, 2))
		{
			if (!item.hasCity() && !item.isKingdomCiv() && item.isSameSpecies(pActorMain) && item.isSapient())
			{
				item.joinCity(this);
			}
		}
	}

	public override void forceConvertSameSpeciesAroundUnit(Actor pActorMain)
	{
		convertSameSpeciesAroundUnit(pActorMain, pOverride: true);
	}

	public void setUnitMetas(Actor pActor)
	{
		if (pActor.hasCulture())
		{
			setCulture(pActor.culture);
		}
		if (pActor.hasLanguage())
		{
			setLanguage(pActor.language);
		}
		if (pActor.hasReligion())
		{
			setReligion(pActor.religion);
		}
	}

	public override void save()
	{
		base.save();
		if (hasCulture())
		{
			data.id_culture = culture.id;
		}
		if (hasReligion())
		{
			data.id_religion = religion.id;
		}
		if (hasLanguage())
		{
			data.id_language = language.id;
		}
		if (kingdom == null)
		{
			data.kingdomID = -1L;
		}
		else
		{
			data.kingdomID = kingdom.id;
		}
		data.zones.Clear();
		foreach (TileZone zone in zones)
		{
			ZoneData item = new ZoneData
			{
				x = zone.x,
				y = zone.y
			};
			data.zones.Add(item);
		}
	}

	public bool hasCulture()
	{
		if (culture != null && !culture.isAlive())
		{
			setCulture(null);
		}
		return culture != null;
	}

	public bool hasLanguage()
	{
		if (language != null && !language.isAlive())
		{
			setLanguage(null);
		}
		return language != null;
	}

	internal void setLanguage(Language pLanguage)
	{
		if (language != pLanguage)
		{
			language = pLanguage;
			World.world.languages.setDirtyCities();
		}
	}

	internal void setReligion(Religion pReligion)
	{
		if (religion != pReligion)
		{
			religion = pReligion;
			World.world.religions.setDirtyCities();
		}
	}

	public Subspecies getMainSubspecies()
	{
		if (hasLeader())
		{
			return leader.subspecies;
		}
		if (getPopulationPeople() == 0)
		{
			return null;
		}
		return base.units[0].subspecies;
	}

	public bool hasReligion()
	{
		if (religion != null && !religion.isAlive())
		{
			setReligion(null);
		}
		return religion != null;
	}

	public bool hasStockpiles()
	{
		return stockpiles.Count > 0;
	}

	public bool hasStorages()
	{
		return storages.Count > 0;
	}

	public Building getRandomStockpile()
	{
		if (!hasStockpiles())
		{
			return null;
		}
		foreach (Building item in stockpiles.LoopRandom())
		{
			if (item.isUsable())
			{
				return item;
			}
		}
		return null;
	}

	public void takeResource(string pResourceID, int pAmount)
	{
		if (!hasStorages())
		{
			return;
		}
		int num = pAmount;
		foreach (Building storage in storages)
		{
			if (storage.isUsable())
			{
				int num2 = 0;
				num2 = ((storage.getResourcesAmount(pResourceID) < num) ? storage.getResourcesAmount(pResourceID) : num);
				storage.takeResource(pResourceID, num2);
				num -= num2;
				if (num == 0)
				{
					break;
				}
			}
		}
		_storage_version++;
	}

	public int getResourcesAmount(string pResourceID)
	{
		if (!hasStorages())
		{
			return 0;
		}
		int num = 0;
		foreach (Building storage in storages)
		{
			if (storage.isUsable())
			{
				num += storage.getResourcesAmount(pResourceID);
			}
		}
		return num;
	}

	public int addResourcesToRandomStockpile(string pResourceID, int pAmount = 1)
	{
		Building randomStockpile = getRandomStockpile();
		if (randomStockpile == null)
		{
			return 0;
		}
		_storage_version++;
		return randomStockpile.addResources(pResourceID, pAmount);
	}

	public bool hasSpaceForResourceInStockpile(ResourceAsset pResourceAsset)
	{
		if (!hasStockpiles())
		{
			return false;
		}
		foreach (Building stockpile in stockpiles)
		{
			if (stockpile.isUsable() && stockpile.hasSpaceForResource(pResourceAsset))
			{
				return true;
			}
		}
		return false;
	}

	public bool hasResourcesForNewItems()
	{
		if (!hasStorages())
		{
			return false;
		}
		foreach (Building storage in storages)
		{
			if (storage.isUsable() && storage.hasResourcesForNewItems())
			{
				return true;
			}
		}
		return false;
	}

	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies)
	{
		if (!hasStorages())
		{
			return null;
		}
		foreach (Building storage in storages)
		{
			if (storage.isUsable())
			{
				ResourceAsset randomSuitableFood = storage.getRandomSuitableFood(pSubspecies);
				if (randomSuitableFood != null)
				{
					return randomSuitableFood;
				}
			}
		}
		return null;
	}

	public int countFood()
	{
		if (!hasStorages())
		{
			return 0;
		}
		int num = 0;
		foreach (Building storage in storages)
		{
			if (storage.isUsable())
			{
				num += storage.countFood();
			}
		}
		return num;
	}

	public ListPool<CityStorageSlot> getTotalResourceSlots(ResType[] pResTypes)
	{
		foreach (CityStorageSlot value2 in _total_resource_slots.Values)
		{
			ResourceAsset asset = value2.asset;
			if (pResTypes.IndexOf(asset.type) != -1)
			{
				value2.amount = 0;
			}
		}
		foreach (Building storage in storages)
		{
			if (!storage.isUsable())
			{
				continue;
			}
			foreach (CityStorageSlot slot in storage.resources.getSlots())
			{
				_total_resource_slots.TryGetValue(slot.id, out var value);
				if (value == null)
				{
					value = new CityStorageSlot(slot.id);
					_total_resource_slots[slot.id] = value;
				}
				value.amount += slot.amount;
			}
		}
		ListPool<CityStorageSlot> listPool = new ListPool<CityStorageSlot>(_total_resource_slots.Count);
		foreach (CityStorageSlot value3 in _total_resource_slots.Values)
		{
			ResourceAsset asset2 = value3.asset;
			if (pResTypes.IndexOf(asset2.type) != -1 && value3.amount != 0)
			{
				listPool.Add(value3);
			}
		}
		listPool.Sort((CityStorageSlot a, CityStorageSlot b) => a.asset.order.CompareTo(b.asset.order));
		return listPool;
	}

	public bool hasKingdom()
	{
		return kingdom != null;
	}

	public float getTimerForNewWarrior()
	{
		return _timer_warrior;
	}

	public List<long> getEquipmentList(EquipmentType pType)
	{
		return data.equipment.getEquipmentList(pType);
	}

	public bool planAllowsToPlaceBuildingInZone(TileZone pZone, TileZone pCenterZone)
	{
		if (status.housing_total < 10 && zones.Count < 20)
		{
			return true;
		}
		return culture.planAllowsToPlaceBuildingInZone(pZone, pCenterZone);
	}

	public bool hasSpecialTownPlans()
	{
		if (!hasCulture())
		{
			return false;
		}
		return culture.hasSpecialTownPlans();
	}

	public bool isNeutral()
	{
		return kingdom.isNeutral();
	}

	public bool isWelcomedToJoin(Actor pActor)
	{
		if (pActor.kingdom == kingdom)
		{
			return true;
		}
		if (pActor.isSameSubspecies(getMainSubspecies()))
		{
			return true;
		}
		if (!hasCulture())
		{
			return false;
		}
		if (culture.hasTrait("xenophobic"))
		{
			return false;
		}
		if (pActor.hasCultureTrait("xenophobic"))
		{
			return false;
		}
		if (culture.hasTrait("xenophiles"))
		{
			if (!pActor.hasCulture())
			{
				return true;
			}
			if (pActor.hasCultureTrait("xenophiles"))
			{
				return true;
			}
		}
		if (isSameSpeciesAsActor(pActor))
		{
			return true;
		}
		return false;
	}

	public bool isSameSpeciesAsActor(Actor pActor)
	{
		if (pActor.isSameSpecies(getCurrentSpecies()))
		{
			return true;
		}
		return false;
	}

	public string getCurrentSpecies()
	{
		Subspecies mainSubspecies = getMainSubspecies();
		if (mainSubspecies != null)
		{
			return mainSubspecies.getActorAsset().id;
		}
		return getActorAsset().id;
	}

	public Sprite getCurrentSpeciesIcon()
	{
		Subspecies mainSubspecies = getMainSubspecies();
		if (mainSubspecies != null)
		{
			return mainSubspecies.getSpriteIcon();
		}
		return getActorAsset().getSpriteIcon();
	}

	public bool hasTransportBoats()
	{
		foreach (Actor boat in _boats)
		{
			if (boat.asset.is_boat_transport)
			{
				return true;
			}
		}
		return false;
	}

	public bool isCityUnderDangerFire()
	{
		return tasks.fire > 0;
	}

	public bool isPossibleToJoin(Actor pActor)
	{
		if (this == pActor.city)
		{
			return false;
		}
		if (isNeutral())
		{
			return true;
		}
		if (!isWelcomedToJoin(pActor))
		{
			return false;
		}
		if (pActor.city != null)
		{
			if (pActor.isKing())
			{
				return false;
			}
			if (pActor.isCityLeader())
			{
				return false;
			}
			if (pActor.city.getPopulationPeople() < getPopulationPeople())
			{
				return false;
			}
		}
		return true;
	}

	public override string ToString()
	{
		if (data == null)
		{
			return "[City is null]";
		}
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[City:{base.id} ");
		if (!isAlive())
		{
			stringBuilderPool.Append("[DEAD] ");
		}
		stringBuilderPool.Append("\"" + name + "\" ");
		stringBuilderPool.Append($"Kingdom:{kingdom?.id ?? (-1)} ");
		if (hasArmy())
		{
			stringBuilderPool.Append($"Army:{army.id} ");
		}
		stringBuilderPool.Append($"Units:{base.units.Count} ");
		if (isDirtyUnits())
		{
			stringBuilderPool.Append("[Dirty] ");
		}
		if (!leader.isRekt())
		{
			stringBuilderPool.Append($"Leader:{leader.id} ");
		}
		if (kingdom?.king?.city == this)
		{
			stringBuilderPool.Append($"King:{kingdom.king.id} ");
		}
		return stringBuilderPool.ToString().Trim() + "]";
	}
}
// --- End of File: City.cs ---



// --- Start of File: CityBanner.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CityBanner : BannerGeneric<City, CityData>
{
	[SerializeField]
	private Sprite _city_sprite;

	[SerializeField]
	private Sprite _capital_sprite;

	private Image _part_city_icon;

	protected override MetaType meta_type => MetaType.City;

	protected override string tooltip_id => "city";

	protected override void setupBanner()
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		base.setupBanner();
		ColorAsset colorAsset = meta_object.kingdom.getColor();
		part_background.sprite = meta_object.kingdom.getElementBackground();
		part_icon.sprite = meta_object.kingdom.getElementIcon();
		Sprite pSprite = (meta_object.isCapitalCity() ? _capital_sprite : _city_sprite);
		_part_city_icon.sprite = DynamicSprites.getIconWithColors(pSprite, null, colorAsset);
		Color colorMainSecond = colorAsset.getColorMainSecond();
		Color colorBanner = colorAsset.getColorBanner();
		colorMainSecond = Color.Lerp(colorMainSecond, Color.black, 0.05f);
		colorBanner = Color.Lerp(colorBanner, Color.black, 0.05f);
		((Graphic)part_background).color = colorMainSecond;
		((Graphic)part_icon).color = colorBanner;
	}

	protected override void setupParts()
	{
		base.setupParts();
		_part_city_icon = ((Component)((Component)this).transform.FindRecursive("Foundation")).GetComponent<Image>();
	}

	protected override TooltipData getTooltipData()
	{
		TooltipData tooltipData = base.getTooltipData();
		tooltipData.city = meta_object;
		return tooltipData;
	}
}
// --- End of File: CityBanner.cs ---



// --- Start of File: CityBehBorderShrink.cs ---
using System.Collections.Generic;
using ai.behaviours;

public class CityBehBorderShrink : BehaviourActionCity
{
	public override bool errorsFound(City pCity)
	{
		return false;
	}

	public override bool shouldRetry(City pCity)
	{
		return false;
	}

	public override BehResult execute(City pCity)
	{
		if (BehaviourActionBase<City>.world.getWorldTimeElapsedSince(pCity.timestamp_shrink) < SimGlobals.m.empty_city_borders_shrink_time)
		{
			return BehResult.Stop;
		}
		if (pCity.hasUnits())
		{
			return BehResult.Stop;
		}
		TileZone zoneToRemove = getZoneToRemove(pCity);
		if (zoneToRemove == null)
		{
			return BehResult.Stop;
		}
		pCity.removeZone(zoneToRemove);
		pCity.timestamp_shrink = BehaviourActionBase<City>.world.getCurWorldTime();
		return BehResult.Continue;
	}

	private TileZone getZoneToRemove(City pCity)
	{
		TileZone result = null;
		if (pCity.border_zones.Count > 0)
		{
			result = getRandomZoneFromList(pCity.border_zones);
		}
		else if (pCity.zones.Count > 0)
		{
			result = getRandomZoneFromList(pCity.zones);
		}
		return result;
	}

	private TileZone getRandomZoneFromList(IReadOnlyCollection<TileZone> pList)
	{
		if (pList.Count == 0)
		{
			return null;
		}
		using ListPool<TileZone> list = new ListPool<TileZone>(pList);
		return list.GetRandom();
	}
}
// --- End of File: CityBehBorderShrink.cs ---



// --- Start of File: CityBehBorderSteal.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class CityBehBorderSteal : BehaviourActionCity
{
	private static List<TileZone> _zones = new List<TileZone>();

	public override BehResult execute(City pCity)
	{
		if (!DebugConfig.isOn(DebugOption.SystemZoneGrowth))
		{
			return BehResult.Stop;
		}
		if (!WorldLawLibrary.world_law_border_stealing.isEnabled())
		{
			return BehResult.Stop;
		}
		if (pCity.status.population == 0)
		{
			return BehResult.Stop;
		}
		if (pCity.buildings.Count == 0)
		{
			return BehResult.Stop;
		}
		for (int i = 0; i < 3; i++)
		{
			if (tryStealZone(pCity))
			{
				break;
			}
		}
		return BehResult.Continue;
	}

	private bool tryStealZone(City pCity)
	{
		_zones.Clear();
		TileZone[] neighbours = pCity.buildings.GetRandom().current_tile.zone.neighbours;
		foreach (TileZone tileZone in neighbours)
		{
			if (tileZone.city != pCity && tileZone.city != null && !tileZone.hasAnyBuildingsInSet(BuildingList.Civs) && tileZone.city.kingdom.isEnemy(pCity.kingdom))
			{
				stealZone(tileZone, pCity);
				return true;
			}
		}
		return false;
	}

	private void stealZone(TileZone pZone, City pCity)
	{
		if (pZone.city != null)
		{
			pZone.city.removeZone(pZone);
		}
		pCity.addZone(pZone);
	}
}
// --- End of File: CityBehBorderSteal.cs ---



// --- Start of File: CityBehBuild.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityPools;
using tools;

namespace ai.behaviours;

public class CityBehBuild : BehaviourActionCity
{
	private static readonly List<BuildOrder> _possible_buildings = new List<BuildOrder>();

	private static readonly List<BuildOrder> _possible_buildings_no_resources = new List<BuildOrder>();

	private static readonly List<TileZone> _possible_zones = new List<TileZone>();

	public override bool shouldRetry(City pCity)
	{
		return false;
	}

	public override BehResult execute(City pCity)
	{
		if (pCity.timer_build > 0f)
		{
			return BehResult.Continue;
		}
		if (!DebugConfig.isOn(DebugOption.SystemBuildTick))
		{
			return BehResult.Continue;
		}
		if (pCity.isGettingCaptured())
		{
			return BehResult.Continue;
		}
		if (pCity.isInDanger())
		{
			return BehResult.Continue;
		}
		pCity.timer_build = 5f;
		buildTick(pCity);
		if (DebugConfig.isOn(DebugOption.CityFastUpgrades))
		{
			pCity.timer_build = 0.2f;
		}
		return BehResult.Continue;
	}

	public static bool buildTick(City pCity)
	{
		if (pCity.buildings.Count > 2 && pCity.hasCulture() && pCity.culture.canUseRoads())
		{
			Building random = pCity.buildings.GetRandom();
			if (random != null)
			{
				makeRoadsBuildings(pCity, random);
			}
		}
		if (pCity.isCityUnderDangerFire() && pCity.hasLeader() && !pCity.leader.isImmuneToFire())
		{
			return false;
		}
		if (pCity.under_construction_building == null)
		{
			foreach (Building building2 in pCity.buildings)
			{
				if (building2.isUnderConstruction())
				{
					pCity.under_construction_building = building2;
					break;
				}
			}
		}
		if (pCity.under_construction_building != null)
		{
			return false;
		}
		calcPossibleBuildings(pCity);
		if (DebugConfig.isOn(DebugOption.OverlayCity))
		{
			pCity._debug_last_possible_build_orders = string.Empty;
			pCity._debug_last_possible_build_orders_no_resources = string.Empty;
			pCity._debug_last_build_order_try = string.Empty;
		}
		if (_possible_buildings.Count == 0)
		{
			return false;
		}
		BuildOrder random2 = _possible_buildings.GetRandom();
		if (DebugConfig.isOn(DebugOption.OverlayCity))
		{
			foreach (BuildOrder possible_building in _possible_buildings)
			{
				pCity._debug_last_possible_build_orders = pCity._debug_last_possible_build_orders + (possible_building.upgrade ? "U-" : "") + possible_building.id + "; ";
			}
			foreach (BuildOrder possible_buildings_no_resource in _possible_buildings_no_resources)
			{
				pCity._debug_last_possible_build_orders_no_resources = pCity._debug_last_possible_build_orders_no_resources + (possible_buildings_no_resource.upgrade ? "U-" : "") + possible_buildings_no_resource.id + "; ";
			}
			pCity._debug_last_build_order_try = (random2.upgrade ? "U-" : "") + random2.id;
		}
		_possible_buildings_no_resources.Clear();
		_possible_buildings.Clear();
		if (random2.upgrade)
		{
			List<Building> buildingListOfID = pCity.getBuildingListOfID(random2.getBuildingAsset(pCity).id);
			if (buildingListOfID == null)
			{
				return false;
			}
			Building random3 = buildingListOfID.GetRandom();
			if (random3 == null)
			{
				return false;
			}
			return upgradeBuilding(random3, pCity);
		}
		Building building = tryToBuild(pCity, random2.getBuildingAsset(pCity));
		if (building == null)
		{
			return false;
		}
		if (DebugConfig.isOn(DebugOption.CityFastConstruction))
		{
			building?.updateBuild(1000);
			pCity.under_construction_building = null;
		}
		if (pCity.hasCulture())
		{
			pCity.culture.canUseRoads();
		}
		return true;
	}

	private void upgradeRandomBuilding(City pCity)
	{
		if (pCity.buildings.Count == 0)
		{
			return;
		}
		foreach (Building item in pCity.buildings.LoopRandom())
		{
			if (item.canBeUpgraded())
			{
				upgradeBuilding(item, pCity);
				break;
			}
		}
	}

	public static bool upgradeBuilding(Building pBuilding, City pCity)
	{
		string upgrade_to = pBuilding.asset.upgrade_to;
		BuildingAsset buildingAsset = AssetManager.buildings.get(upgrade_to);
		if (!pCity.hasEnoughResourcesFor(buildingAsset.cost))
		{
			return false;
		}
		bool num = pBuilding.upgradeBuilding();
		if (num)
		{
			pCity.spendResourcesForBuildingAsset(buildingAsset.cost);
		}
		return num;
	}

	public static void calcPossibleBuildings(City pCity)
	{
		ActorAsset actorAsset = pCity.getActorAsset();
		CityBuildOrderAsset cityBuildOrderAsset = AssetManager.city_build_orders.get(actorAsset.build_order_template_id);
		bool flag = DebugConfig.isOn(DebugOption.OverlayCity);
		foreach (BuildOrder item in cityBuildOrderAsset.list)
		{
			if (!canUseBuildAsset(item, pCity))
			{
				continue;
			}
			if (!hasResourcesForBuildAsset(item, pCity))
			{
				if (flag)
				{
					_possible_buildings_no_resources.Add(item);
				}
			}
			else
			{
				_possible_buildings.Add(item);
			}
		}
	}

	public static bool hasResourcesForBuildAsset(BuildOrder pBuildAsset, City pCity)
	{
		BuildingAsset buildingAsset = pBuildAsset.getBuildingAsset(pCity);
		if (pCity.hasEnoughResourcesFor(buildingAsset.cost))
		{
			return true;
		}
		return false;
	}

	public static bool canUseBuildAsset(BuildOrder pBuildAsset, City pCity)
	{
		BuildingAsset buildingAsset = pBuildAsset.getBuildingAsset(pCity);
		if (pBuildAsset.min_zones != 0 && pCity.zones.Count < pBuildAsset.min_zones)
		{
			return false;
		}
		int num = pCity.countBuildingsType(buildingAsset.type, pCountOnlyFinished: false);
		if (pBuildAsset.check_house_limit)
		{
			if (pCity.status.housing_free > 10)
			{
				return false;
			}
			int houseLimit = pCity.getHouseLimit();
			if (num >= houseLimit)
			{
				return false;
			}
		}
		int limitOfBuildingsType = pCity.getLimitOfBuildingsType(pBuildAsset);
		if (limitOfBuildingsType != 0 && num >= limitOfBuildingsType)
		{
			return false;
		}
		if (pBuildAsset.check_full_village && pCity.status.housing_free != 0)
		{
			return false;
		}
		if (pCity.status.population < pBuildAsset.required_pop)
		{
			return false;
		}
		if (pCity.buildings.Count < pBuildAsset.required_buildings)
		{
			return false;
		}
		if (!haveRequiredBuildings(pBuildAsset, pCity))
		{
			return false;
		}
		if (!haveRequiredBuildingTypes(pBuildAsset.requirements_types, pCity))
		{
			return false;
		}
		if (pBuildAsset.upgrade)
		{
			List<Building> buildingListOfID = pCity.getBuildingListOfID(buildingAsset.id);
			if (buildingListOfID == null || buildingListOfID.Count == 0)
			{
				return false;
			}
		}
		else if (buildingAsset.docks && getDockTile(pCity) == null)
		{
			return false;
		}
		return true;
	}

	private static bool haveRequiredBuildings(BuildOrder pOrder, City pCity)
	{
		if (pOrder.requirements_orders == null)
		{
			return true;
		}
		for (int i = 0; i < pOrder.requirements_orders.Length; i++)
		{
			string pOrderID = pOrder.requirements_orders[i];
			BuildingAsset buildingAsset = pOrder.getBuildingAsset(pCity, pOrderID);
			if (buildingAsset.id == buildingAsset.upgrade_to)
			{
				Debug.LogError((object)("(!) Building is set to be upgraded to self: " + buildingAsset.id));
				continue;
			}
			while (pCity.countBuildingsOfID(buildingAsset.id) == 0)
			{
				if (!buildingAsset.can_be_upgraded || string.IsNullOrEmpty(buildingAsset.upgrade_to))
				{
					return false;
				}
				buildingAsset = AssetManager.buildings.get(buildingAsset.upgrade_to);
			}
		}
		return true;
	}

	private static bool haveRequiredBuildingTypes(string[] pRequiredBuildingTypes, City pCity)
	{
		if (pRequiredBuildingTypes == null)
		{
			return true;
		}
		foreach (string pBuildingTypeID in pRequiredBuildingTypes)
		{
			if (!pCity.hasBuildingType(pBuildingTypeID))
			{
				return false;
			}
		}
		return true;
	}

	public static Building tryToBuild(City pCity, BuildingAsset pBuildingAsset)
	{
		if (!pCity.hasEnoughResourcesFor(pBuildingAsset.cost))
		{
			return null;
		}
		WorldTile worldTile = null;
		List<TileZone> possible_zones = _possible_zones;
		if (pBuildingAsset.type == "type_training_dummies")
		{
			worldTile = getTileTrainingDummy(pBuildingAsset, pCity);
		}
		else if (pBuildingAsset.docks)
		{
			worldTile = getDockTile(pCity);
		}
		else
		{
			if (pBuildingAsset.build_prefer_replace_house)
			{
				worldTile = getOnHouseTile(pCity, pBuildingAsset);
			}
			if (worldTile == null)
			{
				fillPossibleZones(pBuildingAsset, pCity, possible_zones);
			}
		}
		if (worldTile == null && possible_zones.Count > 0)
		{
			if (pBuildingAsset.build_place_center)
			{
				worldTile = tryToBuildInZones(possible_zones, pBuildingAsset, pCity, pForceCenterZone: true);
			}
			if (worldTile == null)
			{
				worldTile = tryToBuildInZones(possible_zones, pBuildingAsset, pCity);
			}
			if (worldTile != null && pBuildingAsset.needs_farms_ground && !checkFarmGround(worldTile, pBuildingAsset, pCity))
			{
				worldTile = null;
			}
		}
		possible_zones.Clear();
		if (worldTile == null)
		{
			return null;
		}
		Building building = (pCity.under_construction_building = BehaviourActionBase<City>.world.buildings.addBuilding(pBuildingAsset, worldTile));
		building.setUnderConstruction();
		pCity.spendResourcesForBuildingAsset(pBuildingAsset.cost);
		return building;
	}

	private static void fillPossibleZones(BuildingAsset pBuildingAsset, City pCity, List<TileZone> pPossibleZones)
	{
		for (int i = 0; i < pCity.zones.Count; i++)
		{
			TileZone tileZone = pCity.zones[i];
			if ((!pBuildingAsset.build_place_single || isZonesClear(tileZone, pBuildingAsset, pCity)) && (!pBuildingAsset.build_place_batch || !isNearbySingleBuilding(tileZone, pBuildingAsset, pCity)) && (!pBuildingAsset.build_place_borders || isZoneNearbyBorder(tileZone, pBuildingAsset, pCity)))
			{
				pPossibleZones.Add(tileZone);
			}
		}
	}

	public static WorldTile getOnHouseTile(City pCity, BuildingAsset pAsset)
	{
		foreach (Building item in pCity.buildings.LoopRandom())
		{
			if (item.asset.priority <= pAsset.priority && item.asset.hasHousingSlots() && isGoodTileForBuilding(item.current_tile, pAsset, pCity))
			{
				return item.current_tile;
			}
		}
		return null;
	}

	public static WorldTile tryToBuildInZones(List<TileZone> pList, BuildingAsset pBuildingAsset, City pCity, bool pForceCenterZone = false)
	{
		CityLayoutTilePlacement tilePlacementFromZone = pCity.getTilePlacementFromZone();
		bool num = pCity.hasCulture() && pCity.culture.hasTrait("buildings_spread");
		bool flag = pCity.hasSpecialTownPlans();
		WorldTile tile = pCity.getTile();
		TileZone pCenterZone = tile?.zone;
		WorldTile result = null;
		int num2 = int.MaxValue;
		bool flag2 = !num && tile != null;
		foreach (TileZone item in pList.LoopRandom())
		{
			WorldTile worldTile = null;
			if (pForceCenterZone)
			{
				if (isGoodTileForBuilding(item.centerTile, pBuildingAsset, pCity))
				{
					worldTile = item.centerTile;
				}
			}
			else if (pBuildingAsset.docks)
			{
				worldTile = tryToBuildInZoneRandomly(item, pBuildingAsset, pCity);
			}
			else
			{
				if (flag && !pCity.planAllowsToPlaceBuildingInZone(item, pCenterZone))
				{
					continue;
				}
				worldTile = getTileBasedOnLayout(tilePlacementFromZone, item, pBuildingAsset, pCity);
			}
			if (worldTile != null)
			{
				if (!flag2)
				{
					result = worldTile;
					break;
				}
				int num3 = Toolbox.SquaredDistTile(tile, worldTile);
				if (num3 < num2)
				{
					result = worldTile;
					num2 = num3;
				}
			}
		}
		return result;
	}

	private static WorldTile getTileBasedOnLayout(CityLayoutTilePlacement pCityLayoutTilePlacement, TileZone pTileZone, BuildingAsset pBuildingAsset, City pCity)
	{
		switch (pCityLayoutTilePlacement)
		{
		case CityLayoutTilePlacement.Random:
		{
			WorldTile worldTile = tryToBuildInZoneRandomly(pTileZone, pBuildingAsset, pCity);
			if (worldTile != null)
			{
				return worldTile;
			}
			break;
		}
		case CityLayoutTilePlacement.CenterTile:
		{
			WorldTile worldTile = tryToBuildInZoneCenter(pTileZone, pBuildingAsset, pCity);
			if (worldTile != null)
			{
				return worldTile;
			}
			break;
		}
		case CityLayoutTilePlacement.Moonsteps:
		{
			WorldTile worldTile = tryToBuildInZoneMoonsteps(pTileZone, pBuildingAsset, pCity);
			if (worldTile != null)
			{
				return worldTile;
			}
			break;
		}
		case CityLayoutTilePlacement.CenterTileDrunk:
		{
			WorldTile worldTile = tryToBuildInZoneDrunk(pTileZone, pBuildingAsset, pCity);
			if (worldTile != null)
			{
				return worldTile;
			}
			break;
		}
		}
		return null;
	}

	private static WorldTile tryToBuildInZoneMoonsteps(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	{
		WorldTile worldTile = (((pZone.x + pZone.y) % 2 == 0) ? pZone.centerTile.tile_up.tile_up.tile_up : pZone.centerTile.tile_down.tile_down.tile_down);
		if (isGoodTileForBuilding(worldTile, pBuildingAsset, pCity))
		{
			return worldTile;
		}
		return null;
	}

	private static WorldTile tryToBuildInZoneDrunk(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	{
		WorldTile worldTile = tryToBuildInZoneCenter(pZone, pBuildingAsset, pCity);
		if (Randy.randomChance(0.6f) && worldTile != null)
		{
			WorldTile random = worldTile.neighboursAll.GetRandom();
			if (isGoodTileForBuilding(random, pBuildingAsset, pCity))
			{
				worldTile = random;
			}
		}
		return worldTile;
	}

	private static WorldTile tryToBuildInZoneRandomly(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	{
		foreach (WorldTile item in pZone.tiles.LoopRandom())
		{
			if (isGoodTileForBuilding(item, pBuildingAsset, pCity))
			{
				return item;
			}
		}
		return null;
	}

	private static WorldTile tryToBuildInZoneCenter(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	{
		if (!isGoodTileForBuilding(pZone.centerTile, pBuildingAsset, pCity))
		{
			return null;
		}
		return pZone.centerTile;
	}

	internal static bool isZoneNearbyBorder(TileZone pParentZone, BuildingAsset pAsset, City pCity)
	{
		TileZone[] neighbours_all = pParentZone.neighbours_all;
		for (int i = 0; i < neighbours_all.Length; i++)
		{
			if (neighbours_all[i].city != pCity)
			{
				return true;
			}
		}
		return false;
	}

	internal static bool isNearbySingleBuilding(TileZone pParentZone, BuildingAsset pAsset, City pCity)
	{
		if (checkZoneNearbySignleBuilding(pParentZone, pAsset, pCity))
		{
			return true;
		}
		TileZone[] neighbours_all = pParentZone.neighbours_all;
		for (int i = 0; i < neighbours_all.Length; i++)
		{
			if (checkZoneNearbySignleBuilding(neighbours_all[i], pAsset, pCity))
			{
				return true;
			}
		}
		return false;
	}

	internal static bool checkZoneNearbySignleBuilding(TileZone pZone, BuildingAsset pAsset, City pCity)
	{
		if (!pZone.hasBuildingOf(pCity))
		{
			return false;
		}
		HashSet<Building> hashset = pZone.getHashset(BuildingList.Civs);
		if (hashset != null)
		{
			foreach (Building item in hashset)
			{
				if (item.asset.build_place_single)
				{
					return true;
				}
			}
		}
		return false;
	}

	internal static bool isZonesNearbyBuilding(TileZone pParentZone, BuildingAsset pAsset, City pCity)
	{
		if (checkZoneNearbyBuilding(pParentZone, pAsset, pCity))
		{
			return true;
		}
		TileZone[] neighbours_all = pParentZone.neighbours_all;
		for (int i = 0; i < neighbours_all.Length; i++)
		{
			if (checkZoneNearbyBuilding(neighbours_all[i], pAsset, pCity))
			{
				return true;
			}
		}
		return false;
	}

	internal static bool checkZoneNearbyBuilding(TileZone pZone, BuildingAsset pAsset, City pCity)
	{
		if (!pZone.isSameCityHere(pCity))
		{
			return false;
		}
		if (!pZone.hasBuildingOf(pCity))
		{
			return false;
		}
		return true;
	}

	internal static bool isZonesClear(TileZone pParentZone, BuildingAsset pAsset, City pCity)
	{
		if (!checkZoneClear(pParentZone, pAsset, pCity))
		{
			return false;
		}
		TileZone[] neighbours_all = pParentZone.neighbours_all;
		for (int i = 0; i < neighbours_all.Length; i++)
		{
			if (!checkZoneClear(neighbours_all[i], pAsset, pCity))
			{
				return false;
			}
		}
		return true;
	}

	internal static bool checkFarmGround(WorldTile pTile, BuildingAsset pAsset, City pCity)
	{
		int num = 0;
		num += countGoodForFarms(pTile.region, pCity);
		for (int i = 0; i < pTile.region.neighbours.Count; i++)
		{
			MapRegion mapRegion = pTile.region.neighbours[i];
			List<TileZone> zones = mapRegion.chunk.zones;
			for (int j = 0; j < zones.Count; j++)
			{
				if (zones[j].city == pCity)
				{
					num += countGoodForFarms(mapRegion, pCity);
				}
			}
		}
		return num > 30;
	}

	internal static int countGoodForFarms(MapRegion pRegion, City pCity)
	{
		int num = 0;
		List<WorldTile> tiles = pRegion.tiles;
		for (int i = 0; i < tiles.Count; i++)
		{
			if (tiles[i].Type.can_be_farm)
			{
				num++;
			}
		}
		return num;
	}

	internal static bool checkZoneClear(TileZone pZone, BuildingAsset pAsset, City pCity)
	{
		if (pZone.hasAnyBuildingsInSet(BuildingList.Civs))
		{
			return false;
		}
		return true;
	}

	public static bool isGoodTileForBuilding(WorldTile pTile, BuildingAsset pAsset, City pCity)
	{
		if (!pTile.canBuildOn(pAsset))
		{
			return false;
		}
		if (BehaviourActionBase<City>.world.buildings.canBuildFrom(pTile, pAsset, pCity))
		{
			return true;
		}
		return false;
	}

	public static void debugRoards(City pCity, Building pBuilding)
	{
		makeRoadsBuildings(pCity, pBuilding);
	}

	public static void makeRoadsBuildings(City pCity, Building pBuilding)
	{
		if (pCity.road_tiles_to_build.Count > 0 || !pBuilding.asset.build_road_to)
		{
			return;
		}
		WorldTile current_tile = pBuilding.current_tile;
		if (current_tile.Type.liquid)
		{
			return;
		}
		using ListPool<WorldTile> listPool = new ListPool<WorldTile>(pCity.buildings.Count);
		foreach (Building building in pCity.buildings)
		{
			if (building != pBuilding && building.asset.build_road_to && !building.current_tile.Type.liquid && building.current_tile.isSameIsland(pBuilding.current_tile))
			{
				listPool.Add(building.current_tile);
			}
		}
		if (listPool.Count != 0)
		{
			bool pForceFinished = false;
			if (DebugConfig.isOn(DebugOption.CityFastConstruction))
			{
				pForceFinished = true;
			}
			WorldTile closestTile = Toolbox.getClosestTile(listPool, current_tile);
			if (closestTile != null)
			{
				listPool.Remove(closestTile);
				MapAction.makeRoadBetween(closestTile, current_tile, pCity, pForceFinished);
			}
			closestTile = Toolbox.getClosestTile(listPool, current_tile);
			if (closestTile != null)
			{
				MapAction.makeRoadBetween(closestTile, current_tile, pCity, pForceFinished);
			}
		}
	}

	public static WorldTile getTileTrainingDummy(BuildingAsset pBuildingAsset, City pCity)
	{
		Building buildingOfType = pCity.getBuildingOfType("type_barracks", pCountOnlyFinished: true, pRandom: true);
		if (buildingOfType == null)
		{
			return null;
		}
		HashSet<WorldTile> hashSet = UnsafeCollectionPool<HashSet<WorldTile>, WorldTile>.Get();
		using ListPool<WorldTile> listPool = new ListPool<WorldTile>();
		using ListPool<WorldTile> listPool2 = new ListPool<WorldTile>();
		foreach (WorldTile tile in buildingOfType.tiles)
		{
			WorldTile[] neighbours = tile.neighbours;
			foreach (WorldTile worldTile in neighbours)
			{
				if (!hashSet.Contains(worldTile))
				{
					hashSet.Add(worldTile);
					if (!worldTile.hasBuilding() && isGoodTileForBuilding(worldTile, pBuildingAsset, pCity))
					{
						listPool.Add(worldTile);
					}
				}
			}
		}
		foreach (ref WorldTile item in listPool)
		{
			WorldTile[] neighbours = item.neighbours;
			foreach (WorldTile worldTile2 in neighbours)
			{
				if (!hashSet.Contains(worldTile2))
				{
					hashSet.Add(worldTile2);
					if (!worldTile2.hasBuilding() && isGoodTileForBuilding(worldTile2, pBuildingAsset, pCity))
					{
						listPool2.Add(worldTile2);
					}
				}
			}
		}
		hashSet.Clear();
		UnsafeCollectionPool<HashSet<WorldTile>, WorldTile>.Release(hashSet);
		if (listPool2.Count == 0)
		{
			return null;
		}
		return listPool2.GetRandom();
	}

	public static WorldTile getDockTile(City pCity)
	{
		BuildingAsset buildingDockAsset = pCity.getActorAsset().getBuildingDockAsset();
		if (buildingDockAsset == null)
		{
			return null;
		}
		OceanHelper.clearOceanPools();
		OceanHelper.saveOceanPoolsWithDocks(pCity);
		if (pCity.getTile() == null)
		{
			return null;
		}
		foreach (TileZone item in pCity.zones.LoopRandom())
		{
			if (item.tiles_with_liquid == 0)
			{
				continue;
			}
			MapChunk chunk = item.chunk;
			if (chunk.regions.Count <= 1)
			{
				continue;
			}
			bool flag = false;
			for (int i = 0; i < chunk.regions.Count; i++)
			{
				MapRegion mapRegion = chunk.regions[i];
				if (mapRegion.type == TileLayerType.Ocean && OceanHelper.goodForNewDock(mapRegion.tiles[0]))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				continue;
			}
			foreach (WorldTile item2 in item.tiles.LoopRandom())
			{
				if (item2.Type.ocean && BehaviourActionBase<City>.world.buildings.canBuildFrom(item2, buildingDockAsset, pCity))
				{
					return item2;
				}
			}
		}
		return null;
	}
}
// --- End of File: CityBehBuild.cs ---



// --- Start of File: CityBehCheckArmy.cs ---
namespace ai.behaviours;

public class CityBehCheckArmy : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		pCity.checkArmyExistence();
		if (pCity.hasArmy())
		{
			return BehResult.Continue;
		}
		if (!pCity.hasAnyWarriors())
		{
			return BehResult.Continue;
		}
		Actor randomWarrior = pCity.getRandomWarrior();
		if (randomWarrior == null)
		{
			return BehResult.Continue;
		}
		BehaviourActionBase<City>.world.armies.newArmy(randomWarrior, pCity);
		return BehResult.Continue;
	}
}
// --- End of File: CityBehCheckArmy.cs ---



// --- Start of File: CityBehCheckAttackZone.cs ---
namespace ai.behaviours;

public class CityBehCheckAttackZone : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		City city = pCity.target_attack_city;
		bool flag = true;
		if (city == null)
		{
			flag = false;
		}
		else if (!city.isAlive() || !pCity.hasAnyWarriors() || !city.kingdom.isEnemy(pCity.kingdom) || !city.reachableFrom(pCity))
		{
			flag = false;
		}
		if (!flag)
		{
			pCity.target_attack_city = null;
			pCity.target_attack_zone = null;
			city = null;
		}
		if (pCity.target_attack_city != null && pCity.target_attack_zone.city != pCity.target_attack_city)
		{
			pCity.target_attack_zone = null;
		}
		if (pCity.hasAttackZoneOrder())
		{
			return BehResult.Continue;
		}
		if (city == null)
		{
			if (!pCity.isOkToSendArmy())
			{
				return BehResult.Continue;
			}
			city = findTargetCity(pCity);
		}
		if (city == null)
		{
			return BehResult.Continue;
		}
		pCity.target_attack_city = city;
		if (city.buildings.Count > 0)
		{
			Building random = city.buildings.GetRandom();
			pCity.target_attack_zone = random.current_tile.zone;
		}
		else if (pCity.hasZones())
		{
			pCity.target_attack_zone = pCity.zones.GetRandom();
		}
		return BehResult.Continue;
	}

	private City findTargetCity(City pOurCity)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Kingdom kingdom = pOurCity.kingdom;
		City result = null;
		float num = float.MaxValue;
		using ListPool<City> listPool = new ListPool<City>(BehaviourActionBase<City>.world.cities.Count);
		BehaviourActionBase<City>.world.wars.getWarCities(kingdom, listPool);
		foreach (ref City item in listPool)
		{
			City current = item;
			float num2 = Toolbox.SquaredDistVec2Float(current.city_center, pOurCity.city_center);
			if (!(num2 >= num) && current.reachableFrom(pOurCity))
			{
				result = current;
				num = num2;
			}
		}
		return result;
	}
}
// --- End of File: CityBehCheckAttackZone.cs ---



// --- Start of File: CityBehCheckCitizenTasks.cs ---
using System.Collections.Generic;

namespace ai.behaviours;

public class CityBehCheckCitizenTasks : BehaviourActionCity
{
	private int _citizens_left;

	public override BehResult execute(City pCity)
	{
		CityTasksData tasks = pCity.tasks;
		CitizenJobs jobs = pCity.jobs;
		CityStatus status = pCity.status;
		jobs.clearJobs();
		checkOccupied(pCity);
		_citizens_left = pCity.status.population_adults;
		tasks.clear();
		if (!DebugConfig.isOn(DebugOption.SystemCityTasks))
		{
			return BehResult.Continue;
		}
		countFires(pCity, tasks);
		countResources(pCity, tasks);
		countRoads(pCity, tasks);
		int num = 0;
		bool flag = false;
		int pTaskAmountMax = 0;
		bool flag2 = pCity.hasStorageBuilding();
		int totalFood = pCity.getTotalFood();
		if (WorldLawLibrary.world_law_civ_army.isEnabled() && status.population_adults > 15 && pCity.hasEnoughFoodForArmy())
		{
			flag = true;
			pTaskAmountMax = getPossibleWarriors(pCity);
		}
		int num2 = 0;
		num2 = ((totalFood > 100) ? 1 : ((totalFood > 60) ? 4 : ((totalFood > 40) ? 5 : ((totalFood <= 20) ? 10 : 7))));
		int num3 = 0;
		num3 = ((pCity.getResourcesAmount("wood") > 15) ? 1 : 3);
		bool flag3 = pCity.hasBuildingType("type_windmill");
		bool flag4 = pCity.hasBuildingType("type_mine");
		bool flag5 = pCity.hasBuildingToBuild();
		int num4 = _citizens_left * 2;
		while (_citizens_left >= 0)
		{
			if (flag5)
			{
				addToJob(CitizenJobLibrary.builder, jobs, 1, 3);
			}
			if (flag2)
			{
				addToJob(CitizenJobLibrary.gatherer_bushes, jobs, 1, tasks.bushes, num2);
				addToJob(CitizenJobLibrary.gatherer_herbs, jobs, 1, tasks.plants, num2);
				addToJob(CitizenJobLibrary.gatherer_honey, jobs, 1, tasks.hives, num2);
			}
			if (flag3)
			{
				addToJob(CitizenJobLibrary.farmer, jobs, 1, pCity.calculated_place_for_farms.Count);
			}
			if (World.world_era.flag_crops_grow && flag3)
			{
				addToJob(CitizenJobLibrary.farmer, jobs, 1, tasks.farms_total);
			}
			if (flag2)
			{
				addToJob(CitizenJobLibrary.miner_deposit, jobs, 1, tasks.minerals);
				addToJob(CitizenJobLibrary.woodcutter, jobs, 1, tasks.trees, num3);
			}
			if (flag4)
			{
				addToJob(CitizenJobLibrary.miner, jobs, 1, 5);
			}
			if (flag)
			{
				addToJob(CitizenJobLibrary.attacker, jobs, 2, pTaskAmountMax);
			}
			addToJob(CitizenJobLibrary.road_builder, jobs, 1, tasks.roads, 1);
			addToJob(CitizenJobLibrary.cleaner, jobs, 1, tasks.ruins, 1);
			if (flag2)
			{
				addToJob(CitizenJobLibrary.hunter, jobs, 1, 1);
				addToJob(CitizenJobLibrary.manure_cleaner, jobs, 1, tasks.poops, 3);
			}
			num++;
			if (num > num4)
			{
				break;
			}
		}
		return BehResult.Continue;
	}

	private void addToJob(CitizenJobAsset pJobAsset, CitizenJobs pJobsContainer, int pAdd, int pTaskAmountMax, int pJobMax = 0)
	{
		if (pAdd == 0 || pTaskAmountMax == 0)
		{
			return;
		}
		int num = pJobsContainer.countCurrentJobs(pJobAsset);
		if (num < pTaskAmountMax && (pJobMax == 0 || num < pJobMax))
		{
			int num2 = pAdd;
			if (_citizens_left <= num2)
			{
				num2 = _citizens_left;
			}
			_citizens_left -= num2;
			pJobsContainer.addToJob(pJobAsset, num2);
		}
	}

	private int getPossibleWarriors(City pCity)
	{
		float armyMaxMultiplier = pCity.getArmyMaxMultiplier();
		return (int)((float)pCity.status.population_adults * armyMaxMultiplier);
	}

	private void countRoads(City pCity, CityTasksData pTasks)
	{
		if (pCity.road_tiles_to_build.Count > 0)
		{
			pTasks.roads = 1;
		}
	}

	private void countResources(City pCity, CityTasksData pTasks)
	{
		bool flag = false;
		if (pCity.hasSpaceForResourceInStockpile(ResourceLibrary.berries))
		{
			flag = true;
		}
		bool flag2 = false;
		if (pCity.hasSpaceForResourceInStockpile(ResourceLibrary.herbs))
		{
			flag2 = true;
		}
		bool flag3 = false;
		if (pCity.hasSpaceForResourceInStockpile(ResourceLibrary.honey))
		{
			flag3 = true;
		}
		bool flag4 = false;
		if (pCity.hasSpaceForResourceInStockpile(ResourceLibrary.wood))
		{
			flag4 = true;
		}
		bool flag5 = false;
		if (pCity.hasSpaceForResourceInStockpile(ResourceLibrary.fertilizer))
		{
			flag5 = true;
		}
		for (int i = 0; i < pCity.zones.Count; i++)
		{
			TileZone tileZone = pCity.zones[i];
			if (flag4)
			{
				pTasks.trees += tileZone.countBuildingsType(BuildingList.Trees);
			}
			pTasks.minerals += tileZone.countBuildingsType(BuildingList.Minerals);
			pTasks.ruins += tileZone.countBuildingsType(BuildingList.Ruins);
			if (flag)
			{
				HashSet<Building> hashset = tileZone.getHashset(BuildingList.Food);
				if (hashset != null)
				{
					foreach (Building item in hashset)
					{
						if (item.hasResourcesToCollect())
						{
							pTasks.bushes++;
						}
					}
				}
			}
			if (flag2)
			{
				pTasks.plants += tileZone.countBuildingsType(BuildingList.Flora);
			}
			if (flag5)
			{
				pTasks.poops += tileZone.countBuildingsType(BuildingList.Poops);
			}
			if (flag3)
			{
				HashSet<Building> hashset2 = tileZone.getHashset(BuildingList.Food);
				if (hashset2 != null)
				{
					foreach (Building item2 in hashset2)
					{
						if (item2.hasResourcesToCollect())
						{
							pTasks.hives++;
						}
					}
				}
			}
			HashSet<WorldTile> tilesOfType = tileZone.getTilesOfType(TopTileLibrary.field);
			if (tilesOfType == null)
			{
				continue;
			}
			foreach (WorldTile item3 in tilesOfType)
			{
				pTasks.farms_total++;
				if (!item3.hasBuilding())
				{
					pTasks.farm_fields++;
				}
				else if (item3.building.asset.wheat && item3.building.component_wheat.isMaxLevel())
				{
					pTasks.wheats++;
				}
			}
		}
	}

	private void countFires(City pCity, CityTasksData pTasks)
	{
		foreach (TileZone neighbour_zone in pCity.neighbour_zones)
		{
			if (neighbour_zone.city == null)
			{
				pTasks.fire += WorldBehaviourActionFire.countFires(neighbour_zone);
			}
		}
		for (int i = 0; i < pCity.zones.Count; i++)
		{
			TileZone pZone = pCity.zones[i];
			pTasks.fire += WorldBehaviourActionFire.countFires(pZone);
		}
	}

	private void checkOccupied(City pCity)
	{
		Dictionary<CitizenJobAsset, int> occupied = pCity.jobs.occupied;
		occupied.Clear();
		for (int i = 0; i < pCity.units.Count; i++)
		{
			Actor actor = pCity.units[i];
			if (actor.citizen_job != null)
			{
				occupied.TryGetValue(actor.citizen_job, out var value);
				occupied[actor.citizen_job] = value + 1;
			}
		}
	}
}
// --- End of File: CityBehCheckCitizenTasks.cs ---



// --- Start of File: CityBehCheckDestruction.cs ---
namespace ai.behaviours;

public class CityBehCheckDestruction : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		if (!pCity.isGettingCaptured())
		{
			return BehResult.Continue;
		}
		Kingdom capturingKingdom = pCity.getCapturingKingdom();
		if (capturingKingdom.isRekt())
		{
			return BehResult.Continue;
		}
		Actor king = capturingKingdom.king;
		if (king == null || !king.hasXenophobic())
		{
			return BehResult.Continue;
		}
		if (capturingKingdom.getSpecies() == pCity.kingdom.getSpecies())
		{
			return BehResult.Continue;
		}
		foreach (Actor unit in pCity.getUnits())
		{
			if (unit.current_zone.city == pCity)
			{
				return BehResult.Continue;
			}
		}
		pCity.kingdom.decreaseHappinessFromRazedCity(pCity);
		capturingKingdom.increaseHappinessFromDestroyingCity();
		foreach (Actor unit2 in pCity.getUnits())
		{
			unit2.stopBeingWarrior();
			unit2.joinCity(null);
		}
		if (pCity.hasLeader())
		{
			pCity.removeLeader();
		}
		return BehResult.Continue;
	}
}
// --- End of File: CityBehCheckDestruction.cs ---



// --- Start of File: CityBehCheckFarms.cs ---
using ai.behaviours;

public class CityBehCheckFarms : BehaviourActionCity
{
	public override bool shouldRetry(City pCity)
	{
		return false;
	}

	public override BehResult execute(City pCity)
	{
		check(pCity);
		return BehResult.Continue;
	}

	public static void check(City pCity)
	{
		pCity.calculated_place_for_farms.Clear();
		pCity.calculated_grown_wheat.Clear();
		pCity.calculated_farm_fields.Clear();
		pCity.calculated_crops.Clear();
		behFindTileForFarm(pCity);
		pCity.calculated_place_for_farms.checkAddRemove();
		pCity.calculated_farm_fields.checkAddRemove();
		pCity.calculated_crops.checkAddRemove();
		behCheckWheat(pCity);
		pCity.calculated_grown_wheat.checkAddRemove();
	}

	private static void behCheckWheat(City pCity)
	{
		foreach (WorldTile calculated_crop in pCity.calculated_crops)
		{
			if (calculated_crop.hasBuilding() && calculated_crop.building.asset.wheat && calculated_crop.building.component_wheat.isMaxLevel())
			{
				pCity.calculated_grown_wheat.Add(calculated_crop);
			}
		}
	}

	private static void behFindTileForFarm(City pCity)
	{
		Building buildingOfType = pCity.getBuildingOfType("type_windmill");
		if (buildingOfType != null)
		{
			checkRegion(buildingOfType.current_tile.region, buildingOfType, pCity);
			for (int i = 0; i < buildingOfType.current_tile.region.neighbours.Count; i++)
			{
				checkRegion(buildingOfType.current_tile.region.neighbours[i], buildingOfType, pCity);
			}
		}
	}

	private static void checkRegion(MapRegion pRegion, Building pBuilding, City pCity)
	{
		MapChunk chunk = pRegion.chunk;
		for (int i = 0; i < chunk.zones.Count; i++)
		{
			checkZone(chunk.zones[i], pBuilding, pCity);
		}
	}

	private static void checkZone(TileZone pZone, Building pBuilding, City pCity)
	{
		if (!pZone.isSameCityHere(pCity))
		{
			return;
		}
		WorldTile[] tiles = pZone.tiles;
		int num = tiles.Length;
		for (int i = 0; i < num; i++)
		{
			WorldTile worldTile = tiles[i];
			if ((float)Toolbox.SquaredDistTile(pBuilding.current_tile, worldTile) > 81f)
			{
				continue;
			}
			if (worldTile.Type.can_be_farm)
			{
				pCity.calculated_place_for_farms.Add(worldTile);
			}
			if (worldTile.Type.farm_field)
			{
				pCity.calculated_farm_fields.Add(worldTile);
				if (worldTile.hasBuilding() && worldTile.building.asset.wheat)
				{
					pCity.calculated_crops.Add(worldTile);
				}
			}
		}
	}
}
// --- End of File: CityBehCheckFarms.cs ---



// --- Start of File: CityBehCheckLeader.cs ---
namespace ai.behaviours;

public class CityBehCheckLeader : BehaviourActionCity
{
	protected override void setupErrorChecks()
	{
		base.setupErrorChecks();
		uses_clans = true;
	}

	public override BehResult execute(City pCity)
	{
		checkLeaderClan(pCity);
		checkFindLeader(pCity);
		return BehResult.Continue;
	}

	private void checkLeaderClan(City pCity)
	{
		if (pCity.hasLeader())
		{
			Actor leader = pCity.leader;
			if (!leader.hasClan())
			{
				BehaviourActionBase<City>.world.clans.newClan(leader, pAddDefaultTraits: true);
			}
		}
	}

	private void checkFindLeader(City pCity)
	{
		if (pCity.hasLeader() || pCity.isGettingCaptured())
		{
			return;
		}
		Actor actor = null;
		actor = tryGetClanLeader(pCity);
		if (actor != null)
		{
			if (actor.city != pCity)
			{
				actor.stopBeingWarrior();
			}
			actor.joinCity(pCity);
			pCity.setLeader(actor, pNew: true);
			return;
		}
		int num = 0;
		foreach (Actor unit in pCity.units)
		{
			if (unit.isKing() || unit.isCityLeader())
			{
				continue;
			}
			int num2 = 1;
			if (unit.is_profession_citizen)
			{
				if (unit.isFavorite())
				{
					num2 += 2;
				}
				int num3 = ActorTool.attributeDice(unit, num2);
				if (actor == null || num3 > num)
				{
					actor = unit;
					num = num3;
				}
			}
		}
		if (actor != null)
		{
			pCity.setLeader(actor, pNew: true);
		}
	}

	private Actor tryGetClanLeader(City pCity)
	{
		Kingdom kingdom = pCity.kingdom;
		Clan clan = null;
		if (kingdom.data.royal_clan_id.hasValue())
		{
			clan = BehaviourActionBase<City>.world.clans.get(kingdom.data.royal_clan_id);
		}
		using ListPool<Actor> listPool = new ListPool<Actor>();
		using ListPool<Actor> listPool2 = new ListPool<Actor>();
		foreach (City city in kingdom.getCities())
		{
			foreach (Actor unit in city.getUnits())
			{
				if (unit.isUnitFitToRule() && !unit.isKing() && !unit.isCityLeader() && unit.hasClan())
				{
					if (clan != null && unit.clan == clan)
					{
						listPool.Add(unit);
					}
					else
					{
						listPool2.Add(unit);
					}
				}
			}
		}
		Actor result = null;
		if (listPool.Count > 0)
		{
			if (pCity.hasCulture())
			{
				return ListSorters.getUnitSortedByAgeAndTraits(listPool, pCity.culture);
			}
			listPool.Sort(ListSorters.sortUnitByAgeOldFirst);
			return listPool[0];
		}
		if (listPool2.Count > 0)
		{
			if (pCity.hasCulture())
			{
				return ListSorters.getUnitSortedByAgeAndTraits(listPool2, pCity.culture);
			}
			listPool2.Sort(ListSorters.sortUnitByAgeOldFirst);
			return listPool2[0];
		}
		return result;
	}
}
// --- End of File: CityBehCheckLeader.cs ---



// --- Start of File: CityBehCheckLoyalty.cs ---
using ai.behaviours;

public class CityBehCheckLoyalty : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		check(pCity);
		return BehResult.Continue;
	}

	public static void check(City pCity)
	{
		pCity.getLoyalty(pForceRecalc: true);
	}
}
// --- End of File: CityBehCheckLoyalty.cs ---



// --- Start of File: CityBehProduceBoat.cs ---
namespace ai.behaviours;

public class CityBehProduceBoat : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		if (pCity.timer_build_boat > 0f)
		{
			return BehResult.Stop;
		}
		Building buildingOfType = pCity.getBuildingOfType("type_docks", pCountOnlyFinished: true, pRandom: true);
		if (buildingOfType == null)
		{
			return BehResult.Stop;
		}
		Actor actor = buildingOfType.component_docks.buildBoatFromHere(pCity);
		if (actor == null)
		{
			return BehResult.Stop;
		}
		actor.joinKingdom(pCity.kingdom);
		actor.joinCity(pCity);
		pCity.timer_build_boat = 10f;
		return BehResult.Continue;
	}
}
// --- End of File: CityBehProduceBoat.cs ---



// --- Start of File: CityBehProduceResources.cs ---
namespace ai.behaviours;

public class CityBehProduceResources : BehaviourActionCity
{
	public override bool shouldRetry(City pCity)
	{
		return false;
	}

	public override BehResult execute(City pCity)
	{
		ActorAsset actorAsset = pCity.getActorAsset();
		if (actorAsset.production == null)
		{
			return BehResult.Stop;
		}
		foreach (string item in actorAsset.production.LoopRandom())
		{
			ResourceAsset resourceAsset = AssetManager.resources.get(item);
			int resourcesAmount = pCity.getResourcesAmount(item);
			if (resourcesAmount <= resourceAsset.maximum)
			{
				int pAmount = pCity.status.population / 10 + 1;
				if (resourcesAmount < resourceAsset.produce_min)
				{
					pAmount = resourceAsset.produce_min;
				}
				tryToProduce(resourceAsset, pCity, pAmount);
			}
		}
		return BehResult.Continue;
	}

	private bool tryToProduce(ResourceAsset pAsset, City pCity, int pAmount = 1)
	{
		for (int i = 0; i < pAmount; i++)
		{
			if (pCity.getResourcesAmount(pAsset.id) == pAsset.maximum)
			{
				return false;
			}
			string[] ingredients = pAsset.ingredients;
			foreach (string pResourceID in ingredients)
			{
				if (pCity.getResourcesAmount(pResourceID) < pAsset.ingredients_amount)
				{
					return false;
				}
			}
			ingredients = pAsset.ingredients;
			foreach (string pResourceID2 in ingredients)
			{
				pCity.takeResource(pResourceID2, pAsset.ingredients_amount);
			}
			if (pCity.addResourcesToRandomStockpile(pAsset.id) <= 0)
			{
				return false;
			}
		}
		return true;
	}
}
// --- End of File: CityBehProduceResources.cs ---



// --- Start of File: CityBehRandomWait.cs ---
namespace ai.behaviours;

public class CityBehRandomWait : BehaviourActionCity
{
	private float min;

	private float max;

	public override bool shouldRetry(City pObject)
	{
		return false;
	}

	public CityBehRandomWait(float pMin = 0f, float pMax = 1f)
	{
		min = pMin;
		max = pMax;
	}

	public override BehResult execute(City pCity)
	{
		pCity.timer_action = Randy.randomFloat(min, max);
		return BehResult.Continue;
	}
}
// --- End of File: CityBehRandomWait.cs ---



// --- Start of File: CityBehSupplyKingdomCities.cs ---
namespace ai.behaviours;

public class CityBehSupplyKingdomCities : BehaviourActionCity
{
	public override BehResult execute(City pCity)
	{
		if (!pCity.hasCulture())
		{
			return BehResult.Stop;
		}
		if (pCity.kingdom.countCities() == 1)
		{
			return BehResult.Stop;
		}
		if (pCity.data.timer_supply > 0f)
		{
			return BehResult.Stop;
		}
		if (!pCity.hasStockpiles())
		{
			return BehResult.Stop;
		}
		Building randomStockpile = pCity.getRandomStockpile();
		if (randomStockpile == null)
		{
			return BehResult.Stop;
		}
		using ListPool<CityStorageSlot> listPool = new ListPool<CityStorageSlot>();
		foreach (CityStorageSlot slot in randomStockpile.resources.getSlots())
		{
			if (slot.amount > slot.asset.supply_bound_give)
			{
				listPool.Add(slot);
			}
		}
		if (listPool.Count == 0)
		{
			return BehResult.Stop;
		}
		foreach (City item in pCity.kingdom.getCities().LoopRandom())
		{
			if (item == pCity)
			{
				continue;
			}
			foreach (CityStorageSlot item2 in listPool.LoopRandom())
			{
				if (item.getResourcesAmount(item2.id) < item2.asset.supply_bound_take)
				{
					shareResource(pCity, item, item2);
					updateSupplyTimer(pCity);
					return BehResult.Continue;
				}
			}
		}
		return BehResult.Continue;
	}

	private void updateSupplyTimer(City pCity)
	{
		float num = 30f;
		if (pCity.hasLeader())
		{
			num *= pCity.leader.stats["multiplier_supply_timer"];
		}
		if (num < 10f)
		{
			num = 10f;
		}
		pCity.data.timer_supply = num;
	}

	private void shareResource(City pCity, City pTargetCity, CityStorageSlot pSlot)
	{
		pCity.takeResource(pSlot.id, pSlot.asset.supply_give);
		pTargetCity.addResourcesToRandomStockpile(pSlot.id, pSlot.asset.supply_give);
	}
}
// --- End of File: CityBehSupplyKingdomCities.cs ---



// --- Start of File: CityBuildingIcons.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class CityBuildingIcons : CityElement
{
	public Image top;

	public Image topLeft;

	public Image topRight;

	public Image left;

	public Image right;

	public Image bottom;

	public Image bottomLeft;

	public Image bottomRight;

	public Image centerBonfire;

	private Image[] _list_house_images;

	private List<SpriteAnimation> _sprite_animations = new List<SpriteAnimation>();

	protected override void Awake()
	{
		_list_house_images = (Image[])(object)new Image[8] { top, topRight, right, bottomRight, bottom, bottomLeft, left, topLeft };
		base.Awake();
	}

	private void Update()
	{
		foreach (SpriteAnimation sprite_animation in _sprite_animations)
		{
			sprite_animation.update(Time.deltaTime);
		}
	}

	protected override void clear()
	{
		Image[] list_house_images = _list_house_images;
		for (int i = 0; i < list_house_images.Length; i++)
		{
			((Component)list_house_images[i]).gameObject.SetActive(false);
		}
		_sprite_animations.Clear();
	}

	protected override IEnumerator showContent()
	{
		((Graphic)centerBonfire).SetNativeSize();
		_sprite_animations.Add(((Component)centerBonfire).GetComponent<SpriteAnimation>());
		using ListPool<string> pPossibleIDs = getCityBuildingTypes();
		if (pPossibleIDs.Count != 0)
		{
			Image[] list_house_images = _list_house_images;
			foreach (Image tImage in list_house_images)
			{
				string tID = pPossibleIDs.GetRandom();
				yield return (object)new WaitForEndOfFrame();
				showSprite(tImage, tID);
			}
		}
	}

	private void showSprite(Image pImage, string pAssetID)
	{
		BuildingAsset buildingAsset = AssetManager.buildings.get(pAssetID);
		Sprite recoloredBuilding = DynamicSprites.getRecoloredBuilding(buildingAsset.building_sprites.animation_data.GetRandom().main.GetRandom(), base.city.kingdom?.getColor(), buildingAsset.atlas_asset);
		pImage.sprite = recoloredBuilding;
		((Graphic)pImage).SetNativeSize();
		((Component)pImage).gameObject.SetActive(true);
	}

	private ListPool<string> getCityBuildingTypes()
	{
		ListPool<string> listPool = new ListPool<string>(base.city.buildings.Count);
		foreach (Building building in base.city.buildings)
		{
			if (building.asset.hasHousingSlots() && building.asset.id.Contains("house"))
			{
				listPool.Add(building.asset.id);
			}
		}
		return listPool;
	}
}
// --- End of File: CityBuildingIcons.cs ---



// --- Start of File: CityBuildingPlacement.cs ---
public enum CityBuildingPlacement
{
	Everywhere,
	Borders,
	NearbyHouses,
	Single,
	Docks
}
// --- End of File: CityBuildingPlacement.cs ---



// --- Start of File: CityBuildOrderAsset.cs ---
using System;
using System.Collections.Generic;
using UnityPools;

[Serializable]
public class CityBuildOrderAsset : Asset
{
	[NonSerialized]
	public string[] list_for_generation;

	public List<BuildOrder> list = new List<BuildOrder>();

	public void addUpgrade(string pID, int pLimitType = 0, int pPop = 0, int pBuildings = 0, bool pCheckFullVillage = false, bool pZonesCheck = false, int pMinZones = 0)
	{
		addBuilding(pID, pLimitType, pPop, pBuildings, pCheckFullVillage, pZonesCheck, pMinZones).upgrade = true;
	}

	public BuildOrder addBuilding(string pID, int pLimitType = 0, int pPop = 0, int pBuildings = 0, bool pCheckFullVillage = false, bool pCheckHouseLimit = false, int pMinZones = 0)
	{
		BuildOrder buildOrder = new BuildOrder();
		buildOrder.id = pID;
		buildOrder.limit_type = pLimitType;
		buildOrder.required_pop = pPop;
		buildOrder.required_buildings = pBuildings;
		buildOrder.check_full_village = pCheckFullVillage;
		buildOrder.check_house_limit = pCheckHouseLimit;
		buildOrder.min_zones = pMinZones;
		list.Add(buildOrder);
		BuildOrderLibrary.b = buildOrder;
		return buildOrder;
	}

	public void prepareForAssetGeneration()
	{
		HashSet<string> hashSet = UnsafeCollectionPool<HashSet<string>, string>.Get();
		foreach (BuildOrder item in list)
		{
			hashSet.Add(item.id);
			if (item.requirements_orders != null)
			{
				hashSet.UnionWith(item.requirements_orders);
			}
		}
		list_for_generation = hashSet.ToArray();
		UnsafeCollectionPool<HashSet<string>, string>.Release(hashSet);
	}
}
// --- End of File: CityBuildOrderAsset.cs ---



// --- Start of File: CityData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine.Scripting;

[Serializable]
public class CityData : MetaObjectData
{
	public CityEquipment equipment;

	public List<ZoneData> zones = new List<ZoneData>();

	public int total_food_consumed;

	public float timer_supply;

	public float timer_trade;

	public List<LeaderEntry> past_rulers;

	[DefaultValue(0)]
	public int total_leaders;

	public double timestamp_kingdom;

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string original_actor_asset { get; set; }

	[DefaultValue(-1L)]
	public long kingdomID { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long leaderID { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long founder_id { get; set; } = -1L;


	public string founder_name { get; set; }

	[DefaultValue(-1L)]
	public long last_leader_id { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long last_kingdom_id { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long id_culture { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long id_language { get; set; } = -1L;


	[DefaultValue(-1L)]
	public long id_religion { get; set; } = -1L;


	public long left { get; set; }

	public long joined { get; set; }

	public long moved { get; set; }

	public long migrated { get; set; }

	[Preserve]
	[Obsolete("use .name instead", true)]
	public string cityName
	{
		set
		{
			if (string.IsNullOrEmpty(base.name) && !string.IsNullOrEmpty(value))
			{
				base.name = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .id instead", true)]
	public long cityID
	{
		set
		{
			if (value.hasValue() && !base.id.hasValue())
			{
				base.id = value;
			}
		}
	}

	[Preserve]
	[Obsolete("use .original_actor_asset instead", true)]
	public string race
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(original_actor_asset))
			{
				original_actor_asset = value;
			}
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		zones.Clear();
		past_rulers?.Clear();
		past_rulers = null;
		equipment?.Dispose();
		equipment = null;
	}
}
// --- End of File: CityData.cs ---



// --- Start of File: CityElement.cs ---
public class CityElement : WindowMetaElement<City, CityData>
{
	protected City city => meta_object;
}
// --- End of File: CityElement.cs ---



// --- Start of File: CityElementNeutralHandler.cs ---
using System.Collections;
using UnityEngine;

public class CityElementNeutralHandler : CityElement
{
	[SerializeField]
	private GameObject _layout_element_content_meta;

	[SerializeField]
	private GameObject _layout_element_wants;

	[SerializeField]
	private GameObject _layout_element_ruler;

	private void checkNeutralElements()
	{
		if (meta_object.isNeutral())
		{
			_layout_element_content_meta.SetActive(false);
			_layout_element_wants.SetActive(false);
			_layout_element_ruler.SetActive(false);
		}
	}

	protected override IEnumerator showContent()
	{
		checkNeutralElements();
		return base.showContent();
	}
}
// --- End of File: CityElementNeutralHandler.cs ---



// --- Start of File: CityEquipment.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class CityEquipment : IDisposable
{
	internal Dictionary<EquipmentType, List<long>> items_dicts;

	public List<long> item_storage_weapons = new List<long>();

	public List<long> item_storage_helmets = new List<long>();

	public List<long> item_storage_armor = new List<long>();

	public List<long> item_storage_boots = new List<long>();

	public List<long> item_storage_rings = new List<long>();

	public List<long> item_storage_amulets = new List<long>();

	public CityEquipment()
	{
		init();
	}

	internal void init()
	{
		if (items_dicts == null)
		{
			items_dicts = new Dictionary<EquipmentType, List<long>>();
		}
		else
		{
			items_dicts.Clear();
		}
		items_dicts.Add(EquipmentType.Weapon, item_storage_weapons);
		items_dicts.Add(EquipmentType.Helmet, item_storage_helmets);
		items_dicts.Add(EquipmentType.Armor, item_storage_armor);
		items_dicts.Add(EquipmentType.Boots, item_storage_boots);
		items_dicts.Add(EquipmentType.Ring, item_storage_rings);
		items_dicts.Add(EquipmentType.Amulet, item_storage_amulets);
	}

	public void clearItems()
	{
		foreach (List<long> allEquipmentList in getAllEquipmentLists())
		{
			foreach (long item in allEquipmentList)
			{
				World.world.items.get(item)?.clearCity();
			}
		}
		clearCollections();
	}

	public int countItems()
	{
		int num = 0;
		foreach (List<long> allEquipmentList in getAllEquipmentLists())
		{
			num += allEquipmentList.Count;
		}
		return num;
	}

	public bool hasAnyItem()
	{
		foreach (List<long> allEquipmentList in getAllEquipmentLists())
		{
			if (allEquipmentList.Count > 0)
			{
				return true;
			}
		}
		return false;
	}

	public void addItem(City pCity, Item pItem, List<long> pList = null)
	{
		EquipmentAsset asset = pItem.getAsset();
		if (pList == null)
		{
			pList = getEquipmentList(asset.equipment_type);
		}
		pItem.setInCityStorage(pCity);
		pList.Add(pItem.id);
	}

	public List<long> getEquipmentList(EquipmentType pType)
	{
		return items_dicts[pType];
	}

	public IEnumerable<List<long>> getAllEquipmentLists()
	{
		foreach (List<long> value in items_dicts.Values)
		{
			yield return value;
		}
	}

	public void loadFromSave(City pCity)
	{
		init();
		foreach (List<long> allEquipmentList in getAllEquipmentLists())
		{
			allEquipmentList.RemoveAll(delegate(long pID)
			{
				Item item = World.world.items.get(pID);
				if (item == null)
				{
					return true;
				}
				return item.getAsset() == null;
			});
		}
		foreach (List<long> allEquipmentList2 in getAllEquipmentLists())
		{
			for (int i = 0; i < allEquipmentList2.Count; i++)
			{
				long pID2 = allEquipmentList2[i];
				World.world.items.get(pID2).setInCityStorage(pCity);
			}
		}
	}

	public void Dispose()
	{
		items_dicts?.Clear();
		clearCollections();
	}

	private void clearCollections()
	{
		item_storage_weapons.Clear();
		item_storage_helmets.Clear();
		item_storage_armor.Clear();
		item_storage_boots.Clear();
		item_storage_rings.Clear();
		item_storage_amulets.Clear();
	}
}
// --- End of File: CityEquipment.cs ---



// --- Start of File: CityJobLibrary.cs ---
public class CityJobLibrary : AssetLibrary<JobCityAsset>
{
	public override void init()
	{
		base.init();
		add(new JobCityAsset
		{
			id = "city"
		});
		t.addTask("check_army");
		t.addTask("wait1");
		t.addTask("do_checks");
		t.addTask("wait1");
		t.addTask("border_shrink");
		t.addTask("wait1");
		t.addTask("produce_boat");
		t.addTask("wait1");
		t.addTask("supply_kingdom_cities");
		t.addTask("wait1");
		t.addTask("produce_resources");
		t.addTask("wait1");
		t.addTask("check_farms");
	}
}
// --- End of File: CityJobLibrary.cs ---



// --- Start of File: CityLayoutTilePlacement.cs ---
public enum CityLayoutTilePlacement
{
	Random,
	CenterTile,
	CenterTileDrunk,
	Moonsteps
}
// --- End of File: CityLayoutTilePlacement.cs ---



// --- Start of File: CityLeaderElement.cs ---
using System.Collections;
using UnityEngine;

public class CityLeaderElement : CityElement
{
	[SerializeField]
	private GameObject _title_element;

	[SerializeField]
	private PrefabUnitElement _ruler_element;

	protected override IEnumerator showContent()
	{
		if (base.city.hasLeader())
		{
			track_objects.Add(base.city.leader);
			_title_element.gameObject.SetActive(true);
			((Component)_ruler_element).gameObject.SetActive(true);
			_ruler_element.show(base.city.leader);
		}
		yield break;
	}

	protected override void clear()
	{
		_title_element.gameObject.SetActive(false);
		((Component)_ruler_element).gameObject.SetActive(false);
		base.clear();
	}

	public override bool checkRefreshWindow()
	{
		if (((Component)_ruler_element).gameObject.activeSelf && !base.city.hasLeader())
		{
			return true;
		}
		return base.checkRefreshWindow();
	}
}
// --- End of File: CityLeaderElement.cs ---



// --- Start of File: CityListComponent.cs ---
public class CityListComponent : ComponentListBase<CityListElement, City, CityData, CityListComponent>
{
	protected override MetaType meta_type => MetaType.City;

	protected override void setupSortingTabs()
	{
		genericMetaSortByAge(base.sortByAge);
		genericMetaSortByRenown(base.sortByRenown);
		genericMetaSortByPopulation(ComponentListBase<CityListElement, City, CityData, CityListComponent>.sortByPopulation);
		sorting_tab.tryAddButton("ui/Icons/iconLoyalty", "sort_by_loyalty", show, delegate
		{
			current_sort = sortByLoyalty;
		});
		sorting_tab.tryAddButton("ui/Icons/iconZones", "sort_by_area", show, delegate
		{
			current_sort = sortByArea;
		});
		sorting_tab.tryAddButton("ui/Icons/iconArmy", "sort_by_army", show, delegate
		{
			current_sort = sortByArmy;
		});
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
		{
			current_sort = sortByKingdom;
		});
	}

	private static int sortByKingdom(City p1, City p2)
	{
		return p2.kingdom.CompareTo(p1.kingdom);
	}

	private static int sortByArmy(City p1, City p2)
	{
		return p2.countWarriors().CompareTo(p1.countWarriors());
	}

	private static int sortByLoyalty(City p1, City p2)
	{
		return p2.getCachedLoyalty().CompareTo(p1.getCachedLoyalty());
	}

	private static int sortByArea(City p1, City p2)
	{
		return p2.zones.Count.CompareTo(p1.zones.Count);
	}
}
// --- End of File: CityListComponent.cs ---



// --- Start of File: CityListElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CityListElement : WindowListElementBase<City, CityData>
{
	public Text text_name;

	public CountUpOnClick population;

	public CountUpOnClick army;

	public CountUpOnClick zones;

	[SerializeField]
	private CountUpOnClick _loyalty;

	public CountUpOnClick age;

	public UiUnitAvatarElement avatarLoader;

	public CityBanner city_banner;

	[SerializeField]
	private GameObject _icon_capital;

	[SerializeField]
	private CityLoyaltyElement _loyalty_element;

	internal override void show(City pCity)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		base.show(pCity);
		avatarLoader.show(pCity.leader);
		_loyalty_element.setCity(pCity);
		text_name.text = pCity.name;
		((Graphic)text_name).color = pCity.kingdom.getColor().getColorText();
		population.setValue(pCity.getPopulationPeople());
		army.setValue(pCity.countWarriors());
		zones.setValue(pCity.zones.Count);
		int loyalty = pCity.getLoyalty(pForceRecalc: true);
		_loyalty.setValue(loyalty);
		if (loyalty < 0)
		{
			((Graphic)_loyalty.getText()).color = Toolbox.color_negative_RGBA;
		}
		else
		{
			((Graphic)_loyalty.getText()).color = Toolbox.color_positive_RGBA;
		}
		age.setValue(pCity.getAge());
		toggleCapital(pCity.isCapitalCity());
	}

	protected override void initMonoFields()
	{
	}

	protected override void loadBanner()
	{
		city_banner.load(meta_object);
	}

	protected override void tooltipAction()
	{
		Tooltip.show(this, "city", new TooltipData
		{
			city = meta_object
		});
	}

	private void toggleCapital(bool pState)
	{
		GameObject icon_capital = _icon_capital;
		if (icon_capital != null)
		{
			icon_capital.SetActive(pState);
		}
	}

	protected override ActorAsset getActorAsset()
	{
		return meta_object.getActorAsset();
	}
}
// --- End of File: CityListElement.cs ---



// --- Start of File: CityLoyaltyElement.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class CityLoyaltyElement : MonoBehaviour
{
	private City _city;

	private TooltipData _tooltip_data;

	public void setCity(City pCity)
	{
		_city = pCity;
	}

	private void Start()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		Button component = ((Component)this).GetComponent<Button>();
		((UnityEvent)component.onClick).AddListener(new UnityAction(showTooltip));
		component.OnHover(new UnityAction(showHoverTooltip));
		component.OnHoverOut(new UnityAction(Tooltip.hideTooltip));
	}

	private void showHoverTooltip()
	{
		if (Config.tooltips_active)
		{
			showTooltip();
		}
	}

	private void showTooltip()
	{
		_tooltip_data = new TooltipData
		{
			city = _city
		};
		Tooltip.show(((Component)this).gameObject, "loyalty", _tooltip_data);
	}
}
// --- End of File: CityLoyaltyElement.cs ---



// --- Start of File: CityManager.cs ---
using System.Collections.Generic;

public class CityManager : MetaSystemManager<City, CityData>
{
	private bool _dirty_buildings;

	public CityManager()
	{
		type_id = "city";
	}

	public City newCity(Kingdom pKingdom, TileZone pZone, Actor pOriginalActor)
	{
		World.world.game_stats.data.citiesCreated++;
		World.world.map_stats.citiesCreated++;
		City city = newObject();
		city.data.founder_id = pOriginalActor.getID();
		city.data.founder_name = pOriginalActor.name;
		city.data.original_actor_asset = pOriginalActor.asset.id;
		city.data.equipment = new CityEquipment();
		city.setKingdom(pKingdom);
		city.addZone(pZone);
		TileZone[] neighbours_all = pZone.neighbours_all;
		foreach (TileZone tileZone in neighbours_all)
		{
			if (tileZone.city == null)
			{
				city.addZone(tileZone);
			}
		}
		World.world.city_zone_helper.city_place_finder.setDirty();
		return city;
	}

	public City buildNewCity(Actor pActor, TileZone pZone)
	{
		Kingdom kingdom = pActor.kingdom;
		City city = World.world.cities.newCity(kingdom, pZone, pActor);
		city.setUnitMetas(pActor);
		city.newCityEvent(pActor);
		WorldLog.logNewCity(city);
		return city;
	}

	public bool tryToCreateCity(Actor pActor, ListPool<Building> pBuildingList)
	{
		if (pActor.current_tile.zone.hasCity())
		{
			return false;
		}
		return true;
	}

	public bool canStartNewCityCivilizationHere(Actor pActor)
	{
		if (pActor.kingdom.asset.is_forced_by_trait)
		{
			return false;
		}
		if (!pActor.canBuildNewCity())
		{
			return false;
		}
		KingdomAsset kingdomAsset = AssetManager.kingdoms.get(pActor.asset.kingdom_id_civilization);
		if (kingdomAsset == null || !kingdomAsset.civ)
		{
			return false;
		}
		WorldTile current_tile = pActor.current_tile;
		TileZone zone = current_tile.zone;
		TileZone[] neighbours = zone.neighbours;
		foreach (TileZone tileZone in neighbours)
		{
			if (tileZone.hasCity())
			{
				WorldTile tile = tileZone.city.getTile();
				if (tile != null && tile.isSameIsland(current_tile))
				{
					tileZone.city.addZone(zone);
					return false;
				}
			}
		}
		return true;
	}

	public City buildFirstCivilizationCity(Actor pActor)
	{
		City city = buildNewCity(pActor, pActor.current_zone);
		pActor.joinCity(city);
		city.setUnitMetas(pActor);
		city.convertSameSpeciesAroundUnit(pActor);
		return city;
	}

	protected override void updateDirtyUnits()
	{
		List<Actor> units_only_alive = World.world.units.units_only_alive;
		for (int i = 0; i < units_only_alive.Count; i++)
		{
			Actor actor = units_only_alive[i];
			City city = actor.city;
			if (city != null && city.isDirtyUnits())
			{
				city.listUnit(actor);
			}
		}
	}

	public void beginChecksBuildings()
	{
		if (_dirty_buildings)
		{
			updateDirtyBuildings();
		}
		_dirty_buildings = false;
	}

	private void updateDirtyBuildings()
	{
		clearAllBuildingLists();
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			City current = enumerator.Current;
			Kingdom kingdom = current.kingdom;
			for (int i = 0; i < current.zones.Count; i++)
			{
				foreach (Building item in current.zones[i].buildings_all)
				{
					if (item.asset.city_building && item.isUsable())
					{
						item.setKingdomCiv(kingdom);
						current.listBuilding(item);
					}
				}
			}
		}
	}

	public void setDirtyBuildings(City pCity)
	{
		_dirty_buildings = true;
		World.world.kingdoms.setDirtyBuildings();
	}

	private void clearAllBuildingLists()
	{
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.clearBuildingList();
		}
	}

	protected override void addObject(City pObject)
	{
		pObject.init();
		base.addObject(pObject);
	}

	public override City loadObject(CityData pData)
	{
		City city = base.loadObject(pData);
		city.loadCity(pData);
		return city;
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			City current = enumerator.Current;
			current.update(pElapsed);
			current.clearCursorOver();
		}
	}

	public void updateAge()
	{
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.updateAge();
		}
	}

	public override List<CityData> save(List<City> pList = null)
	{
		List<CityData> list = new List<CityData>();
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			City current = enumerator.Current;
			current.save();
			list.Add(current.data);
		}
		return list;
	}

	private void checkForCityErrors(SavedMap pSaveData)
	{
		List<CityData> list = new List<CityData>();
		for (int i = 0; i < pSaveData.cities.Count; i++)
		{
			CityData cityData = pSaveData.cities[i];
			if (cityData.zones.Count != 0)
			{
				TileZone tileZone = World.world.zone_calculator.getZone(cityData.zones[0].x, cityData.zones[0].y);
				if (pSaveData.saveVersion < 7)
				{
					tileZone = findZoneViaBuilding(cityData.id, pSaveData.buildings);
				}
				if (tileZone != null)
				{
					list.Add(cityData);
				}
			}
		}
		pSaveData.cities = list;
	}

	public void loadCities(SavedMap pSaveData)
	{
		checkForCityErrors(pSaveData);
		for (int i = 0; i < pSaveData.cities.Count; i++)
		{
			CityData cityData = pSaveData.cities[i];
			City city = loadObject(cityData);
			if (city == null || pSaveData.saveVersion < 7)
			{
				continue;
			}
			for (int j = 0; j < cityData.zones.Count; j++)
			{
				ZoneData zoneData = cityData.zones[j];
				TileZone zone = World.world.zone_calculator.getZone(zoneData.x, zoneData.y);
				if (zone != null)
				{
					city.addZone(zone);
				}
			}
		}
	}

	public override void removeObject(City pObject)
	{
		World.world.game_stats.data.citiesDestroyed++;
		World.world.map_stats.citiesDestroyed++;
		WorldLog.logCityDestroyed(pObject);
		pObject.destroyCity();
		base.removeObject(pObject);
		World.world.city_zone_helper.city_place_finder.setDirty();
		World.world.cultures.setDirtyCities();
		World.world.kingdoms.setDirtyCities();
		World.world.languages.setDirtyCities();
		World.world.religions.setDirtyCities();
	}

	private TileZone findZoneViaBuilding(long pID, List<BuildingData> pList)
	{
		for (int i = 0; i < pList.Count; i++)
		{
			BuildingData buildingData = pList[i];
			if (buildingData.cityID == pID)
			{
				return World.world.GetTileSimple(buildingData.mainX, buildingData.mainY).zone;
			}
		}
		return null;
	}

	public override bool isLocked()
	{
		if (isUnitsDirty())
		{
			return true;
		}
		if (World.world.kingdoms.hasDirtyCities())
		{
			return true;
		}
		return false;
	}
}
// --- End of File: CityManager.cs ---



// --- Start of File: CityMetaBanners.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CityMetaBanners : CityElement, IBaseMetaBanners
{
	[SerializeField]
	private KingdomBanner _banner_kingdom;

	[SerializeField]
	private ClanBanner _banner_clan;

	[SerializeField]
	private AllianceBanner _banner_alliance;

	[SerializeField]
	private LanguageBanner _banner_language;

	[SerializeField]
	private CultureBanner _banner_culture;

	[SerializeField]
	private ReligionBanner _banner_religion;

	[SerializeField]
	private SubspeciesBanner _banner_subspecies;

	[SerializeField]
	private ArmyBanner _banner_army;

	protected List<MetaBannerElement> banners = new List<MetaBannerElement>();

	private const float DELAY = 0.025f;

	protected int visible_banners;

	protected override void Awake()
	{
		base.Awake();
		banners.Add(new MetaBannerElement
		{
			banner = _banner_kingdom,
			check = () => !base.city.kingdom.isRekt() && !base.city.kingdom.isNeutral(),
			nano = () => base.city.kingdom
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_clan,
			check = () => base.city.hasLeader() && base.city.leader.hasClan(),
			nano = () => base.city.leader.clan
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_alliance,
			check = () => base.city.kingdom.hasAlliance(),
			nano = () => base.city.kingdom.getAlliance()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_language,
			check = () => base.city.hasLanguage(),
			nano = () => base.city.getLanguage()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_culture,
			check = () => base.city.hasCulture(),
			nano = () => base.city.getCulture()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_religion,
			check = () => base.city.hasReligion(),
			nano = () => base.city.getReligion()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_subspecies,
			check = () => !base.city.getMainSubspecies().isRekt(),
			nano = () => base.city.getMainSubspecies()
		});
		banners.Add(new MetaBannerElement
		{
			banner = _banner_army,
			check = () => base.city.hasArmy(),
			nano = () => base.city.getArmy()
		});
		((IBaseMetaBanners)this).enableClickAnimation();
	}

	protected override IEnumerator showContent()
	{
		banners.Sort((MetaBannerElement x, MetaBannerElement y) => ((Component)x.banner).transform.GetSiblingIndex().CompareTo(((Component)y.banner).transform.GetSiblingIndex()));
		yield return (object)new WaitForSecondsRealtime(0.025f);
		if (base.city.kingdom.isNeutral())
		{
			yield break;
		}
		foreach (MetaBannerElement banner in banners)
		{
			if (banner.check())
			{
				track_objects.Add(banner.nano());
				metaBannerShow(banner);
			}
		}
	}

	protected override void clear()
	{
		base.clear();
		foreach (MetaBannerElement banner in banners)
		{
			metaBannerHide(banner);
		}
		visible_banners = 0;
	}

	public void metaBannerShow(MetaBannerElement pAsset)
	{
		((Component)pAsset.banner).gameObject.SetActive(true);
		pAsset.banner.load(pAsset.nano());
		visible_banners++;
	}

	public void metaBannerHide(MetaBannerElement pAsset)
	{
		if (((Component)pAsset.banner).gameObject.activeSelf)
		{
			((Component)pAsset.banner).gameObject.SetActive(false);
		}
	}

	public IReadOnlyCollection<MetaBannerElement> getBanners()
	{
		return banners;
	}
}
// --- End of File: CityMetaBanners.cs ---



// --- Start of File: CityPlaceFinder.cs ---
using System.Collections.Generic;

public class CityPlaceFinder : CityZoneWorkerBase
{
	private bool _dirty;

	internal List<TileZone> zones = new List<TileZone>();

	internal bool isDirty()
	{
		if (!DebugConfig.isOn(DebugOption.SystemCityPlaceFinder))
		{
			return false;
		}
		return _dirty;
	}

	internal void recalc()
	{
		if (isDirty())
		{
			_dirty = false;
			clearAll();
			prepareBasicZones();
			prepareQueueFromCities();
			startWave();
			createFinalList();
		}
	}

	internal override void clearAll()
	{
		base.clearAll();
		zones.Clear();
		List<TileZone> list = World.world.zone_calculator.zones;
		for (int i = 0; i < list.Count; i++)
		{
			list[i].setGoodForNewCity(pValue: true);
		}
	}

	private void prepareBasicZones()
	{
		List<TileZone> list = World.world.zone_calculator.zones;
		for (int i = 0; i < list.Count; i++)
		{
			TileZone tileZone = list[i];
			if (!tileZone.canStartCityHere())
			{
				tileZone.setGoodForNewCity(pValue: false);
			}
			else if (tileZone.centerTile.region.island.getTileCount() < 300)
			{
				tileZone.setGoodForNewCity(pValue: false);
			}
		}
	}

	private void prepareQueueFromCities()
	{
		prepareWave();
		foreach (City city in World.world.cities)
		{
			checkCity(city, _wave);
		}
	}

	private void checkCity(City pCity, Queue<ZoneConnection> pWaveQ)
	{
		WorldTile tile = pCity.getTile();
		if (tile == null)
		{
			return;
		}
		TileIsland island = tile.region.island;
		foreach (TileZone border_zone in pCity.border_zones)
		{
			for (int i = 0; i < border_zone.centerTile.chunk.regions.Count; i++)
			{
				MapRegion mapRegion = border_zone.chunk.regions[i];
				if (mapRegion.isTypeGround() && mapRegion.zones.Contains(border_zone) && mapRegion.island == island)
				{
					queueConnection(new ZoneConnection(border_zone, mapRegion), pWaveQ, pSetChecked: true);
				}
			}
		}
	}

	private void startWave()
	{
		Queue<ZoneConnection> queue = _wave;
		Queue<ZoneConnection> queue2 = _next_wave;
		using ListPool<MapRegion> listPool = new ListPool<MapRegion>();
		int num = 3;
		int num2 = 0;
		while (queue2.Count > 0 || queue.Count > 0)
		{
			if (queue.Count == 0)
			{
				Queue<ZoneConnection> queue3 = queue;
				queue = queue2;
				queue2 = queue3;
				num2++;
			}
			if (num2 > num)
			{
				break;
			}
			ZoneConnection zoneConnection = queue.Dequeue();
			TileZone zone = zoneConnection.zone;
			MapRegion region = zoneConnection.region;
			TileZone[] neighbours = zone.neighbours;
			foreach (TileZone tileZone in neighbours)
			{
				if (tileZone.hasCity())
				{
					continue;
				}
				listPool.Clear();
				if (!TileZone.hasZonesConnectedViaRegions(zone, tileZone, region, listPool))
				{
					continue;
				}
				for (int j = 0; j < listPool.Count; j++)
				{
					MapRegion pRegion = listPool[j];
					ZoneConnection zoneConnection2 = new ZoneConnection(tileZone, pRegion);
					if (_zones_checked.Add(zoneConnection2))
					{
						tileZone.setGoodForNewCity(pValue: false);
						queueConnection(zoneConnection2, queue2);
					}
				}
			}
		}
	}

	private void createFinalList()
	{
		for (int i = 0; i < World.world.zone_calculator.zones.Count; i++)
		{
			TileZone tileZone = World.world.zone_calculator.zones[i];
			if (tileZone.isGoodForNewCity())
			{
				zones.Add(tileZone);
			}
		}
	}

	public bool hasPossibleZones()
	{
		if (_dirty)
		{
			return false;
		}
		return zones.Count > 0;
	}

	internal void setDirty()
	{
		_dirty = true;
		clearCurrentZones();
	}

	private void clearCurrentZones()
	{
		if (zones.Count != 0)
		{
			for (int i = 0; i < zones.Count; i++)
			{
				zones[i].setGoodForNewCity(pValue: false);
			}
			zones.Clear();
		}
	}
}
// --- End of File: CityPlaceFinder.cs ---



// --- Start of File: CityResources.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class CityResources : IDisposable
{
	[NonSerialized]
	private Dictionary<string, CityStorageSlot> _resources = new Dictionary<string, CityStorageSlot>();

	[NonSerialized]
	private List<CityStorageSlot> _list_food = new List<CityStorageSlot>();

	[NonSerialized]
	private List<CityStorageSlot> _list_other = new List<CityStorageSlot>();

	public List<CityStorageSlot> saved_resources;

	public void loadFromSave()
	{
		if (saved_resources == null)
		{
			return;
		}
		foreach (CityStorageSlot saved_resource in saved_resources)
		{
			if (AssetManager.resources.get(saved_resource.id) != null && saved_resource.amount >= 0)
			{
				saved_resource.create(saved_resource.id);
				putToDict(saved_resource);
			}
		}
	}

	public int get(string pRes)
	{
		if (_resources.TryGetValue(pRes, out var value))
		{
			return value.amount;
		}
		return 0;
	}

	public int change(string pRes, int pAmount = 1)
	{
		int num = 0;
		if (DebugConfig.isOn(DebugOption.CityInfiniteResources))
		{
			pAmount = 999;
		}
		if (_resources.TryGetValue(pRes, out var value))
		{
			value.amount += pAmount;
			if (value.amount > value.asset.maximum)
			{
				value.amount = value.asset.maximum;
			}
			return value.amount;
		}
		return addNew(pRes, pAmount);
	}

	private int addNew(string pResID, int pAmount)
	{
		CityStorageSlot cityStorageSlot = new CityStorageSlot(pResID);
		cityStorageSlot.amount = pAmount;
		putToDict(cityStorageSlot);
		return cityStorageSlot.amount;
	}

	public bool hasSpaceForResource(ResourceAsset pAsset)
	{
		if (get(pAsset.id) < pAsset.storage_max)
		{
			return true;
		}
		return false;
	}

	public bool hasResourcesForNewItems()
	{
		foreach (ResourceAsset strategic_resource_asset in AssetManager.resources.strategic_resource_assets)
		{
			if (get(strategic_resource_asset.id) > 10)
			{
				return true;
			}
		}
		return false;
	}

	public void set(string pRes, int pAmount)
	{
		if (_resources.TryGetValue(pRes, out var value))
		{
			value.amount = pAmount;
		}
		else
		{
			addNew(pRes, pAmount);
		}
	}

	private void putToDict(CityStorageSlot pRes)
	{
		if (!_resources.ContainsKey(pRes.id))
		{
			_resources.Add(pRes.id, pRes);
			if (pRes.asset.food)
			{
				_list_food.Add(pRes);
			}
			else
			{
				_list_other.Add(pRes);
			}
		}
	}

	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies, string pSpecificFood = null)
	{
		if (_list_food.Count == 0)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(pSpecificFood) && get(pSpecificFood) > 0)
		{
			return AssetManager.resources.get(pSpecificFood);
		}
		HashSet<string> allowedFoodByDiet = pSubspecies.getAllowedFoodByDiet();
		ResourceAsset availableFoodAsset = getAvailableFoodAsset(_list_food, allowedFoodByDiet, pSort: true);
		if (availableFoodAsset == null)
		{
			availableFoodAsset = getAvailableFoodAsset(_list_other, allowedFoodByDiet, pSort: false);
		}
		return availableFoodAsset;
	}

	private ResourceAsset getAvailableFoodAsset(List<CityStorageSlot> pList, HashSet<string> pAllowedFood, bool pSort)
	{
		if (pSort)
		{
			pList.Sort(foodSorter);
		}
		for (int i = 0; i < pList.Count; i++)
		{
			CityStorageSlot cityStorageSlot = pList[i];
			if (cityStorageSlot.amount != 0 && pAllowedFood.Contains(cityStorageSlot.id))
			{
				return cityStorageSlot.asset;
			}
		}
		return null;
	}

	public int foodSorter(CityStorageSlot o1, CityStorageSlot o2)
	{
		return o2.amount.CompareTo(o1.amount);
	}

	public int countFood()
	{
		int num = 0;
		foreach (CityStorageSlot item in _list_food)
		{
			num += item.amount;
		}
		return num;
	}

	public ResourceAsset getRandomFoodAsset()
	{
		if (_list_food.Count == 0)
		{
			return null;
		}
		return _list_food.GetRandom().asset;
	}

	public void save()
	{
		saved_resources = new List<CityStorageSlot>();
		foreach (CityStorageSlot slot in getSlots())
		{
			if (slot.amount != 0)
			{
				saved_resources.Add(slot);
			}
		}
	}

	public IEnumerable<string> getKeys()
	{
		return _resources.Keys;
	}

	public IEnumerable<CityStorageSlot> getSlots()
	{
		return _resources.Values;
	}

	public void Dispose()
	{
		_resources.Clear();
		_list_food.Clear();
		_list_other.Clear();
		saved_resources?.Clear();
	}
}
// --- End of File: CityResources.cs ---



// --- Start of File: CitySelectedMetaBanners.cs ---
public class CitySelectedMetaBanners : CityMetaBanners, ISelectedTabBanners<City>
{
	public void update(City pCity)
	{
		meta_object = pCity;
		clear();
		foreach (MetaBannerElement banner in banners)
		{
			if (banner.check())
			{
				metaBannerShow(banner);
			}
		}
	}

	protected override void OnEnable()
	{
	}

	public int countVisibleBanners()
	{
		return visible_banners;
	}
}
// --- End of File: CitySelectedMetaBanners.cs ---



// --- Start of File: CitySelectedResources.cs ---
public class CitySelectedResources : UICityResources
{
	public void update(City pCity)
	{
		meta_object = pCity;
		showResources();
	}

	protected override void OnEnable()
	{
	}

	protected override void onListChange()
	{
		if (base.city != null)
		{
			base.onListChange();
		}
	}
}
// --- End of File: CitySelectedResources.cs ---



// --- Start of File: CitySortableElement.cs ---
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class CitySortableElement : CityElement, ILayoutController
{
	private RectTransform _rect;

	private List<RectTransform> _rect_children = new List<RectTransform>();

	protected override void Awake()
	{
		_rect = ((Component)this).GetComponent<RectTransform>();
		base.Awake();
	}

	protected virtual void onListChange()
	{
	}

	public void SetLayoutVertical()
	{
		if ((Object)(object)_rect == (Object)null)
		{
			return;
		}
		using ListPool<RectTransform> listPool = _rect.getLayoutChildren();
		if (!listPool.SequenceEqual(_rect_children))
		{
			_rect_children.Clear();
			_rect_children.AddRange(listPool);
			onListChange();
		}
	}

	public void SetLayoutHorizontal()
	{
	}
}
// --- End of File: CitySortableElement.cs ---



// --- Start of File: CityStatsElement.cs ---
using System.Collections;
using UnityEngine;

public class CityStatsElement : CityElement, IStatsElement, IRefreshElement
{
	[SerializeField]
	private CityLoyaltyElement _loyalty_element;

	private StatsIconContainer _stats_icons;

	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	{
		_stats_icons.setIconValue(pName, pMainVal, pMax, pColor, pFloat, pEnding, pSeparator);
	}

	protected override void Awake()
	{
		_stats_icons = ((Component)this).gameObject.AddOrGetComponent<StatsIconContainer>();
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.city != null && base.city.isAlive())
		{
			int populationPeople = base.city.getPopulationPeople();
			int num = base.city.countFoodTotal();
			_stats_icons.showGeneralIcons<City, CityData>(base.city);
			if (populationPeople > base.city.getPopulationMaximum())
			{
				setIconValue("i_population", populationPeople, base.city.getPopulationMaximum(), "#FB2C21");
			}
			else
			{
				setIconValue("i_population", populationPeople, base.city.getPopulationMaximum());
			}
			setIconValue("i_territory", base.city.countZones());
			setIconValue("i_boats", base.city.countBoats());
			CityStatsElement cityStatsElement = this;
			float pMainVal = num;
			string pColor = ((num > populationPeople * 4) ? "#43FF43" : "#FB2C21");
			cityStatsElement.setIconValue("i_food", pMainVal, null, pColor);
			setIconValue("i_farmers", base.city.jobs.countOccupied(CitizenJobLibrary.farmer));
			setIconValue("i_books", base.city.countBooks());
			int loyalty = base.city.getLoyalty(pForceRecalc: true);
			if (loyalty > 0)
			{
				setIconValue("i_loyalty", loyalty, null, "#43FF43");
			}
			else
			{
				setIconValue("i_loyalty", loyalty, null, "#FB2C21");
			}
			_loyalty_element.setCity(base.city);
			if (WorldLawLibrary.world_law_civ_army.isEnabled())
			{
				setIconValue("i_army", base.city.countWarriors(), base.city.getMaxWarriors());
			}
			else
			{
				setIconValue("i_army", base.city.countWarriors());
			}
			setIconValue("i_houses", base.city.getHouseCurrent(), base.city.getHouseLimit());
		}
		yield break;
	}

	GameObject IStatsElement.get_gameObject()
	{
		return ((Component)this).gameObject;
	}
}
// --- End of File: CityStatsElement.cs ---



// --- Start of File: CityStatus.cs ---
public class CityStatus
{
	public int population_adults;

	public int population_children;

	public int population;

	public int housing_total;

	public int housing_free;

	public int housing_occupied;

	public int houses_max;

	public int warrior_slots;

	public int warriors_current;

	public int hungry;

	public int maximum_items;

	public int sick;

	public int homeless;

	public int housed;

	public int males;

	public int females;

	public int families;

	public void clear()
	{
		population_adults = 0;
		population_children = 0;
		population = 0;
		housing_total = 0;
		housing_free = 0;
		housing_occupied = 0;
		houses_max = 0;
		warrior_slots = 0;
		warriors_current = 0;
		hungry = 0;
		maximum_items = 0;
		sick = 0;
		homeless = 0;
		housed = 0;
		males = 0;
		females = 0;
		families = 0;
	}
}
// --- End of File: CityStatus.cs ---



// --- Start of File: CityStorageSlot.cs ---
using System;
using Newtonsoft.Json;

[Serializable]
public class CityStorageSlot
{
	public string id;

	public int amount;

	[JsonIgnore]
	public ResourceAsset asset => AssetManager.resources.get(id);

	public CityStorageSlot(string pID)
	{
		create(pID);
	}

	public void create(string pID)
	{
		id = pID;
	}
}
// --- End of File: CityStorageSlot.cs ---



// --- Start of File: CityTasksData.cs ---
using System;

[Serializable]
public class CityTasksData
{
	public int trees;

	public int minerals;

	public int bushes;

	public int plants;

	public int hives;

	public int farm_fields;

	public int farms_total;

	public int wheats;

	public int ruins;

	public int poops;

	public int roads;

	public int fire;

	public void clear()
	{
		trees = 0;
		minerals = 0;
		bushes = 0;
		plants = 0;
		hives = 0;
		ruins = 0;
		poops = 0;
		farm_fields = 0;
		roads = 0;
		wheats = 0;
		fire = 0;
		farms_total = 0;
	}
}
// --- End of File: CityTasksData.cs ---



// --- Start of File: CityWindow.cs ---
using System.Collections.Generic;
using UnityEngine.UI;

public class CityWindow : WindowMetaGeneric<City, CityData>, IBooksWindow
{
	public Image raceTopIcon1;

	public Image raceTopIcon2;

	public LocalizedText village_title;

	public override MetaType meta_type => MetaType.City;

	protected override City meta_object => SelectedMetas.selected_city;

	public List<long> getBooks()
	{
		return meta_object.getBooks();
	}

	protected override void showTopPartInformation()
	{
		base.showTopPartInformation();
		City city = meta_object;
		if (city != null)
		{
			raceTopIcon1.sprite = city.getSpriteIcon();
			raceTopIcon2.sprite = city.getSpriteIcon();
		}
	}

	public override void startShowingWindow()
	{
		base.startShowingWindow();
		AchievementLibrary.checkCityAchievements(meta_object);
	}

	private void tryShowPastRulers()
	{
		List<LeaderEntry> past_rulers = meta_object.data.past_rulers;
		if (past_rulers != null && past_rulers.Count > 1)
		{
			showStatRow("past_leaders", meta_object.data.past_rulers.Count, MetaType.None, -1L, "iconVillages", "past_rulers", getTooltipPastRulers);
		}
	}

	private TooltipData getTooltipPastRulers()
	{
		return new TooltipData
		{
			tip_name = "past_leaders",
			meta_type = MetaType.City,
			past_rulers = new ListPool<LeaderEntry>(meta_object.data.past_rulers)
		};
	}

	protected override bool onNameChange(string pInput)
	{
		if (!base.onNameChange(pInput))
		{
			return false;
		}
		foreach (Religion religion in World.world.religions)
		{
			if (!religion.isRekt() && religion.data.creator_city_id == meta_object.getID())
			{
				religion.data.creator_city_name = meta_object.data.name;
			}
		}
		foreach (Culture culture in World.world.cultures)
		{
			if (!culture.isRekt() && culture.data.creator_city_id == meta_object.getID())
			{
				culture.data.creator_city_name = meta_object.data.name;
			}
		}
		foreach (Clan clan in World.world.clans)
		{
			if (!clan.isRekt() && clan.data.founder_city_id == meta_object.getID())
			{
				clan.data.founder_city_name = meta_object.data.name;
			}
		}
		foreach (Language language in World.world.languages)
		{
			if (!language.isRekt() && language.data.creator_city_id == meta_object.getID())
			{
				language.data.creator_city_name = meta_object.data.name;
			}
		}
		foreach (Family family in World.world.families)
		{
			if (!family.isRekt() && family.data.founder_city_id == meta_object.getID())
			{
				family.data.founder_city_name = meta_object.data.name;
			}
		}
		foreach (Book book in World.world.books)
		{
			if (!book.isRekt() && book.data.author_city_id == meta_object.getID())
			{
				book.data.author_city_name = meta_object.data.name;
			}
		}
		return true;
	}

	internal override void showStatsRows()
	{
		City city = meta_object;
		if (city != null)
		{
			if (city.kingdom.isNeutral())
			{
				village_title.setKeyAndUpdate("village_dying");
			}
			else
			{
				village_title.setKeyAndUpdate("village");
			}
			tryShowPastNames();
			showStatRow("founded", city.getFoundedDate(), MetaType.None, -1L, "iconAge");
			tryToShowActor("founder", city.data.founder_id, city.data.founder_name, null, "actor_traits/iconStupid");
			tryShowPastRulers();
			tryToShowActor("village_statistics_leader", -1L, null, city.leader, "iconLeaders");
			if (city.hasLeader())
			{
				showStatRow("ruler_money", city.leader.money, "#43FF43", MetaType.None, -1L, pColorText: false, "iconMoney");
			}
			string pValue = city.kingdom.getTaxRateLocal().ToString("0%");
			showStatRow("tax", pValue, "#43FF43", MetaType.None, -1L, pColorText: false, "kingdom_traits/kingdom_trait_tax_rate_local_low");
			string pValue2 = city.kingdom.getTaxRateTribute().ToString("0%");
			showStatRow("tribute", pValue2, "#43FF43", MetaType.None, -1L, pColorText: false, "kingdom_traits/kingdom_trait_tax_rate_tribute_high");
			tryToShowActor("king", -1L, null, city.kingdom.king, "iconKings");
			tryToShowMetaSpecies("founder_species", city.getFounderSpecies()?.id);
		}
	}

	public override void showMetaRows()
	{
		City city = meta_object;
		if (city != null && !city.kingdom.isNeutral())
		{
			meta_rows_container.tryToShowMetaClan("clan", -1L, null, city.leader?.clan);
			meta_rows_container.tryToShowMetaKingdom("kingdom", -1L, null, city.kingdom);
			meta_rows_container.tryToShowMetaAlliance("alliance", -1L, null, city.kingdom.getAlliance());
			meta_rows_container.tryToShowMetaCulture("culture", -1L, null, city.culture);
			meta_rows_container.tryToShowMetaLanguage("language", -1L, null, city.language);
			meta_rows_container.tryToShowMetaReligion("religion", -1L, null, city.religion);
			meta_rows_container.tryToShowMetaSubspecies("main_subspecies", -1L, null, city.getMainSubspecies());
			meta_rows_container.tryToShowMetaArmy("army", -1L, null, city.army);
		}
	}

	public void clickTestItemProduction()
	{
		ItemCrafting.tryToCraftRandomWeapon(meta_object.units.GetRandom(), meta_object);
		scroll_window.tabs.showTab(scroll_window.tabs.getActiveTab());
	}

	public void clickTestClearItems()
	{
		meta_object.data.equipment.clearItems();
		scroll_window.tabs.showTab(scroll_window.tabs.getActiveTab());
	}

	public void clickTestNewBook()
	{
		if (meta_object.hasLeader() && meta_object.leader.hasCulture() && meta_object.leader.hasLanguage())
		{
			World.world.books.generateNewBook(meta_object.leader);
			meta_object.forceDoChecks();
			scroll_window.tabs.showTab(scroll_window.tabs.getActiveTab());
		}
	}
}
// --- End of File: CityWindow.cs ---



// --- Start of File: CityZoneAbandon.cs ---
using System.Collections.Generic;

public class CityZoneAbandon : CityZoneWorkerBase
{
	private List<ListPool<TileZone>> _split_areas = new List<ListPool<TileZone>>();

	private HashSetTileZone _zones_to_check = new HashSetTileZone();

	public void checkCities()
	{
		foreach (City city in World.world.cities)
		{
			city.checkAbandon();
		}
	}

	public void check(City pCity, bool pDebug = false, HashSet<TileZone> pSetToFill = null)
	{
		if (pCity.buildings.Count == 0)
		{
			return;
		}
		clearAll();
		prepareCityZones(pCity);
		startCheckingFromBuildings(pCity);
		_split_areas.Sort(sorter);
		if (pDebug)
		{
			return;
		}
		abandonLeftoverZones(pCity);
		if (_split_areas.Count >= 2)
		{
			_split_areas[0].Dispose();
			_split_areas.RemoveAt(0);
			if (_split_areas.Count > 0)
			{
				abandonSmallAreas(pCity);
			}
		}
	}

	private void startCheckingFromBuildings(City pCity)
	{
		for (int i = 0; i < pCity.buildings.Count; i++)
		{
			Building building = pCity.buildings[i];
			WorldTile current_tile = building.current_tile;
			if (!building.asset.docks)
			{
				startWaveFromTile(current_tile, pCity);
			}
		}
	}

	private void startWaveFromTile(WorldTile pTile, City pCity)
	{
		if (!_zones_to_check.Contains(pTile.zone))
		{
			return;
		}
		prepareWave();
		Queue<ZoneConnection> queue = _wave;
		Queue<ZoneConnection> queue2 = _next_wave;
		ListPool<TileZone> listPool = new ListPool<TileZone>(_wave.Count + _next_wave.Count);
		_split_areas.Add(listPool);
		queueConnection(new ZoneConnection(pTile.zone, pTile.region), queue, pCheck: true);
		using ListPool<MapRegion> listPool2 = new ListPool<MapRegion>();
		int num = 0;
		while (queue2.Count > 0 || queue.Count > 0)
		{
			if (queue.Count == 0)
			{
				Queue<ZoneConnection> queue3 = queue;
				queue = queue2;
				queue2 = queue3;
				num++;
			}
			ZoneConnection zoneConnection = queue.Dequeue();
			TileZone zone = zoneConnection.zone;
			MapRegion region = zoneConnection.region;
			if (zone.isSameCityHere(pCity))
			{
				listPool.Add(zone);
			}
			TileZone[] neighbours = zone.neighbours;
			foreach (TileZone tileZone in neighbours)
			{
				if (!tileZone.isSameCityHere(pCity) || tileZone.tiles_with_ground == 0)
				{
					continue;
				}
				listPool2.Clear();
				if (!TileZone.hasZonesConnectedViaRegions(zone, tileZone, region, listPool2))
				{
					continue;
				}
				for (int j = 0; j < listPool2.Count; j++)
				{
					MapRegion pRegion = listPool2[j];
					ZoneConnection zoneConnection2 = new ZoneConnection(tileZone, pRegion);
					if (_zones_checked.Add(zoneConnection2))
					{
						queueConnection(zoneConnection2, queue2);
					}
				}
			}
		}
	}

	private void abandonLeftoverZones(City pCity)
	{
		if (_zones_to_check.Count == 0)
		{
			return;
		}
		foreach (TileZone item in _zones_to_check)
		{
			pCity.removeZone(item);
		}
	}

	private void abandonSmallAreas(City pCity)
	{
		for (int i = 0; i < _split_areas.Count; i++)
		{
			ListPool<TileZone> listPool = _split_areas[i];
			for (int j = 0; j < listPool.Count; j++)
			{
				TileZone pZone = listPool[j];
				pCity.removeZone(pZone);
			}
		}
	}

	private void prepareCityZones(City pCity)
	{
		_zones_to_check.UnionWith(pCity.zones);
	}

	internal override void clearAll()
	{
		base.clearAll();
		foreach (ListPool<TileZone> split_area in _split_areas)
		{
			split_area.Dispose();
		}
		_split_areas.Clear();
		_zones_to_check.Clear();
	}

	private static int sorter(ListPool<TileZone> pList1, ListPool<TileZone> pList2)
	{
		return pList2.Count.CompareTo(pList1.Count);
	}

	protected override void queueConnection(ZoneConnection pConnection, Queue<ZoneConnection> pWave, bool pCheck = false)
	{
		base.queueConnection(pConnection, pWave, pCheck);
		_zones_to_check.Remove(pConnection.zone);
	}
}
// --- End of File: CityZoneAbandon.cs ---



// --- Start of File: CityZoneGrowth.cs ---
using System.Collections.Generic;

public class CityZoneGrowth : CityZoneWorkerBase
{
	private const float MOD_RADIUS = 0.75f;

	public TileZone getZoneToClaim(Actor pActor, City pCity, bool pDebug = false, HashSet<TileZone> pSetToFill = null, int pBonusRange = 0)
	{
		clearAll();
		WorldTile tile = pCity.getTile();
		if (tile == null)
		{
			return null;
		}
		bool pStopWaveWhenEmptyZoneFound = !pDebug;
		startWaveFromTile(pActor, tile, pCity, pStopWaveWhenEmptyZoneFound, pBonusRange);
		if (pDebug && pSetToFill != null)
		{
			foreach (ZoneConnection item in _zones_checked)
			{
				pSetToFill.Add(item.zone);
			}
			return null;
		}
		return checkGrowBorder(pCity);
	}

	private TileZone checkGrowBorder(City pCity)
	{
		bool num = Randy.randomChance(0.7f);
		TileZone result = null;
		if (num)
		{
			TileZone randomZone = getRandomZone(pCity);
			if (randomZone != null)
			{
				result = randomZone;
			}
		}
		else
		{
			result = getRandomCheckedZone(pCity);
		}
		return result;
	}

	private TileZone getRandomZone(City pCity)
	{
		using ListPool<TileZone> list = new ListPool<TileZone>(pCity.border_zones);
		WorldTile tile = pCity.getTile();
		if (tile == null)
		{
			return null;
		}
		TileZone zone = tile.zone;
		float num = (float)pCity.getZoneRange() * 0.75f;
		num *= num;
		foreach (TileZone item in list.LoopRandom())
		{
			foreach (TileZone item2 in item.neighbours.LoopRandom())
			{
				if (item2.canBeClaimedByCity(pCity) && item2.centerTile.isSameIsland(tile) && !((float)Toolbox.SquaredDist(zone.x, zone.y, item2.x, item2.y) > num))
				{
					return item2;
				}
			}
		}
		return null;
	}

	private TileZone getBestZoneFromList(City pCity, List<TileZone> pList)
	{
		TileZone result = null;
		TileZone zone = pCity.getTile().zone;
		int num = int.MaxValue;
		for (int i = 0; i < pList.Count; i++)
		{
			TileZone tileZone = pList[i];
			int num2 = Toolbox.SquaredDist(tileZone.x, tileZone.y, zone.x, zone.y);
			if (num2 < num)
			{
				result = tileZone;
				num = num2;
			}
		}
		return result;
	}

	private TileZone getRandomCheckedZone(City pCity)
	{
		using ListPool<TileZone> listPool = new ListPool<TileZone>(_zones_checked.Count);
		foreach (ZoneConnection item in _zones_checked)
		{
			TileZone zone = item.zone;
			if (zone.canBeClaimedByCity(pCity))
			{
				listPool.Add(zone);
			}
		}
		if (listPool.Count > 0)
		{
			return listPool.GetRandom();
		}
		return null;
	}

	private void startWaveFromTile(Actor pActor, WorldTile pTile, City pCity, bool pStopWaveWhenEmptyZoneFound = true, int pBonusRange = 0)
	{
		prepareWave();
		if (pActor == null)
		{
			pActor = pCity.leader;
		}
		Queue<ZoneConnection> queue = _wave;
		Queue<ZoneConnection> queue2 = _next_wave;
		queueConnection(new ZoneConnection(pTile.zone, pTile.region), queue, pSetChecked: true);
		using ListPool<MapRegion> listPool = new ListPool<MapRegion>();
		int num = pCity.getZoneRange() + pBonusRange;
		float num2 = (float)num * 0.75f;
		num2 *= num2;
		int num3 = 0;
		bool flag = false;
		while ((queue2.Count > 0 || queue.Count > 0) && !(pStopWaveWhenEmptyZoneFound && flag))
		{
			if (queue.Count == 0)
			{
				Queue<ZoneConnection> queue3 = queue;
				queue = queue2;
				queue2 = queue3;
				num3++;
				if (num3 > num)
				{
					break;
				}
			}
			ZoneConnection zoneConnection = queue.Dequeue();
			TileZone zone = zoneConnection.zone;
			MapRegion region = zoneConnection.region;
			for (int i = 0; i < zone.neighbours.Length; i++)
			{
				TileZone tileZone = zone.neighbours[i];
				if ((pStopWaveWhenEmptyZoneFound && tileZone.hasCity() && !tileZone.isSameCityHere(pCity)) || tileZone.tiles_with_ground == 0 || (pActor != null && pActor.hasSubspecies() && !tileZone.checkCanSettleInThisBiomes(pActor.subspecies)))
				{
					continue;
				}
				listPool.Clear();
				if (!TileZone.hasZonesConnectedViaRegions(zone, tileZone, region, listPool))
				{
					continue;
				}
				for (int j = 0; j < listPool.Count; j++)
				{
					MapRegion pRegion = listPool[j];
					ZoneConnection zoneConnection2 = new ZoneConnection(tileZone, pRegion);
					if (!_zones_checked.Add(zoneConnection2))
					{
						continue;
					}
					if (tileZone.canBeClaimedByCity(pCity))
					{
						flag = true;
					}
					if (!((float)Toolbox.SquaredDist(pTile.zone.x, pTile.zone.y, tileZone.x, tileZone.y) > num2))
					{
						if (pStopWaveWhenEmptyZoneFound && flag)
						{
							break;
						}
						queueConnection(zoneConnection2, queue2);
					}
				}
			}
		}
	}
}
// --- End of File: CityZoneGrowth.cs ---



// --- Start of File: CityZoneHelper.cs ---
public class CityZoneHelper
{
	public CityZoneGrowth city_growth;

	public CityZoneAbandon city_abandon;

	public CityPlaceFinder city_place_finder;

	public CityZoneHelper()
	{
		city_growth = new CityZoneGrowth();
		city_abandon = new CityZoneAbandon();
		city_place_finder = new CityPlaceFinder();
	}

	public void update(float pElapsed)
	{
		city_abandon.checkCities();
	}

	public void clear()
	{
		city_abandon.clearAll();
		city_growth.clearAll();
		city_place_finder.clearAll();
	}
}
// --- End of File: CityZoneHelper.cs ---



// --- Start of File: CityZoneWorkerBase.cs ---
using System.Collections.Generic;

public abstract class CityZoneWorkerBase
{
	protected bool debug;

	protected Queue<ZoneConnection> _wave = new Queue<ZoneConnection>();

	protected Queue<ZoneConnection> _next_wave = new Queue<ZoneConnection>();

	protected HashSet<ZoneConnection> _zones_checked = new HashSet<ZoneConnection>();

	protected void prepareWave()
	{
		_wave.Clear();
		_next_wave.Clear();
	}

	internal virtual void clearAll()
	{
		_zones_checked.Clear();
		_wave.Clear();
		_next_wave.Clear();
		checkZoneDebug();
	}

	protected virtual void queueConnection(ZoneConnection pConnection, Queue<ZoneConnection> pWave, bool pSetChecked = false)
	{
		pWave.Enqueue(pConnection);
		if (pSetChecked)
		{
			_zones_checked.Add(pConnection);
		}
	}

	protected void checkZoneDebug()
	{
		if (debug)
		{
			World.world.zone_calculator.clearDebug();
		}
	}
}
// --- End of File: CityZoneWorkerBase.cs ---



// --- Start of File: Clan.cs ---
using System.Collections.Generic;
using UnityEngine;
using db;

public class Clan : MetaObjectWithTraits<ClanData, ClanTrait>
{
	public BaseStats base_stats_male = new BaseStats();

	public BaseStats base_stats_female = new BaseStats();

	protected override MetaType meta_type => MetaType.Clan;

	protected override bool track_death_types => true;

	public override BaseSystemManager manager => World.world.clans;

	protected override AssetLibrary<ClanTrait> trait_library => AssetManager.clan_traits;

	protected override List<string> default_traits => getActorAsset().default_clan_traits;

	protected override List<string> saved_traits => data.saved_traits;

	protected override string species_id => data.original_actor_asset;

	public void newClan(Actor pFounder, bool pAddDefaultTraits)
	{
		data.original_actor_asset = pFounder.asset.id;
		generateNewMetaObject(pAddDefaultTraits);
		if (pFounder.kingdom.isCiv())
		{
			data.founder_kingdom_name = pFounder.kingdom.data.name;
			data.founder_kingdom_id = pFounder.kingdom.getID();
		}
		data.founder_actor_name = pFounder.getName();
		data.founder_actor_id = pFounder.getID();
		data.founder_city_name = pFounder.city?.name;
		data.founder_city_id = pFounder.city?.getID() ?? (-1);
		data.creator_subspecies_name = pFounder.subspecies.name;
		data.creator_subspecies_id = pFounder.subspecies.getID();
		data.creator_species_id = pFounder.asset.id;
		string pName = pFounder.generateName(MetaType.Clan, getID());
		data.name_culture_id = pFounder.culture?.getID() ?? (-1);
		setName(pName);
	}

	protected override void recalcBaseStats()
	{
		base.recalcBaseStats();
		base_stats_female.clear();
		base_stats_male.clear();
		foreach (ClanTrait trait in getTraits())
		{
			base_stats_male.mergeStats(trait.base_stats_male);
			base_stats_female.mergeStats(trait.base_stats_female);
		}
	}

	public override void increaseBirths()
	{
		base.increaseBirths();
		addRenown(1);
	}

	protected sealed override void setDefaultValues()
	{
		base.setDefaultValues();
	}

	public override void listUnit(Actor pActor)
	{
		base.listUnit(pActor);
	}

	protected override ColorLibrary getColorLibrary()
	{
		return AssetManager.clan_colors_library;
	}

	public override void generateBanner()
	{
		data.banner_background_id = AssetManager.clan_banners_library.getNewIndexBackground();
		data.banner_icon_id = AssetManager.clan_banners_library.getNewIndexIcon();
	}

	public string getMotto()
	{
		if (string.IsNullOrEmpty(data.motto))
		{
			data.motto = NameGenerator.getName("clan_mottos");
		}
		return data.motto;
	}

	public override void save()
	{
		base.save();
		data.saved_traits = getTraitsAsStrings();
	}

	public void checkMembersForNewChief()
	{
		if (base.units.Count != 0 && getChief().isRekt())
		{
			setChief(null);
			Actor nextChief = getNextChief();
			if (nextChief != null)
			{
				setChief(nextChief);
			}
		}
	}

	public void setChief(Actor pActor)
	{
		if (data != null)
		{
			if (pActor.isRekt())
			{
				data.chief_id = -1L;
				chiefLeft();
			}
			else
			{
				data.chief_id = pActor.getID();
				addChief(pActor);
			}
		}
	}

	public void updateChiefs()
	{
		if (data.past_chiefs == null || data.past_chiefs.Count == 0)
		{
			return;
		}
		foreach (LeaderEntry past_chief in data.past_chiefs)
		{
			Actor actor = World.world.units.get(past_chief.id);
			if (!actor.isRekt())
			{
				past_chief.name = actor.name;
			}
		}
	}

	public void addChief(Actor pActor)
	{
		ClanData clanData = data;
		if (clanData.past_chiefs == null)
		{
			clanData.past_chiefs = new List<LeaderEntry>();
		}
		chiefLeft();
		data.past_chiefs.Add(new LeaderEntry
		{
			id = pActor.getID(),
			name = pActor.name,
			color_id = data.color_id,
			timestamp_ago = World.world.getCurWorldTime()
		});
		if (data.past_chiefs.Count > 30)
		{
			data.past_chiefs.Shift();
		}
	}

	public void chiefLeft()
	{
		if (data.past_chiefs != null && data.past_chiefs.Count != 0)
		{
			LeaderEntry leaderEntry = data.past_chiefs.Last();
			if (!(leaderEntry.timestamp_end >= leaderEntry.timestamp_ago))
			{
				leaderEntry.timestamp_end = World.world.getCurWorldTime();
				updateChiefs();
			}
		}
	}

	public void tryForgetChief(Actor pActor)
	{
		if (data.chief_id == pActor.getID())
		{
			setChief(null);
		}
	}

	public Culture getClanCulture()
	{
		Culture culture = getChiefCulture();
		if (culture == null && data.culture_id.hasValue())
		{
			culture = World.world.cultures.get(data.culture_id);
		}
		if (culture == null)
		{
			data.culture_id = -1L;
		}
		else
		{
			data.culture_id = culture.getID();
		}
		return culture;
	}

	private Culture getChiefCulture()
	{
		return getChief()?.culture;
	}

	public Actor getNextChief(Actor pIgnore = null)
	{
		if (isDirtyUnits())
		{
			return null;
		}
		using ListPool<Actor> listPool = new ListPool<Actor>(base.units);
		ListSorters.sortUnitsSortedByAgeAndTraits(listPool, getClanCulture());
		Actor result = null;
		Actor chief = getChief();
		foreach (ref Actor item in listPool)
		{
			Actor current = item;
			if (current != pIgnore && current.isAlive() && chief != current)
			{
				result = current;
				break;
			}
		}
		return result;
	}

	public int getMaxMembers()
	{
		return (int)base_stats_meta["limit_clan_members"];
	}

	public Actor getChief()
	{
		Actor result = null;
		if (data.chief_id.hasValue())
		{
			result = World.world.units.get(data.chief_id);
		}
		return result;
	}

	public bool hasChief()
	{
		return getChief() != null;
	}

	public bool isFull()
	{
		int maxMembers = getMaxMembers();
		if (maxMembers == 0)
		{
			return false;
		}
		return base.units.Count >= maxMembers;
	}

	public bool fitToRule(Actor pActor, Kingdom pKingdom)
	{
		if (pActor.kingdom != pKingdom)
		{
			return false;
		}
		if (!pActor.isUnitFitToRule())
		{
			return false;
		}
		if (pActor.isKing())
		{
			return false;
		}
		return true;
	}

	public Sprite getBackgroundSprite()
	{
		return AssetManager.clan_banners_library.getSpriteBackground(data.banner_background_id);
	}

	public Sprite getIconSprite()
	{
		return AssetManager.clan_banners_library.getSpriteIcon(data.banner_icon_id);
	}

	public override void Dispose()
	{
		DBInserter.deleteData(getID(), "clan");
		base.Dispose();
	}

	public string getTextMaxMembers()
	{
		int maxMembers = getMaxMembers();
		if (maxMembers == 0)
		{
			return base.units.Count.ToString();
		}
		return $"{base.units.Count}/{maxMembers}";
	}

	public override bool hasCities()
	{
		foreach (City city in World.world.cities)
		{
			if (city.getRoyalClan() == this)
			{
				return true;
			}
		}
		return false;
	}

	public override IEnumerable<City> getCities()
	{
		foreach (City city in World.world.cities)
		{
			if (city.getRoyalClan() == this)
			{
				yield return city;
			}
		}
	}

	public override bool hasKingdoms()
	{
		foreach (Kingdom kingdom in World.world.kingdoms)
		{
			if (kingdom.getKingClan() == this)
			{
				return true;
			}
		}
		return false;
	}

	public override IEnumerable<Kingdom> getKingdoms()
	{
		foreach (Kingdom kingdom in World.world.kingdoms)
		{
			if (kingdom.getKingClan() == this)
			{
				yield return kingdom;
			}
		}
	}
}
// --- End of File: Clan.cs ---



// --- Start of File: ClanBanner.cs ---
using UnityEngine.UI;

public class ClanBanner : BannerGeneric<Clan, ClanData>
{
	protected override MetaType meta_type => MetaType.Clan;

	protected override string tooltip_id => "clan";

	protected override TooltipData getTooltipData()
	{
		TooltipData tooltipData = base.getTooltipData();
		tooltipData.clan = meta_object;
		return tooltipData;
	}

	protected override void setupBanner()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.setupBanner();
		part_background.sprite = meta_object.getBackgroundSprite();
		part_icon.sprite = meta_object.getIconSprite();
		ColorAsset colorAsset = meta_object.getColor();
		((Graphic)part_background).color = colorAsset.getColorMainSecond();
		((Graphic)part_icon).color = colorAsset.getColorBanner();
	}
}
// --- End of File: ClanBanner.cs ---



// --- Start of File: ClanBannerLibrary.cs ---
using System.Collections.Generic;

public class ClanBannerLibrary : GenericBannerLibrary
{
	public override void init()
	{
		base.init();
		main = add(new BannerAsset
		{
			id = "main",
			backgrounds = new List<string>
			{
				"clans/clan_background_00", "clans/clan_background_01", "clans/clan_background_02", "clans/clan_background_03", "clans/clan_background_04", "clans/clan_background_05", "clans/clan_background_06", "clans/clan_background_07", "clans/clan_background_08", "clans/clan_background_09",
				"clans/clan_background_10", "clans/clan_background_11", "clans/clan_background_12", "clans/clan_background_13", "clans/clan_background_14", "clans/clan_background_15", "clans/clan_background_16"
			},
			icons = new List<string>
			{
				"clans/clan_icon_00", "clans/clan_icon_01", "clans/clan_icon_02", "clans/clan_icon_03", "clans/clan_icon_04", "clans/clan_icon_05", "clans/clan_icon_06", "clans/clan_icon_07", "clans/clan_icon_08", "clans/clan_icon_09",
				"clans/clan_icon_10", "clans/clan_icon_11", "clans/clan_icon_12", "clans/clan_icon_13", "clans/clan_icon_14", "clans/clan_icon_15", "clans/clan_icon_16", "clans/clan_icon_17", "clans/clan_icon_18", "clans/clan_icon_19",
				"clans/clan_icon_20", "clans/clan_icon_21"
			}
		});
	}
}
// --- End of File: ClanBannerLibrary.cs ---



// --- Start of File: ClanChiefElement.cs ---
using System.Collections;
using UnityEngine;

public class ClanChiefElement : ClanElement
{
	[SerializeField]
	private GameObject _title_element;

	[SerializeField]
	private PrefabUnitElement _chief_element;

	protected override IEnumerator showContent()
	{
		if (base.clan.hasChief())
		{
			track_objects.Add(base.clan.getChief());
			_title_element.SetActive(true);
			((Component)_chief_element).gameObject.SetActive(true);
			_chief_element.show(base.clan.getChief());
		}
		yield break;
	}

	protected override void clear()
	{
		_title_element.SetActive(false);
		((Component)_chief_element).gameObject.SetActive(false);
		base.clear();
	}

	public override bool checkRefreshWindow()
	{
		if (((Component)_chief_element).gameObject.activeSelf && !base.clan.hasChief())
		{
			return true;
		}
		return base.checkRefreshWindow();
	}
}
// --- End of File: ClanChiefElement.cs ---



// --- Start of File: ClanColorsLibrary.cs ---
public class ClanColorsLibrary : ColorLibrary
{
	public ClanColorsLibrary()
	{
		file_path = "colors/colors_general";
	}

	public override void init()
	{
		base.init();
		useSameColorsFrom(AssetManager.kingdom_colors_library);
	}

	public override bool isColorUsedInWorld(ColorAsset pAsset)
	{
		foreach (Clan clan in World.world.clans)
		{
			if (checkColor(pAsset, clan.data.color_id))
			{
				return true;
			}
		}
		return base.isColorUsedInWorld(pAsset);
	}
}
// --- End of File: ClanColorsLibrary.cs ---



// --- Start of File: ClanCustomizeWindow.cs ---
public class ClanCustomizeWindow : GenericCustomizeWindow<Clan, ClanData, ClanBanner>
{
	protected override MetaType meta_type => MetaType.Clan;

	protected override Clan meta_object => SelectedMetas.selected_clan;

	protected override void onBannerChange()
	{
		image_banner_option_1.sprite = meta_object.getBackgroundSprite();
		image_banner_option_2.sprite = meta_object.getIconSprite();
	}
}
// --- End of File: ClanCustomizeWindow.cs ---



// --- Start of File: ClanData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine.Scripting;

[Serializable]
public class ClanData : MetaObjectData
{
	public string motto;

	[DefaultValue(-1L)]
	public long chief_id = -1L;

	[DefaultValue(-1L)]
	public long culture_id = -1L;

	public List<LeaderEntry> past_chiefs;

	public List<string> saved_traits;

	public int books_written;

	public int banner_background_id;

	public int banner_icon_id;

	public string founder_actor_name;

	[DefaultValue(-1L)]
	public long founder_actor_id = -1L;

	public string founder_kingdom_name;

	[DefaultValue(-1L)]
	public long founder_kingdom_id = -1L;

	public string founder_city_name;

	[DefaultValue(-1L)]
	public long founder_city_id = -1L;

	public string creator_species_id = string.Empty;

	public string creator_subspecies_name = string.Empty;

	[DefaultValue(-1L)]
	public long creator_subspecies_id = -1L;

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string original_actor_asset { get; set; }

	[Preserve]
	[Obsolete("use .original_actor_asset instead", true)]
	public string race_id
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(original_actor_asset))
			{
				original_actor_asset = value;
			}
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		saved_traits?.Clear();
		saved_traits = null;
		past_chiefs?.Clear();
		past_chiefs = null;
	}
}
// --- End of File: ClanData.cs ---



// --- Start of File: ClanElement.cs ---
public class ClanElement : WindowMetaElement<Clan, ClanData>
{
	protected Clan clan => meta_object;
}
// --- End of File: ClanElement.cs ---



// --- Start of File: ClanListComponent.cs ---
public class ClanListComponent : ComponentListBase<ClanListElement, Clan, ClanData, ClanListComponent>
{
	protected override MetaType meta_type => MetaType.Clan;

	protected override void setupSortingTabs()
	{
		genericMetaSortByAge(base.sortByAge);
		genericMetaSortByRenown(base.sortByRenown);
		genericMetaSortByPopulation(ComponentListBase<ClanListElement, Clan, ClanData, ClanListComponent>.sortByPopulation);
		genericMetaSortByKills(ComponentListBase<ClanListElement, Clan, ClanData, ClanListComponent>.sortByKills);
		genericMetaSortByDeath(ComponentListBase<ClanListElement, Clan, ClanData, ClanListComponent>.sortByDeaths);
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
		{
			current_sort = sortByKingdom;
		});
	}

	private static int sortByKingdom(Clan p1, Clan p2)
	{
		Actor chief = p1.getChief();
		return p2.getChief().kingdom.CompareTo(chief.kingdom);
	}
}
// --- End of File: ClanListComponent.cs ---



// --- Start of File: ClanListElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ClanListElement : WindowListElementBase<Clan, ClanData>
{
	public Text text_name;

	public CountUpOnClick members;

	public CountUpOnClick dead;

	public CountUpOnClick age;

	public CountUpOnClick renown;

	public UiUnitAvatarElement avatarLoader;

	internal override void show(Clan pClan)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.show(pClan);
		Actor chief = pClan.getChief();
		if (chief.isRekt())
		{
			((Component)avatarLoader).gameObject.SetActive(false);
		}
		else
		{
			((Component)avatarLoader).gameObject.SetActive(true);
			avatarLoader.show(chief);
		}
		text_name.text = pClan.name;
		((Graphic)text_name).color = pClan.getColor().getColorText();
		members.setValue(pClan.countUnits());
		renown.setValue(pClan.getRenown());
		int pValue = pClan.getAge();
		age.setValue(pValue);
		dead.setValue((int)pClan.getTotalDeaths());
	}

	protected override void tooltipAction()
	{
		Tooltip.show(this, "clan", new TooltipData
		{
			clan = meta_object
		});
	}

	protected override ActorAsset getActorAsset()
	{
		return meta_object.getActorAsset();
	}
}
// --- End of File: ClanListElement.cs ---



// --- Start of File: ClanManager.cs ---
using System.Collections.Generic;

public class ClanManager : MetaSystemManager<Clan, ClanData>
{
	public ClanManager()
	{
		type_id = "clan";
	}

	public Clan newClan(Actor pFounder, bool pAddDefaultTraits)
	{
		World.world.game_stats.data.clansCreated++;
		World.world.map_stats.clansCreated++;
		Clan clan = newObject();
		clan.newClan(pFounder, pAddDefaultTraits);
		MetaHelper.addRandomTrait(clan, AssetManager.clan_traits);
		pFounder.setClan(clan);
		if (pFounder.isKing())
		{
			pFounder.kingdom.trySetRoyalClan();
		}
		convertFamilyToClan(pFounder, clan);
		addRandomTraitFromBiomeToClan(clan, pFounder.current_tile);
		return clan;
	}

	private void convertFamilyToClan(Actor pFounder, Clan pNewClan)
	{
		if (!pFounder.hasFamily())
		{
			return;
		}
		foreach (Actor child in pFounder.getChildren())
		{
			if (!child.hasClan())
			{
				child.setClan(pNewClan);
			}
		}
	}

	public override void removeObject(Clan pClan)
	{
		foreach (Kingdom item in World.world.kingdoms.list)
		{
			if (item.data.royal_clan_id == pClan.getID() && pClan.getRenown() >= 10)
			{
				item.logRoyalClanLost(pClan);
			}
		}
		World.world.game_stats.data.clansDestroyed++;
		World.world.map_stats.clansDestroyed++;
		base.removeObject(pClan);
	}

	public void addRandomTraitFromBiomeToClan(Clan pClan, WorldTile pTile)
	{
		pClan.addRandomTraitFromBiome(pTile, pTile.Type.biome_asset?.spawn_trait_clan, AssetManager.clan_traits);
	}

	public override void update(float pElapsed)
	{
		base.update(pElapsed);
		foreach (Clan item in list)
		{
			if (!item.hasChief())
			{
				item.checkMembersForNewChief();
			}
		}
	}

	protected override void updateDirtyUnits()
	{
		List<Actor> units_only_alive = World.world.units.units_only_alive;
		for (int i = 0; i < units_only_alive.Count; i++)
		{
			Actor actor = units_only_alive[i];
			Clan clan = actor.clan;
			if (clan != null && clan.isDirtyUnits())
			{
				clan.listUnit(actor);
			}
		}
	}
}
// --- End of File: ClanManager.cs ---



// --- Start of File: ClanMembersContainer.cs ---
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class ClanMembersContainer : ClanElement
{
	private ObjectPoolGenericMono<PrefabUnitElement> _pool_members;

	[SerializeField]
	private RectTransform _list_members;

	[SerializeField]
	private LocalizedText _title_members;

	[SerializeField]
	private PrefabUnitElement _prefab;

	[SerializeField]
	private Text _members_counter;

	protected override void Awake()
	{
		_pool_members = new ObjectPoolGenericMono<PrefabUnitElement>(_prefab, (Transform)(object)_list_members);
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.clan.units.Count == 0)
		{
			yield break;
		}
		Actor chief = base.clan.getChief();
		using ListPool<Actor> _clan_members = new ListPool<Actor>(base.clan.units);
		track_objects.AddRange(_clan_members);
		_clan_members.Remove(chief);
		if (_clan_members.Count == 0)
		{
			yield break;
		}
		((Component)_title_members).gameObject.SetActive(true);
		((Component)_list_members).gameObject.SetActive(true);
		_members_counter.text = base.clan.getTextMaxMembers();
		Actor chief2 = base.clan.getChief();
		if (chief2 == null || !chief2.hasCulture())
		{
			_clan_members.Sort(ListSorters.sortUnitByAgeOldFirst);
		}
		else
		{
			ListSorters.sortUnitsSortedByAgeAndTraits(_clan_members, base.clan.getClanCulture());
		}
		foreach (ref Actor item in _clan_members)
		{
			Actor tActor = item;
			yield return (object)new WaitForSecondsRealtime(0.025f);
			showMember(tActor);
		}
	}

	private void showMember(Actor pActor)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		PrefabUnitElement next = _pool_members.getNext();
		((Component)next).transform.localScale = new Vector3(0.9f, 0.9f, 1f);
		next.show(pActor);
	}

	protected override void clear()
	{
		((Component)_title_members).gameObject.SetActive(false);
		((Component)_list_members).gameObject.SetActive(false);
		_pool_members.clear();
		base.clear();
	}
}
// --- End of File: ClanMembersContainer.cs ---



// --- Start of File: ClanSelectedContainerTraits.cs ---
using System.Collections.Generic;

public class ClanSelectedContainerTraits : SelectedContainerTraits<ClanTrait, ClanTraitButton, ClanTraitsContainer, ClanTraitsEditor>
{
	protected override MetaType meta_type => MetaType.Clan;

	protected override IReadOnlyCollection<ClanTrait> getTraits()
	{
		return SelectedMetas.selected_clan.getTraits();
	}

	protected override bool canEditTraits()
	{
		return true;
	}
}
// --- End of File: ClanSelectedContainerTraits.cs ---



// --- Start of File: ClanStatsElement.cs ---
using System.Collections;
using UnityEngine;

public class ClanStatsElement : ClanElement, IStatsElement, IRefreshElement
{
	private StatsIconContainer _stats_icons;

	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	{
		_stats_icons.setIconValue(pName, pMainVal, pMax, pColor, pFloat, pEnding, pSeparator);
	}

	protected override void Awake()
	{
		_stats_icons = ((Component)this).gameObject.AddOrGetComponent<StatsIconContainer>();
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.clan != null && base.clan.isAlive())
		{
			_stats_icons.showGeneralIcons<Clan, ClanData>(base.clan);
			setIconValue("i_books_written", base.clan.data.books_written);
		}
		yield break;
	}

	GameObject IStatsElement.get_gameObject()
	{
		return ((Component)this).gameObject;
	}
}
// --- End of File: ClanStatsElement.cs ---



// --- Start of File: ClanTrait.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class ClanTrait : BaseTrait<ClanTrait>
{
	public BaseStats base_stats_male = new BaseStats();

	public BaseStats base_stats_female = new BaseStats();

	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_clan;

	public override string typed_id => "clan_trait";

	protected override IEnumerable<ITraitsOwner<ClanTrait>> getRelatedMetaList()
	{
		return World.world.clans;
	}

	public override BaseCategoryAsset getGroup()
	{
		return AssetManager.clan_trait_groups.get(group_id);
	}
}
// --- End of File: ClanTrait.cs ---



// --- Start of File: ClanTraitButton.cs ---
public class ClanTraitButton : TraitButton<ClanTrait>
{
	protected override string tooltip_type => "clan_trait";

	internal override void load(string pTraitID)
	{
		ClanTrait pElement = AssetManager.clan_traits.get(pTraitID);
		load(pElement);
	}

	protected override void startSignal()
	{
		AchievementLibrary.trait_explorer_clan.checkBySignal();
	}

	protected override TooltipData tooltipDataBuilder()
	{
		return new TooltipData
		{
			clan_trait = augmentation_asset
		};
	}
}
// --- End of File: ClanTraitButton.cs ---



// --- Start of File: ClanTraitEditorButton.cs ---
public class ClanTraitEditorButton : TraitEditorButton<ClanTraitButton, ClanTrait>
{
}
// --- End of File: ClanTraitEditorButton.cs ---



// --- Start of File: ClanTraitGroupAsset.cs ---
using System;

[Serializable]
public class ClanTraitGroupAsset : BaseTraitGroupAsset
{
}
// --- End of File: ClanTraitGroupAsset.cs ---



// --- Start of File: ClanTraitGroupElement.cs ---
public class ClanTraitGroupElement : TraitGroupElement<ClanTrait, ClanTraitButton, ClanTraitEditorButton>
{
}
// --- End of File: ClanTraitGroupElement.cs ---



// --- Start of File: ClanTraitGroupLibrary.cs ---
public class ClanTraitGroupLibrary : BaseCategoryLibrary<ClanTraitGroupAsset>
{
	public override void init()
	{
		base.init();
		add(new ClanTraitGroupAsset
		{
			id = "spirit",
			name = "trait_group_spirit",
			color = "#BAFFC2"
		});
		add(new ClanTraitGroupAsset
		{
			id = "mind",
			name = "trait_group_mind",
			color = "#BAF0F4"
		});
		add(new ClanTraitGroupAsset
		{
			id = "body",
			name = "trait_group_body",
			color = "#FF6B86"
		});
		add(new ClanTraitGroupAsset
		{
			id = "chaos",
			name = "trait_group_chaos",
			color = "#FF6A00"
		});
		add(new ClanTraitGroupAsset
		{
			id = "harmony",
			name = "trait_group_harmony",
			color = "#DD96FF"
		});
		add(new ClanTraitGroupAsset
		{
			id = "fate",
			name = "trait_group_fate",
			color = "#ffd82f"
		});
		add(new ClanTraitGroupAsset
		{
			id = "special",
			name = "trait_group_special",
			color = "#FF8F44"
		});
	}
}
// --- End of File: ClanTraitGroupLibrary.cs ---



// --- Start of File: ClanTraitLibrary.cs ---
using System;
using System.Collections.Generic;

public class ClanTraitLibrary : BaseTraitLibrary<ClanTrait>
{
	protected override string icon_path => "ui/Icons/clan_traits/";

	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	{
		return pAsset.default_clan_traits;
	}

	public override void init()
	{
		base.init();
		add(new ClanTrait
		{
			id = "mark_of_becoming",
			group_id = "special",
			can_be_given = false,
			can_be_removed = false,
			spawn_random_trait_allowed = false
		});
		add(new ClanTrait
		{
			id = "blood_pact",
			group_id = "spirit"
		});
		t.base_stats["warfare"] = 1f;
		t.addDecision("banish_unruly_clan_members");
		t.addOpposite("deathbound");
		add(new ClanTrait
		{
			id = "deathbound",
			group_id = "spirit"
		});
		t.base_stats["warfare"] = 5f;
		t.addDecision("kill_unruly_clan_members");
		t.addOpposite("blood_pact");
		add(new ClanTrait
		{
			id = "bonebreakers",
			group_id = "body"
		});
		t.setUnlockedWithAchievement("achievementSegregator");
		t.base_stats["damage"] = 5f;
		ClanTrait clanTrait = t;
		clanTrait.action_attack_target = (AttackAction)Delegate.Combine(clanTrait.action_attack_target, new AttackAction(ActionLibrary.breakBones));
		add(new ClanTrait
		{
			id = "stonefists",
			group_id = "body"
		});
		t.base_stats["damage"] = 30f;
		add(new ClanTrait
		{
			id = "blood_of_sea",
			group_id = "body"
		});
		t.base_stats["stamina"] = 20f;
		t.base_stats.addTag("fast_swimming");
		add(new ClanTrait
		{
			id = "gaia_shield",
			group_id = "body"
		});
		t.base_stats["armor"] = 10f;
		t.base_stats["multiplier_health"] = 0.1f;
		t.base_stats.addTag("immunity_fire");
		t.base_stats.addTag("immunity_cold");
		add(new ClanTrait
		{
			id = "iron_will",
			group_id = "mind"
		});
		t.base_stats["intelligence"] = 5f;
		t.base_stats.addTag("strong_mind");
		add(new ClanTrait
		{
			id = "flesh_weavers",
			group_id = "body",
			special_effect_interval = 2f
		});
		t.base_stats["multiplier_health"] = 0.2f;
		ClanTrait clanTrait2 = t;
		clanTrait2.action_special_effect = (WorldAction)Delegate.Combine(clanTrait2.action_special_effect, new WorldAction(ActionLibrary.regenerationEffectClan));
		add(new ClanTrait
		{
			id = "endurance_of_titans",
			group_id = "body"
		});
		t.base_stats["multiplier_stamina"] = 3f;
		add(new ClanTrait
		{
			id = "combat_instincts",
			group_id = "mind"
		});
		t.setUnlockedWithAchievement("achievementMasterOfCombat");
		t.base_stats["warfare"] = 10f;
		t.addCombatAction("combat_dash");
		t.addCombatAction("combat_block");
		t.addCombatAction("combat_dodge");
		t.addCombatAction("combat_backstep");
		t.addCombatAction("combat_deflect_projectile");
		add(new ClanTrait
		{
			id = "void_ban",
			group_id = "chaos",
			spawn_random_trait_allowed = false
		});
		t.base_stats["multiplier_mana"] = -10f;
		add(new ClanTrait
		{
			id = "warlocks_vein",
			group_id = "spirit"
		});
		t.base_stats_male["multiplier_mana"] = 2f;
		add(new ClanTrait
		{
			id = "witchs_vein",
			group_id = "spirit"
		});
		t.base_stats_female["multiplier_mana"] = 2f;
		add(new ClanTrait
		{
			id = "magic_blood",
			group_id = "spirit"
		});
		t.setUnlockedWithAchievement("achievementTheAccomplished");
		t.base_stats["multiplier_mana"] = 3f;
		add(new ClanTrait
		{
			id = "blood_of_eons",
			group_id = "body",
			spawn_random_trait_allowed = false
		});
		t.addOpposite("cursed_blood");
		t.base_stats["lifespan"] = 1E+09f;
		add(new ClanTrait
		{
			id = "blood_of_giants",
			group_id = "body"
		});
		t.base_stats["scale"] = 0.05f;
		add(new ClanTrait
		{
			id = "silver_tongues",
			group_id = "mind"
		});
		t.base_stats["opinion"] = 20f;
		t.base_stats["diplomacy"] = 5f;
		add(new ClanTrait
		{
			id = "masters_of_propaganda",
			group_id = "mind"
		});
		t.base_stats["loyalty_traits"] = 20f;
		add(new ClanTrait
		{
			id = "gods_chosen",
			group_id = "spirit"
		});
		t.base_stats["stewardship"] = 10f;
		t.base_stats["diplomacy"] = 5f;
		t.base_stats["armor"] = 20f;
		add(new ClanTrait
		{
			id = "cursed_blood",
			group_id = "chaos",
			spawn_random_trait_allowed = false
		});
		t.setUnlockedWithAchievement("achievementTheBroken");
		t.base_stats["lifespan"] = -666f;
		t.addOpposite("blood_of_eons");
		add(new ClanTrait
		{
			id = "divine_dozen",
			group_id = "harmony"
		});
		t.addOpposite("we_are_legion");
		t.addOpposite("best_five");
		t.base_stats_meta["limit_clan_members"] = 12f;
		add(new ClanTrait
		{
			id = "best_five",
			group_id = "harmony"
		});
		t.addOpposite("we_are_legion");
		t.addOpposite("divine_dozen");
		t.base_stats_meta["limit_clan_members"] = 5f;
		add(new ClanTrait
		{
			id = "we_are_legion",
			group_id = "harmony"
		});
		t.setUnlockedWithAchievement("achievementMegapolis");
		t.addOpposite("best_five");
		t.addOpposite("divine_dozen");
		t.base_stats_meta["limit_clan_members"] = 1000f;
		add(new ClanTrait
		{
			id = "nitroglycerin_blood",
			group_id = "chaos",
			action_death = delegate(BaseSimObject _, WorldTile pTile)
			{
				DropsLibrary.action_grenade(pTile);
				return true;
			}
		});
		t.setUnlockedWithAchievement("achievementMinefield");
		t.base_stats["health"] = -1f;
		add(new ClanTrait
		{
			id = "antimatter_blood",
			group_id = "chaos",
			spawn_random_trait_allowed = false,
			action_death = delegate(BaseSimObject _, WorldTile pTile)
			{
				DropsLibrary.action_antimatter_bomb(pTile);
				return true;
			}
		});
		t.setUnlockedWithAchievement("achievementTraitExplorerClan");
		t.base_stats["damage"] = 1f;
		add(new ClanTrait
		{
			id = "gaia_blood",
			group_id = "spirit",
			action_death = delegate(BaseSimObject _, WorldTile pTile)
			{
				if (!WorldLawLibrary.world_law_clouds.isEnabled())
				{
					return false;
				}
				if (Randy.randomChance(0.3f))
				{
					EffectsLibrary.spawn("fx_cloud", pTile, "cloud_normal");
				}
				return true;
			}
		});
		t.setUnlockedWithAchievement("achievementThePrincess");
		t.base_stats["multiplier_health"] = 0.05f;
		add(new ClanTrait
		{
			id = "grin_mark",
			group_id = "fate",
			spawn_random_trait_allowed = false,
			priority = -100
		});
		t.setTraitInfoToGrinMark();
		t.setUnlockedWithAchievement("achievementCreaturesExplorer");
		add(new ClanTrait
		{
			id = "geb",
			group_id = "special",
			can_be_given = false,
			can_be_removed = false,
			spawn_random_trait_allowed = false
		});
	}
}
// --- End of File: ClanTraitLibrary.cs ---



// --- Start of File: ClanTraitsContainer.cs ---
public class ClanTraitsContainer : TraitsContainer<ClanTrait, ClanTraitButton>
{
}
// --- End of File: ClanTraitsContainer.cs ---



// --- Start of File: ClanTraitsEditor.cs ---
using System.Collections.Generic;

public class ClanTraitsEditor : TraitsEditor<ClanTrait, ClanTraitButton, ClanTraitEditorButton, ClanTraitGroupAsset, ClanTraitGroupElement>
{
	protected override MetaType meta_type => MetaType.Clan;

	protected override List<ClanTraitGroupAsset> augmentation_groups_list => AssetManager.clan_trait_groups.list;

	protected override List<ClanTrait> all_augmentations_list => AssetManager.clan_traits.list;

	protected override ClanTrait edited_marker_augmentation => AssetManager.clan_traits.get("geb");

	protected override void startSignal()
	{
		AchievementLibrary.trait_explorer_clan.checkBySignal();
	}
}
// --- End of File: ClanTraitsEditor.cs ---



// --- Start of File: ClanWindow.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ClanWindow : WindowMetaGeneric<Clan, ClanData>, ITraitWindow<ClanTrait, ClanTraitButton>, IAugmentationsWindow<ITraitsEditor<ClanTrait>>
{
	public NameInput nameInput;

	public NameInput mottoInput;

	public override MetaType meta_type => MetaType.Clan;

	protected override Clan meta_object => SelectedMetas.selected_clan;

	protected override void initNameInput()
	{
		base.initNameInput();
		mottoInput.addListener(applyInputMotto);
	}

	protected override bool onNameChange(string pInput)
	{
		if (!base.onNameChange(pInput))
		{
			return false;
		}
		long iD = meta_object.getID();
		string name = meta_object.data.name;
		foreach (Culture culture in World.world.cultures)
		{
			if (!culture.isRekt() && culture.data.creator_clan_id == iD)
			{
				culture.data.creator_clan_name = name;
			}
		}
		foreach (Religion religion in World.world.religions)
		{
			if (!religion.isRekt() && religion.data.creator_clan_id == iD)
			{
				religion.data.creator_clan_name = name;
			}
		}
		foreach (Language language in World.world.languages)
		{
			if (!language.isRekt() && language.data.creator_clan_id == iD)
			{
				language.data.creator_clan_name = name;
			}
		}
		foreach (Book book in World.world.books)
		{
			if (!book.isRekt() && book.data.author_clan_id == iD)
			{
				book.data.author_clan_name = name;
			}
		}
		return true;
	}

	private void applyInputMotto(string pInput)
	{
		if (pInput != null && meta_object != null)
		{
			meta_object.data.motto = pInput;
		}
	}

	protected override void showTopPartInformation()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		base.showTopPartInformation();
		Clan clan = meta_object;
		if (clan != null)
		{
			mottoInput.setText(clan.getMotto());
			((Graphic)mottoInput.textField).color = clan.getColor().getColorText();
		}
	}

	internal override void showStatsRows()
	{
		Clan clan = meta_object;
		tryShowPastNames();
		showStatRow("founded", clan.getFoundedDate(), MetaType.None, -1L, "iconAge");
		tryToShowActor("clan_founder", clan.data.founder_actor_id, clan.data.founder_actor_name, null, "actor_traits/iconStupid");
		tryToShowActor("clan_chief_title", -1L, null, clan.getChief(), "iconClan");
		tryShowPastChiefs();
		Actor nextChief = clan.getNextChief();
		tryToShowActor("clan_heir", -1L, null, nextChief, "iconClanList");
		tryToShowMetaCulture("culture", -1L, null, clan.getClanCulture());
		tryToShowMetaKingdom("origin", clan.data.founder_kingdom_id, clan.data.founder_kingdom_name);
		tryToShowMetaCity("birthplace", clan.data.founder_city_id, clan.data.founder_city_name);
		tryToShowMetaSubspecies("original_subspecies", clan.data.creator_subspecies_id, clan.data.creator_subspecies_name);
		tryToShowMetaSpecies("species", clan.data.creator_species_id);
	}

	private void tryShowPastChiefs()
	{
		List<LeaderEntry> past_chiefs = meta_object.data.past_chiefs;
		if (past_chiefs != null && past_chiefs.Count > 1)
		{
			showStatRow("past_chiefs", meta_object.data.past_chiefs.Count, MetaType.None, -1L, "iconCaptain", "past_rulers", getTooltipPastChiefs);
		}
	}

	private TooltipData getTooltipPastChiefs()
	{
		return new TooltipData
		{
			tip_name = "past_chiefs",
			meta_type = MetaType.Clan,
			past_rulers = new ListPool<LeaderEntry>(meta_object.data.past_chiefs)
		};
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		mottoInput.inputField.DeactivateInputField();
	}

	public void debugClearExpLevel()
	{
		OnEnable();
	}

	T IAugmentationsWindow<ITraitsEditor<ClanTrait>>.GetComponentInChildren<T>(bool includeInactive)
	{
		return ((Component)this).GetComponentInChildren<T>(includeInactive);
	}
}
// --- End of File: ClanWindow.cs ---



// --- Start of File: ClickActionCallerAttribute.cs ---
using System;

[AttributeUsage(AttributeTargets.Method)]
public class ClickActionCallerAttribute : Attribute
{
}
// --- End of File: ClickActionCallerAttribute.cs ---



// --- Start of File: ClickPowerActionCallerAttribute.cs ---
using System;

[AttributeUsage(AttributeTargets.Method)]
public class ClickPowerActionCallerAttribute : Attribute
{
}
// --- End of File: ClickPowerActionCallerAttribute.cs ---



// --- Start of File: ClickQuitTheGame.cs ---
using UnityEngine;
using db;

public class ClickQuitTheGame : MonoBehaviour
{
	public void clickQuit()
	{
		DBManager.clearAndClose();
		Application.Quit();
	}
}
// --- End of File: ClickQuitTheGame.cs ---



// --- Start of File: Cloud.cs ---
using UnityEngine;

public class Cloud : BaseEffect
{
	public CloudAsset asset;

	private float speed = 1f;

	public SpriteShadow spriteShadow;

	private float _timer_action_1;

	private float _timer_action_2;

	internal float alive_time;

	private float _fade_multiplier = 0.2f;

	internal float effect_texture_width;

	internal float effect_texture_height;

	private float _lifespan;

	internal override void create()
	{
		base.create();
	}

	internal override void prepare()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		sprite_renderer.sprite = Randy.getRandom(asset.cached_sprites);
		sprite_renderer.flipX = Randy.randomBool();
		speed = Randy.randomFloat(asset.speed_min, asset.speed_max);
		Rect rect = sprite_renderer.sprite.rect;
		effect_texture_width = ((Rect)(ref rect)).width * 0.08f;
		rect = sprite_renderer.sprite.rect;
		effect_texture_height = ((Rect)(ref rect)).height * 0.04f;
		_timer_action_1 = asset.interval_action_1;
		_lifespan = 0f;
		alive_time = 0f;
		base.prepare();
		setAlpha(0f);
	}

	public void setLifespan(float pLifespan)
	{
		_lifespan = pLifespan;
	}

	internal void setType(CloudAsset pAsset)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		asset = pAsset;
		sprite_renderer.color = asset.color;
	}

	internal void setType(string pType)
	{
		CloudAsset cloudAsset = AssetManager.clouds.get(pType);
		if (cloudAsset != null)
		{
			setType(cloudAsset);
		}
	}

	public void spawn(WorldTile pTile, string pType)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (pTile == null)
		{
			setType(pType);
			prepare();
		}
		else
		{
			prepare(pTile.posV3, pType);
		}
	}

	internal void prepare(Vector3 pVec, string pType)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		setType(pType);
		prepare();
		pVec.y -= spriteShadow.offset.y;
		((Component)this).transform.localPosition = pVec;
	}

	internal override void prepare(WorldTile pTile, float pScale = 0.5f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		prepare();
		((Component)this).transform.localPosition = new Vector3(pTile.posV3.x, pTile.posV3.y);
	}

	public override void update(float pElapsed)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		alive_time += pElapsed;
		if (Config.time_scale_asset.sonic)
		{
			_fade_multiplier = 0.05f;
		}
		else
		{
			_fade_multiplier = 0.2f;
		}
		if (asset.draw_light_area)
		{
			Vector2 position = Vector2.op_Implicit(((Component)this).transform.localPosition);
			position.x += asset.draw_light_area_offset_x;
			position.y += asset.draw_light_area_offset_y;
			World.world.stack_effects.light_blobs.Add(new LightBlobData
			{
				position = position,
				radius = asset.draw_light_size
			});
		}
		if (!World.world.isPaused())
		{
			((Component)this).transform.Translate(speed * pElapsed, 0f, 0f);
			if (asset.cloud_action_1 != null)
			{
				if (_timer_action_1 > 0f)
				{
					_timer_action_1 -= pElapsed;
				}
				else
				{
					_timer_action_1 = asset.interval_action_1;
					asset.cloud_action_1(this);
				}
			}
			if (asset.cloud_action_2 != null)
			{
				if (_timer_action_2 > 0f)
				{
					_timer_action_2 -= pElapsed;
				}
				else
				{
					_timer_action_2 = asset.interval_action_2;
					asset.cloud_action_2(this);
				}
			}
		}
		if (((Component)this).transform.localPosition.x > (float)MapBox.width || (_lifespan > 0f && alive_time > _lifespan))
		{
			startToDie();
		}
		float num = asset.max_alpha;
		if ((Object)(object)World.world.camera != (Object)null && World.world.camera.orthographicSize > 0f)
		{
			num *= World.world.camera.orthographicSize / 100f;
			if (num > asset.max_alpha)
			{
				num = asset.max_alpha;
			}
		}
		switch (state)
		{
		case 1:
			if (alpha < num)
			{
				alpha += pElapsed * _fade_multiplier;
				if (alpha >= num)
				{
					alpha = num;
				}
			}
			else if (alpha > num)
			{
				alpha -= pElapsed * _fade_multiplier;
				if (alpha <= num)
				{
					alpha = num;
				}
			}
			else
			{
				alpha = num;
			}
			setAlpha(alpha);
			break;
		case 2:
			if (alpha > 0f)
			{
				alpha -= pElapsed * _fade_multiplier;
				setAlpha(alpha);
			}
			else
			{
				alpha = 0f;
				controller.killObject(this);
			}
			break;
		}
	}
}
// --- End of File: Cloud.cs ---



// --- Start of File: CloudAction.cs ---
using System;

[Serializable]
public delegate void CloudAction(Cloud pCloud);
// --- End of File: CloudAction.cs ---



// --- Start of File: CloudAsset.cs ---
using System;
using UnityEngine;

[Serializable]
public class CloudAsset : Asset
{
	public bool normal_cloud;

	[NonSerialized]
	public Color color;

	public string color_hex = "#FFFFFF";

	public float max_alpha = 0.8f;

	public CloudAction cloud_action_1;

	public CloudAction cloud_action_2;

	public float interval_action_1 = 0.05f;

	public float interval_action_2 = 0.05f;

	public float speed_min = 1f;

	public float speed_max = 6f;

	public string drop_id = string.Empty;

	public string[] path_sprites;

	[NonSerialized]
	internal Sprite[] cached_sprites;

	public bool draw_light_area;

	public float draw_light_area_offset_x;

	public float draw_light_area_offset_y;

	public float draw_light_size = 4f;

	public bool considered_disaster;
}
// --- End of File: CloudAsset.cs ---



// --- Start of File: CloudLibrary.cs ---
using UnityEngine;

public class CloudLibrary : AssetLibrary<CloudAsset>
{
	private static string[] _sprites_small = new string[2] { "effects/clouds/cloud_small_1", "effects/clouds/cloud_small_2" };

	private static string[] _sprites_big = new string[3] { "effects/clouds/cloud_big_1", "effects/clouds/cloud_big_2", "effects/clouds/cloud_big_3" };

	private static string[] _sprites_all = new string[5] { "effects/clouds/cloud_small_1", "effects/clouds/cloud_small_2", "effects/clouds/cloud_big_1", "effects/clouds/cloud_big_2", "effects/clouds/cloud_big_3" };

	public override void init()
	{
		base.init();
		add(new CloudAsset
		{
			id = "cloud_rain",
			color_hex = "#5D728C",
			drop_id = "rain",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			speed_max = 4f
		});
		add(new CloudAsset
		{
			id = "cloud_rage",
			color_hex = "#FF3030",
			drop_id = "rage",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			speed_max = 4f,
			considered_disaster = true,
			draw_light_area = true
		});
		add(new CloudAsset
		{
			id = "cloud_lightning",
			color_hex = "#445366",
			drop_id = "rain",
			cloud_action_1 = dropAction,
			cloud_action_2 = spawnLightning,
			path_sprites = _sprites_big,
			speed_max = 4f,
			considered_disaster = true
		});
		add(new CloudAsset
		{
			id = "cloud_acid",
			color_hex = "#17D41C",
			drop_id = "acid",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			speed_max = 4f,
			considered_disaster = true
		});
		add(new CloudAsset
		{
			id = "cloud_lava",
			color_hex = "#D17119",
			drop_id = "lava",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			speed_max = 3f,
			considered_disaster = true,
			draw_light_area = true
		});
		add(new CloudAsset
		{
			id = "cloud_fire",
			color_hex = "#D14219",
			drop_id = "fire",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			speed_max = 3f,
			considered_disaster = true,
			draw_light_area = true
		});
		add(new CloudAsset
		{
			id = "cloud_snow",
			color_hex = "#B8FFFA",
			drop_id = "snow",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			considered_disaster = true,
			speed_max = 4f
		});
		add(new CloudAsset
		{
			id = "cloud_ash",
			color_hex = "#C6B077",
			drop_id = "ash",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_big,
			considered_disaster = true,
			speed_max = 4f
		});
		add(new CloudAsset
		{
			id = "cloud_magic",
			color_hex = "#C976CC",
			drop_id = "magic_rain",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_small,
			considered_disaster = true,
			speed_max = 7f,
			draw_light_area = true
		});
		add(new CloudAsset
		{
			id = "cloud_normal",
			max_alpha = 0.5f,
			interval_action_1 = 2f,
			drop_id = "life_seed",
			cloud_action_1 = dropAction,
			path_sprites = _sprites_all,
			speed_min = 2f,
			normal_cloud = true
		});
	}

	public override void linkAssets()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		base.linkAssets();
		using ListPool<Sprite> listPool = new ListPool<Sprite>();
		foreach (CloudAsset item in list)
		{
			if (item.color_hex != null)
			{
				item.color = Toolbox.makeColor(item.color_hex);
			}
			listPool.Clear();
			string[] path_sprites = item.path_sprites;
			foreach (string text in path_sprites)
			{
				Sprite sprite = SpriteTextureLoader.getSprite(text);
				if ((Object)(object)sprite == (Object)null)
				{
					BaseAssetLibrary.logAssetError("cloud sprite not found", text);
				}
				else
				{
					listPool.Add(sprite);
				}
			}
			item.cached_sprites = listPool.ToArray();
		}
	}

	public static void dropAction(Cloud pCloud)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!(pCloud.alive_time < 3f))
		{
			float effect_texture_width = pCloud.effect_texture_width;
			float effect_texture_height = pCloud.effect_texture_height;
			int num = (int)((Component)pCloud).transform.localPosition.x;
			int num2 = (int)((Component)pCloud).transform.localPosition.y;
			num += (int)Randy.randomFloat(0f - effect_texture_width, effect_texture_width);
			num2 += (int)Randy.randomFloat(0f - effect_texture_height + pCloud.spriteShadow.offset.y, effect_texture_height + pCloud.spriteShadow.offset.y);
			WorldTile tile = World.world.GetTile(num, num2);
			if (tile != null)
			{
				World.world.drop_manager.spawn(tile, pCloud.asset.drop_id, 10f, -1f, -1L);
			}
		}
	}

	public static void spawnLightning(Cloud pCloud)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!Randy.randomChance(0.01f))
		{
			return;
		}
		int num = (int)((Component)pCloud).transform.localPosition.x;
		int num2 = (int)((Component)pCloud).transform.localPosition.y;
		float effect_texture_width = pCloud.effect_texture_width;
		float effect_texture_height = pCloud.effect_texture_height;
		num += (int)Randy.randomFloat(effect_texture_width * 0.5f, effect_texture_width);
		num2 += (int)Randy.randomFloat(0f - effect_texture_height + pCloud.spriteShadow.offset.y, effect_texture_height + pCloud.spriteShadow.offset.y);
		WorldTile tile = World.world.GetTile(num, num2);
		if (tile != null)
		{
			if (Randy.randomBool())
			{
				MapBox.spawnLightningMedium(tile, 0.15f);
			}
			else
			{
				MapBox.spawnLightningSmall(tile, 0.15f);
			}
		}
	}
}
// --- End of File: CloudLibrary.cs ---



// --- Start of File: ColorArray.cs ---
using System.Collections.Generic;
using UnityEngine;

public class ColorArray
{
	public List<Color32> colors;

	public ColorArray(float pR, float pG, float pB, float pA, float pAmount, float pMod = 1f)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		colors = new List<Color32>();
		Color val = default(Color);
		for (int i = 0; (float)i < pAmount; i++)
		{
			float num = ((i <= 0) ? 0f : (1f / pAmount * (float)i));
			((Color)(ref val))._002Ector(pR, pG, pB, num * 1f * pMod);
			colors.Add(Color32.op_Implicit(val));
		}
	}

	public ColorArray(Color32 pColor, int pAmount)
		: this((int)pColor.r, (int)pColor.g, (int)pColor.b, (int)pColor.a, pAmount)
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0008: Unknown result type (might be due to invalid IL or missing references)
	//IL_000f: Unknown result type (might be due to invalid IL or missing references)
	//IL_0016: Unknown result type (might be due to invalid IL or missing references)

}
// --- End of File: ColorArray.cs ---



// --- Start of File: ColorAsset.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ColorAsset : Asset
{
	private static int _create_last_index_id = 1000;

	public int index_id;

	public string color_main;

	public string color_main_2;

	public string color_banner;

	public string color_text;

	public bool favorite;

	[NonSerialized]
	public Color32 k_color_0;

	[NonSerialized]
	public Color32 k_color_1;

	[NonSerialized]
	public Color32 k_color_2;

	[NonSerialized]
	public Color32 k_color_3;

	[NonSerialized]
	public Color32 k_color_4;

	[NonSerialized]
	public Color32 k2_color_0;

	[NonSerialized]
	public Color32 k2_color_1;

	[NonSerialized]
	public Color32 k2_color_2;

	[NonSerialized]
	public Color32 k2_color_3;

	[NonSerialized]
	public Color32 k2_color_4;

	private Color32 _color_main_32;

	private Color32 _color_main_second_32;

	private Color32 _color_unit_32;

	private Color32 _color_border_inside_alpha_32;

	private Color _color_main;

	private Color _color_main_second;

	private Color _color_text;

	private Color _color_minimap_element;

	private Color _color_border_out_capture;

	private Color _color_banner;

	private static readonly List<ColorAsset> _all_colors_list = new List<ColorAsset>();

	private static readonly Dictionary<string, ColorAsset> _all_colors_dict = new Dictionary<string, ColorAsset>();

	public const byte ALPHA_BORDER_INSIDE_BYTE = 170;

	private bool _initialized;

	private Material _material_line;

	private Material _material_gradient;

	public static List<ColorAsset> getAllColorsList()
	{
		return _all_colors_list;
	}

	public ColorAsset()
	{
	}

	public static bool isColorAssetExists(string pColorMain)
	{
		return _all_colors_dict.ContainsKey(pColorMain);
	}

	public static ColorAsset getExistingColorAsset(string pColorMain)
	{
		_all_colors_dict.TryGetValue(pColorMain, out var value);
		return value;
	}

	public static ColorAsset tryMakeNewColorAsset(string pColorMain)
	{
		_all_colors_dict.TryGetValue(pColorMain, out var value);
		if (value == null)
		{
			return new ColorAsset(pColorMain);
		}
		return value;
	}

	private ColorAsset(string pColorMain)
	{
		setMainHexColors(pColorMain, pColorMain, pColorMain);
		index_id = _create_last_index_id++;
		saveToGlobalList(this);
	}

	public static void saveToGlobalList(ColorAsset pAsset, bool pMustBeGlobal = false)
	{
		if (isColorAssetExists(pAsset.color_main))
		{
			if (pMustBeGlobal)
			{
				Debug.LogError((object)("ColorAsset with same <b>color_main</b> already exists in global list: " + pAsset.id + " " + pAsset.index_id + " " + pAsset.color_main));
			}
		}
		else
		{
			_all_colors_list.Add(pAsset);
			_all_colors_dict.Add(pAsset.color_main, pAsset);
		}
	}

	private void setMainHexColors(string pColorMain, string pColorMain2, string pColorBanner)
	{
		color_main = pColorMain;
		color_main_2 = pColorMain2;
		color_banner = pColorBanner;
		color_text = pColorMain;
	}

	public void setEditorColors(Color pMain, Color pMain2, Color pBanner, Color pText)
	{
		initColor();
	}

	public void initColor()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		if (!_initialized)
		{
			_initialized = true;
			_color_main = Toolbox.makeColor(color_main);
			_color_main_32 = Color32.op_Implicit(Toolbox.makeColor(color_main));
			_color_main_second = Toolbox.makeColor(color_main_2);
			_color_main_second_32 = Color32.op_Implicit(Toolbox.makeColor(color_main_2));
			_color_text = Toolbox.makeColor(color_text);
			_color_banner = Toolbox.makeColor(color_banner);
			Color val = Color32.op_Implicit(_color_main_32);
			_color_border_inside_alpha_32 = Color32.op_Implicit(new Color(val.r, val.g, val.b));
			_color_border_inside_alpha_32.a = 170;
			Color32 val2 = default(Color32);
			((Color32)(ref val2))._002Ector((byte)30, (byte)30, (byte)30, byte.MaxValue);
			_color_border_out_capture = new Color(_color_main_second.r, _color_main_second.g, _color_main_second.b, 0.8f);
			_color_unit_32 = Color32.op_Implicit(Color.Lerp(_color_main_second, Color.white, 0.3f));
			_color_unit_32.a = byte.MaxValue;
			k_color_0 = Color32.op_Implicit(_color_text);
			k_color_0 = checkIfColorTooDark(k_color_0);
			_color_minimap_element = Color32.op_Implicit(Color32.Lerp(k_color_0, Color32.op_Implicit(Color.white), 0.2f));
			k_color_1 = Color32.Lerp(k_color_0, val2, 0.13f);
			k_color_2 = Color32.Lerp(k_color_0, val2, 0.35000002f);
			k_color_3 = Color32.Lerp(k_color_0, val2, 0.51f);
			k_color_4 = Color32.Lerp(k_color_0, val2, 0.65999997f);
			k2_color_0 = _color_main_32;
			k2_color_0 = checkIfColorTooDark(k2_color_0);
			k2_color_1 = Color32.Lerp(k2_color_0, val2, 0.13f);
			k2_color_2 = Color32.Lerp(k2_color_0, val2, 0.35000002f);
			k2_color_3 = Color32.Lerp(k2_color_0, val2, 0.51f);
			k2_color_4 = Color32.Lerp(k2_color_0, val2, 0.65999997f);
		}
	}

	public Material getChartLineMaterial()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_material_line == (Object)null)
		{
			_material_line = cloneMaterial("materials/graph/graph_base_line");
			Color colorText = getColorText();
			_material_line.SetColor("_Color", colorText);
		}
		return _material_line;
	}

	public Material getChartInnerFillMaterial()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_material_gradient == (Object)null)
		{
			_material_gradient = cloneMaterial("materials/graph/graph_base_gradient");
			Color colorText = getColorText();
			colorText.a = 0.4f;
			Color colorText2 = getColorText();
			colorText2.a = 0.1f;
			_material_gradient.SetColor("_ColorFrom", colorText);
			_material_gradient.SetColor("_ColorTo", colorText2);
		}
		return _material_gradient;
	}

	private Material cloneMaterial(string pPath)
	{
		return Object.Instantiate<Material>(Resources.Load<Material>(pPath));
	}

	private Color32 checkIfColorTooDark(Color32 pColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (pColor.r < 128 && pColor.g < 128 && pColor.b < 128)
		{
			pColor.r += 50;
			pColor.g += 50;
			pColor.b += 50;
		}
		return pColor;
	}

	private Color32 getDarkerColor(Color32 pColor, byte pValue)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		pColor.r += pValue;
		pColor.g += pValue;
		pColor.b += pValue;
		return pColor;
	}

	public Color32 getColorUnit32()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_unit_32;
	}

	public Color32 getColorMain32()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_main_32;
	}

	public Color32 getColorBorderInsideAlpha32()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_border_inside_alpha_32;
	}

	public Color32 getColorMainSecond32()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_main_second_32;
	}

	public Color getColorMainSecond()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_main_second;
	}

	public Color getColorMain()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_main;
	}

	public Color getColorText()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_text;
	}

	public ref Color getColorTextRef()
	{
		return ref _color_text;
	}

	public Color getColorMinimapElements()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_minimap_element;
	}

	public Color getColorBorderOut_capture()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_border_out_capture;
	}

	public Color getColorBanner()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _color_banner;
	}
}
// --- End of File: ColorAsset.cs ---



// --- Start of File: ColorElement.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ColorElement : MonoBehaviour
{
	public Button button;

	public Image selection;

	public Image outer;

	public Image inner;

	public int index;

	public MetaCustomizationAsset asset;

	public void setColor(Color pOuter, Color pInner)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)outer).color = pOuter;
		((Graphic)inner).color = pInner;
	}

	public void setSelected(bool pSelected)
	{
		((Behaviour)selection).enabled = pSelected;
	}

	public void setAction(UnityAction pAction)
	{
		((UnityEvent)button.onClick).AddListener(pAction);
	}

	public void showTooltip()
	{
		CustomDataContainer<int> customDataContainer = new CustomDataContainer<int>();
		customDataContainer["color_count"] = asset.color_count();
		customDataContainer["color_current"] = index + 1;
		TooltipData pData = new TooltipData
		{
			tip_name = asset.color_locale,
			custom_data_int = customDataContainer
		};
		Tooltip.show(((Component)this).gameObject, "color_counter", pData);
	}
}
// --- End of File: ColorElement.cs ---



// --- Start of File: ColorLibrary.cs ---
using System.Collections.Generic;

public class ColorLibrary : AssetLibrary<ColorAsset>
{
	private readonly List<ColorAsset> _free_colors_main = new List<ColorAsset>();

	private readonly List<ColorAsset> _free_colors_bonus = new List<ColorAsset>();

	private readonly List<ColorAsset> _free_colors_preferred = new List<ColorAsset>();

	internal bool must_be_global;

	public override void post_init()
	{
		base.post_init();
		foreach (ColorAsset item in list)
		{
			item.initColor();
		}
	}

	public ColorAsset getColorByIndex(int pIndex)
	{
		if (pIndex >= list.Count)
		{
			return list[0];
		}
		return list[pIndex];
	}

	public ColorAsset getNextColor(ActorAsset pActorAsset)
	{
		_free_colors_bonus.Clear();
		_free_colors_main.Clear();
		_free_colors_preferred.Clear();
		for (int i = 0; i < list.Count; i++)
		{
			ColorAsset colorAsset = list[i];
			if (!isColorUsedInWorld(colorAsset))
			{
				if (pActorAsset != null && pActorAsset.preferred_colors != null && pActorAsset.preferred_colors.Contains(colorAsset.id))
				{
					_free_colors_preferred.Add(colorAsset);
				}
				if (colorAsset.favorite)
				{
					_free_colors_main.Add(colorAsset);
				}
				else
				{
					_free_colors_bonus.Add(colorAsset);
				}
			}
		}
		if (_free_colors_preferred.Count > 0)
		{
			return _free_colors_preferred.GetRandom();
		}
		if (_free_colors_main.Count > 0)
		{
			return _free_colors_main.GetRandom();
		}
		if (_free_colors_bonus.Count > 0)
		{
			return _free_colors_bonus.GetRandom();
		}
		return list.GetRandom();
	}

	public int getNextColorIndex(ActorAsset pActorAsset)
	{
		ColorAsset nextColor = getNextColor(pActorAsset);
		return list.IndexOf(nextColor);
	}

	public virtual bool isColorUsedInWorld(ColorAsset pAsset)
	{
		return false;
	}

	protected bool checkColor(ColorAsset pAsset, int pColorIndex)
	{
		if (pColorIndex == pAsset.index_id)
		{
			return true;
		}
		return false;
	}

	public override ColorAsset add(ColorAsset pAsset)
	{
		ColorAsset colorAsset = base.add(pAsset);
		ColorAsset.saveToGlobalList(colorAsset, must_be_global);
		return colorAsset;
	}

	public void useSameColorsFrom(ColorLibrary pSource)
	{
		list = pSource.list;
		dict = pSource.dict;
	}
}
// --- End of File: ColorLibrary.cs ---



// --- Start of File: ColorStyleAsset.cs ---
using System;
using UnityEngine;

[Serializable]
public class ColorStyleAsset : Asset
{
	public string taxonomy_kingdom = "#76FFF8";

	public string taxonomy_phylum = "#74FFA3";

	public string taxonomy_subphylum = "#54FF8D";

	public string taxonomy_class = "#76FF4A";

	public string taxonomy_order = "#B9FF48";

	public string taxonomy_family = "#FEFD46";

	public string taxonomy_genus = "#F8AB4F";

	public string taxonomy_common_name = "#DC8D4E";

	public string color_text_grey = "#ADADAD";

	public string color_text_grey_dark = "#7D7D7D";

	public string color_text_selector = "#7FFF75AA";

	public string color_text_selector_remove = "#FF182AAA";

	public string color_text_pumpkin = "#FFA94C";

	public string color_text_pumpkin_light = "#FFBC66";

	public Color favorite_selected = Color.white;

	public Color favorite_not_selected = new Color(0.7f, 0.7f, 0.7f, 0.3f);

	public Color health_bar_main_green = Toolbox.makeColor("#00C21F");

	public Color health_bar_main_red = Toolbox.makeColor("#FF4300");

	public Color health_bar_background = Toolbox.makeColor("#303030");

	public string color_dead_text => color_text_grey_dark;

	public Color getSelectorColor()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Toolbox.makeColor(color_text_selector);
	}

	public Color getSelectorRemoveColor()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Toolbox.makeColor(color_text_selector_remove);
	}

	public string getColorForTaxonomy(string pID)
	{
		return pID switch
		{
			"taxonomy_kingdom" => taxonomy_kingdom, 
			"taxonomy_phylum" => taxonomy_phylum, 
			"taxonomy_subphylum" => taxonomy_subphylum, 
			"taxonomy_class" => taxonomy_class, 
			"taxonomy_order" => taxonomy_order, 
			"taxonomy_family" => taxonomy_family, 
			"taxonomy_genus" => taxonomy_genus, 
			"taxonomy_common_name" => taxonomy_common_name, 
			_ => "0xFFFFFF", 
		};
	}
}
// --- End of File: ColorStyleAsset.cs ---



// --- Start of File: ColorStyleLibrary.cs ---
public class ColorStyleLibrary : AssetLibrary<ColorStyleAsset>
{
	public static ColorStyleAsset m;

	public override void init()
	{
		base.init();
		m = add(new ColorStyleAsset
		{
			id = "main"
		});
	}
}
// --- End of File: ColorStyleLibrary.cs ---



// --- Start of File: ColorTool.cs ---
using System.IO;
using UnityEngine;

public class ColorTool : MonoBehaviour
{
	public string colorString;

	public GameObject prefabKingdom;

	public GameObject prefabClan;

	public GameObject prefabCulture;

	public GameObject prefabAlliance;

	public Transform container;

	public string last_editor = "";

	private void resetCoords()
	{
	}

	public void InitKingdoms()
	{
		cleanup();
		last_editor = "kingdoms";
		KingdomColorsLibrary kingdomColorsLibrary = new KingdomColorsLibrary();
		kingdomColorsLibrary.init();
		kingdomColorsLibrary.post_init();
		foreach (ColorAsset item in kingdomColorsLibrary.list)
		{
			createColorToolElement(item, prefabKingdom, last_editor);
		}
	}

	public void InitCultures()
	{
		cleanup();
		last_editor = "cultures";
		CultureColorsLibrary cultureColorsLibrary = new CultureColorsLibrary();
		cultureColorsLibrary.init();
		cultureColorsLibrary.post_init();
		foreach (ColorAsset item in cultureColorsLibrary.list)
		{
			createColorToolElement(item, prefabCulture, last_editor);
		}
	}

	public void InitClans()
	{
		cleanup();
		last_editor = "clans";
		ClanColorsLibrary clanColorsLibrary = new ClanColorsLibrary();
		clanColorsLibrary.init();
		clanColorsLibrary.post_init();
		foreach (ColorAsset item in clanColorsLibrary.list)
		{
			createColorToolElement(item, prefabClan, last_editor);
		}
	}

	public void cleanup()
	{
		resetCoords();
		while (container.childCount > 0)
		{
			Object.DestroyImmediate((Object)(object)((Component)container.GetChild(0)).gameObject);
		}
	}

	private void createColorToolElement(ColorAsset pColor, GameObject pPrefab, string pWhat)
	{
		ColorToolElement component = Object.Instantiate<GameObject>(pPrefab, container).GetComponent<ColorToolElement>();
		if (last_editor == "kingdoms")
		{
			component.createKingdom(pColor);
		}
		else if (last_editor == "clans")
		{
			component.createClans(pColor);
		}
		else if (last_editor == "cultures")
		{
			component.createCulture(pColor);
		}
		((Object)((Component)component).transform).name = pColor.index_id + "-" + pColor.id;
		((Component)component).transform.SetSiblingIndex(pColor.index_id);
	}

	public void saveEditor()
	{
		if (last_editor == "kingdoms")
		{
			saveKingdoms();
		}
		else if (last_editor == "clans")
		{
			saveClans();
		}
		else if (last_editor == "cultures")
		{
			saveCultures();
		}
	}

	private void convertToolIntoAsset(ColorToolElement pTool, ColorAsset pAsset)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		pAsset.color_main = Toolbox.colorToHex(Color32.op_Implicit(pTool.colorMain), pAlpha: false);
		pAsset.color_main_2 = Toolbox.colorToHex(Color32.op_Implicit(pTool.colorMain2), pAlpha: false);
		pAsset.color_banner = Toolbox.colorToHex(Color32.op_Implicit(pTool.colorBanner), pAlpha: false);
		pAsset.color_text = Toolbox.colorToHex(Color32.op_Implicit(pTool.colorText), pAlpha: false);
		pAsset.id = pTool.id;
		pAsset.favorite = pTool.favorite;
	}

	private void saveKingdoms()
	{
		KingdomColorsLibrary pLibrary = new KingdomColorsLibrary();
		saveLib(pLibrary);
	}

	private void saveCultures()
	{
		CultureColorsLibrary pLibrary = new CultureColorsLibrary();
		saveLib(pLibrary);
	}

	private void saveClans()
	{
		ClanColorsLibrary pLibrary = new ClanColorsLibrary();
		saveLib(pLibrary);
	}

	private void saveLib(ColorLibrary pLibrary)
	{
		for (int i = 0; i < container.childCount; i++)
		{
			ColorToolElement component = ((Component)container.GetChild(i)).GetComponent<ColorToolElement>();
			ColorAsset colorAsset = new ColorAsset();
			convertToolIntoAsset(component, colorAsset);
			colorAsset.index_id = i;
			pLibrary.list.Add(colorAsset);
		}
		string contents = JsonUtility.ToJson((object)pLibrary, true);
		File.WriteAllText(pLibrary.getEditorPathForSave(), contents);
	}
}
// --- End of File: ColorTool.cs ---



// --- Start of File: ColorToolElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ColorToolElement : MonoBehaviour
{
	[Header("Edit Colors")]
	public Color colorMain;

	public Color colorMain2;

	public Color colorBanner;

	public Color colorText;

	[Header("Edit Asset Name / Id")]
	public string id;

	public bool favorite;

	[Header("Other Stuff")]
	[Space(30f)]
	public Image background;

	public Image icon;

	public Text text;

	public Image sprite_favorite;

	public Image borderInside;

	public Image borderOutside;

	[HideInInspector]
	public ColorAsset color_asset;

	public Image test_house;

	public Image test_face;

	public Sprite house_default_sprite;

	public Sprite face_default_sprite;

	public int debug_index;

	public void createKingdom(ColorAsset pColor)
	{
		color_asset = pColor;
	}

	public void createCulture(ColorAsset pColor)
	{
		color_asset = pColor;
		setColorsForObjects(pColor);
		saveColors(pColor);
	}

	public void createClans(ColorAsset pColor)
	{
		color_asset = pColor;
		string random = AssetManager.clan_banners_library.main.backgrounds.GetRandom();
		string random2 = AssetManager.clan_banners_library.main.icons.GetRandom();
		background.sprite = SpriteTextureLoader.getSprite(random);
		icon.sprite = SpriteTextureLoader.getSprite(random2);
		setColorsForObjects(pColor);
		saveColors(pColor);
	}

	private void setColorsForObjects(ColorAsset pColorAsset)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)borderInside).color = Color32.op_Implicit(pColorAsset.getColorBorderInsideAlpha32());
		((Graphic)borderOutside).color = pColorAsset.getColorMainSecond();
		((Graphic)background).color = pColorAsset.getColorMainSecond();
		((Graphic)icon).color = pColorAsset.getColorBanner();
		((Graphic)text).color = pColorAsset.getColorText();
		favorite = pColorAsset.favorite;
		id = pColorAsset.id;
		text.text = pColorAsset.id + " |  " + pColorAsset.index_id;
		debug_index = pColorAsset.index_id;
		if ((Object)(object)test_house != (Object)null && (Object)(object)house_default_sprite != (Object)null)
		{
			test_house.sprite = DynamicSpriteCreator.createNewSpriteForDebug(house_default_sprite, pColorAsset);
		}
		if ((Object)(object)test_face != (Object)null && (Object)(object)face_default_sprite != (Object)null)
		{
			test_face.sprite = DynamicSpriteCreator.createNewSpriteForDebug(face_default_sprite, pColorAsset);
		}
		if ((Object)(object)sprite_favorite != (Object)null)
		{
			((Component)sprite_favorite).gameObject.SetActive(favorite);
		}
	}

	private void OnValidate()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (color_asset != null)
		{
			color_asset.color_main = Toolbox.colorToHex(Color32.op_Implicit(colorMain), pAlpha: false);
			color_asset.color_main_2 = Toolbox.colorToHex(Color32.op_Implicit(colorMain2), pAlpha: false);
			color_asset.color_banner = Toolbox.colorToHex(Color32.op_Implicit(colorBanner), pAlpha: false);
			color_asset.color_text = Toolbox.colorToHex(Color32.op_Implicit(colorText), pAlpha: false);
			color_asset.id = id;
			color_asset.favorite = favorite;
			color_asset.setEditorColors(colorMain, colorMain2, colorBanner, colorText);
			setColorsForObjects(color_asset);
		}
	}

	private void saveColors(ColorAsset pColor)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		colorMain = pColor.getColorMain();
		colorMain2 = pColor.getColorMainSecond();
		colorBanner = pColor.getColorBanner();
		colorText = pColor.getColorText();
	}
}
// --- End of File: ColorToolElement.cs ---



// --- Start of File: ColorType.cs ---
public enum ColorType
{
	White,
	Purple,
	Blue
}
// --- End of File: ColorType.cs ---



// --- Start of File: CombatAction.cs ---
public delegate bool CombatAction(AttackData pData);
// --- End of File: CombatAction.cs ---



// --- Start of File: CombatActionActor.cs ---
public delegate bool CombatActionActor(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f);
// --- End of File: CombatActionActor.cs ---



// --- Start of File: CombatActionActorTargetPosition.cs ---
using UnityEngine;

public delegate bool CombatActionActorTargetPosition(Actor pActor, Vector2 pTargetPosition, WorldTile pTile = null);
// --- End of File: CombatActionActorTargetPosition.cs ---



// --- Start of File: CombatActionAsset.cs ---
using System;

[Serializable]
public class CombatActionAsset : Asset
{
	public bool play_unit_attack_sounds;

	public CombatActionPool[] pools;

	public string tag_required;

	public int rate = 1;

	public float chance = 0.2f;

	public float cooldown = 1f;

	public bool is_spell_use;

	public int cost_stamina;

	public int cost_mana;

	public bool basic;

	public CombatAction action;

	public CombatActionActor action_actor;

	public CombatActionActorTargetPosition action_actor_target_position;

	public CombatActionCheckStart can_do_action;
}
// --- End of File: CombatActionAsset.cs ---



// --- Start of File: CombatActionCheckStart.cs ---
public delegate bool CombatActionCheckStart(Actor pActor, BaseSimObject pAttackTarget);
// --- End of File: CombatActionCheckStart.cs ---



// --- Start of File: CombatActionHolder.cs ---
using System;
using System.Collections.Generic;

public class CombatActionHolder
{
	private readonly List<CombatActionAsset>[] _combat_action_pools = new List<CombatActionAsset>[Enum.GetValues(typeof(CombatActionPool)).Length];

	private bool _has_combat_actions;

	public void fillFromIDS(List<string> pIDs)
	{
		foreach (string pID in pIDs)
		{
			CombatActionAsset combatActionAsset = AssetManager.combat_action_library.get(pID);
			if (combatActionAsset == null)
			{
				continue;
			}
			CombatActionPool[] pools = combatActionAsset.pools;
			foreach (CombatActionPool combatActionPool in pools)
			{
				if (_combat_action_pools[(int)combatActionPool] == null)
				{
					_combat_action_pools[(int)combatActionPool] = new List<CombatActionAsset>();
				}
				_combat_action_pools[(int)combatActionPool].Add(combatActionAsset);
			}
		}
	}

	public List<CombatActionAsset> getPool(CombatActionPool pPool)
	{
		return _combat_action_pools[(int)pPool];
	}

	public void reset()
	{
		if (_has_combat_actions)
		{
			for (int i = 0; i < _combat_action_pools.Length; i++)
			{
				_combat_action_pools[i]?.Clear();
			}
			_has_combat_actions = false;
		}
	}

	public void mergeWith(CombatActionHolder pCombatActions)
	{
		for (int i = 0; i < pCombatActions._combat_action_pools.Length; i++)
		{
			List<CombatActionAsset> list = pCombatActions._combat_action_pools[i];
			if (list != null && list.Count != 0)
			{
				if (_combat_action_pools[i] == null)
				{
					_combat_action_pools[i] = new List<CombatActionAsset>();
				}
				_combat_action_pools[i].AddRange(list);
				_has_combat_actions = true;
			}
		}
	}

	public bool isEmpty()
	{
		return !_has_combat_actions;
	}

	public bool hasAny()
	{
		return _has_combat_actions;
	}
}
// --- End of File: CombatActionHolder.cs ---



// --- Start of File: CombatActionLibrary.cs ---
using System;
using UnityEngine;
using ai;

public class CombatActionLibrary : AssetLibrary<CombatActionAsset>
{
	public static CombatActionAsset combat_attack_melee;

	public static CombatActionAsset combat_attack_range;

	public static CombatActionAsset combat_cast_spell;

	public static CombatActionAsset combat_action_deflect;

	public static CombatActionAsset combat_action_dash;

	public static CombatActionAsset combat_action_backstep;

	public override void init()
	{
		base.init();
		combat_attack_melee = add(new CombatActionAsset
		{
			id = "combat_attack_melee",
			play_unit_attack_sounds = true,
			rate = 6,
			action = attackMeleeAction,
			basic = true
		});
		combat_attack_range = add(new CombatActionAsset
		{
			id = "combat_attack_range",
			play_unit_attack_sounds = true,
			rate = 6,
			action = attackRangeAction,
			basic = true
		});
		combat_cast_spell = add(new CombatActionAsset
		{
			id = "combat_cast_spell",
			play_unit_attack_sounds = true,
			cost_stamina = 5,
			is_spell_use = true,
			rate = 3,
			action = tryToCastSpell
		});
		combat_action_deflect = add(new CombatActionAsset
		{
			id = "combat_deflect_projectile",
			cost_stamina = 5,
			chance = 0.2f,
			pools = new CombatActionPool[1],
			action_actor = doDeflect
		});
		add(new CombatActionAsset
		{
			id = "combat_dodge",
			chance = 0.2f,
			cost_stamina = 5,
			action_actor = doDodgeAction,
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_HIT)
		});
		add(new CombatActionAsset
		{
			id = "combat_block",
			chance = 0.2f,
			cost_stamina = 5,
			cooldown = 0.5f,
			action_actor = doBlockAction,
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_HIT_BLOCK)
		});
		add(new CombatActionAsset
		{
			id = "combat_random_jump",
			cost_stamina = 5,
			cooldown = 2f
		});
		combat_action_dash = add(new CombatActionAsset
		{
			id = "combat_dash",
			cost_stamina = 10,
			chance = 0.2f,
			cooldown = 2f,
			action_actor_target_position = doDashAction,
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_ATTACK_MELEE)
		});
		combat_action_backstep = add(new CombatActionAsset
		{
			id = "combat_backstep",
			cost_stamina = 10,
			chance = 0.2f,
			cooldown = 1f,
			can_do_action = delegate(Actor pSelf, BaseSimObject pAttackTarget)
			{
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				if (pSelf.current_tile.Type.block)
				{
					return false;
				}
				float num3 = Toolbox.SquaredDistVec2Float(pSelf.current_position, pAttackTarget.current_position);
				float num4 = pSelf.getAttackRangeSquared() * 0.5f;
				return (num3 < num4) ? true : false;
			},
			action_actor_target_position = doBackstepAction,
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_ATTACK_RANGE)
		});
		add(new CombatActionAsset
		{
			id = "combat_throw_bomb",
			cost_stamina = 5,
			chance = 0.2f,
			cooldown = 8f,
			action_actor_target_position = doThrowBombAction,
			can_do_action = delegate(Actor pSelf, BaseSimObject pAttackTarget)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				float num2 = Toolbox.SquaredDistVec2Float(pSelf.current_position, pAttackTarget.current_position);
				return num2 > 36f && num2 < 2500f;
			},
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_ATTACK_MELEE, CombatActionPool.BEFORE_ATTACK_RANGE)
		});
		add(new CombatActionAsset
		{
			id = "combat_throw_torch",
			cost_stamina = 30,
			chance = 0.2f,
			cooldown = 8f,
			action_actor_target_position = doThrowTorchAction,
			can_do_action = delegate(Actor pSelf, BaseSimObject pAttackTarget)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				float num = Toolbox.SquaredDistVec2Float(pSelf.current_position, pAttackTarget.current_position);
				return num > 36f && num < 2500f;
			},
			pools = AssetLibrary<CombatActionAsset>.a<CombatActionPool>(CombatActionPool.BEFORE_ATTACK_MELEE, CombatActionPool.BEFORE_ATTACK_RANGE)
		});
	}

	private bool doThrowBombAction(Actor pSelf, Vector2 pTarget, WorldTile pTile = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ActionLibrary.throwBombAtTile(pSelf, pTile);
		pSelf.punchTargetAnimation(Vector2.op_Implicit(pTarget), pFlip: true, pReverse: false, 45f);
		return true;
	}

	private bool doThrowTorchAction(Actor pSelf, Vector2 pTarget, WorldTile pTile = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ActionLibrary.throwTorchAtTile(pSelf, pTile);
		pSelf.punchTargetAnimation(Vector2.op_Implicit(pTarget), pFlip: true, pReverse: false, 45f);
		return true;
	}

	private bool doBackstepAction(Actor pActor, Vector2 pTarget, WorldTile pTile = null)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		float pForceAmountDirection = 5f;
		float pForceHeight = 1.2f;
		Vector2 current_position = pActor.current_position;
		pActor.punchTargetAnimation(Vector2.op_Implicit(pTarget), pFlip: false, pReverse: false, -20f);
		pActor.calculateForce(current_position.x, current_position.y, pTarget.x, pTarget.y, pForceAmountDirection, pForceHeight);
		Vector2 current_position2 = pActor.current_position;
		current_position2.y += pActor.getHeight();
		BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_dodge", current_position2, pActor.actor_scale);
		if ((Object)(object)baseEffect != (Object)null)
		{
			((Component)baseEffect).transform.rotation = Toolbox.getEulerAngle(current_position, pTarget);
		}
		return true;
	}

	private bool doDashAction(Actor pActor, Vector2 pTarget, WorldTile pTile = null)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		float pForceAmountDirection = 5f;
		float pForceHeight = 1.2f;
		Vector2 current_position = pActor.current_position;
		pActor.punchTargetAnimation(Vector2.op_Implicit(pTarget), pFlip: true, pReverse: false, 50f);
		pActor.addStatusEffect("dash", 0f, pColorEffect: false);
		pActor.calculateForce(pTarget.x, pTarget.y, current_position.x, current_position.y, pForceAmountDirection, pForceHeight);
		Vector2 current_position2 = pActor.current_position;
		current_position2.y += pActor.getHeight();
		BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_dodge", current_position2, pActor.actor_scale);
		if ((Object)(object)baseEffect != (Object)null)
		{
			((Component)baseEffect).transform.rotation = Toolbox.getEulerAngle(current_position, pTarget);
		}
		return true;
	}

	private bool doBlockAction(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		ActorTool.applyForceToUnit(pData, pActor, 0.1f);
		if (!pActor.is_visible)
		{
			return true;
		}
		Vector2 current_position = pActor.current_position;
		Vector2 val = Vector2.op_Implicit(pData.hit_position);
		pActor.punchTargetAnimation(Vector2.op_Implicit(val), pFlip: false, pReverse: false, -40f);
		BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_block", val, pActor.a.actor_scale);
		if ((Object)(object)baseEffect == (Object)null)
		{
			return true;
		}
		((Component)baseEffect).transform.rotation = Toolbox.getEulerAngle(current_position.x, current_position.y, val.x, val.y);
		return true;
	}

	private bool doDeflect(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Vector2.op_Implicit(pData.initiator_position);
		pActor.spawnSlashPunch(val);
		pActor.stopMovement();
		pActor.punchTargetAnimation(Vector2.op_Implicit(val), pFlip: true, pActor.hasRangeAttack());
		pActor.startAttackCooldown();
		return true;
	}

	private bool doDodgeAction(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		float num = 3f;
		float pForceHeight = 1.5f;
		Vector2 val = Vector2.op_Implicit(pActor.cur_transform_position);
		Vector2 val2 = Vector2.op_Implicit(pData.initiator_position);
		Vector2 pVector = val - val2;
		Vector2 val3 = ((!Randy.randomBool()) ? (val + Toolbox.rotateVector(pVector, -90f) * num) : (val + Toolbox.rotateVector(pVector, 90f) * num));
		pActor.calculateForce(val.x, val.y, val3.x, val3.y, num, pForceHeight);
		pActor.addStatusEffect("dodge", 0f, pColorEffect: false);
		pActor.punchTargetAnimation(Vector2.op_Implicit(val), pFlip: false, pReverse: false, -60f);
		Vector2 current_position = pActor.current_position;
		current_position.y += pActor.getHeight();
		BaseEffect baseEffect = EffectsLibrary.spawnAt("fx_dodge", current_position, pActor.actor_scale);
		if ((Object)(object)baseEffect != (Object)null)
		{
			((Component)baseEffect).transform.rotation = Toolbox.getEulerAngle(val, val3);
		}
		return true;
	}

	public bool attackRangeAction(AttackData pData)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		Actor actor = pData.initiator.a;
		BaseSimObject target = pData.target;
		string projectile_id = pData.projectile_id;
		_ = actor.actor_scale;
		float scaleMod = actor.getScaleMod();
		float num = actor.stats["size"];
		int num2 = (int)actor.stats["projectiles"];
		Vector2 val;
		if (target == null)
		{
			val = Vector2.op_Implicit(pData.hit_position);
		}
		else
		{
			val = getAttackTargetPosition(pData);
			val.y += 0.2f * scaleMod;
		}
		float num3 = actor.stats["accuracy"];
		float pMaxExclusive = Toolbox.DistVec2Float(actor.current_position, val) / num3 * 0.25f;
		pMaxExclusive = Randy.randomFloat(0f, pMaxExclusive);
		pMaxExclusive = Mathf.Clamp(pMaxExclusive, 0f, 2f);
		float pStartPosZ = 0.6f * scaleMod;
		float pTargetZ = 0f;
		float value = 0f;
		Vector2 val2 = default(Vector2);
		for (int i = 0; i < num2; i++)
		{
			((Vector2)(ref val2))._002Ector(val.x, val.y);
			if (num3 < 10f)
			{
				Vector2 innacuracyVector = getInnacuracyVector(num3);
				innacuracyVector *= pMaxExclusive;
				val2 += innacuracyVector;
			}
			Vector3 newPoint = Toolbox.getNewPoint(actor.current_position.x, actor.current_position.y, val2.x, val2.y, num * scaleMod);
			newPoint.y += actor.getHeight();
			if (target != null && target.isInAir())
			{
				pTargetZ = target.getHeight();
			}
			value = World.world.projectiles.spawn(actor, target, projectile_id, newPoint, Vector2.op_Implicit(val2), pTargetZ, pStartPosZ, pData.kill_action, pData.kingdom).getLaunchAngle();
		}
		actor.spawnSlash(val, null, 2f, pTargetZ, 0f, value);
		return true;
	}

	public Vector2 getInnacuracyVector(float pAccuracyStat)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f * (10f - pAccuracyStat) / 10f;
		float num2 = (float)((double)(Randy.random() * 2f) * Math.PI);
		return new Vector2(num * (float)Math.Cos(num2), num * (float)Math.Sin(num2));
	}

	public static bool tryToCastSpell(AttackData pData)
	{
		Actor actor = pData.initiator.a;
		BaseSimObject baseSimObject = pData.target;
		SpellAsset randomSpell = actor.getRandomSpell();
		if (!actor.hasEnoughMana(randomSpell.cost_mana))
		{
			return false;
		}
		if (!Randy.randomChance(randomSpell.chance + randomSpell.chance * actor.stats["skill_spell"]))
		{
			return false;
		}
		if (randomSpell.cast_target == CastTarget.Himself)
		{
			baseSimObject = actor;
		}
		if (randomSpell.cast_entity == CastEntity.BuildingsOnly)
		{
			if (baseSimObject.isActor())
			{
				return false;
			}
		}
		else if (randomSpell.cast_entity == CastEntity.UnitsOnly && baseSimObject.isBuilding())
		{
			return false;
		}
		if (randomSpell.health_ratio > 0f)
		{
			float healthRatio = actor.getHealthRatio();
			if (randomSpell.health_ratio <= healthRatio)
			{
				return false;
			}
		}
		if (randomSpell.min_distance > 0f && (float)Toolbox.SquaredDistTile(actor.current_tile, baseSimObject.current_tile) < randomSpell.min_distance * randomSpell.min_distance)
		{
			return false;
		}
		bool flag = false;
		if (randomSpell.action != null)
		{
			flag = randomSpell.action.RunAnyTrue(actor, baseSimObject, baseSimObject.current_tile);
		}
		if (flag)
		{
			actor.doCastAnimation();
			actor.addStatusEffect("recovery_spell");
		}
		return flag;
	}

	public bool attackMeleeAction(AttackData pData)
	{
		AttackDataResult attackDataResult = MapBox.newAttack(pData);
		if (pData.initiator.a.is_visible && EffectsLibrary.canShowSlashEffect())
		{
			showMeleeSlashAttack(pData);
		}
		pData.kill_action?.Invoke();
		return attackDataResult.state == ApplyAttackState.Hit;
	}

	public void showMeleeSlashAttack(AttackData pData)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		pData.initiator.a.spawnSlash(Vector2.op_Implicit(pData.hit_position));
	}

	public Vector2 getAttackTargetPosition(AttackData pData)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		BaseSimObject target = pData.target;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))._002Ector(pData.hit_position.x, pData.hit_position.y);
		if (target == null)
		{
			return val;
		}
		float num = target.stats["size"];
		if (target.isActor() && target.a.is_moving && target.isFlying())
		{
			val = Vector2.MoveTowards(val, target.a.next_step_position, num * 3f);
			return val;
		}
		return val;
	}
}
// --- End of File: CombatActionLibrary.cs ---



// --- Start of File: CombatActionPool.cs ---
public enum CombatActionPool
{
	BEFORE_HIT_DEFLECT,
	BEFORE_HIT_BLOCK,
	BEFORE_HIT,
	BEFORE_ATTACK_MELEE,
	BEFORE_ATTACK_RANGE
}
// --- End of File: CombatActionPool.cs ---



// --- Start of File: CombatActionProjectile.cs ---
public delegate bool CombatActionProjectile(Actor pActor, Projectile pProjectile);
// --- End of File: CombatActionProjectile.cs ---



// --- Start of File: CommunicationAsset.cs ---
using System;
using UnityEngine;

[Serializable]
public class CommunicationAsset : Asset
{
	public string icon_path;

	public bool show_topic;

	public float rate;

	public TopicCheck check;

	public TopicPotFill pot_fill;

	[NonSerialized]
	private Sprite _sprite_cache;

	public Sprite getSpriteBubble()
	{
		if ((Object)(object)_sprite_cache == (Object)null)
		{
			_sprite_cache = SpriteTextureLoader.getSprite(icon_path);
		}
		return _sprite_cache;
	}
}
// --- End of File: CommunicationAsset.cs ---



// --- Start of File: CommunicationLibrary.cs ---
public class CommunicationLibrary : AssetLibrary<CommunicationAsset>
{
	public static CommunicationAsset normal;

	public override void init()
	{
		base.init();
		normal = add(new CommunicationAsset
		{
			id = "normal",
			icon_path = "speech/speech_bubble",
			show_topic = true
		});
		add(new CommunicationAsset
		{
			id = "singing",
			icon_path = "speech/speech_02"
		});
		add(new CommunicationAsset
		{
			id = "exclamation",
			icon_path = "speech/speech_03"
		});
		add(new CommunicationAsset
		{
			id = "questioning",
			icon_path = "speech/speech_04"
		});
		add(new CommunicationAsset
		{
			id = "offensive",
			icon_path = "speech/speech_05"
		});
		add(new CommunicationAsset
		{
			id = "defensive",
			icon_path = "speech/speech_06"
		});
		add(new CommunicationAsset
		{
			id = "mortality",
			icon_path = "speech/speech_07"
		});
		add(new CommunicationAsset
		{
			id = "romantic",
			icon_path = "speech/speech_08"
		});
		add(new CommunicationAsset
		{
			id = "pleasant",
			icon_path = "speech/speech_09"
		});
		add(new CommunicationAsset
		{
			id = "unpleasant",
			icon_path = "speech/speech_10"
		});
	}
}
// --- End of File: CommunicationLibrary.cs ---



// --- Start of File: CommunicationTopicAsset.cs ---
public class CommunicationTopicAsset : Asset
{
}
// --- End of File: CommunicationTopicAsset.cs ---



// --- Start of File: CommunicationTopicLibrary.cs ---
using System.Collections.Generic;
using UnityEngine;

public class CommunicationTopicLibrary : AssetLibrary<CommunicationAsset>
{
	private List<Sprite> _cached_sprites_religion = new List<Sprite>();

	private List<Sprite> _cached_sprites_culture = new List<Sprite>();

	private List<Sprite> _cached_sprites_family = new List<Sprite>();

	private List<Sprite> _cached_sprites_kingdom = new List<Sprite>();

	private List<Sprite> _cached_sprites_city = new List<Sprite>();

	private List<Sprite> _cached_sprites_clan = new List<Sprite>();

	private List<Sprite> _cached_sprites_time_and_death = new List<Sprite>();

	private List<Sprite> _cached_sprites_general_topics = new List<Sprite>();

	private List<Sprite> _cached_sprites_boats_water = new List<Sprite>();

	private List<Sprite> _cached_sprites_housed = new List<Sprite>();

	private List<Sprite> _cached_sprites_homeless = new List<Sprite>();

	private const int MAX_TOPIC_SPRITES = 10;

	public override void init()
	{
		add(new CommunicationAsset
		{
			id = "emotions",
			rate = 0.9f,
			check = (Actor pActor) => pActor.hasEmotions(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite spriteBasedOnHappinessValue = HappinessHelper.getSpriteBasedOnHappinessValue(pActor.getHappiness());
				for (int i = 0; i < 3; i++)
				{
					pPotSprites.Add(spriteBasedOnHappinessValue);
				}
				if (!pActor.hasHappinessHistory())
				{
					return;
				}
				foreach (HappinessHistory item in pActor.happiness_change_history)
				{
					Sprite sprite2 = item.asset.getSprite();
					pPotSprites.Add(sprite2);
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "is_housed",
			rate = 0.2f,
			check = (Actor pActor) => pActor.hasCity() && pActor.hasHouse(),
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_housed);
			}
		});
		add(new CommunicationAsset
		{
			id = "is_homeless",
			rate = 0.4f,
			check = (Actor pActor) => pActor.hasCity() && !pActor.hasHouse(),
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_homeless);
			}
		});
		add(new CommunicationAsset
		{
			id = "favorite_food",
			rate = 0.4f,
			check = (Actor pActor) => pActor.hasFavoriteFood(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite spriteIcon2 = pActor.favorite_food_asset.getSpriteIcon();
				if ((Object)(object)spriteIcon2 != (Object)null)
				{
					pPotSprites.Add(spriteIcon2);
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "religion",
			rate = 0.2f,
			check = (Actor pActor) => pActor.hasReligion(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSprite5 = pActor.religion.getTopicSprite();
				if ((Object)(object)topicSprite5 != (Object)null)
				{
					pPotSprites.Add(topicSprite5);
				}
				pPotSprites.AddRange(_cached_sprites_religion);
			}
		});
		add(new CommunicationAsset
		{
			id = "culture",
			rate = 0.15f,
			check = (Actor pActor) => pActor.hasCulture(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSprite4 = pActor.culture.getTopicSprite();
				if ((Object)(object)topicSprite4 != (Object)null)
				{
					pPotSprites.Add(topicSprite4);
				}
				pPotSprites.AddRange(_cached_sprites_culture);
			}
		});
		add(new CommunicationAsset
		{
			id = "equipment",
			rate = 0.2f,
			check = (Actor pActor) => pActor.hasEquipment(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				foreach (ActorEquipmentSlot item2 in pActor.equipment)
				{
					Sprite sprite = item2.getItem().getAsset().getSprite();
					if ((Object)(object)sprite != (Object)null)
					{
						pPotSprites.Add(sprite);
					}
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "language",
			rate = 0.15f,
			check = (Actor pActor) => pActor.hasLanguage(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSprite3 = pActor.language.getTopicSprite();
				if ((Object)(object)topicSprite3 != (Object)null)
				{
					pPotSprites.Add(topicSprite3);
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "actor_traits",
			rate = 0.3f,
			check = (Actor pActor) => pActor.hasTraits(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSpriteTrait = pActor.getTopicSpriteTrait();
				if ((Object)(object)topicSpriteTrait != (Object)null)
				{
					pPotSprites.Add(topicSpriteTrait);
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "family",
			rate = 0.3f,
			check = (Actor pActor) => pActor.hasFamily(),
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_family);
			}
		});
		add(new CommunicationAsset
		{
			id = "kingdom_civ",
			rate = 0.2f,
			check = (Actor pActor) => pActor.isKingdomCiv(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSprite2 = pActor.kingdom.getTopicSprite();
				if ((Object)(object)topicSprite2 != (Object)null)
				{
					pPotSprites.Add(topicSprite2);
				}
				pPotSprites.AddRange(_cached_sprites_kingdom);
			}
		});
		add(new CommunicationAsset
		{
			id = "statuses",
			rate = 0.7f,
			check = (Actor pActor) => pActor.hasAnyStatusEffect(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				foreach (Status status in pActor.getStatuses())
				{
					pPotSprites.Add(status.asset.getSprite());
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "city",
			rate = 0.3f,
			check = (Actor pActor) => pActor.hasCity(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_city);
				if (pActor.city.hasStorages())
				{
					ResourceAsset randomFoodAsset = pActor.city.storages.GetRandom().resources.getRandomFoodAsset();
					if (randomFoodAsset != null)
					{
						Sprite spriteIcon = randomFoodAsset.getSpriteIcon();
						if ((Object)(object)spriteIcon != (Object)null)
						{
							pPotSprites.Add(spriteIcon);
						}
					}
				}
			}
		});
		add(new CommunicationAsset
		{
			id = "city_boats",
			rate = 0.1f,
			check = (Actor pActor) => pActor.hasCity() && pActor.city.countBoats() > 0,
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_boats_water);
			}
		});
		add(new CommunicationAsset
		{
			id = "clan",
			rate = 0.3f,
			check = (Actor pActor) => pActor.hasClan(),
			pot_fill = delegate(Actor pActor, ListPool<Sprite> pPotSprites)
			{
				Sprite topicSprite = pActor.clan.getTopicSprite();
				if ((Object)(object)topicSprite != (Object)null)
				{
					pPotSprites.Add(topicSprite);
				}
				pPotSprites.AddRange(_cached_sprites_clan);
			}
		});
		add(new CommunicationAsset
		{
			id = "time_and_death",
			rate = 0.3f,
			check = (Actor _) => true,
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_time_and_death);
			}
		});
		add(new CommunicationAsset
		{
			id = "world_subspecies",
			rate = 0.1f,
			check = (Actor _) => World.world.subspecies.hasAny(),
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_general_topics);
			}
		});
		add(new CommunicationAsset
		{
			id = "general_topics",
			rate = 1f,
			check = (Actor _) => true,
			pot_fill = delegate(Actor _, ListPool<Sprite> pPotSprites)
			{
				pPotSprites.AddRange(_cached_sprites_general_topics);
			}
		});
	}

	public override void linkAssets()
	{
		cacheSpritesGeneralTopics();
		base.linkAssets();
	}

	public Sprite getTopicSprite(Actor pActor)
	{
		using ListPool<Sprite> listPool = new ListPool<Sprite>();
		list.Shuffle();
		foreach (CommunicationAsset item in list)
		{
			if (Randy.randomChance(item.rate) && item.check(pActor))
			{
				item.pot_fill(pActor, listPool);
				if (listPool.Count > 10)
				{
					break;
				}
			}
		}
		return listPool.GetRandom();
	}

	private void cacheSpritesGeneralTopics()
	{
		_cached_sprites_housed.Add(SpriteTextureLoader.getSprite("ui/Icons/iconHoused"));
		_cached_sprites_homeless.Add(SpriteTextureLoader.getSprite("ui/Icons/iconHomeless"));
		_cached_sprites_religion.Add(SpriteTextureLoader.getSprite("ui/Icons/iconReligion"));
		_cached_sprites_religion.Add(SpriteTextureLoader.getSprite("ui/Icons/iconReligionList"));
		_cached_sprites_culture.Add(SpriteTextureLoader.getSprite("ui/Icons/iconCulture"));
		_cached_sprites_culture.Add(SpriteTextureLoader.getSprite("ui/Icons/iconCultureList"));
		_cached_sprites_family.Add(SpriteTextureLoader.getSprite("ui/Icons/iconFamily"));
		_cached_sprites_family.Add(SpriteTextureLoader.getSprite("ui/Icons/iconFamilyList"));
		_cached_sprites_family.Add(SpriteTextureLoader.getSprite("ui/Icons/iconChildren"));
		_cached_sprites_kingdom.Add(SpriteTextureLoader.getSprite("ui/Icons/iconKingdom"));
		_cached_sprites_kingdom.Add(SpriteTextureLoader.getSprite("ui/Icons/iconKingdomList"));
		_cached_sprites_kingdom.Add(SpriteTextureLoader.getSprite("ui/Icons/iconRebellion"));
		_cached_sprites_kingdom.Add(SpriteTextureLoader.getSprite("ui/Icons/iconKings"));
		_cached_sprites_city.Add(SpriteTextureLoader.getSprite("ui/Icons/iconCity"));
		_cached_sprites_city.Add(SpriteTextureLoader.getSprite("ui/Icons/iconCityList"));
		_cached_sprites_city.Add(SpriteTextureLoader.getSprite("ui/Icons/iconLeaders"));
		_cached_sprites_clan.Add(SpriteTextureLoader.getSprite("ui/Icons/iconClan"));
		_cached_sprites_clan.Add(SpriteTextureLoader.getSprite("ui/Icons/iconClanList"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconClock"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconDead"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconSkulls"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconKills"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconAge"));
		_cached_sprites_time_and_death.Add(SpriteTextureLoader.getSprite("ui/Icons/iconRenown"));
		_cached_sprites_general_topics.Add(SpriteTextureLoader.getSprite("ui/Icons/iconGodFinger"));
		_cached_sprites_general_topics.Add(SpriteTextureLoader.getSprite("ui/Icons/iconBre"));
		_cached_sprites_boats_water.Add(SpriteTextureLoader.getSprite("ui/Icons/iconBoat"));
		_cached_sprites_boats_water.Add(SpriteTextureLoader.getSprite("ui/Icons/iconTileDeepOcean"));
		_cached_sprites_boats_water.Add(SpriteTextureLoader.getSprite("ui/Icons/iconTileCloseOcean"));
	}
}
// --- End of File: CommunicationTopicLibrary.cs ---



// --- Start of File: ComponentListBase.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class ComponentListBase<TListElement, TMetaObject, TData, TComponent> : MonoBehaviour, IComponentList, IShouldRefreshWindow where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData where TComponent : ComponentListBase<TListElement, TMetaObject, TData, TComponent>
{
	public GameObject no_items;

	public SortingTab sorting_tab;

	public TListElement element_prefab;

	public Transform list_transform;

	public ScrollRect scroll_rect;

	[SerializeField]
	private Text _title_counter;

	[SerializeField]
	private Text _favorites_counter;

	[SerializeField]
	private Text _dead_counter;

	private ListItemsFilter _show_items;

	public GetListOfObjectsFunc<TListElement, TMetaObject, TData, TComponent> get_objects_delegate = getObjects;

	private ObjectPoolGenericMono<TListElement> _pool_elements;

	private ObjectPoolGenericMono<BaseEmptyListMono> _pool_empty_elements;

	protected Comparison<TMetaObject> current_sort;

	public readonly List<NanoObject> meta_list = new List<NanoObject>();

	private bool autolayout_done;

	private const int PADDING_ELEMENTS = 3;

	private static readonly bool _debug;

	private bool _created;

	protected int latest_counted;

	private float _element_height;

	protected virtual MetaType meta_type
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	private MetaTypeAsset _meta_type_asset => AssetManager.meta_type_library.getAsset(meta_type);

	protected virtual bool change_asset_sort_order => true;

	protected virtual IEnumerable<TMetaObject> getObjectsList()
	{
		return get_objects_delegate((TComponent)this);
	}

	protected ObjectPoolGenericMono<BaseEmptyListMono> getPoolEmpty()
	{
		return _pool_empty_elements;
	}

	private void checkCreate()
	{
		if (!_created)
		{
			_created = true;
			create();
		}
	}

	protected virtual void create()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		_pool_elements = new ObjectPoolGenericMono<TListElement>(element_prefab, list_transform);
		_element_height = ((Component)((Component)element_prefab).transform).GetComponent<RectTransform>().sizeDelta.y;
		addEmptyPoolSystem();
		showSortingTabs();
	}

	protected virtual void setupSortingTabs()
	{
	}

	protected virtual void showSortingTabs()
	{
		sorting_tab.clearButtons();
		setupSortingTabs();
		sorting_tab.enableFirstIfNone();
	}

	private void OnRenderObject()
	{
		autolayout_done = true;
	}

	private void LateUpdate()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!autolayout_done)
		{
			return;
		}
		IReadOnlyList<BaseEmptyListMono> listTotal = _pool_empty_elements.getListTotal();
		int num = int.MaxValue;
		int num2 = int.MinValue;
		float y = ((Transform)scroll_rect.content).localPosition.y;
		Rect rect = scroll_rect.viewport.rect;
		float pScrollRectTop = y + ((Rect)(ref rect)).height;
		for (int i = 0; i < listTotal.Count; i++)
		{
			BaseEmptyListMono baseEmptyListMono = listTotal[i];
			if (!((Component)baseEmptyListMono).gameObject.activeSelf)
			{
				continue;
			}
			if (IsVisibleInScrollRect(baseEmptyListMono.rect_transform, scroll_rect, pScrollRectTop, y))
			{
				if (num == int.MaxValue)
				{
					num = i;
				}
				num2 = i;
			}
			else if (num2 > int.MinValue)
			{
				break;
			}
		}
		if (num2 == int.MaxValue || num == int.MinValue)
		{
			return;
		}
		int num3 = Math.Max(0, num - 3);
		int num4 = Math.Min(listTotal.Count - 1, num2 + 3);
		for (int j = 0; j < listTotal.Count; j++)
		{
			if (j < num3 || j > num4)
			{
				BaseEmptyListMono pEmptyMono = listTotal[j];
				releaseElement(pEmptyMono);
			}
		}
		for (int k = num3; k <= num4; k++)
		{
			BaseEmptyListMono baseEmptyListMono2 = listTotal[k];
			if (((Component)baseEmptyListMono2).gameObject.activeSelf && !baseEmptyListMono2.hasElement())
			{
				makeElementVisible(baseEmptyListMono2);
			}
		}
		if (_debug)
		{
			debugUpdateElementNames(listTotal, pScrollRectTop, y);
		}
	}

	private void makeElementVisible(BaseEmptyListMono pEmptyMono)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		TListElement next = _pool_elements.getNext();
		next.show((TMetaObject)pEmptyMono.meta_object);
		((Component)next).transform.SetParent(((Component)pEmptyMono).transform);
		((Component)next).transform.localPosition = Vector3.zero;
		pEmptyMono.assignElement((MonoBehaviour)(object)next);
	}

	private bool IsVisibleInScrollRect(RectTransform pRectTransform, ScrollRect pScrollRect, float pScrollRectTop, float pScrollRectBottom)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Vector2.op_Implicit(((Transform)pRectTransform).localPosition);
		val *= -1f;
		float num = pRectTransform.sizeDelta.y * 0.6f;
		if (val.y <= pScrollRectTop + num + ((Component)this).transform.localPosition.y)
		{
			return val.y >= pScrollRectBottom - num + ((Component)this).transform.localPosition.y;
		}
		return false;
	}

	private void addEmptyPoolSystem()
	{
		BaseEmptyListMono baseEmptyListMono = Resources.Load<BaseEmptyListMono>("ui/list_element_empty");
		baseEmptyListMono = Object.Instantiate<BaseEmptyListMono>(baseEmptyListMono, list_transform);
		((Component)baseEmptyListMono).gameObject.SetActive(false);
		LayoutElement val = default(LayoutElement);
		if (_element_height > 0f && ((Component)baseEmptyListMono).TryGetComponent<LayoutElement>(ref val))
		{
			val.minHeight = _element_height;
		}
		_pool_empty_elements = new ObjectPoolGenericMono<BaseEmptyListMono>(baseEmptyListMono, list_transform);
	}

	private void showElement(TMetaObject pObject)
	{
		_pool_empty_elements.getNext().assignObject(pObject);
	}

	protected static IEnumerable<TMetaObject> getObjects(ComponentListBase<TListElement, TMetaObject, TData, TComponent> pComponentList)
	{
		IEnumerable<TMetaObject> pList = pComponentList._meta_type_asset.get_list().Cast<TMetaObject>();
		foreach (TMetaObject item in pComponentList.getFiltered(pList))
		{
			yield return item;
		}
	}

	protected virtual IEnumerable<TMetaObject> getFiltered(IEnumerable<TMetaObject> pList)
	{
		switch (getCurrentFilter())
		{
		case ListItemsFilter.Favorites:
			foreach (TMetaObject p in pList)
			{
				if (p.isFavorite())
				{
					yield return p;
				}
			}
			yield break;
		case ListItemsFilter.Dead:
			foreach (TMetaObject p2 in pList)
			{
				if (p2.hasDied())
				{
					yield return p2;
				}
			}
			yield break;
		case ListItemsFilter.OnlyAlive:
			foreach (TMetaObject p3 in pList)
			{
				if (!p3.hasDied())
				{
					yield return p3;
				}
			}
			yield break;
		}
		foreach (TMetaObject p4 in pList)
		{
			yield return p4;
		}
	}

	private void OnEnable()
	{
		checkCreate();
		showSortingTabs();
		show();
	}

	protected virtual void show()
	{
		if (!Config.game_loaded)
		{
			return;
		}
		clear();
		latest_counted = 0;
		if (isEmpty())
		{
			if ((Object)(object)no_items != (Object)null)
			{
				no_items.SetActive(true);
			}
		}
		else
		{
			if ((Object)(object)no_items != (Object)null)
			{
				no_items.SetActive(false);
			}
			showElements();
			latest_counted = _pool_empty_elements.countActive();
		}
		if ((Object)(object)_title_counter != (Object)null)
		{
			_title_counter.text = latest_counted.ToString();
		}
		if ((Object)(object)_favorites_counter != (Object)null)
		{
			_favorites_counter.text = latest_counted.ToString();
		}
		if ((Object)(object)_dead_counter != (Object)null)
		{
			_dead_counter.text = latest_counted.ToString();
		}
		_pool_empty_elements.disableInactive();
		ScrollWindow.checkElements();
	}

	public ListPool<NanoObject> getElements()
	{
		meta_list.Clear();
		meta_list.AddRange(getObjectsList());
		meta_list.Sort((NanoObject a, NanoObject b) => current_sort(a as TMetaObject, b as TMetaObject));
		SortButton currentButton = sorting_tab.getCurrentButton();
		if (currentButton != null && currentButton.getState() == SortButtonState.Down)
		{
			meta_list.Reverse();
		}
		return new ListPool<NanoObject>(meta_list);
	}

	protected void showElements()
	{
		using ListPool<NanoObject> listPool = getElements();
		for (int i = 0; i < listPool.Count; i++)
		{
			NanoObject nanoObject = listPool[i];
			showElement(nanoObject as TMetaObject);
		}
		if (change_asset_sort_order)
		{
			_meta_type_asset.setListGetter(getElements);
		}
	}

	public virtual bool isEmpty()
	{
		IEnumerable<TMetaObject> objectsList = getObjectsList();
		if (objectsList == null)
		{
			return true;
		}
		return !objectsList.Any();
	}

	public virtual void clear()
	{
		IReadOnlyList<BaseEmptyListMono> listTotal = _pool_empty_elements.getListTotal();
		for (int i = 0; i < listTotal.Count; i++)
		{
			BaseEmptyListMono baseEmptyListMono = listTotal[i];
			releaseElement(baseEmptyListMono);
			baseEmptyListMono.clearObject();
		}
		_pool_empty_elements.clear();
		_pool_elements.resetParent();
		meta_list.Clear();
		_meta_type_asset.setListGetter(null);
	}

	private void releaseElement(BaseEmptyListMono pEmptyMono)
	{
		if (pEmptyMono.hasElement())
		{
			TListElement pElement = (TListElement)(WindowListElementBase<TMetaObject, TData>)(object)pEmptyMono.element;
			pEmptyMono.clearElement();
			_pool_elements.release(pElement);
		}
	}

	private void debugUpdateElementNames(IReadOnlyList<BaseEmptyListMono> pList, float pScrollRectTop, float pScrollRectBottom)
	{
		for (int i = 0; i < pList.Count; i++)
		{
			BaseEmptyListMono baseEmptyListMono = pList[i];
			bool tVisible = IsVisibleInScrollRect(baseEmptyListMono.rect_transform, scroll_rect, pScrollRectTop, pScrollRectBottom);
			baseEmptyListMono.debugUpdateName(tVisible);
		}
	}

	private void OnDisable()
	{
		clear();
	}

	public void setShowFavoritesOnly()
	{
		_show_items = ListItemsFilter.Favorites;
	}

	public void setShowAll()
	{
		_show_items = ListItemsFilter.All;
	}

	public void setShowDeadOnly()
	{
		_show_items = ListItemsFilter.Dead;
	}

	public void setShowAliveOnly()
	{
		_show_items = ListItemsFilter.OnlyAlive;
	}

	public virtual void setDefault()
	{
	}

	public ListItemsFilter getCurrentFilter()
	{
		return _show_items;
	}

	public void init(GameObject pNoItems, SortingTab pSortingTab, GameObject pListElementPrefab, Transform pListTransform, ScrollRect pScrollRect, Text pTitleCounter, Text pFavoritesCounter, Text pDeadCounter)
	{
		no_items = pNoItems;
		sorting_tab = pSortingTab;
		element_prefab = pListElementPrefab.GetComponent<TListElement>();
		list_transform = pListTransform;
		scroll_rect = pScrollRect;
		_title_counter = pTitleCounter;
		_favorites_counter = pFavoritesCounter;
		_dead_counter = pDeadCounter;
	}

	public virtual bool checkRefreshWindow()
	{
		foreach (NanoObject item in meta_list)
		{
			if (item.isRekt())
			{
				return true;
			}
		}
		return false;
	}

	protected void genericMetaSortByAge(Comparison<TMetaObject> pAction)
	{
		sorting_tab.tryAddButton("ui/Icons/iconAge", "sort_by_age", show, delegate
		{
			current_sort = pAction;
		});
	}

	protected void genericMetaSortByRenown(Comparison<TMetaObject> pAction)
	{
		sorting_tab.tryAddButton("ui/Icons/iconRenown", "sort_by_renown", show, delegate
		{
			current_sort = pAction;
		});
	}

	protected void genericMetaSortByPopulation(Comparison<TMetaObject> pAction)
	{
		sorting_tab.tryAddButton("ui/Icons/iconPopulation", "sort_by_members", show, delegate
		{
			current_sort = pAction;
		});
	}

	protected void genericMetaSortByKills(Comparison<TMetaObject> pAction)
	{
		sorting_tab.tryAddButton("ui/Icons/iconKills", "sort_by_kills", show, delegate
		{
			current_sort = pAction;
		});
	}

	protected void genericMetaSortByDeath(Comparison<TMetaObject> pAction)
	{
		sorting_tab.tryAddButton("ui/Icons/iconDead", "sort_by_dead", show, delegate
		{
			current_sort = pAction;
		});
	}

	protected int sortByRenown(IMetaObject p1, IMetaObject p2)
	{
		return p2.getRenown().CompareTo(p1.getRenown());
	}

	protected int sortByAge(IMetaObject p1, IMetaObject p2)
	{
		return -p2.getMetaData().created_time.CompareTo(p1.getMetaData().created_time);
	}

	public static int sortByPopulation(IMetaObject p1, IMetaObject p2)
	{
		return p2.getPopulationPeople().CompareTo(p1.getPopulationPeople());
	}

	public static int sortByKills(IMetaObject p1, IMetaObject p2)
	{
		return p2.getTotalKills().CompareTo(p1.getTotalKills());
	}

	public static int sortByDeaths(IMetaObject p1, IMetaObject p2)
	{
		return p2.getTotalDeaths().CompareTo(p1.getTotalDeaths());
	}
}
// --- End of File: ComponentListBase.cs ---



// --- Start of File: ComponentListSapient.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ComponentListSapient<TListElement, TMetaObject, TData, TComponent> : ComponentListBase<TListElement, TMetaObject, TData, TComponent>, ISapientListComponent where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData where TComponent : ComponentListBase<TListElement, TMetaObject, TData, TComponent>
{
	[SerializeField]
	private Text _sapient_counter;

	[SerializeField]
	private Text _non_sapient_counter;

	private SapientListFilter _filter;

	protected override void show()
	{
		if (Config.game_loaded)
		{
			base.show();
			if ((Object)(object)_sapient_counter != (Object)null)
			{
				_sapient_counter.text = latest_counted.ToString();
			}
			if ((Object)(object)_non_sapient_counter != (Object)null)
			{
				_non_sapient_counter.text = latest_counted.ToString();
			}
		}
	}

	protected override IEnumerable<TMetaObject> getFiltered(IEnumerable<TMetaObject> pList)
	{
		switch (_filter)
		{
		case SapientListFilter.Default:
			foreach (TMetaObject item in base.getFiltered(pList))
			{
				yield return item;
			}
			break;
		case SapientListFilter.Sapient:
			foreach (ISapient p in pList)
			{
				if (p.isSapient())
				{
					yield return (TMetaObject)p;
				}
			}
			break;
		case SapientListFilter.NonSapient:
			foreach (ISapient p2 in pList)
			{
				if (!p2.isSapient())
				{
					yield return (TMetaObject)p2;
				}
			}
			break;
		}
	}

	public void setShowSapientOnly()
	{
		_filter = SapientListFilter.Sapient;
	}

	public void setShowNonSapientOnly()
	{
		_filter = SapientListFilter.NonSapient;
	}

	public override void setDefault()
	{
		_filter = SapientListFilter.Default;
	}

	public void setSapientCounter(Text pCounter)
	{
		_sapient_counter = pCounter;
	}

	public void setNonSapientCounter(Text pCounter)
	{
		_non_sapient_counter = pCounter;
	}
}
// --- End of File: ComponentListSapient.cs ---



// --- Start of File: CondActorFlying.cs ---
namespace ai.behaviours.conditions;

public class CondActorFlying : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		return pActor.isFlying();
	}
}
// --- End of File: CondActorFlying.cs ---



// --- Start of File: CondActorNotJustLanded.cs ---
using UnityEngine;

namespace ai.behaviours.conditions;

public class CondActorNotJustLanded : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		pActor.data.get("justLanded", out var pResult, 0);
		bool result = pResult <= 0;
		pResult--;
		pActor.data.set("justLanded", Mathf.Max(pResult, 0));
		return result;
	}
}
// --- End of File: CondActorNotJustLanded.cs ---



// --- Start of File: CondCurrentTileNoOtherUnits.cs ---
namespace ai.behaviours.conditions;

public class CondCurrentTileNoOtherUnits : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		return pActor.current_tile.countUnits() <= 1;
	}
}
// --- End of File: CondCurrentTileNoOtherUnits.cs ---



// --- Start of File: CondDragonCanLand.cs ---
namespace ai.behaviours.conditions;

public class CondDragonCanLand : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		if (!Dragon.canLand(pActor))
		{
			return false;
		}
		if (pActor.getActorComponent<Dragon>().lastLanded == pActor.current_tile)
		{
			return false;
		}
		pActor.data.get("justUp", out var pResult, pDefault: false);
		if (pResult)
		{
			pActor.data.removeBool("justUp");
			return false;
		}
		return true;
	}
}
// --- End of File: CondDragonCanLand.cs ---



// --- Start of File: CondDragonCanLandAttack.cs ---
namespace ai.behaviours.conditions;

public class CondDragonCanLandAttack : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		pActor.data.get("landAttacks", out var pResult, 0);
		if (pResult >= 2)
		{
			return false;
		}
		pActor.data.get("attacksForCity", out var pResult2, 0);
		if (pResult2 > 0 && pActor.current_tile.zone.city != null)
		{
			pActor.data.get("cityToAttack", out var pResult3, -1L);
			if (pResult3 == pActor.current_tile.zone.city.data.id)
			{
				return true;
			}
		}
		Dragon actorComponent = pActor.getActorComponent<Dragon>();
		if (actorComponent.targetsWithinLandAttackRange())
		{
			return true;
		}
		if (pActor.hasTrait("zombie") && World.world.kingdoms_wild.get("golden_brain").hasBuildings())
		{
			foreach (Building building in World.world.kingdoms_wild.get("golden_brain").buildings)
			{
				if (actorComponent.landAttackRange(building.current_tile))
				{
					return true;
				}
			}
		}
		return false;
	}
}
// --- End of File: CondDragonCanLandAttack.cs ---



// --- Start of File: CondDragonCanSlide.cs ---
namespace ai.behaviours.conditions;

public class CondDragonCanSlide : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		if (!pActor.getActorComponent<Dragon>().hasTargetsForSlide())
		{
			return false;
		}
		pActor.data.get("justSlid", out var pResult, pDefault: false);
		pActor.data.removeBool("justSlid");
		return !pResult;
	}
}
// --- End of File: CondDragonCanSlide.cs ---



// --- Start of File: CondDragonHasCityTarget.cs ---
namespace ai.behaviours.conditions;

public class CondDragonHasCityTarget : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		pActor.data.get("attacksForCity", out var pResult, 0);
		if (pResult == 0)
		{
			return false;
		}
		pActor.data.get("cityToAttack", out var pResult2, -1L);
		return pResult2.hasValue();
	}
}
// --- End of File: CondDragonHasCityTarget.cs ---



// --- Start of File: CondDragonHasTargets.cs ---
namespace ai.behaviours.conditions;

public class CondDragonHasTargets : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		return pActor.getActorComponent<Dragon>().aggroTargets.Count > 0;
	}
}
// --- End of File: CondDragonHasTargets.cs ---



// --- Start of File: CondDragonNotSleepy.cs ---
namespace ai.behaviours.conditions;

public class CondDragonNotSleepy : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		pActor.data.get("sleepy", out var pResult, 0);
		return pResult < 10;
	}
}
// --- End of File: CondDragonNotSleepy.cs ---



// --- Start of File: CondDragonSleeping.cs ---
namespace ai.behaviours.conditions;

public class CondDragonSleeping : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		string text = pActor.ai.task?.id;
		if (!(text == "dragon_sleep"))
		{
			return text == "dragon_wakeup";
		}
		return true;
	}
}
// --- End of File: CondDragonSleeping.cs ---



// --- Start of File: CondDragonSleepy.cs ---
namespace ai.behaviours.conditions;

public class CondDragonSleepy : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		pActor.data.get("sleepy", out var pResult, 0);
		return pResult > 10;
	}
}
// --- End of File: CondDragonSleepy.cs ---



// --- Start of File: CondNoPeace.cs ---
namespace ai.behaviours.conditions;

public class CondNoPeace : BehaviourActorCondition
{
	public override bool check(Actor pActor)
	{
		return !WorldLawLibrary.world_law_peaceful_monsters.isEnabled();
	}
}
// --- End of File: CondNoPeace.cs ---



// --- Start of File: Config.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Beebyte.Obfuscator;
using UnityEngine;
using UnityEngine.CrashReportHandler;
using UnityEngine.Rendering;

[ObfuscateLiterals]
public class Config
{
	public static bool parallel_jobs_updater = true;

	public static bool parallel_chunk_manager = true;

	public static string versionCodeText = string.Empty;

	public static string gitCodeText = string.Empty;

	public static string versionCodeDate = string.Empty;

	public static string iname = string.Empty;

	internal static bool? gen = null;

	public static string testStreamingAssets = "test";

	public static bool ui_main_hidden = false;

	public static int WORLD_SAVE_VERSION = 17;

	public static string current_map_template = "continent";

	public static string customMapSize = "standard";

	public static int customZoneX = 0;

	public static int customZoneY = 0;

	public static int customPerlinScale = 10;

	public static int customRandomShapes = 10;

	public static int customWaterLevel = 10;

	public static int ZONE_AMOUNT_X = 4;

	public static int ZONE_AMOUNT_Y = 4;

	public static string customMapSizeDefault = "standard";

	public static string maxMapSize = "iceberg";

	public static int ZONE_AMOUNT_X_DEFAULT = 3;

	public static int ZONE_AMOUNT_Y_DEFAULT = 4;

	public const int MAP_BLOCK_SIZE = 64;

	public const int CHUNK_SIZE = 16;

	public const int TILES_IN_CHUNK = 256;

	public const int CITY_ZONE_SIZE = 8;

	public const int CITY_ZONE_TILES = 64;

	public const int TILES_IN_REGION = 256;

	public const int PREVIEW_MAP_SIZE = 512;

	public const float FOCUS_SCROLL_DELAY_PC = 0.4f;

	public const float FOCUS_SCROLL_DELAY_PHONE = 0.55f;

	public static WorldTimeScaleAsset time_scale_asset = null;

	public static bool fps_lock_30 = false;

	public static bool MODDED = false;

	public static bool EVERYTHING_MAGIC_COLOR = false;

	public static bool EVERYTHING_FIREWORKS = false;

	private static bool _paused = false;

	public static bool lockGameControls = false;

	internal static string steam_name;

	internal static string steam_id;

	internal static bool steam_language_allow_detect = true;

	internal static string discordId;

	internal static string discordName;

	internal static string discordDiscriminator;

	public static bool testAds = false;

	public static bool firebaseInitiating = false;

	public static bool firebaseChecked = false;

	public static bool firebaseEnabled = true;

	public static bool authEnabled = false;

	public const string firebaseDatabaseURL = "https://worldbox-g.firebaseio.com/";

	public const string baseURL = "https://versions.superworldbox.com";

	public const string currencyURL = "https://currency.superworldbox.com";

	public static bool adsInitialized = false;

	public static bool disable_dispose_logs = true;

	public static bool disable_loading_logs = false;

	public static bool disable_discord = false;

	public static bool disable_steam = false;

	public static bool disable_db = false;

	public static bool disable_startup_window = false;

	public static bool disable_tutorial = false;

	public static bool debug_log_meta_ranks = false;

	public static string debug_last_selected_power_button;

	public static string debug_last_window;

	public static int debug_worlds_loaded;

	public static WindowStats debug_window_stats;

	public static bool load_random_test_map = false;

	public static bool load_new_map = false;

	public static bool load_dragon = false;

	public static bool load_save_on_start = false;

	public static bool load_save_from_path = false;

	public static string load_test_save_path = "";

	public static bool load_test_map = false;

	public static int load_save_on_start_slot = 1;

	public static string auto_test_on_start = null;

	public static float LOAD_TIME_INIT = 0f;

	public static float LOAD_TIME_CREATE = 0f;

	public static float LOAD_TIME_GENERATE = 0f;

	public static float LAST_LOAD_TIME = 0f;

	public static bool editor_test_rewards_from_ads = false;

	private static bool _hpr = false;

	public static bool sprite_animations_on = true;

	public static bool shadows_active = false;

	public static bool tooltips_active = true;

	public static bool preload_windows = true;

	public static bool preload_quantum_sprites = true;

	public static bool preload_buildings = true;

	public static bool preload_units = true;

	public static bool autosaves = true;

	public static bool graphs = true;

	public static bool experimental_mode = false;

	public static bool wbb_confirmed = false;

	public static bool full_screen = true;

	public static bool firebase_available = false;

	public static bool upload_available = false;

	public static bool game_loaded = false;

	public static bool show_console_on_start = false;

	public static bool show_console_on_error = true;

	public static bool editor_maxim = false;

	public static bool editor_mastef = false;

	public static bool editor_nikon = false;

	public static bool editor_devs = false;

	public static bool fmod_test_build = false;

	public static bool isEditor = false;

	public static bool isMobile = false;

	public static bool isIos = false;

	public static bool isAndroid = false;

	public static bool isComputer = true;

	public static bool grey_goo_damaged = false;

	public static GodPower power_to_unlock;

	private static string _current_brush = "circ_5";

	public static string selected_trait_editor = string.Empty;

	public static readonly SelectedObjectsGraph selected_objects_graph = new SelectedObjectsGraph();

	private static bool _dragging_item = false;

	public static IDraggable dragging_item_object = null;

	public static Kingdom whisper_A;

	public static Kingdom whisper_B;

	public static Kingdom unity_A;

	public static Kingdom unity_B;

	private static float timer = 30f;

	private static bool skip = false;

	private static List<string> _loggedSelectedPowers = new List<string>();

	private static bool _scheduledGC = false;

	private static bool _scheduledGCUnload = false;

	public static string gv;

	public static bool worldLoading => SmoothLoader.isLoading();

	public static bool paused
	{
		get
		{
			return _paused;
		}
		set
		{
			_paused = value;
		}
	}

	public static bool hasPremium
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if (editor_test_rewards_from_ads)
			{
				return false;
			}
			return _hpr;
		}
		set
		{
			_hpr = value;
		}
	}

	public static string current_brush
	{
		get
		{
			return _current_brush;
		}
		set
		{
			_current_brush = value;
			current_brush_data = Brush.get(value);
		}
	}

	public static BrushData current_brush_data { get; private set; }

	public static bool joyControls => false;

	public static string gs { get; } = "";


	public static void setDraggingObject(IDraggable pGameObject)
	{
		dragging_item_object = pGameObject;
		_dragging_item = true;
	}

	public static bool isDraggingObject(IDraggable pGameObject)
	{
		if (dragging_item_object == null)
		{
			return false;
		}
		if (dragging_item_object == pGameObject)
		{
			return true;
		}
		return false;
	}

	public static IDraggable getDraggingObject()
	{
		return dragging_item_object;
	}

	public static void clearDraggingObject()
	{
		_dragging_item = false;
		dragging_item_object = null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool isDraggingItem()
	{
		return _dragging_item;
	}

	public static void setWorldSpeed(WorldTimeScaleAsset pAsset, bool pUpdateDebug = true)
	{
		if (!pAsset.sonic && pUpdateDebug)
		{
			DebugConfig.setOption(DebugOption.SonicSpeed, pVal: false, pUpdateSpecialSettings: false);
		}
		time_scale_asset = pAsset;
	}

	public static void setWorldSpeed(string pID, bool pUpdateDebug = true)
	{
		setWorldSpeed(AssetManager.time_scales.get(pID), pUpdateDebug);
	}

	public static void nextWorldSpeed(bool pCycle = false)
	{
		setWorldSpeed(time_scale_asset.getNext(pCycle));
	}

	public static void prevWorldSpeed()
	{
		setWorldSpeed(time_scale_asset.getPrevious());
	}

	public static void setPortrait(bool pValue)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Invalid comparison between Unknown and I4
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		if (pValue)
		{
			Screen.autorotateToPortrait = true;
			Screen.autorotateToPortraitUpsideDown = true;
			Screen.autorotateToLandscapeLeft = false;
			Screen.autorotateToLandscapeRight = false;
			if ((int)Input.deviceOrientation == 2)
			{
				Screen.orientation = (ScreenOrientation)2;
			}
			else
			{
				Screen.orientation = (ScreenOrientation)1;
			}
			Screen.orientation = (ScreenOrientation)5;
			World.world.camera.ResetAspect();
		}
		else
		{
			Screen.autorotateToPortrait = false;
			Screen.autorotateToPortraitUpsideDown = false;
			Screen.autorotateToLandscapeLeft = true;
			Screen.autorotateToLandscapeRight = true;
			if ((int)Input.deviceOrientation == 4)
			{
				Screen.orientation = (ScreenOrientation)4;
			}
			else
			{
				Screen.orientation = (ScreenOrientation)3;
			}
			Screen.orientation = (ScreenOrientation)5;
			World.world.camera.ResetAspect();
		}
	}

	public static void setAutorotation(bool pValue)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Expected I4, but got Unknown
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		OptionAsset optionAsset = AssetManager.options_library.get("portrait");
		if (pValue)
		{
			Screen.autorotateToPortrait = true;
			Screen.autorotateToPortraitUpsideDown = true;
			Screen.autorotateToLandscapeLeft = true;
			Screen.autorotateToLandscapeRight = true;
			DeviceOrientation deviceOrientation = Input.deviceOrientation;
			Screen.orientation = (ScreenOrientation)((deviceOrientation - 1) switch
			{
				0 => 1, 
				1 => 2, 
				2 => 3, 
				3 => 4, 
				_ => 1, 
			});
			Screen.orientation = (ScreenOrientation)5;
			optionAsset.interactable = false;
			World.world.camera.ResetAspect();
		}
		else
		{
			optionAsset.interactable = true;
			setPortrait(PlayerConfig.optionBoolEnabled("portrait"));
		}
	}

	public static void enableAutoRotation(bool pValue)
	{
	}

	public static bool skipCrashMetadata()
	{
		if (MODDED)
		{
			return true;
		}
		if (experimental_mode)
		{
			return true;
		}
		if ((!gen) ?? false)
		{
			return true;
		}
		return false;
	}

	[Skip]
	[SkipRename]
	[DoNotFake]
	public static void updateCrashMetadata()
	{
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		if (!game_loaded || SmoothLoader.isLoading() || skip)
		{
			return;
		}
		if (timer > 0f)
		{
			timer -= Time.fixedDeltaTime;
			return;
		}
		timer = 30f;
		if (skipCrashMetadata())
		{
			skip = true;
			CrashReportHandler.enableCaptureExceptions = false;
			return;
		}
		CrashReportHandler.enableCaptureExceptions = false;
		try
		{
			if (!string.IsNullOrEmpty(versionCodeText))
			{
				CrashReportHandler.SetUserMetadata("u_versionCodeText", versionCodeText);
			}
			if (!string.IsNullOrEmpty(gitCodeText))
			{
				CrashReportHandler.SetUserMetadata("u_gitCodeText", gitCodeText);
			}
			CrashReportHandler.SetUserMetadata("c_MODDED", MODDED.ToString());
			CrashReportHandler.SetUserMetadata("c_HAVE_PREMIUM", hasPremium.ToString());
			CrashReportHandler.SetUserMetadata("c_game_speed", time_scale_asset.id);
			CrashReportHandler.SetUserMetadata("c_sonic_speed", DebugConfig.isOn(DebugOption.SonicSpeed).ToString());
			CrashReportHandler.SetUserMetadata("c_show_map_names", Zones.showMapNames().ToString());
			if (DebugConfig.instance.debugButton.gameObject.activeSelf)
			{
				CrashReportHandler.SetUserMetadata("c_debug_button", "visible");
			}
			CrashReportHandler.SetUserMetadata("o_camera_lowRes", World.world.quality_changer.isLowRes().ToString());
			CrashReportHandler.SetUserMetadata("o_selected_power", World.world.getSelectedPowerID());
			CrashReportHandler.SetUserMetadata("c_map_mode", World.world.zone_calculator.getCurrentModeDebug().ToString());
			if (ScrollWindow.isWindowActive())
			{
				CrashReportHandler.SetUserMetadata("o_window_open", ScrollWindow.getCurrentWindow().screen_id);
			}
			else
			{
				CrashReportHandler.SetUserMetadata("o_window_open", "false");
			}
			string text = "";
			for (int i = 0; i < _loggedSelectedPowers.Count; i++)
			{
				text = text + _loggedSelectedPowers[i] + ",";
			}
			CrashReportHandler.SetUserMetadata("o_power_history", text);
			CrashReportHandler.SetUserMetadata("map_units", World.world.units.Count.ToString());
			CrashReportHandler.SetUserMetadata("map_buildings", World.world.buildings.Count.ToString());
			CrashReportHandler.SetUserMetadata("map_civ_kingdoms", World.world.kingdoms.Count.ToString());
			CrashReportHandler.SetUserMetadata("map_cultures", World.world.cultures.Count.ToString());
			CrashReportHandler.SetUserMetadata("map_layers", World.world.zone_calculator.zones.Count.ToString());
			CrashReportHandler.SetUserMetadata("map_chunks", World.world.map_chunk_manager.chunks.Length.ToString());
			CrashReportHandler.SetUserMetadata("map_drops_active", World.world.drop_manager.getActiveIndex().ToString());
			CrashReportHandler.SetUserMetadata("map_stackEffects_active", World.world.stack_effects.countActive().ToString());
			try
			{
				ApplicationInstallMode installMode = Application.installMode;
				CrashReportHandler.SetUserMetadata("u_installMode", ((object)(ApplicationInstallMode)(ref installMode)).ToString());
				ApplicationSandboxType sandboxType = Application.sandboxType;
				CrashReportHandler.SetUserMetadata("u_sandboxType", ((object)(ApplicationSandboxType)(ref sandboxType)).ToString());
				GraphicsTier activeTier = Graphics.activeTier;
				CrashReportHandler.SetUserMetadata("g_activeTier", ((object)(GraphicsTier)(ref activeTier)).ToString());
			}
			catch (Exception)
			{
			}
		}
		catch (Exception ex2)
		{
			skip = true;
			Debug.LogError((object)ex2);
			throw;
		}
		CrashReportHandler.enableCaptureExceptions = true;
	}

	public static void logSelectedPower(GodPower pPower)
	{
		if (_loggedSelectedPowers.Count > 5)
		{
			_loggedSelectedPowers.RemoveAt(0);
		}
		_loggedSelectedPowers.Add(pPower.id);
	}

	public static void scheduleGC(string pWhere, bool pUnloadResources = false)
	{
		_scheduledGC = true;
		if (pUnloadResources)
		{
			_scheduledGCUnload = true;
		}
	}

	public static void checkGC()
	{
		if (_scheduledGC)
		{
			forceGC("scheduled", _scheduledGCUnload);
		}
	}

	public static void forceGC(string pWhere, bool pUnloadResources = false)
	{
		if (pUnloadResources)
		{
			Resources.UnloadUnusedAssets();
			GC.Collect(1, GCCollectionMode.Optimized, blocking: false);
		}
		else
		{
			GC.Collect(0, GCCollectionMode.Optimized, blocking: false);
		}
		_scheduledGC = false;
		_scheduledGCUnload = false;
	}

	public static float getScrollToGroupDelay()
	{
		if (!isMobile)
		{
			return 0.4f;
		}
		return 0.55f;
	}

	public static void fireworksCheck(bool pEnabled)
	{
		EVERYTHING_FIREWORKS = pEnabled;
		PlayerConfig.instance.data.fireworksCheck2025 = pEnabled;
		PlayerConfig.saveData();
	}

	public static void valCheck(bool pEnabled)
	{
		PlayerConfig.instance.data.valCheck2025 = pEnabled;
		PlayerConfig.saveData();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void pCheck(bool value)
	{
		PlayerConfig.instance.data.pPossible0507 = value;
		PlayerConfig.saveData();
	}

	public static void magicCheck(bool pEnabled)
	{
		EVERYTHING_MAGIC_COLOR = pEnabled;
		PlayerConfig.instance.data.magicCheck2025 = pEnabled;
		PlayerConfig.saveData();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void givePremium()
	{
		InAppManager.activatePrem();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void removePremium()
	{
		hasPremium = false;
		PlayerConfig.instance.data.premium = false;
		PlayerConfig.saveData();
		PremiumElementsChecker.checkElements();
	}
}
// --- End of File: Config.cs ---



// --- Start of File: Console.cs ---
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.UI;

namespace WorldBoxConsole;

public class Console : MonoBehaviour
{
	private const int MAX_ELEMENTS = 2500;

	private const int MAX_LINES = 25000;

	private const int MAX_CHARS_PER_LINE = 256;

	private static int _line_num = 0;

	private static int _warning_num = 0;

	private static int _error_num = 0;

	private Text _prefab;

	private static Queue<string> _texts = new Queue<string>(2500);

	private static StringBuilder _log = new StringBuilder();

	private static int _error_repeated = 0;

	private static int _warning_repeated = 0;

	private static Dictionary<string, int> _previous_errors = new Dictionary<string, int>();

	private static Dictionary<string, int> _previous_warnings = new Dictionary<string, int>();

	private static HashSet<string> _stacks = new HashSet<string>();

	private RectTransform _text_group;

	private List<Text> _text_obj = new List<Text>();

	private ObjectPoolGenericMono<Text> _pool_texts;

	private static ConcurrentQueue<LogItem> log_queue = new ConcurrentQueue<LogItem>();

	private void Awake()
	{
		ref RectTransform text_group = ref _text_group;
		Transform obj = ((Component)this).transform.Find("Scroll View/Viewport/Content");
		text_group = (RectTransform)(object)((obj is RectTransform) ? obj : null);
		_prefab = ((Component)((Transform)_text_group).Find("CText")).GetComponent<Text>();
		_prefab.text = "";
		_pool_texts = new ObjectPoolGenericMono<Text>(_prefab, (Transform)(object)_text_group);
		((Component)_prefab).gameObject.SetActive(false);
	}

	private void addText()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Text next = _pool_texts.getNext();
		((Object)next).name = "CText " + (_text_obj.Count + 1);
		RectTransform component = ((Component)next).GetComponent<RectTransform>();
		((Transform)component).localScale = Vector3.one;
		((Transform)component).localPosition = Vector3.zero;
		_text_obj.Add(next);
		truncateGameObjects();
	}

	private void truncateGameObjects()
	{
		while (_text_obj.Count > 2500)
		{
			_text_obj[0].text = "";
			_pool_texts.release(_text_obj[0]);
			_text_obj.RemoveAt(0);
		}
	}

	internal static bool hasErrors()
	{
		return _error_num > 0;
	}

	private static void truncateTexts()
	{
		if (_texts.Count > 2500)
		{
			while (_texts.Count > 2500)
			{
				_texts.Dequeue();
			}
			_line_num = 0;
		}
	}

	private void OnEnable()
	{
		if (Config.game_loaded)
		{
			_line_num = 0;
			_text_group.SetBottom(0f);
		}
	}

	private void OnDisable()
	{
		_line_num = 0;
		foreach (Text item in _text_obj)
		{
			item.text = "";
		}
		_pool_texts.clear();
		_text_obj.Clear();
	}

	public void Toggle()
	{
		if (((Component)this).gameObject.activeSelf)
		{
			((Component)this).gameObject.SetActive(false);
		}
		else
		{
			((Component)this).gameObject.SetActive(true);
		}
	}

	public void Hide()
	{
		((Component)this).gameObject.SetActive(false);
	}

	public void Show()
	{
		((Component)this).gameObject.SetActive(true);
	}

	public bool isActive()
	{
		return ((Component)this).gameObject.activeSelf;
	}

	public static void HandleLog(string pLogString, string pStackTrace, LogType pLogType)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (ThreadHelper.isMainThread())
		{
			ProcessLog(pLogString, pStackTrace, pLogType, DateTime.Now);
		}
		else
		{
			log_queue.Enqueue(new LogItem(pLogString, pStackTrace, pLogType));
		}
	}

	public static void ProcessLog(string pLogString, string pStackTrace, LogType pLogType, DateTime pTime)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Expected I4, but got Unknown
		if (pLogString.Contains("FIRAPP_DEFAULT"))
		{
			return;
		}
		if (pLogString.Length > 256 && !pLogString.Contains("</"))
		{
			string[] array = pLogString.Split('\n');
			using StringBuilderPool stringBuilderPool = new StringBuilderPool();
			for (int i = 0; i < array.Length; i++)
			{
				while (array[i].Length > 256)
				{
					stringBuilderPool.Append(array[i].Substring(0, 256));
					stringBuilderPool.Append('\n');
					array[i] = array[i].Substring(256);
				}
				stringBuilderPool.Append(array[i]);
				stringBuilderPool.Append('\n');
			}
			pLogString = stringBuilderPool.ToString();
		}
		pLogString = pLogString.Trim(' ', '\n');
		pLogString = ConsoleFormatter.logFormatter(pLogString);
		switch ((int)pLogType)
		{
		case 0:
		case 1:
		case 4:
			if (_error_num == 0)
			{
				_texts.Enqueue(ConsoleFormatter.addSystemInfo().Trim('\n', ' '));
			}
			if (_previous_errors.ContainsKey(pLogString))
			{
				_previous_errors[pLogString]++;
				_error_repeated++;
				_log.Clear();
				return;
			}
			clearRepeat();
			if (!_stacks.Add(pStackTrace))
			{
				pStackTrace = "";
			}
			_log.Append(ConsoleFormatter.logError(_error_num, pLogString, pStackTrace));
			_previous_errors.Add(pLogString, 1);
			_error_num++;
			break;
		case 2:
			if (_previous_warnings.ContainsKey(pLogString))
			{
				_previous_warnings[pLogString]++;
				_warning_repeated++;
				_log.Clear();
				return;
			}
			clearRepeat();
			_log.Append(ConsoleFormatter.logWarning(_warning_num, pLogString));
			_previous_warnings.Add(pLogString, 1);
			_warning_num++;
			break;
		default:
			clearRepeat();
			_log.Append(pLogString);
			break;
		}
		PrependTime(_log, pTime);
		_texts.Enqueue(_log.ToString().Trim('\n', ' '));
		_log.Clear();
		truncateTexts();
	}

	private static void clearRepeat()
	{
		if (_error_repeated > 0)
		{
			_texts.Enqueue("<color=red>( previous errors repeated " + _error_repeated + " times )</color>");
			if (_error_repeated > 10)
			{
				_texts.Enqueue("<color=red>YOU SHOULD RESTART THE GAME</color>");
			}
			_error_repeated = 0;
		}
		if (_warning_repeated > 0)
		{
			_texts.Enqueue("<color=yellow>( previous warning repeated " + _warning_repeated + " times )</color>");
			_warning_repeated = 0;
		}
	}

	private void Update()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		LogItem result;
		while (log_queue.TryDequeue(out result))
		{
			ProcessLog(result.log, result.stack_trace, result.type, result.time);
		}
		if (_line_num == _texts.Count + _error_repeated + _warning_repeated)
		{
			return;
		}
		string text = string.Join('\n', _texts).Trim('\n', ' ');
		if (_error_repeated > 0)
		{
			text = text + "\n<color=red>( previous errors repeated " + _error_repeated + " times )</color>";
			if (_error_repeated > 10)
			{
				text += "\n<color=red>YOU SHOULD RESTART THE GAME</color>";
			}
		}
		else if (_warning_repeated > 0)
		{
			text = text + "\n<color=yellow>( previous warning repeated " + _warning_repeated + " times )</color>";
		}
		string[] array = text.Split('\n');
		if (array.Length > 25000)
		{
			string[] array2 = new string[25000];
			Array.Copy(array, array.Length - 25000, array2, 0, 25000);
			array = array2;
		}
		int num = -1;
		for (int i = 0; i < array.Length; i++)
		{
			int num2 = Mathf.CeilToInt((float)(i + 1) / 10f) - 1;
			for (int j = _text_obj.Count; j < num2 + 1; j++)
			{
				addText();
			}
			Text val = _text_obj[num2];
			if (num2 != num)
			{
				val.text = "";
				num = num2;
			}
			val.text = val.text + "\n" + array[i].Trim('\n', ' ');
			val.text = val.text.Trim('\n', ' ');
		}
		_line_num = _texts.Count + _error_repeated + _warning_repeated;
	}

	public static void PrependTime(StringBuilder pStringBuilder, DateTime pDateTime)
	{
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("[").Append("<color=white>").Append((pDateTime.Hour < 10) ? "0" : "")
			.Append(pDateTime.Hour)
			.Append("</color>")
			.Append(':')
			.Append("<color=white>")
			.Append((pDateTime.Minute < 10) ? "0" : "")
			.Append(pDateTime.Minute)
			.Append("</color>")
			.Append(':')
			.Append("<color=white>")
			.Append((pDateTime.Second < 10) ? "0" : "")
			.Append(pDateTime.Second)
			.Append("</color>")
			.Append("] ");
		pStringBuilder.Insert(0, stringBuilderPool.string_builder);
	}

	public void openLogsFolder()
	{
		Application.OpenURL("file://" + Application.persistentDataPath);
	}
}
// --- End of File: Console.cs ---



// --- Start of File: ConsoleFormatter.cs ---
using System;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.Rendering;
using db;

namespace WorldBoxConsole;

public class ConsoleFormatter
{
	private static string log;

	private static string start;

	private static string end;

	private static string build = "";

	private static Regex _regex = new Regex("[\\d\\.]+");

	public static string logWarning(int pWarningNum, string pLogString)
	{
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.AppendLine().Append("<color=yellow>--- warning[").Append(pWarningNum)
			.Append("]: ---" + build + "</color>")
			.AppendLine();
		string[] array = pLogString.Trim().Split('\n');
		foreach (string value in array)
		{
			stringBuilderPool.Append("<b><color=cyan>").Append(value).Append("</color></b>")
				.AppendLine();
		}
		return stringBuilderPool.ToString();
	}

	public static string logError(int pErrorNum, string pLogString, string pStackTrace)
	{
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		string text = "";
		try
		{
			text = getShortGameplayStateInfo();
		}
		catch (Exception)
		{
			text = "(gameplay state crashed)";
		}
		string[] array = text.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries);
		foreach (string value in array)
		{
			stringBuilderPool.Append("<size=7><b><color=#df4ec8>").Append(value).Append("</color></b></size>")
				.AppendLine();
		}
		stringBuilderPool.Append("<color=red>--- error[").Append(pErrorNum).Append("]: ---")
			.Append(build)
			.Append("</color>")
			.AppendLine();
		array = pLogString.Trim().Split('\n');
		foreach (string value2 in array)
		{
			stringBuilderPool.Append("<b><color=cyan>").Append(value2).Append("</color></b>")
				.AppendLine();
		}
		if (!string.IsNullOrEmpty(pStackTrace.Trim('\n', ' ')))
		{
			try
			{
				pStackTrace = formatStacktrace(pStackTrace);
			}
			catch (Exception)
			{
			}
			stringBuilderPool.Append("<color=red>--- stack: ---").Append(build).Append("</color>")
				.AppendLine()
				.Append(pStackTrace)
				.AppendLine();
		}
		return stringBuilderPool.ToString();
	}

	public static string addSystemInfo()
	{
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("-----------").AppendLine().Append("Game Version: <color=white>")
			.Append(Application.version)
			.Append("</color>");
		build = " " + Application.version;
		if (!string.IsNullOrEmpty(Config.versionCodeText))
		{
			stringBuilderPool.Append(" (<color=white>").Append(Config.versionCodeText);
			if (!string.IsNullOrEmpty(Config.gitCodeText))
			{
				stringBuilderPool.Append("@").Append(Config.gitCodeText);
			}
			stringBuilderPool.Append("</color>)");
			build = build + " (" + Config.versionCodeText;
			if (!string.IsNullOrEmpty(Config.gitCodeText))
			{
				build = build + "@" + Config.gitCodeText;
			}
			build += ")";
		}
		build += " ---";
		StringBuilderPool stringBuilderPool2 = stringBuilderPool.AppendLine().Append("Modded: <color=white>").Append(Config.MODDED)
			.Append("</color>")
			.AppendLine()
			.Append("operatingSystemFamily: <color=white>")
			.Append(SystemInfo.operatingSystemFamily)
			.Append("</color>")
			.AppendLine()
			.Append("deviceModel: <color=white>")
			.Append(SystemInfo.deviceModel)
			.Append("</color>")
			.AppendLine()
			.Append("deviceName: <color=white>")
			.Append(SystemInfo.deviceName)
			.Append("</color>")
			.AppendLine()
			.Append("deviceType: <color=white>")
			.Append(SystemInfo.deviceType)
			.Append("</color>")
			.AppendLine()
			.Append("systemMemorySize: <color=white>")
			.Append(SystemInfo.systemMemorySize)
			.Append("</color>")
			.AppendLine()
			.Append("graphicsDeviceID: <color=white>")
			.Append(SystemInfo.graphicsDeviceID)
			.Append("</color>")
			.AppendLine()
			.Append("Graphics.activeTier: <color=white>");
		GraphicsTier activeTier = Graphics.activeTier;
		stringBuilderPool2.Append(((object)(GraphicsTier)(ref activeTier)).ToString()).Append("</color>").AppendLine()
			.Append("GC.GetTotalMemory: <color=white>")
			.Append(GC.GetTotalMemory(forceFullCollection: false) / 1000000 + " mb")
			.Append("</color>")
			.AppendLine()
			.Append("graphicsMemorySize: <color=white>")
			.Append(SystemInfo.graphicsMemorySize)
			.Append("</color>")
			.AppendLine()
			.Append("maxTextureSize: <color=white>")
			.Append(SystemInfo.maxTextureSize)
			.Append("</color>")
			.AppendLine()
			.Append("operatingSystem: <color=white>")
			.Append(SystemInfo.operatingSystem)
			.Append("</color>")
			.AppendLine()
			.Append("processorType: <color=white>")
			.Append(SystemInfo.processorType)
			.Append("</color>")
			.AppendLine()
			.Append("installMode: <color=white>")
			.Append(Application.installMode)
			.Append("</color>")
			.AppendLine()
			.Append("sandboxType: <color=white>")
			.Append(Application.sandboxType)
			.Append("</color>")
			.AppendLine()
			.Append("FPS: <color=white>")
			.Append(FPS.fps)
			.Append("</color>")
			.AppendLine()
			.Append("-----------");
		return stringBuilderPool.ToString();
	}

	public static string logFormatter(string pLogString, string pColor = "white")
	{
		pLogString = pLogString.Trim(' ', '\n');
		if (pLogString != "" && HasDigit(pLogString) && !pLogString.Contains("<color"))
		{
			return _regex.Replace(pLogString, "<color=" + pColor + ">$0</color>");
		}
		return pLogString;
	}

	private static bool HasDigit(string pString)
	{
		for (int i = 0; i < pString.Length; i++)
		{
			if (char.IsDigit(pString[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static string formatStacktrace(string pStackTrace)
	{
		string[] array = pStackTrace.Split('\n');
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].Contains("(at "))
			{
				string[] array2 = array[i].Split(new string[1] { " (at " }, StringSplitOptions.None);
				start = array2[0];
				end = array2[1].Substring(0, array2[1].Length - 1);
			}
			else
			{
				start = array[i];
				end = "";
			}
			if (start.Contains("("))
			{
				string[] array3 = start.Split('(');
				string text = array3[0];
				string text2 = array3[1].Substring(0, array3[1].Length - 1);
				char? c = null;
				if (text.Contains(":"))
				{
					c = ':';
				}
				else if (text.Contains("."))
				{
					c = '.';
				}
				if (c.HasValue)
				{
					string[] array4 = text.Split(c.Value);
					array4[^1] = "<b><color=cyan>" + array4[^1] + "</color></b>";
					text = string.Join(c.Value.ToString(), array4);
				}
				if (text2.Trim() != string.Empty)
				{
					string[] array5 = ((!text2.Contains(",")) ? new string[1] { text2 } : text2.Split(','));
					for (int j = 0; j < array5.Length; j++)
					{
						string text3 = array5[j].Trim();
						if (text3.Contains(' '))
						{
							string[] array6 = text3.Split(' ');
							string text4 = array6[0];
							if (text4.Contains("."))
							{
								text4 = text4.Split('.')[^1];
							}
							string text5 = array6[1];
							array5[j] = "<color=#FFCC1C>" + text4 + "</color> <b><color=cyan>" + text5 + "</color></b>";
						}
						else
						{
							array5[j] = "<color=#FFCC1C>" + text3 + "</color>";
						}
						text2 = string.Join(", ", array5);
					}
				}
				start = text + "(" + text2 + ")";
				while (start.Contains("System."))
				{
					start = start.Replace("System.", string.Empty);
				}
			}
			if (end != string.Empty)
			{
				if (end.Contains("BuiltInPackages/"))
				{
					end = end.Split(new string[1] { "BuiltInPackages/" }, StringSplitOptions.None)[1];
				}
				if (end.Contains("unity/build/"))
				{
					end = end.Split(new string[1] { "unity/build/" }, StringSplitOptions.None)[1];
				}
				if (end.Contains("Unity.app/"))
				{
					end = end.Split(new string[1] { "Unity.app/" }, StringSplitOptions.None)[1];
				}
				if (end.Contains("Export/"))
				{
					end = end.Split(new string[1] { "Export/" }, StringSplitOptions.None)[1];
				}
				if (end.Contains("github/workspace/"))
				{
					end = end.Split(new string[1] { "github/workspace/" }, StringSplitOptions.None)[1];
				}
				if (end.Contains(":"))
				{
					string[] array7 = end.Split(':');
					string[] array8 = array7[^2].Split('/');
					array8[^1] = "<size=7><b><color=cyan>" + array8[^1] + "</color></b></size>";
					array7[^2] = string.Join("/", array8);
					array7[^1] = "<size=7><b><color=cyan>" + array7[^1] + "</color></b></size>";
					end = string.Join(":", array7);
				}
				end = "<size=5> (at " + end + ")</size>";
			}
			array[i] = "<size=7>" + start + "</size>" + end;
		}
		pStackTrace = string.Join("\n", array);
		return pStackTrace;
	}

	private static string getShortGameplayStateInfo()
	{
		MapBox instance = MapBox.instance;
		if ((Object)(object)instance == (Object)null)
		{
			return "(world not loaded)";
		}
		WindowStats debug_window_stats = Config.debug_window_stats;
		bool? flag = instance.quality_changer?.isLowRes();
		string text = PowerButtonSelector.instance?.selectedButton?.godPower?.id;
		string debug_last_selected_power_button = Config.debug_last_selected_power_button;
		bool flag2 = SelectedUnit.isSet();
		bool flag3 = ControllableUnit.isControllingUnit();
		string text2 = Config.time_scale_asset?.id ?? "null";
		int debug_worlds_loaded = Config.debug_worlds_loaded;
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("spd: <H>" + text2 + "</H>");
		if (!string.IsNullOrEmpty(text) || !string.IsNullOrEmpty(debug_last_selected_power_button))
		{
			stringBuilderPool.Append(", ");
			stringBuilderPool.Append("pow: <H>" + (text ?? "none") + "</H>");
			if (debug_last_selected_power_button != text)
			{
				stringBuilderPool.Append(" last: <H>" + (debug_last_selected_power_button ?? "none") + "</H>");
			}
		}
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append("zoom: <H>");
		stringBuilderPool.Append((!flag.HasValue) ? "null" : (flag.Value ? "map" : "full"));
		stringBuilderPool.Append("</H>");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append("win: <H>" + (debug_window_stats.current ?? "none") + "</H> (<H>" + (debug_window_stats.previous ?? "none") + "</H>)");
		stringBuilderPool.Append($" (o:{debug_window_stats.opens},c:{debug_window_stats.closes},s:{debug_window_stats.shows},h:{debug_window_stats.hides})");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"worlds: {debug_worlds_loaded}");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"modded: <H>{Config.MODDED}</H>");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"db pend: <H>{DBInserter.hasCommands()}</H>");
		stringBuilderPool.AppendLine();
		using StringBuilderPool stringBuilderPool2 = new StringBuilderPool();
		foreach (BaseSystemManager list_all_sim_manager in MapBox.instance.list_all_sim_managers)
		{
			string value = list_all_sim_manager.debugShort();
			if (!string.IsNullOrEmpty(value))
			{
				if (stringBuilderPool2.Length > 0)
				{
					stringBuilderPool2.Append(", ");
				}
				stringBuilderPool2.Append(value);
				if (stringBuilderPool2.Length > 78)
				{
					stringBuilderPool.Append(stringBuilderPool2.ToString());
					stringBuilderPool.AppendLine();
					stringBuilderPool2.Clear();
				}
			}
		}
		if (stringBuilderPool2.Length > 0)
		{
			stringBuilderPool.Append(stringBuilderPool2.ToString());
			stringBuilderPool.AppendLine();
		}
		using StringBuilderPool stringBuilderPool3 = new StringBuilderPool();
		if (flag2)
		{
			string text3 = SelectedUnit.unit?.asset?.id;
			stringBuilderPool3.Append("selected: <H>" + text3 + "</H>");
			if (SelectedUnit.multipleSelected())
			{
				int num = SelectedUnit.countSelected();
				stringBuilderPool3.Append($" ({num})");
			}
		}
		if (flag3)
		{
			if (stringBuilderPool3.Length > 0)
			{
				stringBuilderPool3.Append(", ");
			}
			string text4 = ControllableUnit.getControllableUnit()?.asset?.id;
			int num2 = ControllableUnit.count();
			stringBuilderPool3.Append("controlling: <H>" + text4 + "</H>");
			if (num2 > 1)
			{
				stringBuilderPool3.Append($" ({num2})");
			}
		}
		if (stringBuilderPool3.Length > 0)
		{
			stringBuilderPool.Append(stringBuilderPool3.ToString());
			stringBuilderPool.AppendLine();
		}
		return logFormatter(stringBuilderPool.ToString(), "yellow").Replace("<H>", "<color=yellow>").Replace("</H>", "</color>");
	}

	private static string getWindowInfo()
	{
		if (!ScrollWindow.isWindowActive())
		{
			return Config.debug_last_window;
		}
		return ScrollWindow.getCurrentWindow()?.screen_id;
	}
}
// --- End of File: ConsoleFormatter.cs ---



// --- Start of File: ConsoleHelper.cs ---
public static class ConsoleHelper
{
	public static void clearLogConsole()
	{
	}
}
// --- End of File: ConsoleHelper.cs ---



// --- Start of File: ConsonantSeparator.cs ---
using System.Collections.Generic;

public static class ConsonantSeparator
{
	private static HashSet<char> _consonants = new HashSet<char>
	{
		'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',
		'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'
	};

	public static void addRandomVowels(StringBuilderPool pString, string[] pPartsToInsert)
	{
		if (pString.Length < 2)
		{
			return;
		}
		pString.ToLowerInvariant();
		int num = pString.LastIndexOfAny(' ', ',') + 2;
		using ListPool<int> listPool = new ListPool<int>(pString.Length);
		for (int i = num; i < pString.Length; i++)
		{
			if (isConsonant(pString[i - 1]) && isConsonant(pString[i]))
			{
				listPool.Add(i);
			}
		}
		if (listPool.Count != 0)
		{
			int random = OnomasticsLibrary.GetRandom(listPool);
			string random2 = OnomasticsLibrary.GetRandom(pPartsToInsert);
			pString.Insert(random, random2);
		}
	}

	public static ListPool<int> findAllConsonants(StringBuilderPool pString, int pStart, int pLength)
	{
		ListPool<int> listPool = new ListPool<int>(pLength);
		for (int i = pStart; i < pStart + pLength; i++)
		{
			if (isConsonant(pString[i]))
			{
				listPool.Add(i);
			}
		}
		return listPool;
	}

	public static ListPool<int> findAllSingleConsonants(StringBuilderPool pString, int pStart, int pLength)
	{
		ListPool<int> listPool = new ListPool<int>(pLength);
		for (int i = pStart; i < pStart + pLength; i++)
		{
			if (isConsonant(pString[i]) && (i <= 0 || !isConsonant(pString[i - 1])) && (i >= pString.Length - 1 || !isConsonant(pString[i + 1])))
			{
				listPool.Add(i);
			}
		}
		return listPool;
	}

	public static bool isConsonant(char pChar)
	{
		pChar = char.ToLowerInvariant(pChar);
		if (_consonants.Contains(pChar))
		{
			return true;
		}
		if (!char.IsLetter(pChar))
		{
			return false;
		}
		return !VowelSeparator.isVowel(pChar);
	}
}
// --- End of File: ConsonantSeparator.cs ---



// --- Start of File: ConstantineConventer.cs ---
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class ConstantineConventer
{
	private static bool enabled;

	public static void init()
	{
		if (enabled)
		{
			string[] array = Resources.Load<TextAsset>("texts/fmod_sheet").text.Split('\n');
			Debug.Log((object)array[0]);
			List<string> list = new List<string>();
			string text = "";
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string text2 = array2[i].Replace("\r\n", "").Replace("\r", "").Replace("\n", "");
				string text3 = text2.Split('/')[^1];
				string text4 = "\tpublic const string ";
				text4 += text3;
				text4 += " = ";
				text4 += "\"";
				text4 += text2;
				text4 += "\"";
				text4 += ";";
				list.Add(text4);
				text = text + text4 + "\n";
			}
			File.WriteAllText(Application.dataPath + "/Resources/texts/fmod_sheet_converted.txt", text);
		}
	}

	public static void init2()
	{
		string[] array = Resources.Load<TextAsset>("texts/fmod_sheet").text.Split('\n');
		Debug.Log((object)array[0]);
		List<string> list = new List<string>();
		string text = "";
		string text2 = "";
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			string text3 = array2[i].Replace("\r\n", "").Replace("\r", "").Replace("\n", "");
			if (text3.Contains("$"))
			{
				text3 = text3.Replace("$ ", "");
				text3 = text3.Replace("$", "");
				text2 = text3;
				continue;
			}
			if (!text3.Contains("WB_SFX_"))
			{
				text += "\n";
				continue;
			}
			string text4 = "\tpublic const string ";
			text4 += text3;
			text4 += " = ";
			text4 = text4 + text2 + " + ";
			text4 += "\"";
			text4 += text3;
			text4 += "\"";
			text4 += ";";
			list.Add(text4);
			text = text + text4 + "\n";
		}
		File.WriteAllText(Application.dataPath + "/Resources/texts/fmod_sheet_converted.txt", text);
	}
}
// --- End of File: ConstantineConventer.cs ---



// --- Start of File: ConstructionCost.cs ---
using System;
using Beebyte.Obfuscator;

[Serializable]
[ObfuscateLiterals]
public class ConstructionCost
{
	public int wood;

	public int stone;

	public int common_metals;

	public int gold;

	public ConstructionCost(int pWood = 0, int pStone = 0, int pCommonMetals = 0, int pGold = 0)
	{
		wood = pWood;
		stone = pStone;
		common_metals = pCommonMetals;
		gold = pGold;
	}
}
// --- End of File: ConstructionCost.cs ---



// --- Start of File: ConstructionPlacement.cs ---
public enum ConstructionPlacement
{
	OnlyGround,
	OnlyLiquid,
	Everywhere
}
// --- End of File: ConstructionPlacement.cs ---



// --- Start of File: ContainerItemColor.cs ---
using System;
using UnityEngine;

[Serializable]
public class ContainerItemColor
{
	public string color_id;

	public Color color;

	private Material material;

	private string path_material;

	public ContainerItemColor(string pID, string pMaterialPath)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		color = Toolbox.makeColor(pID);
		color_id = pID;
		path_material = pMaterialPath;
	}

	public Material getMaterial()
	{
		if (string.IsNullOrEmpty(path_material))
		{
			return null;
		}
		Material val = Resources.Load<Material>(path_material);
		material = val;
		return material;
	}
}
// --- End of File: ContainerItemColor.cs ---



// --- Start of File: ControllableUnit.cs ---
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public static class ControllableUnit
{
	private const float TOUCH_ATTACK_START_DELAY = 0.05f;

	private static Actor _unit_main = null;

	private static HashSet<Actor> _units = new HashSet<Actor>();

	private static Vector2 _movement_vector;

	private static Vector2 _click_vector;

	private static bool _action_pressed_jump = false;

	private static bool _action_pressed_dash = false;

	private static bool _action_pressed_backstep = false;

	private static bool _action_pressed_steal = false;

	private static bool _action_pressed_swear = false;

	private static bool _action_pressed_talk = false;

	private static bool _attack_pressed_button_left = false;

	private static bool _attack_pressed_button_right = false;

	private static bool _attack_just_pressed_button_left = false;

	private static bool _attack_just_pressed_button_right = false;

	private static float _touch_attack_started_at;

	private static bool _touch_attack_just_started;

	private static string[] _possessed_icons = new string[6] { "ui/Icons/iconBre", "ui/Icons/iconCrying", "ui/Icons/iconAngry", "ui/Icons/actor_traits/iconStupid", "ui/Icons/actor_traits/iconStrongMinded", "ui/Icons/iconDead" };

	public static bool isControllingUnit(Actor pUnit)
	{
		if (!isControllingUnit())
		{
			return false;
		}
		return _units.Contains(pUnit);
	}

	public static HashSet<Actor> getCotrolledUnits()
	{
		return _units;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool isControllingUnit()
	{
		return _units.Any();
	}

	public static int count()
	{
		return _units.Count;
	}

	public static bool isControllingCrabzilla()
	{
		if (isControllingUnit())
		{
			return _unit_main.asset.id == "crabzilla";
		}
		return false;
	}

	public static bool isControllingNormalUnits()
	{
		if (!isControllingUnit())
		{
			return false;
		}
		return _unit_main.asset.show_controllable_tip;
	}

	public static Actor getControllableUnit()
	{
		return _unit_main;
	}

	public static bool isAttackPressedLeft()
	{
		return _attack_pressed_button_left;
	}

	public static bool isAttackPressedRight()
	{
		return _attack_pressed_button_right;
	}

	public static bool isAttackJustPressedLeft()
	{
		return _attack_just_pressed_button_left;
	}

	public static bool isAttackJustPressedRight()
	{
		return _attack_just_pressed_button_right;
	}

	public static void setControllableCreatures(ListPool<Actor> pListActors)
	{
		foreach (ref Actor pListActor in pListActors)
		{
			setControllableCreature(pListActor);
		}
	}

	public static void setControllableCreatureAndSelected(Actor pActor)
	{
		using ListPool<Actor> listPool = new ListPool<Actor>();
		foreach (Actor item in SelectedUnit.getAllSelected())
		{
			if (item.canBePossessed())
			{
				listPool.Add(item);
			}
		}
		setControllableCreatures(listPool);
		setControllableCreature(pActor);
		SelectedUnit.clear();
	}

	public static void setControllableCreatureCrabzilla(Actor pActor)
	{
		setControllableCreature(pActor);
	}

	public static void setControllableCreature(Actor pActor)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if (!pActor.canBePossessed())
		{
			return;
		}
		SelectedUnit.clear();
		_unit_main = pActor;
		_units.Add(pActor);
		addStatus(pActor);
		if (isControllingUnit())
		{
			Config.setWorldSpeed("x1");
			Config.paused = false;
		}
		if (Config.joyControls)
		{
			if (isControllingUnit())
			{
				World.world.joys.SetActive(true);
				if (isControllingCrabzilla())
				{
					UltimateJoystick.EnableJoystick("JoyRight");
					((Component)TouchPossessionController.instance).gameObject.SetActive(false);
				}
				else
				{
					UltimateJoystick.DisableJoystick("JoyRight");
					if (!InputHelpers.mouseSupported)
					{
						((Component)TouchPossessionController.instance).gameObject.SetActive(true);
					}
				}
			}
			else
			{
				World.world.joys.SetActive(false);
			}
			UltimateJoystick.ResetJoysticks();
		}
		else if ((Object)(object)World.world.joys != (Object)null)
		{
			Object.Destroy((Object)(object)World.world.joys, 0.5f);
			World.world.joys = null;
		}
		_movement_vector = Vector2.zero;
		resetClickVector();
		_attack_pressed_button_left = false;
		_attack_pressed_button_right = false;
		_attack_just_pressed_button_left = false;
		_attack_just_pressed_button_right = false;
		if (isControllingNormalUnits() && InputHelpers.mouseSupported)
		{
			PossessionUI.toggle(pState: true);
		}
	}

	private static void resetClickVector()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		_click_vector = Vector2.zero;
	}

	public static Vector2 getMovementVector()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return _movement_vector;
	}

	public static Vector2 getClickVector()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return _click_vector;
	}

	public static bool isActionPressedJump()
	{
		return _action_pressed_jump;
	}

	public static bool isActionPressedTalk()
	{
		return _action_pressed_talk;
	}

	public static bool isActionPressedDash()
	{
		return _action_pressed_dash;
	}

	public static bool isActionPressedBackstep()
	{
		return _action_pressed_backstep;
	}

	public static bool isActionPressedSteal()
	{
		return _action_pressed_steal;
	}

	public static bool isActionPressedSwear()
	{
		return _action_pressed_swear;
	}

	public static void remove(Actor pActor)
	{
		_units.Remove(pActor);
		if (_unit_main == pActor)
		{
			_unit_main = null;
			trySelectNewMain();
		}
	}

	private static void trySelectNewMain()
	{
		if (_units.Count == 0)
		{
			clear();
		}
		else
		{
			_unit_main = _units.GetRandom();
		}
	}

	public static void clear(bool pCallKill = true)
	{
		PossessionUI.toggle(pState: false);
		if (Config.joyControls)
		{
			World.world.joys.SetActive(false);
			UltimateJoystick.ResetJoysticks();
		}
		if (!isControllingUnit())
		{
			return;
		}
		foreach (ref Actor item in new ListPool<Actor>(getCotrolledUnits()))
		{
			Actor current = item;
			current.finishStatusEffect("possessed");
			current.cancelAllBeh();
			current.applyRandomForce();
			current.makeStunned(1f);
			current.makeConfused(6f);
			current.setPossessedMovement(pValue: false);
			if (pCallKill && current.asset.id == "crabzilla")
			{
				current.getHitFullHealth(AttackType.Divine);
			}
		}
		_unit_main = null;
		_units.Clear();
		World.world.selected_buttons.unselectAll();
	}

	public static void updateControllableUnit()
	{
		if (!isControllingUnit())
		{
			return;
		}
		if (InputHelpers.GetAnyMouseButtonUp())
		{
			foreach (Actor cotrolledUnit in getCotrolledUnits())
			{
				cotrolledUnit.resetAttackTimeout();
			}
		}
		updateCamera();
		updateMovementVector();
		updateClick();
		updateMouseAttackPosition();
		checkActions();
		checkPossessionStatus();
	}

	private static bool isAnyActionsPressed()
	{
		if (!_action_pressed_jump && !_action_pressed_dash && !_action_pressed_steal && !_action_pressed_swear && !_action_pressed_talk)
		{
			return _action_pressed_backstep;
		}
		return true;
	}

	private static void checkActions()
	{
		_action_pressed_jump = HotkeyLibrary.action_jump.isJustPressed() || TouchPossessionController.isActionPressedJump();
		_action_pressed_dash = HotkeyLibrary.action_dash.isJustPressed() || TouchPossessionController.isActionPressedDash();
		_action_pressed_backstep = HotkeyLibrary.action_backstep.isJustPressed() || TouchPossessionController.isActionPressedBackStep();
		bool attack_pressed_button_left = _attack_pressed_button_left;
		_action_pressed_steal = HotkeyLibrary.action_steal.isJustPressed() || (attack_pressed_button_left && TouchPossessionController.isSelectedActionSteal());
		_action_pressed_swear = HotkeyLibrary.action_swear.isJustPressed() || (attack_pressed_button_left && TouchPossessionController.isSelectedActionSwear());
		_action_pressed_talk = HotkeyLibrary.action_talk.isJustPressed() || (attack_pressed_button_left && TouchPossessionController.isSelectedActionTalk());
		_attack_just_pressed_button_right = _attack_just_pressed_button_right || (attack_pressed_button_left && TouchPossessionController.isSelectedActionKick());
	}

	private static void updateMouseAttackPosition()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		resetClickVector();
		if (!InputHelpers.mouseSupported && Input.touchSupported)
		{
			_click_vector = getTouchAttackPosition();
		}
		else
		{
			_click_vector = World.world.getMousePos();
		}
	}

	private static bool getAttackTouch(out Touch pTouch)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		pTouch = default(Touch);
		if (World.world.player_control.already_used_zoom)
		{
			return false;
		}
		UltimateJoystick ultimateJoystick = UltimateJoystick.GetUltimateJoystick("JoyLeft");
		bool joystickState = ultimateJoystick.GetJoystickState();
		int touchId = ultimateJoystick.getTouchId();
		bool result = false;
		Touch[] touches = Input.touches;
		for (int i = 0; i < touches.Length; i++)
		{
			Touch val = touches[i];
			if (!World.world.isTouchOverUI(val) && (!joystickState || ((Touch)(ref val)).fingerId != touchId))
			{
				pTouch = val;
				result = true;
				break;
			}
		}
		return result;
	}

	private static Vector2 getTouchAttackPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = Vector2.zero;
		if (getAttackTouch(out var pTouch))
		{
			result = Vector2.op_Implicit(World.world.camera.ScreenToWorldPoint(Vector2.op_Implicit(((Touch)(ref pTouch)).position)));
		}
		return result;
	}

	private static void checkPossessionStatus()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		if (!(_movement_vector != Vector2.zero) && !_attack_pressed_button_right && !_attack_pressed_button_left && !isAnyActionsPressed())
		{
			return;
		}
		foreach (Actor cotrolledUnit in getCotrolledUnits())
		{
			addStatus(cotrolledUnit);
			cotrolledUnit.stopSleeping();
			fixNextStep(cotrolledUnit);
		}
	}

	private static void fixNextStep(Actor pActor)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		pActor.next_step_position = pActor.next_step_position_possession;
	}

	private static void addStatus(Actor pActor)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (pActor.hasStatus("possessed"))
		{
			flag = true;
		}
		pActor.addStatusEffect("possessed", 10f, pColorEffect: false);
		pActor.cancelAllBeh();
		if (!flag && pActor.hasTag("strong_mind"))
		{
			pActor.spawnSlashYell(World.world.getMousePos());
			pActor.addStatusEffect("swearing", 2f, pColorEffect: false);
			pActor.punchTargetAnimation(Vector2.op_Implicit(World.world.getMousePos()), pFlip: false, pReverse: false, -40f);
			string random = _possessed_icons.GetRandom();
			pActor.forceSocializeTopic(random);
		}
	}

	private static void updateClick()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Invalid comparison between Unknown and I4
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Invalid comparison between Unknown and I4
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Invalid comparison between Unknown and I4
		if (Config.joyControls)
		{
			Touch pTouch;
			if (((Component)UltimateJoystick.GetUltimateJoystick("JoyRight")).gameObject.activeSelf)
			{
				if (_attack_pressed_button_left && !UltimateJoystick.GetJoystickState("JoyRight"))
				{
					_attack_pressed_button_left = false;
				}
				else if (UltimateJoystick.GetTapCount("JoyRight"))
				{
					_attack_pressed_button_left = !_attack_pressed_button_left;
				}
			}
			else if (UltimateJoystick.GetJoystickState("JoyLeft") && Input.touchCount <= 1)
			{
				_attack_pressed_button_left = false;
				_attack_pressed_button_right = false;
				_attack_just_pressed_button_left = false;
				_attack_just_pressed_button_right = false;
			}
			else if (getAttackTouch(out pTouch))
			{
				if ((int)((Touch)(ref pTouch)).phase == 0)
				{
					_touch_attack_started_at = Time.time;
					_touch_attack_just_started = true;
					return;
				}
				_attack_pressed_button_left = (int)((Touch)(ref pTouch)).phase == 2 || (int)((Touch)(ref pTouch)).phase == 1;
				_attack_pressed_button_right = false;
				_attack_just_pressed_button_left = _touch_attack_just_started;
				_attack_just_pressed_button_right = false;
				_touch_attack_just_started = false;
			}
			else
			{
				_attack_pressed_button_left = false;
				_attack_pressed_button_right = false;
				_attack_just_pressed_button_left = false;
				_attack_just_pressed_button_right = false;
			}
		}
		else
		{
			_attack_pressed_button_left = Input.GetMouseButton(0);
			_attack_pressed_button_right = Input.GetMouseButton(1);
			_attack_just_pressed_button_left = Input.GetMouseButtonDown(0);
			_attack_just_pressed_button_right = Input.GetMouseButtonDown(1);
		}
	}

	public static bool isMovementActionActive()
	{
		if (Config.joyControls)
		{
			UltimateJoystick ultimateJoystick = UltimateJoystick.GetUltimateJoystick("JoyLeft");
			if ((Object)(object)ultimateJoystick == (Object)null)
			{
				return false;
			}
			if (ultimateJoystick.GetJoystickState())
			{
				return true;
			}
		}
		else
		{
			if (HotkeyLibrary.up.isHolding())
			{
				return true;
			}
			if (HotkeyLibrary.down.isHolding())
			{
				return true;
			}
			if (HotkeyLibrary.left.isHolding())
			{
				return true;
			}
			if (HotkeyLibrary.right.isHolding())
			{
				return true;
			}
		}
		return false;
	}

	private static void updateMovementVector()
	{
		if (Config.joyControls)
		{
			updateMovementVectorJoystick();
		}
		else
		{
			updateMovementVectorKeyboard();
		}
	}

	private static void updateMovementVectorJoystick()
	{
		if (isMovementActionActive())
		{
			float joyAxisVerticalLeft = getJoyAxisVerticalLeft();
			float joyAxisHorizontalLeft = getJoyAxisHorizontalLeft();
			_movement_vector.x = joyAxisHorizontalLeft;
			_movement_vector.y = joyAxisVerticalLeft;
		}
	}

	private static void updateMovementVectorKeyboard()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		_movement_vector = Vector2.zero;
		if (HotkeyLibrary.up.isHolding())
		{
			_movement_vector.y = 1f;
		}
		else if (HotkeyLibrary.down.isHolding())
		{
			_movement_vector.y = -1f;
		}
		if (HotkeyLibrary.right.isHolding())
		{
			_movement_vector.x = 1f;
		}
		else if (HotkeyLibrary.left.isHolding())
		{
			_movement_vector.x = -1f;
		}
	}

	public static void updateCamera()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector2 current_position = _unit_main.current_position;
		Vector3 position = ((Component)World.world.camera).transform.position;
		position.x = current_position.x;
		position.y = current_position.y;
		float num = 1f / World.world.camera.orthographicSize;
		((Component)World.world.camera).transform.position = Vector3.Lerp(((Component)World.world.camera).transform.position, position, num);
	}

	public static float getJoyAxisVerticalRight()
	{
		return UltimateJoystick.GetVerticalAxis("JoyRight");
	}

	public static float getJoyAxisHorizontalRight()
	{
		return UltimateJoystick.GetHorizontalAxis("JoyRight");
	}

	private static float getJoyAxisVerticalLeft()
	{
		return UltimateJoystick.GetVerticalAxis("JoyLeft");
	}

	private static float getJoyAxisHorizontalLeft()
	{
		return UltimateJoystick.GetHorizontalAxis("JoyLeft");
	}
}
// --- End of File: ControllableUnit.cs ---



// --- Start of File: ConwayLife.cs ---
using System.Collections.Generic;
using UnityEngine;

public class ConwayLife : MapLayer
{
	public static Color32 colorEater = Color32.op_Implicit(new Color(1f, 0.2f, 1f));

	public static Color32 colorCreator;

	public bool makeFlash = true;

	private HashSetWorldTile newList;

	private float nextTickTimer;

	private float nextTickInterval = 0.05f;

	private int decreaseTick;

	private List<WorldTile> toRemove = new List<WorldTile>();

	internal override void create()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		base.create();
		colorCreator = Color32.op_Implicit(Toolbox.makeColor("#3BCC55"));
		hashsetTiles = new HashSetWorldTile();
		newList = new HashSetWorldTile();
	}

	protected override void UpdateDirty(float pElapsed)
	{
		UpdateVisual();
		if (World.world.isPaused())
		{
			return;
		}
		if (nextTickTimer > 0f)
		{
			nextTickTimer -= pElapsed;
			return;
		}
		nextTickTimer = nextTickInterval;
		for (int i = 0; i < Config.time_scale_asset.conway_ticks; i++)
		{
			updateTick();
		}
	}

	private void UpdateVisual()
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (pixels_to_update.Count == 0)
		{
			return;
		}
		foreach (WorldTile item in pixels_to_update)
		{
			if (hashsetTiles.Contains(item))
			{
				if (item.data.conwayType == ConwayType.Eater)
				{
					pixels[item.data.tile_id] = colorEater;
				}
				else if (item.data.conwayType == ConwayType.Creator)
				{
					pixels[item.data.tile_id] = colorCreator;
				}
				else
				{
					pixels[item.data.tile_id] = Toolbox.clear;
				}
			}
			else
			{
				item.data.conwayType = ConwayType.None;
				pixels[item.data.tile_id] = Toolbox.clear;
			}
		}
		pixels_to_update.Clear();
		updatePixels();
	}

	public void remove(WorldTile pTile)
	{
		if (hashsetTiles.Count != 0)
		{
			hashsetTiles.Remove(pTile);
			pixels_to_update.Add(pTile);
			pTile.data.conwayType = ConwayType.None;
		}
	}

	public void add(WorldTile pTile, string pType)
	{
		if (pType == "conway")
		{
			pTile.data.conwayType = ConwayType.Eater;
		}
		else
		{
			pTile.data.conwayType = ConwayType.Creator;
		}
		hashsetTiles.Add(pTile);
		pixels_to_update.Add(pTile);
	}

	private void updateTick()
	{
		if (decreaseTick-- <= 0)
		{
			decreaseTick = 5;
		}
		if (hashsetTiles.Count <= 0 && newList.Count <= 0)
		{
			return;
		}
		newList.Clear();
		foreach (WorldTile hashsetTile in hashsetTiles)
		{
			checkCell(hashsetTile);
			WorldTile[] neighboursAll = hashsetTile.neighboursAll;
			foreach (WorldTile pCell in neighboursAll)
			{
				checkCell(pCell);
			}
		}
		HashSetWorldTile hashSetWorldTile = hashsetTiles;
		hashsetTiles = newList;
		newList = hashSetWorldTile;
		UpdateVisual();
	}

	private void makeAlive(WorldTile pCell)
	{
		if (decreaseTick == 5)
		{
			MusicBox.playSound("event:/SFX/UNIQUE/ConwayMove", pCell);
			if (pCell.data.conwayType == ConwayType.Eater)
			{
				MapAction.decreaseTile(pCell, pDamage: true, "destroy_no_flash");
			}
			else
			{
				MapAction.increaseTile(pCell, pDamage: true, "destroy_no_flash");
			}
		}
		newList.Add(pCell);
		if (makeFlash)
		{
			makeFlashh(pCell, 25);
		}
	}

	internal void makeFlashh(WorldTile pCell, int pAmount)
	{
		if (pCell.data.conwayType != ConwayType.None)
		{
			_ = pCell.data.conwayType;
		}
	}

	internal override void clear()
	{
		base.clear();
		newList.Clear();
		hashsetTiles.Clear();
	}

	private void checkCell(WorldTile pCell)
	{
		if (pixels_to_update.Contains(pCell))
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		pixels_to_update.Add(pCell);
		if (pCell.data.conwayType == ConwayType.Eater)
		{
			num2++;
		}
		if (pCell.data.conwayType == ConwayType.Creator)
		{
			num3++;
		}
		WorldTile[] neighboursAll;
		if (hashsetTiles.Contains(pCell))
		{
			neighboursAll = pCell.neighboursAll;
			foreach (WorldTile worldTile in neighboursAll)
			{
				if (hashsetTiles.Contains(worldTile))
				{
					num++;
					if (worldTile.data.conwayType == ConwayType.Creator)
					{
						num3++;
					}
					else if (worldTile.data.conwayType == ConwayType.Eater)
					{
						num2++;
					}
				}
				if (num >= 4)
				{
					if (makeFlash)
					{
						makeFlashh(pCell, 15);
					}
					pCell.data.conwayType = ConwayType.None;
					return;
				}
			}
			if (num == 2 || num == 3)
			{
				if (pCell.data.conwayType == ConwayType.None && (num2 != 0 || num3 != 0))
				{
					if (num2 >= num3)
					{
						pCell.data.conwayType = ConwayType.Eater;
					}
					else
					{
						pCell.data.conwayType = ConwayType.Creator;
					}
				}
				makeAlive(pCell);
			}
			else
			{
				pCell.data.conwayType = ConwayType.None;
			}
			return;
		}
		neighboursAll = pCell.neighboursAll;
		foreach (WorldTile worldTile2 in neighboursAll)
		{
			if (hashsetTiles.Contains(worldTile2))
			{
				num++;
			}
			if (worldTile2.data.conwayType == ConwayType.Eater)
			{
				num2++;
			}
			if (worldTile2.data.conwayType == ConwayType.Creator)
			{
				num3++;
			}
		}
		if (num != 3)
		{
			return;
		}
		if (pCell.data.conwayType == ConwayType.None && (num2 != 0 || num3 != 0))
		{
			if (num2 >= num3)
			{
				pCell.data.conwayType = ConwayType.Eater;
			}
			else
			{
				pCell.data.conwayType = ConwayType.Creator;
			}
		}
		makeAlive(pCell);
	}

	internal void checkKillRange(Vector2Int pPos, int pRad)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (hashsetTiles.Count == 0)
		{
			return;
		}
		toRemove.Clear();
		foreach (WorldTile hashsetTile in hashsetTiles)
		{
			if (Toolbox.DistVec2(hashsetTile.pos, pPos) <= (float)pRad)
			{
				hashsetTile.data.conwayType = ConwayType.None;
				toRemove.Add(hashsetTile);
			}
		}
		foreach (WorldTile item in toRemove)
		{
			remove(item);
		}
	}
}
// --- End of File: ConwayLife.cs ---



// --- Start of File: ConwayType.cs ---
public enum ConwayType
{
	Eater,
	Creator,
	None
}
// --- End of File: ConwayType.cs ---



// --- Start of File: CoreSystemManager.cs ---
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public abstract class CoreSystemManager<TObject, TData> : SystemManager<TObject, TData>, IEnumerable<TObject>, IEnumerable where TObject : CoreSystemObject<TData>, new() where TData : BaseSystemData, new()
{
	public readonly List<TObject> list = new List<TObject>(512);

	private readonly HashSet<TObject> _hashset = new HashSet<TObject>(512);

	private bool _dirty_list;

	public override int Count => _hashset.Count;

	private void setListDirty()
	{
		_dirty_list = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public IEnumerator<TObject> GetEnumerator()
	{
		return _hashset.GetEnumerator();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public override void checkLists()
	{
		if (_dirty_list)
		{
			_dirty_list = false;
			list.Clear();
			list.AddRange(_hashset);
		}
	}

	public override void loadFromSave(List<TData> pList)
	{
		base.loadFromSave(pList);
		setListDirty();
	}

	protected override void addObject(TObject pObject)
	{
		base.addObject(pObject);
		setListDirty();
		_hashset.Add(pObject);
	}

	public virtual List<TData> save(List<TObject> pList = null)
	{
		if (pList == null)
		{
			pList = this.list;
		}
		List<TData> list = new List<TData>();
		foreach (TObject p in pList)
		{
			if (p.isAlive())
			{
				p.save();
				list.Add(p.data);
			}
		}
		return list;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override void removeObject(TObject pObject)
	{
		base.removeObject(pObject);
		_hashset.Remove(pObject);
		setListDirty();
	}

	public TObject getRandom()
	{
		foreach (TObject item in list.LoopRandom())
		{
			if (_hashset.Contains(item))
			{
				return item;
			}
		}
		return null;
	}

	public override void clear()
	{
		foreach (TObject item in _hashset)
		{
			item.setAlive(pValue: false);
		}
		scheduleToDisposeHashSet(_hashset);
		_hashset.Clear();
		list.Clear();
		setListDirty();
		base.clear();
	}
}
// --- End of File: CoreSystemManager.cs ---



// --- Start of File: CoreSystemObject.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public abstract class CoreSystemObject<TData> : NanoObject, ICoreObject, ILoadable<TData>, IFavoriteable where TData : BaseSystemData
{
	public TData data;

	public virtual BaseSystemManager manager
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	public override string name
	{
		get
		{
			return data.name;
		}
		protected set
		{
			data.name = value;
		}
	}

	public string obsidian_name_id => data.obsidian_name_id;

	public bool isFavorite()
	{
		return data.favorite;
	}

	public void switchFavorite()
	{
		data.favorite = !data.favorite;
	}

	public virtual void setFavorite(bool pState)
	{
		data.favorite = pState;
	}

	public virtual bool updateColor(ColorAsset pColor)
	{
		return false;
	}

	public virtual void save()
	{
		data.save();
	}

	public virtual void loadData(TData pData)
	{
		setData(pData);
		data.load();
	}

	public virtual void setData(TData pData)
	{
		data = pData;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override void setAlive(bool pValue)
	{
		_alive = pValue;
		if (!pValue && data.died_time == 0.0)
		{
			data.died_time = World.world.getCurWorldTime();
		}
	}

	public override bool hasDied()
	{
		return data.died_time > 0.0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public virtual int getAge()
	{
		return Date.getYearsSince(data.created_time);
	}

	public override double getFoundedTimestamp()
	{
		return data.created_time;
	}

	public bool isJustCreated()
	{
		return Math.Abs(data.created_time - World.world.getCurWorldTime()) <= 0.05000000074505806;
	}

	public string getFoundedDate()
	{
		return Date.getDate(data.created_time);
	}

	public string getDiedDate()
	{
		return Date.getDate(data.died_time);
	}

	public string getFoundedYear()
	{
		return Date.getYearDate(data.created_time);
	}

	public string getDiedYear()
	{
		return Date.getYearDate(data.died_time);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int getAgeMonths()
	{
		return Date.getMonthsSince(data.created_time);
	}

	public override void trackName(bool pPostChange = false)
	{
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
		{
			BaseSystemData baseSystemData = data;
			if (baseSystemData.past_names == null)
			{
				baseSystemData.past_names = new List<NameEntry>();
			}
			if (data.past_names.Count == 0)
			{
				NameEntry item = new NameEntry(data.name, pCustom: false, -1, data.created_time);
				data.past_names.Add(item);
			}
			else if (!(data.past_names.Last().name == data.name))
			{
				NameEntry item2 = new NameEntry(data.name, data.custom_name);
				data.past_names.Add(item2);
			}
		}
	}

	public override void Dispose()
	{
		data?.Dispose();
		data = null;
		base.Dispose();
	}

	public sealed override long getID()
	{
		return data.id;
	}

	public string getBirthday()
	{
		return Date.getDate(data.created_time);
	}
}
// --- End of File: CoreSystemObject.cs ---



// --- Start of File: CornerAye.cs ---
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;

public class CornerAye : MonoBehaviour
{
	public static CornerAye instance;

	public Transform sprite;

	private RectTransform _rect;

	private void Awake()
	{
		_rect = ((Component)sprite).GetComponent<RectTransform>();
		reset();
	}

	private void reset()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		_rect.anchoredPosition = new Vector2(100f, 0f);
		ShortcutExtensions.DOKill((Component)(object)((Component)sprite).transform, false);
	}

	private void Start()
	{
		instance = this;
	}

	public void startAye()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Expected O, but got Unknown
		reset();
		float num = 0.3f;
		((Tween)TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOLocalMove(((Component)sprite).transform, default(Vector3), num, false), (Ease)27)).onComplete = new TweenCallback(moveBack);
	}

	private void moveBack()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))._002Ector(100f, 0f);
		float num = 0.3f;
		TweenSettingsExtensions.SetDelay<TweenerCore<Vector3, Vector3, VectorOptions>>(TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOLocalMove(((Component)sprite).transform, val, num, false), (Ease)7), 0.1f);
	}
}
// --- End of File: CornerAye.cs ---



// --- Start of File: CoroutineHelper.cs ---
using UnityEngine;

public static class CoroutineHelper
{
	public static WaitForSecondsRealtime wait_for_0_5_s => new WaitForSecondsRealtime(0.5f);

	public static WaitForSecondsRealtime wait_for_0_01_s => new WaitForSecondsRealtime(0.01f);

	public static WaitForSecondsRealtime wait_for_0_05_s => new WaitForSecondsRealtime(0.05f);

	public static WaitForSecondsRealtime wait_for_0_025_s => new WaitForSecondsRealtime(0.025f);

	public static YieldInstruction wait_for_end_of_frame => (YieldInstruction)new WaitForEndOfFrame();

	public static YieldInstruction wait_for_next_frame => null;
}
// --- End of File: CoroutineHelper.cs ---



// --- Start of File: CorruptedTreeObject.cs ---
using UnityEngine;

public class CorruptedTreeObject : MonoBehaviour
{
	public bool used;
}
// --- End of File: CorruptedTreeObject.cs ---



// --- Start of File: CorruptedTreesManager.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class CorruptedTreesManager : MonoBehaviour
{
	private string currentString = "";

	private List<CorruptedTreeObject> _objects;

	public GameObject win_icon;

	public void Start()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Expected O, but got Unknown
		_objects = new List<CorruptedTreeObject>();
		for (int i = 0; i < ((Component)this).transform.childCount; i++)
		{
			CorruptedTreeObject tObj = ((Component)((Component)this).transform.GetChild(i)).GetComponent<CorruptedTreeObject>();
			_objects.Add(tObj);
			((Component)((Component)tObj).transform.GetChild(0)).gameObject.SetActive(false);
			((UnityEvent)((Component)tObj).GetComponent<Button>().onClick).AddListener((UnityAction)delegate
			{
				click(tObj);
			});
		}
		win_icon.gameObject.SetActive(false);
	}

	public void click(CorruptedTreeObject pObject)
	{
		if (!pObject.used)
		{
			pObject.used = true;
			((Component)((Component)pObject).transform.GetChild(0)).gameObject.SetActive(true);
			((Behaviour)((Component)pObject).GetComponent<Image>()).enabled = false;
			string text = "162534" ?? "";
			currentString += ((Object)((Component)pObject).transform).name;
			text = text.Substring(0, currentString.Length);
			if ("162534".CompareTo(text) == 0)
			{
				win();
			}
			else if (!text.Contains(currentString))
			{
				lost();
			}
		}
	}

	private void win()
	{
		win_icon.gameObject.SetActive(true);
		AchievementLibrary.the_corrupted_trees.check();
	}

	private void lost()
	{
		foreach (CorruptedTreeObject @object in _objects)
		{
			((Component)@object).GetComponent<UiCreature>().click();
		}
	}
}
// --- End of File: CorruptedTreesManager.cs ---



// --- Start of File: CountUpOnClick.cs ---
using System.Globalization;
using System.Linq;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class CountUpOnClick : MonoBehaviour
{
	private const float TWEEN_DURATION = 0.45f;

	[SerializeField]
	private Text _text;

	private Tweener _cur_tween;

	private int _value;

	private string _end = "";

	private bool _value_updated;

	private void Start()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		Button val = default(Button);
		if (!((Component)this).TryGetComponent<Button>(ref val) || (Object)(object)_text == (Object)null)
		{
			((Behaviour)this).enabled = false;
		}
		else if (!_value_updated && !checkString())
		{
			((Behaviour)this).enabled = false;
		}
		else
		{
			((UnityEvent)val.onClick).AddListener(new UnityAction(countAnimation));
		}
	}

	public void setValue(int pValue, string pEnd = "")
	{
		((Behaviour)this).enabled = true;
		_value = pValue;
		_end = pEnd;
		_value_updated = true;
		_text.text = _value.ToText(4) + pEnd;
	}

	private bool checkString()
	{
		string text = _text.text;
		if (!checkIfStringIsLegit(text))
		{
			return false;
		}
		if (!int.TryParse(text, NumberStyles.Any, CultureInfo.CurrentCulture, out _value))
		{
			((Behaviour)this).enabled = false;
			return false;
		}
		return true;
	}

	private bool checkIfStringIsLegit(string pString)
	{
		if (string.IsNullOrEmpty(pString))
		{
			return false;
		}
		if (!pString.All(char.IsDigit))
		{
			return false;
		}
		return true;
	}

	private void countAnimation()
	{
		if (_value_updated)
		{
			_value_updated = false;
		}
		checkDestroyTween();
		_cur_tween = (Tweener)(object)_text.DOUpCounter(0, _value, 0.45f, _end);
	}

	public Text getText()
	{
		return _text;
	}

	private void OnDisable()
	{
		checkDestroyTween();
	}

	private void checkDestroyTween()
	{
		TweenExtensions.Kill((Tween)(object)_cur_tween, true);
		_cur_tween = null;
	}
}
// --- End of File: CountUpOnClick.cs ---



// --- Start of File: CrabArm.cs ---
using System.Collections.Generic;
using UnityEngine;

public class CrabArm : MonoBehaviour
{
	internal Crabzilla crabzilla;

	public SpriteRenderer laser;

	public Transform laserPoint;

	public GameObject joint;

	public List<Sprite> laserSprites;

	public bool mirrored;

	private const float LASER_INTERVAL = 0.07f;

	private float _laser_timer = 0.07f;

	private int _laser_frame_index;

	private void Start()
	{
		((Renderer)laser).enabled = false;
	}

	internal void update(float pElapsed)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = World.world.camera.WorldToScreenPoint(crabzilla.armTarget.transform.position);
		val.z = 5.23f;
		Vector3 val2 = World.world.camera.WorldToScreenPoint(joint.transform.position);
		val.x -= val2.x;
		val.y -= val2.y;
		float num = Mathf.Atan2(val.y, val.x) * 57.29578f + 90f;
		if (mirrored)
		{
			num += 180f;
		}
		joint.transform.rotation = Quaternion.Euler(new Vector3(0f, 0f, num));
		updateLaser(pElapsed);
		if (crabzilla.isBeamEnabled())
		{
			float x = ((Component)laserPoint).transform.position.x;
			float y = ((Component)laserPoint).transform.position.y;
			MusicBox.inst.playDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaLazer", x, y);
			World.world.stack_effects.light_blobs.Add(new LightBlobData
			{
				position = new Vector2(((Component)laser).transform.position.x, ((Component)laser).transform.position.y),
				radius = 1.5f
			});
			if (_laser_frame_index > 6 && _laser_frame_index < 10)
			{
				damageWorld();
			}
		}
	}

	private void damageWorld()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float x = ((Component)laserPoint).transform.position.x;
		float y = ((Component)laserPoint).transform.position.y;
		WorldTile tile = World.world.GetTile((int)x, (int)y);
		if (tile != null)
		{
			MapAction.damageWorld(tile, 4, AssetManager.terraform.get("crab_laser"));
		}
	}

	private void updateLaser(float pTime)
	{
		_laser_timer -= pTime;
		if (crabzilla.isBeamEnabled())
		{
			if (_laser_timer <= 0f)
			{
				_laser_frame_index++;
				if (_laser_frame_index >= 10)
				{
					_laser_frame_index = 6;
				}
			}
		}
		else if (_laser_frame_index != 0)
		{
			_laser_frame_index++;
			if (_laser_frame_index > 13)
			{
				_laser_frame_index = 0;
			}
		}
		if (_laser_timer <= 0f)
		{
			_laser_timer = 0.07f;
		}
		if (((Object)laser.sprite).name != ((Object)laserSprites[_laser_frame_index]).name)
		{
			laser.sprite = laserSprites[_laser_frame_index];
		}
		((Renderer)laser).enabled = _laser_frame_index != 0 || crabzilla.isBeamEnabled();
	}
}
// --- End of File: CrabArm.cs ---



// --- Start of File: CrabBody.cs ---
using UnityEngine;

public class CrabBody : MonoBehaviour
{
}
// --- End of File: CrabBody.cs ---



// --- Start of File: CrabLeg.cs ---
using UnityEngine;

public class CrabLeg : MonoBehaviour
{
	public CrabLegLimbPoint limbPoint;

	internal Crabzilla crabzilla;

	private Vector3 _current_position;

	private Vector3 _target_position;

	private Vector3 _random_pos = Vector3.zero;

	public CrabLegJoint legJoint;

	private Vector3 _target_pos;

	internal void create()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		_target_position = ((Component)limbPoint).transform.position;
		_target_position.z = 0f;
		_current_position = _target_position;
		((Component)this).transform.position = new Vector3(_target_position.x, _target_position.y, 0f);
		((Renderer)((Component)this).GetComponent<SpriteRenderer>()).enabled = false;
	}

	internal void update(float pElapsed)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		float num = Toolbox.DistVec3(_current_position, _target_position);
		_current_position = Vector3.MoveTowards(_current_position, _target_position, 1.5f + num / 5f);
		((Component)this).transform.position = new Vector3(_current_position.x, _current_position.y, 0f);
		_target_pos = ((Component)limbPoint).transform.position + _random_pos;
		if (!legJoint.isAngleOk(-20f, 30f))
		{
			moveLeg();
		}
	}

	public void moveLeg()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		_target_pos = ((Component)limbPoint).transform.position + _random_pos;
		_target_pos.z = 0f;
		_target_position = _target_pos;
		_random_pos.x = Randy.randomFloat(-1f, 1f);
		_random_pos.y = Randy.randomFloat(-1f, 1f);
		Vector2 val = ControllableUnit.getMovementVector();
		if (!ControllableUnit.isMovementActionActive())
		{
			val = Vector2.zero;
		}
		if (val.x != 0f)
		{
			if (val.x > 0f)
			{
				_random_pos.x += 2f;
			}
			else
			{
				_random_pos.x -= 2f;
			}
		}
		if (val.y != 0f)
		{
			if (val.y > 0f)
			{
				_random_pos.y += 2f;
			}
			else
			{
				_random_pos.y -= 2f;
			}
		}
		crabzilla.legMoved();
		WorldTile tile = World.world.GetTile((int)_target_pos.x, (int)_target_pos.y);
		if (tile != null)
		{
			MapAction.damageWorld(tile, 3, AssetManager.terraform.get("crab_step"));
			MusicBox.playSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaFootsteps", tile);
		}
	}
}
// --- End of File: CrabLeg.cs ---



// --- Start of File: CrabLegJoint.cs ---
using UnityEngine;

public class CrabLegJoint : MonoBehaviour
{
	[Header("Joints")]
	public Transform Joint0;

	public Transform Joint1;

	public Transform Hand;

	[Header("Target")]
	public Transform Target;

	private float length0;

	private float length1;

	public float targetDistance;

	public bool mirrored;

	internal Crabzilla crabzilla;

	public float angleMax;

	public float angleMin;

	public float defaultAngle;

	private float atan;

	private float jointAngle0;

	private float jointAngle1;

	public float angle0;

	public float angle1;

	public float groundAngleMin = 50f;

	public float groundAngleMax = 140f;

	internal Transform bodyPoint;

	public float actual_z_pos;

	internal void create()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Expected O, but got Unknown
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		actual_z_pos = ((Component)this).transform.localPosition.z;
		length0 = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Joint1.position));
		length1 = Vector2.Distance(Vector2.op_Implicit(Joint1.position), Vector2.op_Implicit(Hand.position));
		_ = mirrored;
		targetDistance = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Target.position));
		Vector2 val = Vector2.op_Implicit(Target.position - Joint0.position);
		Quaternion rotation = ((Component)crabzilla).transform.rotation;
		atan = 0f - ((Quaternion)(ref rotation)).eulerAngles.z + Mathf.Atan2(val.y, val.x) * 57.29578f;
		float num = (targetDistance * targetDistance + length0 * length0 - length1 * length1) / (2f * targetDistance * length0);
		defaultAngle = Mathf.Acos(num) * 57.29578f;
		angleMin = defaultAngle + 20f;
		angleMax = defaultAngle + 20f;
		GameObject val2 = new GameObject("leg_point_" + ((Object)((Component)this).transform).name);
		val2.transform.position = new Vector3(((Component)this).transform.position.x, ((Component)this).transform.position.y, 0f);
		val2.transform.parent = ((Component)crabzilla.mainBody).transform;
		bodyPoint = val2.transform;
	}

	public bool isAngleOk(float pMinAngle, float pMaxAngle)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		angleMin = defaultAngle + pMinAngle;
		angleMax = defaultAngle + pMaxAngle;
		bool num = Toolbox.inBounds(angle0, angleMin, angleMax);
		Vector2 val = Vector2.op_Implicit(((Component)Joint1).transform.position - ((Component)Hand).transform.position);
		bool flag = Toolbox.inBounds(Mathf.Atan2(val.y, val.x) * 57.29578f, groundAngleMin, groundAngleMax);
		return num && flag;
	}

	internal void LateUpdate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = bodyPoint.position;
		position.z = 0f;
		((Component)this).transform.position = position;
		((Component)this).transform.localPosition = new Vector3(((Component)this).transform.localPosition.x, ((Component)this).transform.localPosition.y, actual_z_pos);
		targetDistance = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Target.position));
		Vector2 val = Vector2.op_Implicit(Target.position - Joint0.position);
		Quaternion rotation = ((Component)crabzilla).transform.rotation;
		atan = 0f - ((Quaternion)(ref rotation)).eulerAngles.z + Mathf.Atan2(val.y, val.x) * 57.29578f;
		if (length0 + length1 < targetDistance)
		{
			jointAngle0 = atan;
			jointAngle1 = 0f;
		}
		else
		{
			float num = (targetDistance * targetDistance + length0 * length0 - length1 * length1) / (2f * targetDistance * length0);
			angle0 = Mathf.Acos(num) * 57.29578f;
			float num2 = (length1 * length1 + length0 * length0 - targetDistance * targetDistance) / (2f * length1 * length0);
			angle1 = Mathf.Acos(num2) * 57.29578f;
			if (mirrored)
			{
				jointAngle0 = atan + angle0;
				jointAngle1 = 180f + angle1;
			}
			else
			{
				jointAngle0 = atan - angle0;
				jointAngle1 = 180f - angle1;
			}
		}
		if (!float.IsNaN(jointAngle0))
		{
			Vector3 localEulerAngles = ((Component)Joint0).transform.localEulerAngles;
			localEulerAngles.z = jointAngle0;
			((Component)Joint0).transform.localEulerAngles = localEulerAngles;
			Vector3 localEulerAngles2 = ((Component)Joint1).transform.localEulerAngles;
			localEulerAngles2.z = jointAngle1;
			((Component)Joint1).transform.localEulerAngles = localEulerAngles2;
		}
	}
}
// --- End of File: CrabLegJoint.cs ---



// --- Start of File: CrabLegLimbPoint.cs ---
using UnityEngine;

public class CrabLegLimbPoint : MonoBehaviour
{
	private void Start()
	{
		((Renderer)((Component)this).GetComponent<SpriteRenderer>()).enabled = false;
	}
}
// --- End of File: CrabLegLimbPoint.cs ---



// --- Start of File: CrabLimb.cs ---
public enum CrabLimb
{
	ArmRight,
	ArmLeft,
	LegRight1,
	LegRight2,
	LegRight3,
	LegLeft1,
	LegLeft2,
	LegLeft3,
	MainBody
}
// --- End of File: CrabLimb.cs ---



// --- Start of File: CrabLimbGroup.cs ---
using System.Collections.Generic;

public class CrabLimbGroup
{
	public CrabLimb crabLimb;

	private CrabLimbItem[] _list;

	private CrabLimbState _dmg_state;

	private Actor actor;

	private float _flicker_timer;

	private const float _flicker_interval = 0.15f;

	public CrabLimbGroup(CrabLimb pCrabLimb, Actor pActor)
	{
		actor = pActor;
		crabLimb = pCrabLimb;
		List<CrabLimbItem> list = new List<CrabLimbItem>();
		CrabLimbItem[] componentsInChildren = actor.avatar.GetComponentsInChildren<CrabLimbItem>(false);
		foreach (CrabLimbItem crabLimbItem in componentsInChildren)
		{
			if (crabLimbItem.crabLimb == crabLimb)
			{
				list.Add(crabLimbItem);
			}
		}
		_list = list.ToArray();
		_dmg_state = CrabLimbState.HighHP;
	}

	internal void update(float pElapsed)
	{
		if (_flicker_timer != 0f)
		{
			_flicker_timer -= pElapsed;
			if (_flicker_timer < 0f)
			{
				_flicker_timer = 0f;
			}
			float pProgress = 1f - _flicker_timer / 0.15f;
			CrabLimbItem[] list = _list;
			for (int i = 0; i < list.Length; i++)
			{
				list[i].flicker(pProgress);
			}
		}
	}

	internal void showDamage()
	{
		if (IsFlickering())
		{
			return;
		}
		int health = actor.getHealth();
		int maxHealth = actor.getMaxHealth();
		if ((float)health > (float)maxHealth * 0.7f)
		{
			if (_dmg_state == CrabLimbState.HighHP)
			{
				return;
			}
			_dmg_state = CrabLimbState.HighHP;
		}
		else if ((float)health > (float)maxHealth * 0.35f)
		{
			if (_dmg_state == CrabLimbState.MedHP)
			{
				return;
			}
			_dmg_state = CrabLimbState.MedHP;
		}
		else
		{
			if (_dmg_state == CrabLimbState.LowHP)
			{
				return;
			}
			_dmg_state = CrabLimbState.LowHP;
		}
		CrabLimbItem[] list = _list;
		for (int i = 0; i < list.Length; i++)
		{
			list[i].stateChange(_dmg_state);
		}
		_flicker_timer = 0.15f;
	}

	internal bool IsFlickering()
	{
		return _flicker_timer > 0f;
	}
}
// --- End of File: CrabLimbGroup.cs ---



// --- Start of File: CrabLimbItem.cs ---
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class CrabLimbItem : MonoBehaviour
{
	public CrabLimb crabLimb;

	public Sprite high_hp;

	public Sprite med_hp;

	public Sprite low_hp;

	internal SpriteRenderer _sprite_renderer;

	private Color _shade;

	private Color _dmg = new Color(1f, 0f, 0f, 1f);

	private void Awake()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		_sprite_renderer = ((Component)this).GetComponent<SpriteRenderer>();
		_sprite_renderer.sprite = high_hp;
		_shade = _sprite_renderer.color;
	}

	internal void stateChange(CrabLimbState pState)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		switch (pState)
		{
		case CrabLimbState.HighHP:
			_sprite_renderer.sprite = high_hp;
			break;
		case CrabLimbState.MedHP:
			_sprite_renderer.sprite = med_hp;
			break;
		case CrabLimbState.LowHP:
			_sprite_renderer.sprite = low_hp;
			break;
		}
		_sprite_renderer.color = _dmg;
	}

	internal void flicker(float pProgress)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		_sprite_renderer.color = Color.Lerp(_dmg, _shade, pProgress);
	}
}
// --- End of File: CrabLimbItem.cs ---



// --- Start of File: CrabLimbState.cs ---
public enum CrabLimbState
{
	HighHP,
	MedHP,
	LowHP
}
// --- End of File: CrabLimbState.cs ---



// --- Start of File: Crabzilla.cs ---
using System;
using UnityEngine;

public class Crabzilla : BaseActorComponent
{
	internal const float HIGH_HP_THRESHOLD = 0.7f;

	internal const float MED_HP_THRESHOLD = 0.35f;

	private CrabLeg[] list_legs;

	private CrabLegJoint[] list_joints;

	private CrabLimbGroup[] list_limbs;

	private int active_limb = -1;

	public CrabBody mainBody;

	internal const float angle0_min = -20f;

	internal const float angle0_max = 30f;

	public GameObject armTarget;

	public GameObject mouthSprite;

	private SpriteAnimation mouthSpriteAnim;

	private bool _beam_enabled;

	private Vector3 bodyRotationTarget;

	private Vector3 bodyRotation;

	private float moveRotationLimit = 5f;

	private Vector3 bodyPosTarget;

	private Vector3 bodyPos;

	private float bodyPosTimeout;

	public CrabArm arm1;

	public CrabArm arm2;

	public float z_pos = 10f;

	internal override void create(Actor pActor)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		base.create(pActor);
		((Component)this).transform.position = Vector2.op_Implicit(actor.current_position);
		bodyPos = new Vector3(0f, 27.8f, 0f);
		bodyPosTarget = new Vector3(0f, 27.8f, 0f);
		mouthSpriteAnim = mouthSprite.GetComponent<SpriteAnimation>();
		createLimbs();
		ControllableUnit.setControllableCreatureCrabzilla(actor);
		if (Config.isMobile)
		{
			WorldTip.showNow("crabzilla_controls_mobile", pTranslate: true, "top", 8f);
		}
		else
		{
			WorldTip.showNow("crabzilla_controls_pc", pTranslate: true, "top", 8f);
		}
		if (Config.joyControls)
		{
			UltimateJoystick.ResetJoysticks();
		}
		Vector3 position = ((Component)this).transform.position;
		position.z = z_pos;
		((Component)this).transform.position = position;
		actor.current_position = Vector2.op_Implicit(((Component)this).transform.position);
	}

	public bool isBeamEnabled()
	{
		return _beam_enabled;
	}

	internal void legMoved()
	{
		if (!(bodyPosTimeout > 0f))
		{
			bodyPosTarget.y = 27.8f + Randy.randomFloat(-3f, 3f);
		}
	}

	public override void update(float pElapsed)
	{
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		if (bodyPosTimeout > 0f)
		{
			bodyPosTimeout -= pElapsed;
		}
		arm1.update(pElapsed);
		arm2.update(pElapsed);
		CrabLeg[] array = list_legs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].update(pElapsed);
		}
		if (isAnyLimbFlickering())
		{
			list_limbs[active_limb].update(pElapsed);
		}
		bool beam_enabled = ControllableUnit.isAttackPressedLeft();
		_beam_enabled = beam_enabled;
		mouthSprite.SetActive(isBeamEnabled());
		if (mouthSprite.gameObject.activeSelf)
		{
			mouthSpriteAnim.update(pElapsed);
			MusicBox.inst.playDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaVoice", actor.current_position.x, actor.current_position.y);
		}
		Vector2 val = ControllableUnit.getMovementVector();
		if (!ControllableUnit.isMovementActionActive())
		{
			val = Vector2.zero;
		}
		if (val.x > 0f)
		{
			bodyRotationTarget.z = moveRotationLimit;
		}
		else if (val.x < 0f)
		{
			bodyRotationTarget.z = 0f - moveRotationLimit;
		}
		else
		{
			bodyRotationTarget.z = 0f;
		}
		float num = World.world.elapsed * 60f;
		bodyRotation = Vector3.MoveTowards(bodyRotation, bodyRotationTarget, 0.7f * num);
		if (val.y > 0f && bodyRotation.z > moveRotationLimit)
		{
			bodyRotation.z = moveRotationLimit;
		}
		else if (val.y < 0f && bodyRotation.z < 0f - moveRotationLimit)
		{
			bodyRotation.z = 0f - moveRotationLimit;
		}
		bodyPos.z = 0f;
		bodyPosTarget.z = 0f;
		((Component)mainBody).transform.localRotation = Quaternion.Euler(bodyRotation);
		bodyPos = Vector2.op_Implicit(Vector2.MoveTowards(Vector2.op_Implicit(bodyPos), Vector2.op_Implicit(bodyPosTarget), 0.7f * num));
		((Component)mainBody).transform.localPosition = bodyPos;
		Vector3 position = ((Component)this).transform.position;
		if (!object.Equals(val, Vector2.zero))
		{
			Vector2 val2 = Vector2.op_Implicit(((Component)this).transform.position);
			val2 = Vector2.MoveTowards(val2, val2 + val * 0.2f * num, 1f * num);
			((Vector3)(ref position))._002Ector(val2.x, val2.y);
			if (position.x < 0f)
			{
				position.x = 0f;
			}
			if (position.y < 0f)
			{
				position.y = 0f;
			}
			if (position.x > (float)MapBox.width)
			{
				position.x = MapBox.width;
			}
			if (position.y > (float)MapBox.height)
			{
				position.y = MapBox.height;
			}
			position.z = z_pos;
		}
		position.x += actor.shake_offset.x;
		position.y += actor.shake_offset.y;
		((Component)this).transform.position = position;
		actor.current_position = Vector2.op_Implicit(((Component)this).transform.position);
		actor.dirty_current_tile = true;
		updateArms();
	}

	private void updateArms()
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (Config.joyControls)
		{
			Vector2 val = Vector2.op_Implicit(armTarget.transform.position);
			float joyAxisVerticalRight = ControllableUnit.getJoyAxisVerticalRight();
			float joyAxisHorizontalRight = ControllableUnit.getJoyAxisHorizontalRight();
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))._002Ector(joyAxisHorizontalRight, joyAxisVerticalRight);
			if (!object.Equals(val2, Vector2.zero))
			{
				val = Vector2.MoveTowards(val, val + val2 * 2f, 1f);
				if (Toolbox.DistVec3(Vector2.op_Implicit(val), ((Component)this).transform.position) > 35f)
				{
					val = Vector2.MoveTowards(Vector2.op_Implicit(((Component)this).transform.position), val, 35f);
				}
			}
			armTarget.transform.position = Vector2.op_Implicit(val);
		}
		else
		{
			Vector3 position = Vector2.op_Implicit(World.world.getMousePos());
			armTarget.transform.position = position;
		}
	}

	private void createLimbs()
	{
		list_joints = ((Component)this).GetComponentsInChildren<CrabLegJoint>(false);
		CrabLegJoint[] array = list_joints;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].crabzilla = this;
		}
		list_legs = ((Component)this).GetComponentsInChildren<CrabLeg>(false);
		CrabLeg[] array2 = list_legs;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].crabzilla = this;
		}
		arm1.crabzilla = this;
		arm2.crabzilla = this;
		list_limbs = new CrabLimbGroup[Enum.GetNames(typeof(CrabLimb)).Length];
		for (int j = 0; j < list_limbs.Length; j++)
		{
			list_limbs[j] = new CrabLimbGroup((CrabLimb)j, actor);
		}
		list_limbs.Shuffle();
		array2 = list_legs;
		foreach (CrabLeg obj in array2)
		{
			obj.create();
			obj.update(World.world.delta_time);
		}
		array = list_joints;
		foreach (CrabLegJoint obj2 in array)
		{
			obj2.create();
			obj2.LateUpdate();
		}
		update(World.world.delta_time);
		array2 = list_legs;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].moveLeg();
		}
	}

	internal static bool getHit(BaseSimObject pSelf, BaseSimObject pAttackedBy = null, WorldTile pTile = null)
	{
		Actor a = pSelf.a;
		Crabzilla actorComponent = a.getActorComponent<Crabzilla>();
		if (a.getHealthRatio() > 0.45f)
		{
			return true;
		}
		actorComponent.ShowLimbDamage();
		return true;
	}

	public void ShowLimbDamage()
	{
		if (!isAnyLimbFlickering())
		{
			active_limb++;
			if (active_limb >= list_limbs.Length)
			{
				active_limb = 0;
				list_limbs.Shuffle();
			}
			actor.startShake(0.05f);
			list_limbs[active_limb].showDamage();
		}
	}

	private bool isAnyLimbFlickering()
	{
		if (active_limb == -1)
		{
			return false;
		}
		if (list_limbs[active_limb].IsFlickering())
		{
			return true;
		}
		return false;
	}
}
// --- End of File: Crabzilla.cs ---



// --- Start of File: CreepWorkerMovementType.cs ---
public enum CreepWorkerMovementType
{
	RandomNeighbourAll,
	RandomNeighbour,
	Direction
}
// --- End of File: CreepWorkerMovementType.cs ---



// --- Start of File: CrowdinSettings.cs ---
public static class CrowdinSettings
{
	public const string API_TOKEN = "-";

	public const string PROJECT_ID = "-";
}
// --- End of File: CrowdinSettings.cs ---



// --- Start of File: CubeNode.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.UI;

public class CubeNode : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IInitializePotentialDragHandler
{
	private const float SCALE_HIGHLIGHTED = 1.6f;

	private const float SCALE_NORMAL = 1f;

	private const float TOOLTIP_SCALE_MIN = 0.4f;

	private const float TOOLTIP_SCALE_MAX = 1f;

	public Vector4 logical_pos;

	internal List<CubeNode> connected_nodes = new List<CubeNode>();

	private List<CubeNodeConnection> connections = new List<CubeNodeConnection>();

	[SerializeField]
	private Image _image;

	[SerializeField]
	private Text _text;

	private CubeOverview _cube_overview;

	internal float render_depth;

	internal float scale_mod_spawn = 1f;

	internal float bonus_scale = 1f;

	internal bool highlighted;

	private float _timer_change;

	private TooltipData _tooltip_data;

	private CubeNodeAssetData _data;

	public BaseUnlockableAsset current_asset => _data.asset;

	private void Start()
	{
		_cube_overview = ((Component)this).gameObject.GetComponentInParent<CubeOverview>();
		initClick();
		initTooltip();
	}

	public void update()
	{
		_timer_change -= Time.deltaTime;
	}

	public void setDebugText(string pText)
	{
		_text.text = pText;
	}

	public void clear()
	{
		connected_nodes.Clear();
		connections.Clear();
		_timer_change = 0f;
	}

	protected void initClick()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		Button val = default(Button);
		if (((Component)this).TryGetComponent<Button>(ref val))
		{
			((UnityEvent)val.onClick).AddListener(new UnityAction(setPressed));
		}
	}

	protected void initTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			Object.Destroy((Object)(object)tipButton);
		}
	}

	private void showTooltip()
	{
		_cube_overview.setLatestTouched(this);
		KnowledgeAsset knowledgeAsset = AssetManager.knowledge_library.get(_data.knowledge_type);
		_tooltip_data = knowledgeAsset.show_tooltip(((Component)this).transform, _data.asset);
	}

	public void setupAsset(CubeNodeAssetData pData)
	{
		if (!(_timer_change > 0f))
		{
			_timer_change = 2f;
			_data = pData;
			_image.sprite = _data.asset.getSprite();
		}
	}

	public void updateTooltip()
	{
		if (highlighted && Tooltip.isShowingFor(((Component)this).transform))
		{
			_tooltip_data.tooltip_scale = Mathf.Lerp(0.4f, 1f, render_depth);
		}
	}

	public void setHighlighted()
	{
		if (!highlighted)
		{
			highlighted = true;
			scale_mod_spawn = 1.6f;
			showTooltip();
		}
	}

	public void setPressed()
	{
		_cube_overview.isDragging();
	}

	public void setColor(Color pColor)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)_image).color = pColor;
	}

	public void addConnection(CubeNode pNode, CubeNodeConnection pConnection)
	{
		connected_nodes.Add(pNode);
		connections.Add(pConnection);
	}

	public void OnInitializePotentialDrag(PointerEventData pEventData)
	{
		CubeOverview cube_overview = _cube_overview;
		if (cube_overview != null)
		{
			((Component)cube_overview).SendMessage("OnInitializePotentialDrag", (object)pEventData);
		}
	}

	public void OnBeginDrag(PointerEventData pEventData)
	{
		CubeOverview cube_overview = _cube_overview;
		if (cube_overview != null)
		{
			((Component)cube_overview).SendMessage("OnBeginDrag", (object)pEventData);
		}
	}

	public void OnDrag(PointerEventData pEventData)
	{
		CubeOverview cube_overview = _cube_overview;
		if (cube_overview != null)
		{
			((Component)cube_overview).SendMessage("OnDrag", (object)pEventData);
		}
	}

	public void OnEndDrag(PointerEventData pEventData)
	{
		CubeOverview cube_overview = _cube_overview;
		if (cube_overview != null)
		{
			((Component)cube_overview).SendMessage("OnEndDrag", (object)pEventData);
		}
	}
}
// --- End of File: CubeNode.cs ---



// --- Start of File: CubeNodeAssetData.cs ---
public class CubeNodeAssetData
{
	public readonly BaseUnlockableAsset asset;

	public readonly string knowledge_type;

	public CubeNodeAssetData(BaseUnlockableAsset pAsset, string pKnowledgeType)
	{
		asset = pAsset;
		knowledge_type = pKnowledgeType;
	}
}
// --- End of File: CubeNodeAssetData.cs ---



// --- Start of File: CubeNodeConnection.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CubeNodeConnection : MonoBehaviour
{
	[SerializeField]
	private Sprite _connection_inner;

	[SerializeField]
	private Sprite _connection_outer;

	public Image image;

	internal CubeNode node_1;

	internal CubeNode node_2;

	internal bool inner_cube;

	internal float mod_light = 1f;

	public void update()
	{
		mod_light -= Time.deltaTime * 2f;
		mod_light = Mathf.Max(0f, mod_light);
	}

	public void setConnection(bool pInner)
	{
		inner_cube = pInner;
		if (pInner)
		{
			image.sprite = _connection_inner;
		}
		else
		{
			image.sprite = _connection_outer;
		}
	}

	public void clear()
	{
		node_1 = null;
		node_2 = null;
		inner_cube = false;
	}
}
// --- End of File: CubeNodeConnection.cs ---



// --- Start of File: CubeOverview.cs ---
using System;
using System.Collections.Generic;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class CubeOverview : MonoBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IDragHandler, IEndDragHandler
{
	[SerializeField]
	private DragSnapElement _knob_perspective_strength_x;

	[SerializeField]
	private DragSnapElement _knob_perspective_strength_y;

	[SerializeField]
	private DragSnapElement _knob_perspective_strength_z;

	[SerializeField]
	private DragSnapElement _knob_perspective_strength_main;

	[SerializeField]
	private DragSnapElement _knob_warp;

	[SerializeField]
	private DragSnapElement _knob_lense;

	[SerializeField]
	private DragSnapElement _knob_spacing;

	[SerializeField]
	private DragSnapElement _knob_speed_outer;

	[SerializeField]
	private DragSnapElement _knob_speed_inner;

	[SerializeField]
	private DragSnapElement _knob_speed_4d;

	[SerializeField]
	private DragSnapElement _knob_icon_size;

	[SerializeField]
	private DragSnapElement _knob_connection_size;

	[SerializeField]
	private DragSnapElement _knob_reset;

	private CubeNode _active_node;

	[SerializeField]
	private CubeNode _prefab_node;

	[SerializeField]
	private CubeNodeConnection _prefab_connection;

	[SerializeField]
	private RectTransform _parent_connections;

	[SerializeField]
	private RectTransform _parent_nodes;

	[SerializeField]
	private GameObject _object_main;

	private float _offset_target_x = -0.015f;

	private float _offset_target_y = 0.07f;

	private bool _is_dragging;

	private Vector2 _last_mouse_delta;

	private float _offset_x;

	private float _offset_y;

	internal bool highlighted;

	private List<CubeNode> _nodes_by_index = new List<CubeNode>();

	private List<CubeNode> _nodes = new List<CubeNode>();

	private ObjectPoolGenericMono<CubeNode> _pool_nodes;

	private ObjectPoolGenericMono<CubeNodeConnection> _pool_connections;

	private Quaternion _rotation_q = Quaternion.identity;

	private Quaternion _rotation_q_2 = Quaternion.identity;

	private List<CubeNodeAssetData> _all_available_assets = new List<CubeNodeAssetData>();

	private CubeNode _latest_touched_node;

	private KnowledgeAsset _filter_asset;

	private float _angle_4d;

	private const float DRAGGING_SMOOTHING_TIME = 0.1f;

	private const float ROTATION_BOUNDS = 0.7f;

	private const float ROTATION_BOUNDS_MARGIN = 1.05f;

	private const float DRAG_SPEED = 0.46f;

	private const float DRAG_ROTATE_SPEED = 0.005f;

	private const float MIN_NODE_CURSOR_DISTANCE = 40f;

	public float RADIUS_NODE_PLACEMENT = 30f;

	private const float NODE_SCALE_MIN = 0.4f;

	private const float NODE_SCALE_MAX = 1.2f;

	private Color _color_node_back = Toolbox.makeColor("#1D7A74");

	private Color _color_node_front = Toolbox.makeColor("#DDDDDD");

	private Color _node_highlighted = Toolbox.makeColor("#FFFFFF");

	private Color _color_connection_back = Toolbox.makeColor("#1D7A74", 0.5f);

	private Color _color_connection_default = Toolbox.makeColor("#3AFFF5", 1f);

	private const float PERSPECTIVE_STRENGTH_MAIN = 3f;

	private const float PERSPECTIVE_STRENGTH_MAIN_MOD = 1f;

	private const float PERSPECTIVE_STRENGTH_AXIS = 1f;

	private const float SPACING_MOD = 1f;

	private const float SPEED_MOD_OUTER = 0.2f;

	private const float SPEED_MOD_INNER = 0.2f;

	private const float SPEED_MOD_4D = 0.3f;

	private const float MOD_NODE_SIZE = 1f;

	private const float MOD_CONNECTION_SIZE = 1f;

	private const float WARP_MOD = 0f;

	private const float LENSE_MOD = 0f;

	private const float FOLD_MOD = 0f;

	private float _perspective_strength_main_mod = 1f;

	private float _perspective_strength_main = 3f;

	private float _perspective_strength_x = 1f;

	private float _perspective_strength_y = 1f;

	private float _perspective_strength_z = 1f;

	private float _mod_lense;

	private float _mod_warp;

	private float _spacing_mod = 1f;

	private float _speed_mod_inner = 0.2f;

	private float _speed_mod_outer = 0.2f;

	private float _speed_mod_4d = 0.3f;

	private float _mod_node_size = 1f;

	private float _mod_connection_size = 1f;

	public float spacing = 25f;

	private static readonly Vector4[] _hypercube_positions = (Vector4[])(object)new Vector4[16]
	{
		new Vector4(-1f, -1f, -1f, -1f),
		new Vector4(1f, -1f, -1f, -1f),
		new Vector4(-1f, 1f, -1f, -1f),
		new Vector4(1f, 1f, -1f, -1f),
		new Vector4(-1f, -1f, 1f, -1f),
		new Vector4(1f, -1f, 1f, -1f),
		new Vector4(-1f, 1f, 1f, -1f),
		new Vector4(1f, 1f, 1f, -1f),
		new Vector4(-1f, -1f, -1f, 1f),
		new Vector4(1f, -1f, -1f, 1f),
		new Vector4(-1f, 1f, -1f, 1f),
		new Vector4(1f, 1f, -1f, 1f),
		new Vector4(-1f, -1f, 1f, 1f),
		new Vector4(1f, -1f, 1f, 1f),
		new Vector4(-1f, 1f, 1f, 1f),
		new Vector4(1f, 1f, 1f, 1f)
	};

	private static readonly int[,] _hypercube_connections = new int[32, 2]
	{
		{ 0, 1 },
		{ 0, 2 },
		{ 0, 4 },
		{ 0, 8 },
		{ 1, 3 },
		{ 1, 5 },
		{ 1, 9 },
		{ 2, 3 },
		{ 2, 6 },
		{ 2, 10 },
		{ 3, 7 },
		{ 3, 11 },
		{ 4, 5 },
		{ 4, 6 },
		{ 4, 12 },
		{ 5, 7 },
		{ 5, 13 },
		{ 6, 7 },
		{ 6, 14 },
		{ 7, 15 },
		{ 8, 9 },
		{ 8, 10 },
		{ 8, 12 },
		{ 9, 11 },
		{ 9, 13 },
		{ 10, 11 },
		{ 10, 14 },
		{ 11, 15 },
		{ 12, 13 },
		{ 12, 14 },
		{ 13, 15 },
		{ 14, 15 }
	};

	protected void Awake()
	{
		_pool_nodes = new ObjectPoolGenericMono<CubeNode>(_prefab_node, (Transform)(object)_parent_nodes);
		_pool_connections = new ObjectPoolGenericMono<CubeNodeConnection>(_prefab_connection, (Transform)(object)_parent_connections);
	}

	private void initStartPositions()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < _hypercube_positions.Length; i++)
		{
			CubeNodeAssetData random = _all_available_assets.GetRandom();
			CubeNode next = _pool_nodes.getNext();
			next.setupAsset(random);
			next.logical_pos = _hypercube_positions[i];
			next.setDebugText(i.ToString() ?? "");
			((Object)((Component)next).gameObject).name = i.ToString();
			_nodes.Add(next);
			_nodes_by_index.Add(next);
		}
		updateNodesVisual();
	}

	private void prepareConnections()
	{
		for (int i = 0; i < _hypercube_connections.GetLength(0); i++)
		{
			int index = _hypercube_connections[i, 0];
			int index2 = _hypercube_connections[i, 1];
			CubeNode pNode = _nodes_by_index[index];
			CubeNode pNode2 = _nodes_by_index[index2];
			makeConnection(pNode, pNode2);
		}
	}

	private Vector3 project4Dto3D(Vector4 p)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		float num = _perspective_strength_main * _perspective_strength_main_mod;
		float num2 = Mathf.Exp((0f - Mathf.Abs(p.w)) * _mod_lense);
		float num3 = p.w;
		float num4 = Mathf.Sin(num3 * _mod_warp);
		if (_mod_warp > 0f)
		{
			num3 = num4;
		}
		float num5 = num - num3;
		if (Mathf.Abs(num5) < 0.01f)
		{
			num5 = 0.01f * Mathf.Sign(num5);
		}
		float num6 = ((num5 == 0f) ? 0f : (num / num5));
		num6 *= num2;
		return new Vector3(p.x * num6 * _perspective_strength_x, p.y * num6 * _perspective_strength_y, p.z * num6 * _perspective_strength_z);
	}

	private void updateRotationAndSpeeds()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		if (!_is_dragging)
		{
			_angle_4d += Time.deltaTime * _speed_mod_4d;
		}
		if (Input.GetMouseButton(0))
		{
			_perspective_strength_main = Mathf.Lerp(_perspective_strength_main, 4f, 0.1f);
		}
		else
		{
			_perspective_strength_main = Mathf.Lerp(_perspective_strength_main, 3f, 0.1f);
		}
		float num = 0f - _offset_x;
		float num2 = 0f - _offset_y;
		float num3 = _offset_y;
		float num4 = _offset_y;
		if (!_is_dragging)
		{
			num += _speed_mod_inner;
			num2 += _speed_mod_inner;
			num3 += _speed_mod_outer;
			num4 += _speed_mod_outer;
		}
		Quaternion val = Quaternion.Euler(num, num2, 0f);
		_rotation_q = val * _rotation_q;
		Quaternion val2 = Quaternion.Euler(num3, num4, 0f);
		_rotation_q_2 = val2 * _rotation_q_2;
	}

	private void updateNodesVisual()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		float angle_4d = _angle_4d;
		foreach (CubeNode node in _nodes)
		{
			bool num = node.logical_pos.w < 0f;
			float num2 = spacing * _spacing_mod;
			Vector4 p = rotate4D(node.logical_pos, angle_4d);
			Vector3 val = project4Dto3D(p) * num2;
			Vector3 localPosition = (num ? _rotation_q : _rotation_q_2) * val;
			((Component)node).transform.localPosition = localPosition;
			calculateNodeDepth(node, RADIUS_NODE_PLACEMENT);
			updateNodeColorAndScale(node);
		}
		sortNodesByDepth();
	}

	private Vector4 rotate4D(Vector4 pPoint, float pAngle)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Cos(pAngle);
		float num2 = Mathf.Sin(pAngle);
		float num3 = pPoint.x * num - pPoint.w * num2;
		float num4 = pPoint.x * num2 + pPoint.w * num;
		float num5 = pPoint.y * num - pPoint.z * num2;
		float num6 = pPoint.y * num2 + pPoint.z * num;
		return new Vector4(num3, num5, num6, num4);
	}

	protected void OnEnable()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		ShortcutExtensions.DOKill((Component)(object)_object_main.transform, false);
		_object_main.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
		TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(_object_main.transform, 1f, 0.6f), (Ease)27);
		fillAssets();
		clearContent();
		initStartPositions();
		prepareConnections();
		_is_dragging = false;
	}

	private CubeNodeConnection makeConnection(CubeNode pNode1, CubeNode pNode2)
	{
		CubeNodeConnection next = _pool_connections.getNext();
		next.node_1 = pNode1;
		next.node_2 = pNode2;
		pNode1.addConnection(pNode2, next);
		pNode2.addConnection(pNode1, next);
		if (pNode1.logical_pos.w < 0f && pNode2.logical_pos.w < 0f)
		{
			next.setConnection(pInner: true);
		}
		else
		{
			next.setConnection(pInner: false);
		}
		((Object)((Component)next).gameObject).name = "connection " + ((Object)((Component)pNode1).gameObject).name + "-" + ((Object)((Component)pNode2).gameObject).name;
		return next;
	}

	private void fillAssets()
	{
		_all_available_assets.Clear();
		if (_filter_asset != null)
		{
			loadUnlockables(_filter_asset.get_library(), _filter_asset.id);
			_filter_asset = null;
			return;
		}
		loadUnlockables(AssetManager.actor_library, "units");
		loadUnlockables(AssetManager.items, "items");
		loadUnlockables(AssetManager.gene_library, "genes");
		loadUnlockables(AssetManager.traits, "traits");
		loadUnlockables(AssetManager.subspecies_traits, "subspecies_traits");
		loadUnlockables(AssetManager.culture_traits, "culture_traits");
		loadUnlockables(AssetManager.language_traits, "language_traits");
		loadUnlockables(AssetManager.clan_traits, "clan_traits");
		loadUnlockables(AssetManager.religion_traits, "religion_traits");
		loadUnlockables(AssetManager.kingdoms_traits, "kingdom_traits");
		loadUnlockables(AssetManager.plots_library, "plots");
	}

	private void loadUnlockables(ILibraryWithUnlockables pLibrary, string pType)
	{
		foreach (BaseUnlockableAsset item in pLibrary.elements_list)
		{
			if (item.show_in_knowledge_window && !item.isTemplateAsset())
			{
				_all_available_assets.Add(new CubeNodeAssetData(item, pType));
			}
		}
	}

	private void Update()
	{
		if (InputHelpers.mouseSupported || (Object)(object)_latest_touched_node == (Object)null || !Tooltip.isShowingFor(((Component)_latest_touched_node).transform))
		{
			updateRotationAndSpeeds();
		}
		foreach (CubeNode node in _nodes)
		{
			node.update();
		}
		if (!_is_dragging)
		{
			smoothOffsets();
			_active_node = getHighlightedNode();
			highlightNode(_active_node);
		}
		updateNodesVisual();
		updateConnectionPositions();
		updateKnobs();
	}

	private void updateKnobs()
	{
		float num = 0.05f;
		if ((Object)(object)_knob_perspective_strength_main != (Object)null)
		{
			float num2 = _knob_perspective_strength_main.getDragMod() * 0.03f;
			_perspective_strength_main_mod += num2 * num;
			_perspective_strength_main_mod = Mathf.Clamp(_perspective_strength_main_mod, 0.1f, 1f);
		}
		if ((Object)(object)_knob_perspective_strength_x != (Object)null)
		{
			float dragMod = _knob_perspective_strength_x.getDragMod();
			_perspective_strength_x += dragMod * num;
			_perspective_strength_x = Mathf.Clamp(_perspective_strength_x, 0f, 2f);
		}
		if ((Object)(object)_knob_perspective_strength_y != (Object)null)
		{
			float dragMod2 = _knob_perspective_strength_y.getDragMod();
			_perspective_strength_y += dragMod2 * num;
			_perspective_strength_y = Mathf.Clamp(_perspective_strength_y, 0f, 2f);
		}
		if ((Object)(object)_knob_perspective_strength_z != (Object)null)
		{
			float dragMod3 = _knob_perspective_strength_z.getDragMod();
			_perspective_strength_z += dragMod3 * num;
			_perspective_strength_z = Mathf.Clamp(_perspective_strength_z, 0f, 2f);
		}
		if ((Object)(object)_knob_spacing != (Object)null)
		{
			float dragMod4 = _knob_spacing.getDragMod();
			_spacing_mod += dragMod4 * num;
			_spacing_mod = Mathf.Clamp(_spacing_mod, 0f, 3f);
		}
		if ((Object)(object)_knob_warp != (Object)null)
		{
			float dragMod5 = _knob_warp.getDragMod();
			_mod_warp += dragMod5 * num;
			_mod_warp = Mathf.Clamp(_mod_warp, 0f, 10f);
		}
		if ((Object)(object)_knob_lense != (Object)null)
		{
			float dragMod6 = _knob_lense.getDragMod();
			_mod_lense += dragMod6 * num;
			_mod_lense = Mathf.Clamp(_mod_lense, 0f, 2f);
		}
		if ((Object)(object)_knob_speed_outer != (Object)null)
		{
			float dragMod7 = _knob_speed_outer.getDragMod();
			_speed_mod_outer += dragMod7 * num;
			_speed_mod_outer = Mathf.Clamp(_speed_mod_outer, 0f, 20f);
		}
		if ((Object)(object)_knob_speed_inner != (Object)null)
		{
			float dragMod8 = _knob_speed_inner.getDragMod();
			_speed_mod_inner += dragMod8 * num;
			_speed_mod_inner = Mathf.Clamp(_speed_mod_inner, 0f, 20f);
		}
		if ((Object)(object)_knob_connection_size != (Object)null)
		{
			float dragMod9 = _knob_connection_size.getDragMod();
			_mod_connection_size += dragMod9 * num;
			_mod_connection_size = Mathf.Clamp(_mod_connection_size, 0f, 10f);
		}
		if ((Object)(object)_knob_icon_size != (Object)null)
		{
			float dragMod10 = _knob_icon_size.getDragMod();
			_mod_node_size += dragMod10 * num;
			_mod_node_size = Mathf.Clamp(_mod_node_size, 0f, 20f);
		}
		if ((Object)(object)_knob_speed_4d != (Object)null)
		{
			float dragMod11 = _knob_speed_4d.getDragMod();
			_speed_mod_4d += dragMod11 * num;
			_speed_mod_4d = Mathf.Clamp(_speed_mod_4d, 0f, 20f);
		}
		if ((Object)(object)_knob_reset != (Object)null)
		{
			float dragMod12 = _knob_reset.getDragMod();
			dragMod12 = Math.Abs(dragMod12);
			_perspective_strength_main = Mathf.Lerp(_perspective_strength_main, 3f, dragMod12 * num);
			_perspective_strength_x = Mathf.Lerp(_perspective_strength_x, 1f, dragMod12 * num);
			_perspective_strength_y = Mathf.Lerp(_perspective_strength_y, 1f, dragMod12 * num);
			_perspective_strength_z = Mathf.Lerp(_perspective_strength_z, 1f, dragMod12 * num);
			_spacing_mod = Mathf.Lerp(_spacing_mod, 1f, dragMod12 * num);
			_speed_mod_outer = Mathf.Lerp(_speed_mod_outer, 0.2f, dragMod12 * num);
			_speed_mod_inner = Mathf.Lerp(_speed_mod_inner, 0.2f, dragMod12 * num);
			_speed_mod_4d = Mathf.Lerp(_speed_mod_4d, 0.3f, dragMod12 * num);
			_mod_connection_size = Mathf.Lerp(_mod_connection_size, 1f, dragMod12 * num);
			_mod_node_size = Mathf.Lerp(_mod_node_size, 1f, dragMod12 * num);
			_perspective_strength_main_mod = Mathf.Lerp(_perspective_strength_main_mod, 1f, dragMod12 * num);
			_mod_warp = Mathf.Lerp(_mod_warp, 0f, dragMod12 * num);
			_mod_lense = Mathf.Lerp(_mod_lense, 0f, dragMod12 * num);
		}
	}

	private void updateConnectionPositions()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		foreach (CubeNodeConnection item in _pool_connections.getListTotal())
		{
			item.update();
			float num = 1f;
			CubeNode node_ = item.node_1;
			CubeNode node_2 = item.node_2;
			if (item.inner_cube)
			{
				num = 3f;
			}
			if (node_.highlighted || node_2.highlighted)
			{
				num = 6f;
			}
			num *= _mod_connection_size;
			float num2 = ((!(node_.render_depth > node_2.render_depth)) ? node_2.render_depth : node_.render_depth);
			Color color = Color.Lerp(_color_connection_back, _color_connection_default, num2);
			((Graphic)item.image).color = color;
			Vector2 val = Vector2.op_Implicit(((Component)node_).transform.localPosition);
			Vector2 val2 = Vector2.op_Implicit(((Component)node_2).transform.localPosition);
			Vector2 val3 = (val + val2) / 2f;
			((Component)item).transform.localPosition = Vector2.op_Implicit(val3);
			float num3 = Vector3.Distance(Vector2.op_Implicit(val), Vector2.op_Implicit(val2));
			((Component)item).transform.localScale = new Vector3(num3, num, 1f);
			Vector3 val4 = Vector2.op_Implicit(val2 - val);
			float num4 = Mathf.Atan2(val4.y, val4.x) * 57.29578f;
			((Component)item).transform.rotation = Quaternion.Euler(0f, 0f, num4);
		}
	}

	public CubeNodeAssetData getRandom()
	{
		return _all_available_assets.GetRandom();
	}

	public void setLatestTouched(CubeNode pNode)
	{
		_latest_touched_node = pNode;
	}

	public void setFilterAsset(KnowledgeAsset pAsset)
	{
		_filter_asset = pAsset;
	}

	private void highlightAllConnectonsFromDrag(float pLight)
	{
		foreach (CubeNodeConnection item in _pool_connections.getListTotal())
		{
			if (!(item.mod_light > pLight))
			{
				item.mod_light = pLight;
			}
		}
	}

	private void highlightNode(CubeNode pHighlighted = null)
	{
		foreach (CubeNode node in _nodes)
		{
			if (!((Object)(object)node == (Object)(object)pHighlighted) && node.highlighted)
			{
				node.highlighted = false;
				Tooltip.hideTooltipNow();
			}
		}
		pHighlighted?.setHighlighted();
	}

	private CubeNode getClosestNodeToCursor()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		CubeNode result = null;
		float num = float.MaxValue;
		Vector2 val = Vector2.op_Implicit(Input.mousePosition);
		if (!InputHelpers.mouseSupported && InputHelpers.touchCount == 0)
		{
			return _active_node;
		}
		foreach (CubeNode node in _nodes)
		{
			Vector2 val2 = Vector2.op_Implicit(((Component)node).transform.position);
			float num2 = Vector2.Distance(val, val2);
			if (!(num2 > 40f))
			{
				if ((Object)(object)node == (Object)(object)_active_node)
				{
					return node;
				}
				if (num2 < num)
				{
					num = num2;
					result = node;
				}
			}
		}
		return result;
	}

	private void smoothOffsets()
	{
		_offset_x = Mathf.Lerp(_offset_x, _offset_target_x, 0.1f);
		_offset_y = Mathf.Lerp(_offset_y, _offset_target_y, 0.1f);
	}

	internal bool isDragging()
	{
		return _is_dragging;
	}

	private void calculateNodeDepth(CubeNode pElement, float pRadius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float z = ((Component)pElement).transform.localPosition.z;
		float render_depth = Mathf.InverseLerp(0f - pRadius, pRadius, z);
		pElement.render_depth = render_depth;
	}

	private void sortNodesByDepth()
	{
		foreach (CubeNode node in _nodes)
		{
			((Component)node).transform.SetAsLastSibling();
		}
		_nodes.Sort((CubeNode a, CubeNode b) => a.render_depth.CompareTo(b.render_depth));
	}

	private void clearContent()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		foreach (CubeNode node in _nodes)
		{
			node.clear();
		}
		foreach (CubeNodeConnection item in _pool_connections.getListTotal())
		{
			item.clear();
		}
		_rotation_q = Quaternion.identity;
		_rotation_q_2 = Quaternion.identity;
		_pool_connections.clear();
		_pool_nodes.clear();
		_nodes.Clear();
		_nodes_by_index.Clear();
	}

	public void OnDrag(PointerEventData eventData)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		_is_dragging = true;
		Vector2 delta = eventData.delta;
		if (((Vector2)(ref delta)).magnitude > ((Vector2)(ref _last_mouse_delta)).magnitude)
		{
			highlightAllConnectonsFromDrag(0.35f);
		}
		_last_mouse_delta = delta;
		_offset_x = (0f - delta.y) * 0.46f;
		_offset_y = delta.x * 0.46f;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		_is_dragging = false;
		Vector2 delta = eventData.delta;
		_offset_target_x += (0f - delta.y) * 0.005f;
		_offset_target_y += delta.x * 0.005f;
		if (Mathf.Abs(_offset_target_x) > 0.7f || Mathf.Abs(_offset_target_y) > 0.7f)
		{
			if (Mathf.Abs(_offset_target_x) > Mathf.Abs(_offset_target_y))
			{
				_offset_target_y = _offset_target_y / Mathf.Abs(_offset_target_x) * 0.7f;
			}
			else
			{
				_offset_target_x = _offset_target_x / Mathf.Abs(_offset_target_y) * 0.7f;
			}
		}
		_offset_target_x = Mathf.Clamp(_offset_target_x, -0.7f, 0.7f);
		_offset_target_y = Mathf.Clamp(_offset_target_y, -0.7f, 0.7f);
		highlightAllConnectonsFromDrag(1f);
	}

	public void OnInitializePotentialDrag(PointerEventData eventData)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		eventData.useDragThreshold = false;
		_last_mouse_delta = Vector2.zero;
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		_offset_x = (_offset_target_x = 0f);
		_offset_y = (_offset_target_y = 0f);
		Tooltip.hideTooltipNow();
	}

	private void updateNodeColorAndScale(CubeNode pNode)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((!pNode.current_asset.isUnlockedByPlayer()) ? Toolbox.color_black : ((!pNode.highlighted) ? Color.Lerp(_color_node_back, _color_node_front, pNode.render_depth) : Color.Lerp(_color_node_back, _node_highlighted, pNode.render_depth)));
		pNode.setColor(color);
		float num = Mathf.Lerp(0.4f, 1.2f, pNode.render_depth);
		if (Mathf.Approximately(num, 0.4f))
		{
			pNode.setupAsset(getRandom());
		}
		num *= pNode.scale_mod_spawn * pNode.bonus_scale;
		num *= _mod_node_size;
		((Component)pNode).transform.localScale = new Vector3(num, num, num);
		pNode.updateTooltip();
	}

	private CubeNode getHighlightedNode()
	{
		if (_is_dragging)
		{
			return null;
		}
		if (_offset_x > 1.05f || _offset_x < -1.05f)
		{
			return null;
		}
		if (_offset_y > 1.05f || _offset_y < -1.05f)
		{
			return null;
		}
		return getClosestNodeToCursor();
	}
}
// --- End of File: CubeOverview.cs ---



// --- Start of File: Culture.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
using db;

public class Culture : MetaObjectWithTraits<CultureData, CultureTrait>
{
	public const int MAX_LEVEL = 5;

	public readonly List<City> cities = new List<City>();

	public readonly List<Kingdom> kingdoms = new List<Kingdom>();

	public readonly BooksHandler books = new BooksHandler();

	private readonly List<string> _preferred_weapons_craft_subtypes = new List<string>();

	private readonly List<EquipmentAsset> _preferred_weapons_craft_assets = new List<EquipmentAsset>();

	private NameSetAsset _name_set_asset;

	private readonly List<CultureTrait> _traits_town_plan_zones = new List<CultureTrait>();

	private readonly Dictionary<MetaType, OnomasticsData> _onomastics_data = new Dictionary<MetaType, OnomasticsData>();

	protected override MetaType meta_type => MetaType.Culture;

	public override BaseSystemManager manager => World.world.cultures;

	protected override AssetLibrary<CultureTrait> trait_library => AssetManager.culture_traits;

	protected override List<string> default_traits => getActorAsset().default_culture_traits;

	protected override List<string> saved_traits => data.saved_traits;

	protected override string species_id => data.original_actor_asset;

	public void createCulture(Actor pActor, bool pAddDefaultTraits)
	{
		string pName = pActor.generateName(MetaType.Culture, getID());
		setName(pName);
		data.name_culture_id = pActor.culture?.getID() ?? (-1);
		data.original_actor_asset = pActor.asset.id;
		data.creator_city_name = pActor.city?.name;
		data.creator_city_id = pActor.city?.getID() ?? (-1);
		data.creator_name = pActor.getName();
		data.creator_id = pActor.getID();
		data.creator_species_id = pActor.asset.id;
		data.creator_subspecies_name = pActor.subspecies.name;
		data.creator_subspecies_id = pActor.subspecies.getID();
		data.creator_clan_name = pActor.clan?.name;
		data.creator_clan_id = pActor.clan?.getID() ?? (-1);
		data.creator_kingdom_id = pActor.kingdom?.getID() ?? (-1);
		data.creator_kingdom_name = pActor.kingdom?.name;
		data.name_template_set = pActor.asset.name_template_sets.GetRandom();
		books.setMeta(this);
		generateNewMetaObject(pAddDefaultTraits);
		setDirty();
	}

	public void cloneAndEvolveOnomastics(Culture pFrom)
	{
		CultureData cultureData = pFrom.data;
		data.parent_culture_id = pFrom.id;
		data.name_template_set = cultureData.name_template_set;
		pFrom.loadAllOnomasticsData();
		_onomastics_data.Clear();
		foreach (KeyValuePair<MetaType, OnomasticsData> onomastics_datum in pFrom._onomastics_data)
		{
			OnomasticsData onomasticsData = new OnomasticsData();
			onomasticsData.loadFromShortTemplate(onomastics_datum.Value.getShortTemplate());
			OnomasticsEvolver.scramble(onomasticsData);
			_onomastics_data.Add(onomastics_datum.Key, onomasticsData);
		}
	}

	protected override void recalcBaseStats()
	{
		base.recalcBaseStats();
		recalcPreferredWeapons();
		recalcTownPlanTraits();
	}

	private void recalcTownPlanTraits()
	{
		_traits_town_plan_zones.Clear();
		foreach (CultureTrait trait in getTraits())
		{
			if (trait.town_layout_plan)
			{
				_traits_town_plan_zones.Add(trait);
			}
		}
	}

	public void countConversion()
	{
		addRenown(1);
	}

	protected sealed override void setDefaultValues()
	{
		base.setDefaultValues();
	}

	public override void increaseBirths()
	{
		throw new NotImplementedException(GetType().Name);
	}

	public int countCities()
	{
		return cities.Count;
	}

	public int countKingdoms()
	{
		return kingdoms.Count;
	}

	protected override ColorLibrary getColorLibrary()
	{
		return AssetManager.culture_colors_library;
	}

	public bool canUseRoads()
	{
		if (hasTrait("roads"))
		{
			return true;
		}
		return false;
	}

	public void testDebugNewBook()
	{
		if (base.units.Count != 0)
		{
			Actor random = base.units.GetRandom();
			if (random.getCity() != null && random.city.hasBookSlots())
			{
				World.world.books.generateNewBook(random);
			}
		}
	}

	private void recalcPreferredWeapons()
	{
		_preferred_weapons_craft_subtypes.Clear();
		_preferred_weapons_craft_assets.Clear();
		foreach (CultureTrait trait in getTraits())
		{
			if (!trait.is_weapon_trait)
			{
				continue;
			}
			if (trait.related_weapon_subtype_ids != null)
			{
				foreach (string related_weapon_subtype_id in trait.related_weapon_subtype_ids)
				{
					_preferred_weapons_craft_subtypes.Add(related_weapon_subtype_id);
				}
			}
			if (trait.related_weapons_ids == null)
			{
				continue;
			}
			foreach (string related_weapons_id in trait.related_weapons_ids)
			{
				EquipmentAsset equipmentAsset = AssetManager.items.get(related_weapons_id);
				if (equipmentAsset != null)
				{
					_preferred_weapons_craft_assets.Add(equipmentAsset);
				}
			}
		}
	}

	public bool hasPreferredWeaponsToCraft()
	{
		return _preferred_weapons_craft_assets.Count > 0;
	}

	public List<EquipmentAsset> getPreferredWeaponAssets()
	{
		return _preferred_weapons_craft_assets;
	}

	public string getPreferredWeaponSubtypeIDs()
	{
		if (_preferred_weapons_craft_subtypes.Count == 0)
		{
			return null;
		}
		return _preferred_weapons_craft_subtypes.GetRandom();
	}

	public float chanceToGiveTraits()
	{
		return 0.5f;
	}

	public void clearListCities()
	{
		cities.Clear();
	}

	public void clearListKingdoms()
	{
		kingdoms.Clear();
	}

	public void listCity(City pCity)
	{
		cities.Add(pCity);
	}

	public void listKingdom(Kingdom pKingdom)
	{
		kingdoms.Add(pKingdom);
	}

	public override void generateBanner()
	{
		data.banner_decor_id = AssetManager.culture_banners_library.getNewIndexBackground();
		data.banner_element_id = AssetManager.culture_banners_library.getNewIndexIcon();
	}

	public override void save()
	{
		base.save();
		data.saved_traits = getTraitsAsStrings();
		if (_onomastics_data.Count > 0)
		{
			data.onomastics = new Dictionary<MetaType, string>(_onomastics_data.Count);
			{
				foreach (MetaType key in _onomastics_data.Keys)
				{
					OnomasticsData onomasticsData = _onomastics_data[key];
					data.onomastics[key] = onomasticsData.getShortTemplate();
				}
				return;
			}
		}
		data.onomastics?.Clear();
		data.onomastics = null;
	}

	public override void loadData(CultureData pData)
	{
		base.loadData(pData);
		if (!string.IsNullOrEmpty(data.name_template_set) && !AssetManager.name_sets.has(data.name_template_set))
		{
			data.name_template_set = null;
			_name_set_asset = null;
		}
		books.setDirty();
		books.setMeta(this);
		_onomastics_data.Clear();
		if (pData.onomastics == null)
		{
			return;
		}
		foreach (KeyValuePair<MetaType, string> onomastic in pData.onomastics)
		{
			OnomasticsData onomasticsData = new OnomasticsData();
			onomasticsData.loadFromShortTemplate(onomastic.Value);
			_onomastics_data.Add(onomastic.Key, onomasticsData);
		}
	}

	public override void updateDirty()
	{
		foreach (City city in cities)
		{
			city.setStatusDirty();
		}
	}

	public void debug(DebugTool pTool)
	{
		pTool.setText("id:", base.id, 0f, pShowBar: false, 0L);
		pTool.setText("name:", name, 0f, pShowBar: false, 0L);
		pTool.setText("followers:", countUnits(), 0f, pShowBar: false, 0L);
		pTool.setText("cities:", countCities(), 0f, pShowBar: false, 0L);
	}

	internal void updateTitleCenter()
	{
	}

	public Sprite getElementSprite()
	{
		return AssetManager.culture_banners_library.getSpriteIcon(data.banner_element_id);
	}

	public Sprite getDecorSprite()
	{
		return AssetManager.culture_banners_library.getSpriteBackground(data.banner_decor_id);
	}

	public List<long> getBooks()
	{
		return books.getList();
	}

	public override bool isReadyForRemoval()
	{
		if (books.hasBooks())
		{
			return false;
		}
		return base.isReadyForRemoval();
	}

	public override void convertSameSpeciesAroundUnit(Actor pActorMain, bool pOverrideExisting = false)
	{
		foreach (Actor item in getUnitFromChunkForConversion(pActorMain))
		{
			if (pOverrideExisting || !item.hasCulture())
			{
				item.setCulture(this);
			}
		}
	}

	public override void forceConvertSameSpeciesAroundUnit(Actor pActorMain)
	{
		convertSameSpeciesAroundUnit(pActorMain, pOverrideExisting: true);
	}

	public override void Dispose()
	{
		DBInserter.deleteData(getID(), "culture");
		books.clear();
		_preferred_weapons_craft_subtypes.Clear();
		_preferred_weapons_craft_assets.Clear();
		cities.Clear();
		kingdoms.Clear();
		_traits_town_plan_zones.Clear();
		_name_set_asset = null;
		_onomastics_data.Clear();
		base.Dispose();
	}

	public string getNameTemplate(MetaType pType)
	{
		if (_name_set_asset == null)
		{
			if (string.IsNullOrEmpty(data.name_template_set))
			{
				data.name_template_set = getActorAsset().name_template_sets.GetRandom();
			}
			if (string.IsNullOrEmpty(data.name_template_set))
			{
				_name_set_asset = null;
				return AssetManager.name_generator.get(getActorAsset().getNameTemplate(pType)).id;
			}
		}
		_name_set_asset = AssetManager.name_sets.get(data.name_template_set);
		return _name_set_asset.get(pType);
	}

	public void loadAllOnomasticsData()
	{
		foreach (MetaType type in NameSetAsset.getTypes())
		{
			getOnomasticData(type);
		}
	}

	public OnomasticsData getOnomasticData(MetaType pType, bool pReset = false)
	{
		if (!_onomastics_data.TryGetValue(pType, out var value) || pReset)
		{
			if (value == null)
			{
				value = new OnomasticsData();
			}
			else
			{
				value.clearTemplateData();
			}
			string nameTemplate = getNameTemplate(pType);
			if (!string.IsNullOrEmpty(nameTemplate))
			{
				NameGeneratorAsset nameGeneratorAsset = AssetManager.name_generator.get(nameTemplate);
				if (nameGeneratorAsset.hasOnomastics())
				{
					OnomasticsData originalData = OnomasticsCache.getOriginalData(nameGeneratorAsset.onomastics_templates.GetRandom());
					value.cloneFrom(originalData);
				}
				else
				{
					Debug.Log((object)$"no onomastics data found for {nameGeneratorAsset.id} for {pType}");
				}
			}
			if (value.isEmpty())
			{
				Debug.Log((object)("name set asset " + _name_set_asset.id + " doesn't have " + pType));
				Debug.Log((object)"loading from actor");
				string nameTemplate2 = getActorAsset().getNameTemplate(pType);
				NameGeneratorAsset nameGeneratorAsset2 = AssetManager.name_generator.get(nameTemplate2);
				if (nameGeneratorAsset2.hasOnomastics())
				{
					OnomasticsData originalData2 = OnomasticsCache.getOriginalData(nameGeneratorAsset2.onomastics_templates.GetRandom());
					value.cloneFrom(originalData2);
				}
				else
				{
					Debug.Log((object)$"no onomastics data found for {nameGeneratorAsset2.id} for {pType}");
				}
			}
			if (value.isEmpty())
			{
				value.setDebugTest();
				Debug.Log((object)$"no onomastics data found for {_name_set_asset.id} for {pType}, defaulting");
			}
			_onomastics_data[pType] = value;
		}
		return value;
	}

	public bool planAllowsToPlaceBuildingInZone(TileZone pZone, TileZone pCenterZone)
	{
		foreach (CultureTrait traits_town_plan_zone in _traits_town_plan_zones)
		{
			if (!traits_town_plan_zone.passable_zone_checker(pZone, pCenterZone))
			{
				return false;
			}
		}
		return true;
	}

	public bool hasSpecialTownPlans()
	{
		return _traits_town_plan_zones.Count > 0;
	}

	public bool hasTrueRoots()
	{
		return hasTrait("true_roots");
	}

	public bool isPossibleToConvertToOtherMeta()
	{
		return !hasTrueRoots();
	}

	public override bool hasCities()
	{
		return cities.Count > 0;
	}

	public override IEnumerable<City> getCities()
	{
		return cities;
	}

	public override bool hasKingdoms()
	{
		return kingdoms.Count > 0;
	}

	public override IEnumerable<Kingdom> getKingdoms()
	{
		return kingdoms;
	}
}
// --- End of File: Culture.cs ---



// --- Start of File: CultureBanner.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CultureBanner : BannerGeneric<Culture, CultureData>
{
	protected override MetaType meta_type => MetaType.Culture;

	protected override string tooltip_id => "culture";

	protected override void loadPartBackground()
	{
		part_background = ((Component)((Component)this).transform.FindRecursive("Decor")).GetComponent<Image>();
	}

	protected override TooltipData getTooltipData()
	{
		TooltipData tooltipData = base.getTooltipData();
		tooltipData.culture = meta_object;
		return tooltipData;
	}

	protected override void setupBanner()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		base.setupBanner();
		part_icon.sprite = meta_object.getElementSprite();
		part_background.sprite = meta_object.getDecorSprite();
		ColorAsset colorAsset = meta_object.getColor();
		((Graphic)part_icon).color = colorAsset.getColorBanner();
		((Graphic)part_background).color = colorAsset.getColorMainSecond();
		((Graphic)part_frame).color = colorAsset.getColorMainSecond();
	}
}
// --- End of File: CultureBanner.cs ---



// --- Start of File: CultureBannerLibrary.cs ---
using System.Collections.Generic;

public class CultureBannerLibrary : GenericBannerLibrary
{
	public override void init()
	{
		base.init();
		main = add(new BannerAsset
		{
			id = "main",
			icons = new List<string> { "cultures/culture_element_0", "cultures/culture_element_1", "cultures/culture_element_2", "cultures/culture_element_3", "cultures/culture_element_4", "cultures/culture_element_5", "cultures/culture_element_6", "cultures/culture_element_7" },
			backgrounds = new List<string> { "cultures/culture_decor_0", "cultures/culture_decor_1", "cultures/culture_decor_2", "cultures/culture_decor_3", "cultures/culture_decor_4", "cultures/culture_decor_5", "cultures/culture_decor_6", "cultures/culture_decor_7", "cultures/culture_decor_8" }
		});
	}
}
// --- End of File: CultureBannerLibrary.cs ---



// --- Start of File: CultureBookButton.cs ---
using UnityEngine;
using UnityEngine.UI;

public class CultureBookButton : MonoBehaviour
{
	private Book _book;

	public Image cover;

	public Image icon;

	private bool _created;

	private void Start()
	{
		create();
	}

	private void create()
	{
		if (!_created)
		{
			_created = true;
			setupTooltip();
		}
	}

	public void setupTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			tipButton.setHoverAction(showTooltip);
		}
	}

	internal void load(long pBookID)
	{
		Book pBook = World.world.books.get(pBookID);
		load(pBook);
	}

	internal void load(Book pBook)
	{
		_book = pBook;
		BookTypeAsset asset = _book.getAsset();
		string pPath = "books/book_icons/" + asset.path_icons + _book.data.path_icon;
		string pPath2 = "books/book_covers/" + _book.data.path_cover;
		Sprite sprite = SpriteTextureLoader.getSprite(pPath);
		Sprite sprite2 = SpriteTextureLoader.getSprite(pPath2);
		icon.sprite = sprite;
		cover.sprite = sprite2;
		((Object)((Component)this).gameObject).name = _book.getAsset().id;
	}

	private void showTooltip()
	{
		Tooltip.show(((Component)this).gameObject, "book", new TooltipData
		{
			book = _book
		});
	}
}
// --- End of File: CultureBookButton.cs ---



// --- Start of File: CultureColorsLibrary.cs ---
using System;

[Serializable]
public class CultureColorsLibrary : ColorLibrary
{
	public CultureColorsLibrary()
	{
		file_path = "colors/colors_general";
	}

	public override void init()
	{
		base.init();
		useSameColorsFrom(AssetManager.kingdom_colors_library);
	}

	public override bool isColorUsedInWorld(ColorAsset pAsset)
	{
		foreach (Culture culture in World.world.cultures)
		{
			if (checkColor(pAsset, culture.data.color_id))
			{
				return true;
			}
		}
		return base.isColorUsedInWorld(pAsset);
	}
}
// --- End of File: CultureColorsLibrary.cs ---



// --- Start of File: CultureCustomizeWindow.cs ---
public class CultureCustomizeWindow : GenericCustomizeWindow<Culture, CultureData, CultureBanner>
{
	protected override MetaType meta_type => MetaType.Culture;

	protected override Culture meta_object => SelectedMetas.selected_culture;

	protected override void onBannerChange()
	{
		image_banner_option_1.sprite = meta_object.getDecorSprite();
		image_banner_option_2.sprite = meta_object.getElementSprite();
	}
}
// --- End of File: CultureCustomizeWindow.cs ---



// --- Start of File: CultureData.cs ---
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine.Scripting;

[Serializable]
public class CultureData : MetaObjectData
{
	public int banner_decor_id;

	public int banner_element_id;

	public string creator_city_name = string.Empty;

	[DefaultValue(-1L)]
	public long creator_city_id = -1L;

	[DefaultValue(-1L)]
	public long creator_id = -1L;

	public string creator_name = string.Empty;

	public string creator_species_id = string.Empty;

	public string creator_subspecies_name = string.Empty;

	[DefaultValue(-1L)]
	public long creator_subspecies_id = -1L;

	[DefaultValue(-1L)]
	public long creator_kingdom_id = -1L;

	public string creator_kingdom_name = string.Empty;

	[DefaultValue(-1L)]
	public long creator_clan_id = -1L;

	public string creator_clan_name = string.Empty;

	public List<string> saved_traits;

	public double timestamp_last_written_book;

	public Dictionary<MetaType, string> onomastics;

	[JsonProperty("year")]
	[Preserve]
	[Obsolete("not used anymore", false)]
	public int year_obsolete;

	[DefaultValue("")]
	public string name_template_set = "";

	[DefaultValue(-1L)]
	public long parent_culture_id = -1L;

	[JsonProperty(/*Could not decode attribute arguments.*/)]
	public string original_actor_asset { get; set; }

	[Preserve]
	[Obsolete("use .original_actor_asset instead", true)]
	public string race
	{
		set
		{
			if (!string.IsNullOrEmpty(value) && string.IsNullOrEmpty(original_actor_asset))
			{
				original_actor_asset = value;
			}
		}
	}

	public override void Dispose()
	{
		saved_traits?.Clear();
		saved_traits = null;
		onomastics?.Clear();
		onomastics = null;
		base.Dispose();
	}
}
// --- End of File: CultureData.cs ---



// --- Start of File: CultureElement.cs ---
public class CultureElement : WindowMetaElement<Culture, CultureData>
{
	protected Culture culture => meta_object;
}
// --- End of File: CultureElement.cs ---



// --- Start of File: CultureListComponent.cs ---
public class CultureListComponent : ComponentListBase<CultureListElement, Culture, CultureData, CultureListComponent>
{
	protected override MetaType meta_type => MetaType.Culture;

	protected override void setupSortingTabs()
	{
		genericMetaSortByAge(base.sortByAge);
		genericMetaSortByRenown(base.sortByRenown);
		genericMetaSortByPopulation(ComponentListBase<CultureListElement, Culture, CultureData, CultureListComponent>.sortByPopulation);
		genericMetaSortByKills(ComponentListBase<CultureListElement, Culture, CultureData, CultureListComponent>.sortByKills);
		genericMetaSortByDeath(ComponentListBase<CultureListElement, Culture, CultureData, CultureListComponent>.sortByDeaths);
		sorting_tab.tryAddButton("ui/Icons/iconVillages", "sort_by_villages", show, delegate
		{
			current_sort = sortByVillages;
		});
	}

	public static int sortByVillages(Culture pCulture1, Culture pCulture2)
	{
		return pCulture2.countCities().CompareTo(pCulture1.countCities());
	}
}
// --- End of File: CultureListComponent.cs ---



// --- Start of File: CultureListElement.cs ---
using DG.Tweening;
using UnityEngine;
using UnityEngine.UI;

public class CultureListElement : WindowListElementBase<Culture, CultureData>
{
	public Text name;

	public CountUpOnClick textFollowers;

	public CountUpOnClick textCities;

	public CountUpOnClick textRenown;

	public CountUpOnClick textAge;

	public CountUpOnClick textBooks;

	internal override void show(Culture pCulture)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		base.show(pCulture);
		name.text = pCulture.data.name;
		((Graphic)name).color = pCulture.getColor().getColorText();
		textAge.setValue(pCulture.getAge());
		textFollowers.setValue(pCulture.countUnits());
		textRenown.setValue(pCulture.getRenown());
		textCities.setValue(pCulture.countCities());
		textBooks.setValue(pCulture.books.count());
	}

	protected override void OnDisable()
	{
		ShortcutExtensions.DOKill((Component)(object)textFollowers, false);
		ShortcutExtensions.DOKill((Component)(object)textCities, false);
		ShortcutExtensions.DOKill((Component)(object)textRenown, false);
		ShortcutExtensions.DOKill((Component)(object)textAge, false);
		ShortcutExtensions.DOKill((Component)(object)textBooks, false);
		base.OnDisable();
	}

	protected override void tooltipAction()
	{
		Tooltip.show(this, "culture", new TooltipData
		{
			culture = meta_object
		});
	}

	protected override ActorAsset getActorAsset()
	{
		return meta_object.getActorAsset();
	}
}
// --- End of File: CultureListElement.cs ---



// --- Start of File: CultureManager.cs ---
using System.Collections.Generic;

public class CultureManager : MetaSystemManager<Culture, CultureData>
{
	private bool _dirty_kingdoms = true;

	private bool _dirty_cities = true;

	public CultureManager()
	{
		type_id = "culture";
	}

	public Culture newCulture(Actor pFounder, bool pAddDefaultTraits)
	{
		World.world.game_stats.data.culturesCreated++;
		World.world.map_stats.culturesCreated++;
		Culture culture = newObject();
		culture.createCulture(pFounder, pAddDefaultTraits);
		addRandomTraitFromBiomeToCulture(culture, pFounder.current_tile);
		MetaHelper.addRandomTrait(culture, AssetManager.culture_traits);
		return culture;
	}

	public void addRandomTraitFromBiomeToCulture(Culture pCulture, WorldTile pTile)
	{
		pCulture.addRandomTraitFromBiome(pTile, pTile.Type.biome_asset?.spawn_trait_culture, AssetManager.culture_traits);
	}

	public override void removeObject(Culture pObject)
	{
		World.world.game_stats.data.culturesForgotten++;
		World.world.map_stats.culturesForgotten++;
		base.removeObject(pObject);
	}

	protected override void updateDirtyUnits()
	{
		List<Actor> units_only_alive = World.world.units.units_only_alive;
		for (int i = 0; i < units_only_alive.Count; i++)
		{
			Actor actor = units_only_alive[i];
			Culture culture = actor.culture;
			if (culture != null && culture.isDirtyUnits())
			{
				culture.listUnit(actor);
			}
		}
	}

	public void beginChecksKingdoms()
	{
		if (_dirty_kingdoms)
		{
			updateDirtyKingdoms();
		}
		_dirty_kingdoms = false;
	}

	private void updateDirtyKingdoms()
	{
		clearAllKingdomLists();
		foreach (Kingdom kingdom in World.world.kingdoms)
		{
			if (kingdom.hasCulture())
			{
				kingdom.culture.listKingdom(kingdom);
			}
		}
	}

	private void clearAllKingdomLists()
	{
		using IEnumerator<Culture> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.clearListKingdoms();
		}
	}

	public void beginChecksCities()
	{
		if (_dirty_cities)
		{
			updateDirtyCities();
		}
		_dirty_cities = false;
	}

	private void updateDirtyCities()
	{
		clearAllCitiesListst();
		foreach (City city in World.world.cities)
		{
			if (city.hasCulture())
			{
				city.culture.listCity(city);
			}
		}
	}

	private void clearAllCitiesListst()
	{
		using IEnumerator<Culture> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.clearListCities();
		}
	}

	public void setDirtyCities()
	{
		_dirty_cities = true;
	}

	public void setDirtyKingdoms()
	{
		_dirty_kingdoms = true;
	}

	public override bool isLocked()
	{
		if (isUnitsDirty())
		{
			return true;
		}
		if (_dirty_cities)
		{
			return true;
		}
		if (_dirty_kingdoms)
		{
			return true;
		}
		return false;
	}

	public Culture getMainCulture(List<Actor> pUnitList)
	{
		for (int i = 0; i < pUnitList.Count; i++)
		{
			Actor actor = pUnitList[i];
			if (actor.hasCulture())
			{
				Culture culture = actor.culture;
				countMetaObject(culture);
			}
		}
		return getMostUsedMetaObject();
	}

	public override void clear()
	{
		base.clear();
	}
}
// --- End of File: CultureManager.cs ---



// --- Start of File: CultureSelectedContainerTraits.cs ---
using System.Collections.Generic;

public class CultureSelectedContainerTraits : SelectedContainerTraits<CultureTrait, CultureTraitButton, CultureTraitsContainer, CultureTraitsEditor>
{
	protected override MetaType meta_type => MetaType.Culture;

	protected override IReadOnlyCollection<CultureTrait> getTraits()
	{
		return SelectedMetas.selected_culture.getTraits();
	}

	protected override bool canEditTraits()
	{
		return true;
	}
}
// --- End of File: CultureSelectedContainerTraits.cs ---



// --- Start of File: CultureSelectedOnomasticsNames.cs ---
using UnityEngine;

public class CultureSelectedOnomasticsNames : OnomasticsNameGenerator
{
	[SerializeField]
	private GameObject _main_container;

	[SerializeField]
	private GameObject _separator;

	private Culture _culture;

	private string _last_template;

	private MetaType _meta_type => MetaType.Unit;

	public void load(Culture pCulture)
	{
		string templateString = getTemplateString(pCulture);
		if (_culture != pCulture || !(templateString == _last_template))
		{
			_culture = pCulture;
			_last_template = templateString;
			clickRegenerate();
		}
	}

	public void update()
	{
		bool flag = _culture.isRekt();
		_main_container.SetActive(!flag);
		_separator.SetActive(!flag);
		if (!flag)
		{
			OnomasticsData onomasticData = _culture.getOnomasticData(_meta_type);
			updateNameGeneration(onomasticData);
		}
	}

	public void click()
	{
		clickRegenerate();
	}

	private string getTemplateString(Culture pCulture)
	{
		return pCulture.getOnomasticData(_meta_type).getShortTemplate();
	}
}
// --- End of File: CultureSelectedOnomasticsNames.cs ---



// --- Start of File: CultureStatsElement.cs ---
using System.Collections;
using UnityEngine;

public class CultureStatsElement : CultureElement, IStatsElement, IRefreshElement
{
	private StatsIconContainer _stats_icons;

	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	{
		_stats_icons.setIconValue(pName, pMainVal, pMax, pColor, pFloat, pEnding, pSeparator);
	}

	protected override void Awake()
	{
		_stats_icons = ((Component)this).gameObject.AddOrGetComponent<StatsIconContainer>();
		base.Awake();
	}

	protected override IEnumerator showContent()
	{
		if (base.culture != null && base.culture.isAlive())
		{
			_stats_icons.showGeneralIcons<Culture, CultureData>(base.culture);
			setIconValue("i_cities", base.culture.countCities());
			setIconValue("i_kingdoms", base.culture.countKingdoms());
			setIconValue("i_books", base.culture.books.count());
		}
		yield break;
	}

	GameObject IStatsElement.get_gameObject()
	{
		return ((Component)this).gameObject;
	}
}
// --- End of File: CultureStatsElement.cs ---



// --- Start of File: CultureTrait.cs ---
using System;
using System.Collections.Generic;

[Serializable]
public class CultureTrait : BaseTrait<CultureTrait>
{
	public bool is_weapon_trait;

	public List<string> related_weapon_subtype_ids;

	public List<string> related_weapons_ids;

	public bool town_layout_plan;

	public PassableZoneChecker passable_zone_checker;

	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_culture;

	public override string typed_id => "culture_trait";

	protected override IEnumerable<ITraitsOwner<CultureTrait>> getRelatedMetaList()
	{
		return World.world.cultures;
	}

	public override BaseCategoryAsset getGroup()
	{
		return AssetManager.culture_trait_groups.get(group_id);
	}

	public void addWeaponSpecial(string pID)
	{
		if (related_weapons_ids == null)
		{
			related_weapons_ids = new List<string>();
		}
		related_weapons_ids.Add(pID);
		is_weapon_trait = true;
	}

	public void addWeaponSubtype(string pSubtype)
	{
		if (related_weapon_subtype_ids == null)
		{
			related_weapon_subtype_ids = new List<string>();
		}
		related_weapon_subtype_ids.Add(pSubtype);
		is_weapon_trait = true;
	}

	public void setTownLayoutPlan(PassableZoneChecker pZoneCheckerDelegate)
	{
		town_layout_plan = true;
		passable_zone_checker = pZoneCheckerDelegate;
	}
}
// --- End of File: CultureTrait.cs ---



// --- Start of File: CultureTraitButton.cs ---
public class CultureTraitButton : TraitButton<CultureTrait>
{
	protected override string tooltip_type => "culture_trait";

	internal override void load(string pTraitID)
	{
		CultureTrait pElement = AssetManager.culture_traits.get(pTraitID);
		load(pElement);
	}

	protected override void startSignal()
	{
		AchievementLibrary.trait_explorer_culture.checkBySignal();
	}

	protected override TooltipData tooltipDataBuilder()
	{
		return new TooltipData
		{
			culture_trait = augmentation_asset
		};
	}
}
// --- End of File: CultureTraitButton.cs ---



// --- Start of File: CultureTraitEditorButton.cs ---
public class CultureTraitEditorButton : TraitEditorButton<CultureTraitButton, CultureTrait>
{
}
// --- End of File: CultureTraitEditorButton.cs ---



// --- Start of File: CultureTraitGroupAsset.cs ---
using System;

[Serializable]
public class CultureTraitGroupAsset : BaseTraitGroupAsset
{
}
// --- End of File: CultureTraitGroupAsset.cs ---



// --- Start of File: CultureTraitGroupElement.cs ---
public class CultureTraitGroupElement : TraitGroupElement<CultureTrait, CultureTraitButton, CultureTraitEditorButton>
{
}
// --- End of File: CultureTraitGroupElement.cs ---



// --- Start of File: CultureTraitGroupLibrary.cs ---
public class CultureTraitGroupLibrary : BaseCategoryLibrary<CultureTraitGroupAsset>
{
	public override void init()
	{
		base.init();
		add(new CultureTraitGroupAsset
		{
			id = "harmony",
			name = "trait_group_harmony",
			color = "#FFE877"
		});
		add(new CultureTraitGroupAsset
		{
			id = "architecture",
			name = "trait_group_architecture",
			color = "#BAF0F4"
		});
		add(new CultureTraitGroupAsset
		{
			id = "town_plan",
			name = "trait_group_town_plan",
			color = "#BAF0F4"
		});
		add(new CultureTraitGroupAsset
		{
			id = "kingdom",
			name = "trait_group_kingdom",
			color = "#FF6B86"
		});
		add(new CultureTraitGroupAsset
		{
			id = "buildings",
			name = "trait_group_buildings",
			color = "#ADADAD"
		});
		add(new CultureTraitGroupAsset
		{
			id = "succession",
			name = "trait_group_succession",
			color = "#CA59FF"
		});
		add(new CultureTraitGroupAsset
		{
			id = "knowledge",
			name = "trait_group_knowledge",
			color = "#BAFFC2"
		});
		add(new CultureTraitGroupAsset
		{
			id = "warfare",
			name = "trait_group_warfare",
			color = "#FF6B86"
		});
		add(new CultureTraitGroupAsset
		{
			id = "weapons",
			name = "trait_group_weapons",
			color = "#FF6B86"
		});
		add(new CultureTraitGroupAsset
		{
			id = "craft",
			name = "trait_group_craft",
			color = "#FF6B11"
		});
		add(new CultureTraitGroupAsset
		{
			id = "happiness",
			name = "trait_group_happiness",
			color = "#FFFAA3"
		});
		add(new CultureTraitGroupAsset
		{
			id = "worldview",
			name = "trait_group_worldview",
			color = "#B0FF8E"
		});
		add(new CultureTraitGroupAsset
		{
			id = "miscellaneous",
			name = "trait_group_miscellaneous",
			color = "#D8D8D8"
		});
		add(new CultureTraitGroupAsset
		{
			id = "fate",
			name = "trait_group_fate",
			color = "#ffd82f"
		});
		add(new CultureTraitGroupAsset
		{
			id = "special",
			name = "trait_group_special",
			color = "#FF8F44"
		});
	}
}
// --- End of File: CultureTraitGroupLibrary.cs ---



// --- Start of File: CultureTraitLibrary.cs ---
using System.Collections.Generic;

public class CultureTraitLibrary : BaseTraitLibrary<CultureTrait>
{
	protected override string icon_path => "ui/Icons/culture_traits/";

	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	{
		return pAsset.default_culture_traits;
	}

	public override void init()
	{
		base.init();
		addWeaponRelatedTraits();
		addTownPlansZones();
		addTownPlansTilePlacements();
		add(new CultureTrait
		{
			id = "roads",
			group_id = "architecture"
		});
		add(new CultureTrait
		{
			id = "expansionists",
			group_id = "kingdom",
			priority = 100
		});
		add(new CultureTrait
		{
			id = "tiny_legends",
			group_id = "kingdom",
			priority = 99
		});
		t.addOpposite("youth_reverence");
		add(new CultureTrait
		{
			id = "animal_whisperers",
			group_id = "miscellaneous"
		});
		add(new CultureTrait
		{
			id = "ancestors_knowledge",
			group_id = "knowledge"
		});
		t.setUnlockedWithAchievement("achievementTraitExplorerCulture");
		add(new CultureTrait
		{
			id = "statue_lovers",
			value = 4f,
			group_id = "buildings"
		});
		add(new CultureTrait
		{
			id = "tower_lovers",
			value = 4f,
			group_id = "buildings"
		});
		add(new CultureTrait
		{
			id = "training_potential",
			group_id = "knowledge"
		});
		add(new CultureTrait
		{
			id = "elder_reverence",
			value = 2f,
			group_id = "happiness"
		});
		t.addOpposite("youth_reverence");
		add(new CultureTrait
		{
			id = "youth_reverence",
			group_id = "happiness"
		});
		t.addOpposite("elder_reverence");
		t.addOpposite("tiny_legends");
		add(new CultureTrait
		{
			id = "conscription_female_only",
			group_id = "kingdom",
			priority = 90
		});
		t.addOpposite("conscription_male_only");
		add(new CultureTrait
		{
			id = "conscription_male_only",
			group_id = "kingdom",
			priority = 89
		});
		t.addOpposite("conscription_female_only");
		add(new CultureTrait
		{
			id = "fast_learners",
			group_id = "knowledge",
			value = 2f
		});
		add(new CultureTrait
		{
			id = "pep_talks",
			group_id = "happiness"
		});
		add(new CultureTrait
		{
			id = "expertise_exchange",
			value = 10f,
			group_id = "knowledge"
		});
		add(new CultureTrait
		{
			id = "happiness_from_war",
			group_id = "happiness"
		});
		add(new CultureTrait
		{
			id = "dense_dwellings",
			value = 2f,
			group_id = "harmony"
		});
		t.addOpposite("solitude_seekers");
		t.addOpposite("hive_society");
		add(new CultureTrait
		{
			id = "solitude_seekers",
			value = 0.5f,
			group_id = "harmony"
		});
		t.addOpposite("dense_dwellings");
		t.addOpposite("hive_society");
		add(new CultureTrait
		{
			id = "hive_society",
			value = 10f,
			group_id = "harmony"
		});
		t.setUnlockedWithAchievement("achievementAntWorld");
		t.addOpposite("dense_dwellings");
		t.addOpposite("solitude_seekers");
		add(new CultureTrait
		{
			id = "gossip_lovers",
			group_id = "happiness"
		});
		add(new CultureTrait
		{
			id = "reading_lovers",
			group_id = "knowledge"
		});
		add(new CultureTrait
		{
			id = "attentive_readers",
			value = 2f,
			group_id = "knowledge"
		});
		add(new CultureTrait
		{
			id = "join_or_die",
			group_id = "worldview",
			priority = 100,
			action_attack_target = delegate(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile)
			{
				if (!pSelf.a.isKingdomCiv())
				{
					return false;
				}
				if (!pTarget.isActor())
				{
					return false;
				}
				if (!pTarget.isAlive())
				{
					return false;
				}
				if (pTarget.a.kingdom == pSelf.kingdom)
				{
					return false;
				}
				if (!pTarget.isKingdomCiv() && !pTarget.kingdom.isNomads())
				{
					return false;
				}
				if (!pTarget.a.isSapient())
				{
					return false;
				}
				if (pTarget.a.hasTag("strong_mind"))
				{
					return false;
				}
				if (pTarget.a.getHealthRatio() > 0.3f)
				{
					return false;
				}
				if (!Randy.randomChance(0.3f))
				{
					return false;
				}
				pTarget.a.removeFromPreviousFaction();
				pTarget.a.joinKingdom(pSelf.kingdom);
				pSelf.a.clearAttackTarget();
				pTarget.a.clearAttackTarget();
				pTarget.a.applyRandomForce();
				return true;
			}
		});
		add(new CultureTrait
		{
			id = "true_roots",
			group_id = "miscellaneous"
		});
		add(new CultureTrait
		{
			id = "legacy_keepers",
			group_id = "miscellaneous"
		});
		add(new CultureTrait
		{
			id = "serenity_now",
			group_id = "worldview"
		});
		t.base_stats.addTag("love_peace");
		t.addOpposite("xenophobic");
		add(new CultureTrait
		{
			id = "weaponsmith_mastery",
			value = 5f,
			group_id = "warfare"
		});
		add(new CultureTrait
		{
			id = "armorsmith_mastery",
			value = 5f,
			group_id = "warfare"
		});
		add(new CultureTrait
		{
			id = "patriarchy",
			group_id = "succession",
			has_description_2 = false,
			priority = 97
		});
		t.addOpposite("matriarchy");
		add(new CultureTrait
		{
			id = "matriarchy",
			group_id = "succession",
			has_description_2 = false,
			priority = 96
		});
		t.addOpposite("patriarchy");
		add(new CultureTrait
		{
			id = "ultimogeniture",
			group_id = "succession",
			priority = 96
		});
		add(new CultureTrait
		{
			id = "diplomatic_ascension",
			group_id = "succession",
			priority = 100
		});
		t.base_stats.addTag("love_peace");
		t.addOpposite("warriors_ascension");
		t.addOpposite("fames_crown");
		t.addOpposite("golden_rule");
		add(new CultureTrait
		{
			id = "fames_crown",
			group_id = "succession",
			priority = 100
		});
		t.addOpposite("warriors_ascension");
		t.addOpposite("diplomatic_ascension");
		t.addOpposite("golden_rule");
		add(new CultureTrait
		{
			id = "golden_rule",
			group_id = "succession",
			priority = 100
		});
		t.addOpposite("warriors_ascension");
		t.addOpposite("fames_crown");
		t.addOpposite("diplomatic_ascension");
		add(new CultureTrait
		{
			id = "shattered_crown",
			group_id = "succession",
			priority = 60
		});
		add(new CultureTrait
		{
			id = "unbroken_chain",
			group_id = "succession",
			priority = 59
		});
		t.setUnlockedWithAchievement("achievementSuccession");
		add(new CultureTrait
		{
			id = "warriors_ascension",
			group_id = "succession",
			priority = 99
		});
		t.addOpposite("diplomatic_ascension");
		t.addOpposite("fames_crown");
		t.addOpposite("golden_rule");
		add(new CultureTrait
		{
			id = "xenophobic",
			group_id = "worldview"
		});
		t.addOpposite("xenophiles");
		t.addOpposite("serenity_now");
		add(new CultureTrait
		{
			id = "ethnocentric_guard",
			group_id = "worldview"
		});
		add(new CultureTrait
		{
			id = "xenophiles",
			group_id = "worldview"
		});
		t.base_stats.addTag("love_peace");
		t.addOpposite("xenophobic");
		add(new CultureTrait
		{
			id = "ethno_sculpted",
			group_id = "special",
			can_be_given = false,
			can_be_removed = false,
			can_be_in_book = false,
			spawn_random_trait_allowed = false
		});
		add(new CultureTrait
		{
			id = "grin_mark",
			group_id = "fate",
			spawn_random_trait_allowed = false,
			priority = -100
		});
		t.setTraitInfoToGrinMark();
		t.setUnlockedWithAchievement("achievementCreaturesExplorer");
	}

	private void addTownPlansZones()
	{
		add(new CultureTrait
		{
			id = "city_layout_architects_eye",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isInPassableRingMap);
		add(new CultureTrait
		{
			id = "city_layout_madman_labyrinth",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isPassableMadmanLabyrinth);
		add(new CultureTrait
		{
			id = "city_layout_honeycomb",
			group_id = "town_plan"
		});
		t.setUnlockedWithAchievement("achievementSwarm");
		t.setTownLayoutPlan(TownPlans.isPassableHoneycomb);
		add(new CultureTrait
		{
			id = "city_layout_bricks",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isPassableBrickHorizontal);
		add(new CultureTrait
		{
			id = "city_layout_raindrops",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isPassableBrickVertical);
		add(new CultureTrait
		{
			id = "city_layout_cross",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isPassableCross);
		add(new CultureTrait
		{
			id = "city_layout_claws",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isPassableDiagonal);
		add(new CultureTrait
		{
			id = "city_layout_pebbles",
			group_id = "town_plan",
			priority = 50
		});
		t.setTownLayoutPlan(TownPlans.isPassableClustersSmall);
		add(new CultureTrait
		{
			id = "city_layout_stone_garden",
			group_id = "town_plan",
			priority = 49
		});
		t.setTownLayoutPlan(TownPlans.isPassableClustersMedium);
		add(new CultureTrait
		{
			id = "city_layout_titan_footprints",
			group_id = "town_plan",
			priority = 48
		});
		t.setTownLayoutPlan(TownPlans.isPassableClustersBig);
		add(new CultureTrait
		{
			id = "city_layout_silk_web",
			group_id = "town_plan",
			priority = 47
		});
		t.setTownLayoutPlan(TownPlans.isPassableLatticeSmall);
		add(new CultureTrait
		{
			id = "city_layout_iron_weave",
			group_id = "town_plan",
			priority = 46
		});
		t.setTownLayoutPlan(TownPlans.isPassableLatticeMedium);
		add(new CultureTrait
		{
			id = "city_layout_monolith_mesh",
			group_id = "town_plan",
			priority = 45
		});
		t.setTownLayoutPlan(TownPlans.isPassableLatticeBig);
		add(new CultureTrait
		{
			id = "city_layout_royal_checkers",
			group_id = "town_plan",
			priority = 44
		});
		t.setTownLayoutPlan(TownPlans.isPassableDiamondCluster);
		add(new CultureTrait
		{
			id = "city_layout_diamond",
			group_id = "town_plan",
			priority = 43
		});
		t.setTownLayoutPlan(TownPlans.isPassableDiamond);
		add(new CultureTrait
		{
			id = "city_layout_parallels",
			group_id = "town_plan",
			priority = 42
		});
		t.setTownLayoutPlan(TownPlans.isPassableLineHorizontal);
		add(new CultureTrait
		{
			id = "city_layout_pillars",
			group_id = "town_plan",
			priority = 41
		});
		t.setTownLayoutPlan(TownPlans.isPassableLineVertical);
		add(new CultureTrait
		{
			id = "city_layout_rings",
			group_id = "town_plan"
		});
		t.setTownLayoutPlan(TownPlans.isInPassableRing);
		addTownLayoutOpposites();
	}

	private void addTownPlansTilePlacements()
	{
		add(new CultureTrait
		{
			id = "buildings_spread",
			group_id = "town_plan",
			priority = 100
		});
		add(new CultureTrait
		{
			id = "city_layout_tile_wobbly_pattern",
			group_id = "town_plan",
			priority = 98
		});
		t.addOpposite("city_layout_the_grand_arrangement");
		t.addOpposite("city_layout_tile_moonsteps");
		add(new CultureTrait
		{
			id = "city_layout_the_grand_arrangement",
			group_id = "town_plan",
			priority = 99
		});
		t.addOpposite("city_layout_tile_wobbly_pattern");
		t.addOpposite("city_layout_tile_moonsteps");
		add(new CultureTrait
		{
			id = "city_layout_tile_moonsteps",
			group_id = "town_plan",
			priority = 97
		});
		t.addOpposite("city_layout_tile_wobbly_pattern");
		t.addOpposite("city_layout_the_grand_arrangement");
	}

	private void addTownLayoutOpposites()
	{
		using ListPool<string> listPool = new ListPool<string>();
		foreach (CultureTrait item in list)
		{
			if (item.town_layout_plan)
			{
				listPool.Add(item.id);
			}
		}
		foreach (CultureTrait item2 in list)
		{
			if (item2.town_layout_plan)
			{
				item2.addOpposites(listPool);
				item2.removeOpposite(item2.id);
			}
		}
	}

	private void addWeaponRelatedTraits()
	{
		add(new CultureTrait
		{
			id = "axe_lovers",
			value = 10f,
			group_id = "weapons",
			is_weapon_trait = true
		});
		t.addWeaponSubtype("axe");
		add(new CultureTrait
		{
			id = "sword_lovers",
			value = 10f,
			group_id = "weapons",
			is_weapon_trait = true
		});
		t.addWeaponSubtype("sword");
		add(new CultureTrait
		{
			id = "bow_lovers",
			value = 6f,
			group_id = "weapons",
			is_weapon_trait = true
		});
		t.addWeaponSubtype("bow");
		add(new CultureTrait
		{
			id = "hammer_lovers",
			value = 10f,
			group_id = "weapons",
			is_weapon_trait = true
		});
		t.addWeaponSubtype("hammer");
		add(new CultureTrait
		{
			id = "spear_lovers",
			value = 10f,
			group_id = "weapons",
			is_weapon_trait = true
		});
		t.addWeaponSubtype("spear");
		add(new CultureTrait
		{
			id = "craft_flame_weapon",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("flame_sword");
		t.addWeaponSpecial("flame_hammer");
		add(new CultureTrait
		{
			id = "craft_ice_weapon",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("ice_hammer");
		add(new CultureTrait
		{
			id = "craft_evil_staff",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("evil_staff");
		add(new CultureTrait
		{
			id = "craft_white_staff",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("white_staff");
		add(new CultureTrait
		{
			id = "craft_necro_staff",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("necromancer_staff");
		add(new CultureTrait
		{
			id = "craft_druid_staff",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("druid_staff");
		add(new CultureTrait
		{
			id = "craft_doctor_staff",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true
		});
		t.addWeaponSpecial("plague_doctor_staff");
		add(new CultureTrait
		{
			id = "craft_shotgun",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true,
			priority = -1,
			spawn_random_trait_allowed = false
		});
		t.setUnlockedWithAchievement("achievementSwordWithShotgun");
		t.addWeaponSpecial("shotgun");
		add(new CultureTrait
		{
			id = "craft_blaster",
			value = 10f,
			group_id = "craft",
			is_weapon_trait = true,
			priority = -2,
			spawn_random_trait_allowed = false
		});
		t.addWeaponSpecial("alien_blaster");
	}

	public static float getValueFloat(string pID)
	{
		return AssetManager.culture_traits.get(pID).value;
	}

	public static int getValue(string pID)
	{
		return (int)AssetManager.culture_traits.get(pID).value;
	}
}
// --- End of File: CultureTraitLibrary.cs ---



// --- Start of File: CultureTraitsContainer.cs ---
public class CultureTraitsContainer : TraitsContainer<CultureTrait, CultureTraitButton>
{
}
// --- End of File: CultureTraitsContainer.cs ---



// --- Start of File: CultureTraitsEditor.cs ---
using System.Collections.Generic;

public class CultureTraitsEditor : TraitsEditor<CultureTrait, CultureTraitButton, CultureTraitEditorButton, CultureTraitGroupAsset, CultureTraitGroupElement>
{
	protected override MetaType meta_type => MetaType.Culture;

	protected override List<CultureTraitGroupAsset> augmentation_groups_list => AssetManager.culture_trait_groups.list;

	protected override List<CultureTrait> all_augmentations_list => AssetManager.culture_traits.list;

	protected override CultureTrait edited_marker_augmentation => AssetManager.culture_traits.get("ethno_sculpted");

	protected override void startSignal()
	{
		AchievementLibrary.trait_explorer_culture.checkBySignal();
	}

	protected override void metaAugmentationClick(CultureTraitEditorButton pButton)
	{
		base.metaAugmentationClick(pButton);
		if (!(pButton.augmentation_button.getElementAsset().group_id != "succession"))
		{
			AchievementLibrary.succession.check();
		}
	}
}
// --- End of File: CultureTraitsEditor.cs ---



// --- Start of File: CultureWindow.cs ---
using System.Collections.Generic;
using UnityEngine;

public class CultureWindow : WindowMetaGeneric<Culture, CultureData>, ITraitWindow<CultureTrait, CultureTraitButton>, IAugmentationsWindow<ITraitsEditor<CultureTrait>>, IBooksWindow
{
	public StatBar experienceBar;

	public override MetaType meta_type => MetaType.Culture;

	protected override Culture meta_object => SelectedMetas.selected_culture;

	public void testDebugNewBook()
	{
		meta_object.testDebugNewBook();
		startShowingWindow();
		scroll_window.tabs.showTab(scroll_window.tabs.getActiveTab());
	}

	public List<long> getBooks()
	{
		return meta_object.books.getList();
	}

	protected override void showTopPartInformation()
	{
		base.showTopPartInformation();
		_ = meta_object;
	}

	internal override void showStatsRows()
	{
		Culture culture = meta_object;
		tryShowPastNames();
		showStatRow("founded", culture.getFoundedDate(), MetaType.None, -1L);
		tryToShowActor("founder", culture.data.creator_id, culture.data.creator_name, null, "actor_traits/iconStupid");
		tryToShowMetaClan("founder_clan", culture.data.creator_clan_id, culture.data.creator_clan_name);
		tryToShowMetaKingdom("origin", culture.data.creator_kingdom_id, culture.data.creator_kingdom_name);
		tryToShowMetaCity("birthplace", culture.data.creator_city_id, culture.data.creator_city_name);
		tryToShowMetaSubspecies("founder_subspecies", culture.data.creator_subspecies_id, culture.data.creator_subspecies_name);
		tryToShowMetaSpecies("founder_species", culture.data.creator_species_id);
	}

	protected override bool onNameChange(string pInput)
	{
		if (!base.onNameChange(pInput))
		{
			return false;
		}
		long iD = meta_object.getID();
		string name = meta_object.data.name;
		foreach (Book book in World.world.books)
		{
			if (!book.isRekt() && book.data.culture_id == iD)
			{
				book.data.culture_name = name;
			}
		}
		return true;
	}

	T IAugmentationsWindow<ITraitsEditor<CultureTrait>>.GetComponentInChildren<T>(bool includeInactive)
	{
		return ((Component)this).GetComponentInChildren<T>(includeInactive);
	}
}
// --- End of File: CultureWindow.cs ---



// --- Start of File: CursedSacrifice.cs ---
public static class CursedSacrifice
{
	private const int SACRIFICE_COUNT = 314;

	private const int MAX_MESSAGES = 9;

	private static int _last_message_index = -1;

	private static int _current_sacrifice_count = 0;

	private static double _cursed_world_timestamp = 0.0;

	private static bool _latest_sacrificed_was_egg;

	public static void checkGoodForSacrifice(Actor pActor)
	{
		bool flag = false;
		if (pActor.hasSubspecies())
		{
			bool flag2 = pActor.hasStatus("magnetized") || pActor.hasStatus("strange_urge") || pActor.hasStatus("possessed");
			if (pActor.hasSubspeciesTrait("pure") && flag2)
			{
				flag = true;
			}
		}
		if (flag)
		{
			if (pActor.asset.id == "elf")
			{
				World.world.game_stats.data.elvesSacrificed++;
				_latest_sacrificed_was_egg = pActor.isEgg();
				spawnVoidElves();
			}
			World.world.game_stats.data.creaturesSacrificed++;
			countSacrifice();
		}
	}

	public static void spawnVoidElves()
	{
		Subspecies voidElvesSubspecies = getVoidElvesSubspecies();
		if (voidElvesSubspecies != null)
		{
			TileZone random = World.world.zone_camera.getVisibleZones().GetRandom();
			if (random != null)
			{
				WorldTile randomTile = random.getRandomTile();
				World.world.units.spawnNewUnit("elf", randomTile, pSpawnSound: false, pMiracleSpawn: true, 6f, voidElvesSubspecies, pGiveOwnerlessItems: true, pAdultAge: true);
			}
		}
	}

	private static Subspecies getVoidElvesSubspecies()
	{
		using ListPool<Subspecies> listPool = new ListPool<Subspecies>();
		ActorAsset actorAsset = AssetManager.actor_library.get("elf");
		foreach (Subspecies subspecy in World.world.subspecies)
		{
			if (subspecy.getActorAsset() == actorAsset && subspecy.hasTrait("mutation_skin_void"))
			{
				listPool.Add(subspecy);
			}
		}
		Subspecies result;
		if (listPool.Count == 0)
		{
			WorldTile worldTile = World.world.islands_calculator.tryGetRandomGround();
			if (worldTile == null)
			{
				return null;
			}
			Subspecies subspecies = World.world.subspecies.newSpecies(actorAsset, worldTile);
			subspecies.addTrait("mutation_skin_void");
			subspecies.addTrait("gift_of_void");
			subspecies.addTrait("reproduction_soulborne");
			subspecies.addTrait("big_stomach");
			subspecies.addTrait("voracious");
			subspecies.addTrait("genetic_mirror");
			subspecies.addTrait("genetic_psychosis");
			subspecies.addTrait("enhanced_strength");
			subspecies.addTrait("cold_resistance");
			subspecies.addTrait("heat_resistance");
			subspecies.addTrait("adaptation_corruption");
			subspecies.addTrait("adaptation_desert");
			subspecies.addTrait("hovering");
			subspecies.removeTrait("pure");
			subspecies.removeTrait("prefrontal_cortex");
			subspecies.removeTrait("advanced_hippocampus");
			subspecies.removeTrait("amygdala");
			subspecies.removeTrait("wernicke_area");
			subspecies.addBirthTrait("desire_harp");
			subspecies.addBirthTrait("evil");
			subspecies.data.name = "Elfus Voidus";
			result = subspecies;
		}
		else
		{
			result = listPool.GetRandom();
		}
		return result;
	}

	public static void countAllSacrificesDebug()
	{
		for (int i = 0; i < 314; i++)
		{
			countSacrifice();
		}
	}

	private static void countSacrifice()
	{
		if (_current_sacrifice_count == 314)
		{
			return;
		}
		_current_sacrifice_count++;
		int num = (int)(getCurseProgressRatio() * 9f);
		if (num > _last_message_index)
		{
			_last_message_index = num;
			string pColor = "#F3961F";
			if (_last_message_index > 6)
			{
				pColor = "#FF637D";
			}
			if (_last_message_index == 9)
			{
				pColor = "#E060CD";
			}
			WorldTip.showNow("world_curse_message_" + _last_message_index, pTranslate: true, "top", 3f, pColor);
			_ = _last_message_index;
			_ = 4;
			World.world.startShake(0.3f + (float)_last_message_index * 0.1f, 0.01f, 0.23f + (float)_last_message_index * 0.02f, pShakeX: true);
		}
	}

	public static float getCurseProgressRatio()
	{
		return (float)_current_sacrifice_count / 314f;
	}

	public static float getCurseProgressRatioForBlackhole()
	{
		if (AchievementLibrary.isUnlocked("achievementCursedWorld"))
		{
			return 1f;
		}
		return (float)_current_sacrifice_count / 314f;
	}

	public static void reset()
	{
		_current_sacrifice_count = 0;
		_last_message_index = 0;
		_latest_sacrificed_was_egg = false;
	}

	private static int getCurrentSacrificeCount()
	{
		return _current_sacrifice_count;
	}

	public static void loadAlreadyCursedState()
	{
		_current_sacrifice_count = 314;
	}

	public static bool isWorldReadyForCURSE()
	{
		if (AchievementLibrary.isUnlocked("achievementCursedWorld"))
		{
			return true;
		}
		return isAllSacrificesDone();
	}

	public static bool isAllSacrificesDone()
	{
		return getCurrentSacrificeCount() >= 314;
	}

	public static void justCursedWorld()
	{
		if (Config.hasPremium)
		{
			_cursed_world_timestamp = World.world.getCurSessionTime();
			AchievementLibrary.cursed_world.check();
		}
	}

	public static bool justGotCursedWorld()
	{
		return World.world.getRealTimeElapsedSince(_cursed_world_timestamp) < 1f;
	}

	public static bool isLatestWasEgg()
	{
		return _latest_sacrificed_was_egg;
	}
}
// --- End of File: CursedSacrifice.cs ---



// --- Start of File: CursorSpeed.cs ---
using UnityEngine;

public class CursorSpeed
{
	private Vector2 _lastFramePos;

	private Vector2 _curFramePos;

	private float difference;

	public float speed;

	public float fmod_speed;

	public void update()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetMouseButton(0))
		{
			((Vector2)(ref _lastFramePos)).Set(_curFramePos.x, _curFramePos.y);
			Vector3 mousePosition = Input.mousePosition;
			((Vector2)(ref _curFramePos)).Set(mousePosition.x, mousePosition.y);
			difference = Toolbox.DistVec2Float(_curFramePos, _lastFramePos) / 2f;
			if (difference > speed)
			{
				speed = difference;
			}
		}
		speed = speed * 0.95f - 1f;
		if (speed < 0f)
		{
			speed = 0f;
		}
		fmod_speed = (int)speed;
		if (fmod_speed > 100f)
		{
			fmod_speed = 100f;
		}
	}

	public void debug(DebugTool pTool)
	{
		pTool.setText("difference", difference, 0f, pShowBar: false, 0L);
		pTool.setText("speed", speed, 0f, pShowBar: false, 0L);
		pTool.setText("fmod_speed", fmod_speed, 0f, pShowBar: false, 0L);
	}
}
// --- End of File: CursorSpeed.cs ---



// --- Start of File: CursorTooltipHelper.cs ---
using UnityEngine;

public static class CursorTooltipHelper
{
	private static float _timeout = 0f;

	private static float _timeout_interval = 0.2f;

	public static bool is_over_meta;

	public static void update()
	{
		if (!InputHelpers.mouseSupported)
		{
			return;
		}
		if (World.world.isBusyWithUI())
		{
			cancel();
			return;
		}
		if (isInputHappening())
		{
			cancel();
			return;
		}
		bool flag = false;
		flag = updateGameplayTooltip();
		if (!flag)
		{
			flag = updateMapTooltip();
		}
		if (!flag)
		{
			cancel();
		}
	}

	private static bool updateGameplayTooltip()
	{
		if (!PlayerConfig.optionBoolEnabled("tooltip_units"))
		{
			return false;
		}
		if (!MapBox.isRenderGameplay())
		{
			return false;
		}
		Actor last_actor = UnitSelectionEffect.last_actor;
		if (last_actor == null)
		{
			return false;
		}
		if (!last_actor.isAlive())
		{
			return false;
		}
		if (_timeout > 0f)
		{
			_timeout -= World.world.delta_time;
			return true;
		}
		string text = "actor";
		if (!HotkeyLibrary.many_mod.isHolding() || !showTooltipForSelectedMeta(last_actor))
		{
			if (last_actor.isKing())
			{
				text = "actor_king";
			}
			else if (last_actor.isCityLeader())
			{
				text = "actor_leader";
			}
			Tooltip.hideTooltip(last_actor, pOnlySimObjects: true, text);
			Tooltip.show(last_actor, text, new TooltipData
			{
				actor = last_actor,
				tooltip_scale = 0.7f,
				is_sim_tooltip = true,
				sound_allowed = false
			});
		}
		return true;
	}

	private static bool showTooltipForSelectedMeta(Actor pActor)
	{
		MetaType currentMapBorderMode = Zones.getCurrentMapBorderMode();
		TooltipData tooltipData = new TooltipData
		{
			tooltip_scale = 0.7f,
			is_sim_tooltip = true
		};
		object obj = null;
		string text;
		switch (currentMapBorderMode)
		{
		case MetaType.Alliance:
			if (!pActor.kingdom.hasAlliance())
			{
				return false;
			}
			text = "alliance";
			tooltipData.alliance = pActor.kingdom.getAlliance();
			obj = pActor.kingdom.getAlliance();
			break;
		case MetaType.Kingdom:
			if (!pActor.isKingdomCiv())
			{
				return false;
			}
			text = "kingdom";
			tooltipData.kingdom = pActor.kingdom;
			obj = pActor.kingdom;
			break;
		case MetaType.City:
			if (!pActor.hasCity())
			{
				return false;
			}
			text = "city";
			tooltipData.city = pActor.city;
			obj = pActor.city;
			break;
		case MetaType.Clan:
			if (!pActor.hasClan())
			{
				return false;
			}
			text = "clan";
			tooltipData.clan = pActor.clan;
			obj = pActor.clan;
			break;
		case MetaType.Culture:
			if (!pActor.hasCulture())
			{
				return false;
			}
			text = "culture";
			tooltipData.culture = pActor.culture;
			obj = pActor.culture;
			break;
		case MetaType.Family:
			if (!pActor.hasFamily())
			{
				return false;
			}
			text = "family";
			tooltipData.family = pActor.family;
			obj = pActor.family;
			break;
		case MetaType.Language:
			if (!pActor.hasLanguage())
			{
				return false;
			}
			text = "language";
			tooltipData.language = pActor.language;
			obj = pActor.language;
			break;
		case MetaType.Religion:
			if (!pActor.hasReligion())
			{
				return false;
			}
			text = "religion";
			tooltipData.religion = pActor.religion;
			obj = pActor.religion;
			break;
		case MetaType.Subspecies:
			if (!pActor.hasSubspecies())
			{
				return false;
			}
			text = "subspecies";
			tooltipData.subspecies = pActor.subspecies;
			obj = pActor.subspecies;
			break;
		default:
			return false;
		}
		Tooltip.hideTooltip(obj, pOnlySimObjects: true, text);
		Tooltip.show(obj, text, tooltipData);
		return true;
	}

	private static bool updateMapTooltip()
	{
		if (!PlayerConfig.optionBoolEnabled("tooltip_zones"))
		{
			return false;
		}
		if (!MapBox.isRenderMiniMap())
		{
			return false;
		}
		if (!Zones.showMapBorders())
		{
			return false;
		}
		if (_timeout > 0f)
		{
			_timeout -= World.world.delta_time;
			return true;
		}
		bool result = false;
		WorldTile mouseTilePosCachedFrame = World.world.getMouseTilePosCachedFrame();
		MetaTypeAsset cachedMapMetaAsset = World.world.getCachedMapMetaAsset();
		if (mouseTilePosCachedFrame != null && cachedMapMetaAsset != null)
		{
			result = cachedMapMetaAsset.check_cursor_tooltip(mouseTilePosCachedFrame.zone, cachedMapMetaAsset, cachedMapMetaAsset.getZoneOptionState());
		}
		return result;
	}

	private static void cancel()
	{
		Tooltip.hideTooltip(null, pOnlySimObjects: true, string.Empty);
		resetTimout();
	}

	private static bool isInputHappening()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetMouseButton(0) || Input.GetMouseButton(1) || Input.GetMouseButton(2))
		{
			return true;
		}
		if (Input.mouseScrollDelta.y != 0f)
		{
			return true;
		}
		if (HotkeyLibrary.many_mod.isHolding())
		{
			return false;
		}
		return Input.anyKey;
	}

	private static void resetTimout()
	{
		_timeout = _timeout_interval;
	}
}
// --- End of File: CursorTooltipHelper.cs ---



// --- Start of File: CustomButtonSwitch.cs ---
using System;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.EventSystems;

public class CustomButtonSwitch : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public Action click_increase;

	public Action click_decrease;

	private Animator anim;

	private Vector3 defaultScale;

	private Vector3 clickedScale;

	private void Start()
	{
		anim = ((Component)this).gameObject.GetComponent<Animator>();
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1)
		{
			click_decrease?.Invoke();
			SoundBox.click();
			newClickAnimation();
		}
		else
		{
			click_increase?.Invoke();
			SoundBox.click();
			newClickAnimation();
		}
	}

	private void Awake()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		defaultScale = ((Component)this).transform.localScale;
		clickedScale = defaultScale * 1.1f;
	}

	public void newClickAnimation()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
		((Component)this).transform.localScale = clickedScale;
		TweenSettingsExtensions.SetEase<TweenerCore<Vector3, Vector3, VectorOptions>>(ShortcutExtensions.DOScale(((Component)this).transform, defaultScale, 0.3f), (Ease)28);
	}

	private void OnDestroy()
	{
		ShortcutExtensions.DOKill((Component)(object)((Component)this).transform, false);
	}
}
// --- End of File: CustomButtonSwitch.cs ---



// --- Start of File: CustomDataContainer.cs ---
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityPools;

[Serializable]
[JsonConverter(typeof(CustomDataContainerConverter))]
public class CustomDataContainer<TType> : IDisposable
{
	[NonSerialized]
	internal Dictionary<string, TType> dict = UnsafeCollectionPool<Dictionary<string, Dictionary<string, TType>>, KeyValuePair<string, Dictionary<string, TType>>>.Get();

	public TType this[string pKey]
	{
		get
		{
			return dict[pKey];
		}
		set
		{
			dict[pKey] = value;
		}
	}

	public IEnumerable<string> Keys => dict.Keys;

	public bool TryGetValue(string pKey, out TType pValue)
	{
		return dict.TryGetValue(pKey, out pValue);
	}

	public void Remove(string pKey)
	{
		dict.Remove(pKey);
	}

	public void Dispose()
	{
		if (dict != null)
		{
			dict.Clear();
			UnsafeCollectionPool<Dictionary<string, Dictionary<string, TType>>, KeyValuePair<string, Dictionary<string, TType>>>.Release((Dictionary<string, Dictionary<string, TType>>)(object)dict);
		}
		dict = null;
	}
}
// --- End of File: CustomDataContainer.cs ---



// --- Start of File: CustomDataContainerConverter.cs ---
using System;
using System.Reflection;
using Newtonsoft.Json;

public class CustomDataContainerConverter : JsonConverter
{
	public override void WriteJson(JsonWriter pWriter, object pValue, JsonSerializer pSerializer)
	{
		FieldInfo? field = pValue.GetType().GetField("dict", BindingFlags.Instance | BindingFlags.NonPublic);
		Type fieldType = field.FieldType;
		object value = field.GetValue(pValue);
		pSerializer.Serialize(pWriter, value, fieldType);
	}

	public override object ReadJson(JsonReader pReader, Type pObjectType, object pExistingValue, JsonSerializer pSerializer)
	{
		object obj = Activator.CreateInstance(pObjectType);
		FieldInfo? field = pObjectType.GetField("dict", BindingFlags.Instance | BindingFlags.NonPublic);
		Type fieldType = field.FieldType;
		field.SetValue(obj, pSerializer.Deserialize(pReader, fieldType));
		return obj;
	}

	public override bool CanConvert(Type pObjectType)
	{
		return false;
	}
}
// --- End of File: CustomDataContainerConverter.cs ---



// --- Start of File: CustomizeWindow.cs ---
using UnityEngine;

public class CustomizeWindow : MonoBehaviour
{
	public ColorElement color_element_prefab;

	public MetaType meta_type;

	private bool _created;

	private void OnEnable()
	{
		if (!_created)
		{
			_created = true;
			AssetManager.meta_customization_library.getAsset(meta_type).customize_component(((Component)this).gameObject);
		}
	}
}
// --- End of File: CustomizeWindow.cs ---



// --- Start of File: CustomJsonArrayWriter.cs ---
using System.IO;
using Newtonsoft.Json;

public class CustomJsonArrayWriter : JsonTextWriter
{
	public CustomJsonArrayWriter(TextWriter writer)
		: base(writer)
	{
	}

	protected override void WriteIndent()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)((JsonWriter)this).WriteState != 3)
		{
			((JsonTextWriter)this).WriteIndent();
		}
		else
		{
			((JsonWriter)this).WriteIndentSpace();
		}
	}
}
// --- End of File: CustomJsonArrayWriter.cs ---



// --- Start of File: CustomTextureAtlas.cs ---
public class CustomTextureAtlas
{
	private static int width = 1202;

	private static int height = 2021;

	public static bool filesExists()
	{
		return true;
	}

	public static void createUnityBin()
	{
	}

	private static void save(string pData)
	{
	}

	internal static void delete(string pTexture)
	{
	}

	public static string createTextureID(string pString)
	{
		string pID = width.ToString() + height;
		return Toolbox.textureID(pString, pID);
	}
}
// --- End of File: CustomTextureAtlas.cs ---



// --- Start of File: Date.cs ---
using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

public static class Date
{
	public static string getAgoString(double pTimestamp)
	{
		return formatSeconds(World.world.getWorldTimeElapsedSince(pTimestamp)) + " ago";
	}

	public static string formatSeconds(float pSeconds)
	{
		if (pSeconds < 60f)
		{
			return ((int)pSeconds).ToText() + "s";
		}
		string text = ((int)pSeconds / 60).ToText();
		return text + "m";
	}

	public static float getMonthTime()
	{
		int monthsSince = getMonthsSince(0.0);
		return (float)World.world.getCurWorldTime() - (float)monthsSince * 5f;
	}

	public static string getYearDate(double pTime)
	{
		return getYear(pTime).ToText();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getYear(double pTime)
	{
		return getYear0(pTime) + 1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getYear0(double pTime)
	{
		return (int)(pTime / 60.0);
	}

	public static int[] getRawDate(double pTime)
	{
		int num = (int)(pTime / 5.0 / 12.0);
		while (pTime < 0.0)
		{
			pTime += 600000.0;
		}
		double num2 = pTime / 5.0;
		double num3 = num2 / 12.0;
		int num4 = (int)num2;
		int num5 = (int)num3;
		int num6 = (int)((pTime - (double)((float)num5 * 5f * 12f)) / 5.0);
		int num7 = (int)((pTime - (double)((float)num4 * 5f)) / 5.0 * 30.0);
		num++;
		num6++;
		num7++;
		return new int[3] { num7, num6, num };
	}

	public static string getDate(double pTime)
	{
		int[] rawDate = getRawDate(pTime);
		int num = rawDate[0];
		int pMonth = rawDate[1];
		int num2 = rawDate[2];
		if (LocalizedTextManager.instance.language == "en")
		{
			using (StringBuilderPool stringBuilderPool = new StringBuilderPool())
			{
				stringBuilderPool.Append(num);
				stringBuilderPool.Append(GetDaySuffix(num));
				stringBuilderPool.Append(" of ");
				stringBuilderPool.Append(formatMonth(pMonth));
				stringBuilderPool.Append(", ");
				stringBuilderPool.Append(num2.ToText());
				return stringBuilderPool.ToString();
			}
		}
		return formatDate(num, pMonth, num2);
	}

	internal static string formatMonth(int pMonth)
	{
		return LocalizedTextManager.getText("month_" + pMonth);
	}

	internal static string formatDate(int pDay, int pMonth, int pYear)
	{
		CultureInfo culture = LocalizedTextManager.getCulture();
		string input = culture.DateTimeFormat.LongDatePattern;
		if (culture.TwoLetterISOLanguageName == "ar")
		{
			input = "/ddMMMMyyyy/";
		}
		string text = Regex.Replace(input, "\\bdddd[,\\s]*", "").Trim();
		string text2 = LocalizedTextManager.getText("inflected_month_" + pMonth);
		MatchCollection matchCollection = null;
		if (text.Contains("'"))
		{
			matchCollection = Regex.Matches(text, "'[^']*'");
			for (int i = 0; i < matchCollection.Count; i++)
			{
				text = text.Replace(matchCollection[i].Value, "{{{" + i + "}}}");
			}
		}
		text = text.Replace("MMMM", "[[[1]]]");
		text = text.Replace("yyyy", "[[[2]]]");
		text = text.Replace("dd", "[[[3]]]");
		text = Regex.Replace(text, "\\b[d]\\b", "[[[4]]]");
		text = text.Replace("MM", "[[[5]]]");
		text = text.Replace("M", "[[[6]]]");
		text = text.Replace("[[[1]]]", text2);
		text = text.Replace("[[[2]]]", pYear.ToText());
		text = text.Replace("[[[3]]]", (pDay < 10) ? ("0" + pDay) : pDay.ToString());
		text = text.Replace("[[[4]]]", pDay.ToString());
		text = text.Replace("[[[5]]]", (pMonth < 10) ? ("0" + pMonth) : pMonth.ToString());
		text = text.Replace("[[[6]]]", pMonth.ToString());
		if (matchCollection != null && matchCollection.Count > 0)
		{
			for (int num = matchCollection.Count - 1; num >= 0; num--)
			{
				text = text.Replace("{{{" + num + "}}}", matchCollection[num].Value.Trim('\''));
			}
		}
		return text;
	}

	public static int getCurrentMonth()
	{
		return getMonth(World.world.getCurWorldTime());
	}

	public static int getMonth(double pTimestamp)
	{
		float num = getYear0(pTimestamp);
		return (int)((pTimestamp - (double)(num * 12f * 5f)) / 5.0 + 1.0);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getCurrentYear()
	{
		return getYear(World.world.getCurWorldTime());
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getYearsSince(double pFrom)
	{
		return getYear0(World.world.getCurWorldTime() - pFrom);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int getMonthsSince(double pFrom)
	{
		return (int)((World.world.getCurWorldTime() - pFrom) / 5.0);
	}

	private static string GetDaySuffix(int day)
	{
		switch (day)
		{
		case 1:
		case 21:
		case 31:
			return "st";
		case 2:
		case 22:
			return "nd";
		case 3:
		case 23:
			return "rd";
		default:
			return "th";
		}
	}

	public static bool isMonolithMonth()
	{
		if (getCurrentMonth() == 4)
		{
			return true;
		}
		return false;
	}

	public static string getUIStringYearMonthShort()
	{
		return "y:" + getCurrentYear().ToText() + ", m:" + getCurrentMonth().ToText();
	}

	public static string getUIStringYearMonth()
	{
		return "y: " + getCurrentYear().ToText() + ", m: " + getCurrentMonth().ToText();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static string TimeNow()
	{
		DateTime now = DateTime.Now;
		char[] array = new char[8];
		Write2Chars(array, 0, now.Hour);
		array[2] = ':';
		Write2Chars(array, 3, now.Minute);
		array[5] = ':';
		Write2Chars(array, 6, now.Second);
		return new string(array);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void Write2Chars(char[] chars, int offset, int value)
	{
		chars[offset] = Digit(value / 10);
		chars[offset + 1] = Digit(value % 10);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static char Digit(int value)
	{
		return (char)(value + 48);
	}
}
// --- End of File: Date.cs ---



// --- Start of File: DBGetter.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using SQLite;
using UnityPools;
using db.tables;

namespace db;

public static class DBGetter
{
	public static ListPool<GraphTimeScale> getTimeScales(NanoObject pObject)
	{
		if (Config.disable_db)
		{
			return new ListPool<GraphTimeScale>();
		}
		return getTimeScales(pObject.getID(), pObject.getType());
	}

	public static ListPool<GraphTimeScale> getTimeScales(long pID, string pMetaType)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			HistoryMetaDataAsset historyMetaDataAsset = AssetManager.history_meta_data_library.get(pMetaType);
			using ListPool<string> listPool = new ListPool<string>(AssetManager.graph_time_library.list.Count);
			foreach (GraphTimeAsset item in AssetManager.graph_time_library.list)
			{
				HistoryInterval interval = item.interval;
				TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(historyMetaDataAsset.getTableType(interval), (CreateFlags)0);
				listPool.Add($"select \"{item.id}\" as Scale, count() as Count from {mapping.TableName} where id = {pID} GROUP BY id HAVING Count > 0");
			}
			string query = string.Join(" UNION ", listPool);
			using ListPool<(string, int)> listPool2 = ((SQLiteConnection)(object)syncConnection).QueryPool<(string, int)>(query, Array.Empty<object>());
			if (listPool2.Count == 0)
			{
				return new ListPool<GraphTimeScale>();
			}
			using ListPool<GraphTimeScale> listPool3 = new ListPool<GraphTimeScale>(listPool2.Count);
			foreach (ref(string, int) item2 in listPool2)
			{
				(string, int) current2 = item2;
				listPool3.Add(AssetManager.graph_time_library.get(current2.Item1).scale_id);
			}
			ListPool<GraphTimeScale> listPool4 = new ListPool<GraphTimeScale>(listPool3.Count);
			GraphTimeScale graphTimeScale = listPool3.Max();
			for (GraphTimeScale graphTimeScale2 = GraphTimeScale.year_10; graphTimeScale2 <= graphTimeScale; graphTimeScale2++)
			{
				listPool4.Add(graphTimeScale2);
			}
			return listPool4;
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static ListPool<WorldLogMessage> getWorldLogMessages()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		DBInserter.executeCommands();
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping<WorldLogMessage>((CreateFlags)0);
			return ((SQLiteConnection)(object)syncConnection).QueryPool<WorldLogMessage>($"select * from {mapping.TableName} order by timestamp DESC, ROWID DESC LIMIT {2000}", Array.Empty<object>());
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static bool getData(CategoryData pData, NanoObject pObject, HistoryInterval pInterval, HistoryTable pExtraData)
	{
		return getData(pData, pObject.getID(), pObject.getType(), pInterval, pExtraData);
	}

	public static bool getData(CategoryData pData, long pID, string pMetaType, HistoryInterval pInterval, HistoryTable pExtraData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			HistoryMetaDataAsset historyMetaDataAsset = AssetManager.history_meta_data_library.get(pMetaType);
			TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(historyMetaDataAsset.getTableType(pInterval), (CreateFlags)0);
			ListPool<object> listPool = ((SQLiteConnection)(object)syncConnection).QueryPool(mapping, "select * from " + mapping.TableName + " where id = ? order by timestamp ASC", pID);
			if (listPool.Count > 0)
			{
				if (((HistoryTable)listPool.Last()).timestamp < pExtraData.timestamp)
				{
					listPool.Add(pExtraData);
				}
			}
			else
			{
				listPool.Add(pExtraData);
			}
			if (pData.db_list != null)
			{
				if (pData.db_list.ValuesEqual(listPool))
				{
					listPool.Dispose();
					return false;
				}
				pData.Clear();
			}
			foreach (ref object item in listPool)
			{
				Dictionary<string, long?> dictionary = parseValues(item, mapping);
				Dictionary<string, long> dictionary2 = UnsafeCollectionPool<Dictionary<string, long>, KeyValuePair<string, long>>.Get();
				foreach (string key in dictionary.Keys)
				{
					long? num = dictionary[key];
					if (!num.HasValue)
					{
						num = pData.Last?.Value[key];
						if (!num.HasValue)
						{
							num = 0L;
						}
					}
					dictionary2.Add(key, num.Value);
				}
				pData.AddLast(dictionary2);
				UnsafeCollectionPool<Dictionary<string, long?>, KeyValuePair<string, long?>>.Release(dictionary);
			}
			pData.db_list = listPool;
			return true;
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static Dictionary<string, long?> parseValues(object pItem, TableMapping pTableMapping)
	{
		Column[] columns = pTableMapping.Columns;
		Dictionary<string, long?> dictionary = UnsafeCollectionPool<Dictionary<string, long?>, KeyValuePair<string, long?>>.Get();
		Column[] array = columns;
		foreach (Column val in array)
		{
			if (!(val.Name == "id"))
			{
				object value = val.GetValue(pItem);
				if (value == null)
				{
					dictionary.Add(val.Name, null);
					continue;
				}
				long value2 = (long)value;
				dictionary.Add(val.Name, value2);
			}
		}
		return dictionary;
	}
}
// --- End of File: DBGetter.cs ---



// --- Start of File: DBInserter.cs ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using SQLite;
using UnityEngine;
using db.tables;

namespace db;

public static class DBInserter
{
	internal static int _insert_commands_count = 0;

	internal static readonly List<(long MetaID, Type MetaType)> _delete_commands = new List<(long, Type)>(4096);

	internal static readonly Dictionary<string, ListPool<HistoryTable>> _insert_commands = new Dictionary<string, ListPool<HistoryTable>>(64);

	internal static readonly Dictionary<string, ListPool<BaseSystemData>> _insert_metas = new Dictionary<string, ListPool<BaseSystemData>>(64);

	internal static readonly List<WorldLogMessage> _insert_logs = new List<WorldLogMessage>(64);

	private const float SQL_TIMEOUT_TIME = 10f;

	private static float _sql_timeout = 10f;

	private static Task _thread;

	private static bool _locked = false;

	public static void Lock()
	{
		_locked = true;
	}

	public static void Unlock()
	{
		_locked = false;
	}

	public static bool isLocked()
	{
		if (!_locked)
		{
			return Config.disable_db;
		}
		return true;
	}

	public static void deleteData(long pID, string pMetaType)
	{
		if (isLocked())
		{
			return;
		}
		foreach (Type value in AssetManager.history_meta_data_library.get(pMetaType).table_types.Values)
		{
			_delete_commands.Add((pID, value));
		}
	}

	public static void insertLog(WorldLogMessage pObject)
	{
		if (!isLocked())
		{
			_insert_logs.Add(pObject);
			_insert_commands_count++;
		}
	}

	public static void insertData(BaseSystemData pObject, string tMetaType)
	{
		if (!isLocked())
		{
			if (!_insert_metas.TryGetValue(tMetaType, out var value))
			{
				value = new ListPool<BaseSystemData>();
				_insert_metas.Add(tMetaType, value);
			}
			value.Add(pObject);
			_insert_commands_count++;
			if (ScrollWindow.isWindowActive())
			{
				executeCommands();
			}
		}
	}

	public static void insertData(HistoryTable pObject, string tMetaType)
	{
		if (!isLocked())
		{
			if (!_insert_commands.TryGetValue(tMetaType, out var value))
			{
				value = new ListPool<HistoryTable>();
				_insert_commands.Add(tMetaType, value);
			}
			value.Add(pObject);
			_insert_commands_count++;
		}
	}

	public static bool hasCommands()
	{
		if (_insert_commands_count <= 0)
		{
			return _delete_commands.Count > 0;
		}
		return true;
	}

	public static void clearCommands()
	{
		_insert_logs.Clear();
		_insert_commands.Clear();
		_insert_metas.Clear();
		_insert_commands_count = 0;
		_delete_commands.Clear();
	}

	public static void executeCommands()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		waitForAsync();
		if (isLocked() || !hasCommands())
		{
			return;
		}
		SQLiteConnectionWithLock tDBConn = DBManager.getSyncConnection();
		LockWrapper val = tDBConn.Lock();
		try
		{
			if (!hasCommands())
			{
				return;
			}
			ListPool<ListPool<BaseSystemData>> tMetasList = ((_insert_metas.Values.Count > 0) ? new ListPool<ListPool<BaseSystemData>>(_insert_metas.Values.Count) : null);
			ListPool<ListPool<HistoryTable>> tCommandsList = ((_insert_commands.Values.Count > 0) ? new ListPool<ListPool<HistoryTable>>(_insert_commands.Values.Count) : null);
			ListPool<WorldLogMessage> tInsertLogsList = ((_insert_logs.Count > 0) ? new ListPool<WorldLogMessage>(_insert_logs) : null);
			ListPool<(long MetaID, Type MetaType)> tDeleteCommandsList = ((_delete_commands.Count > 0) ? new ListPool<(long, Type)>(_delete_commands) : null);
			foreach (ListPool<HistoryTable> value in _insert_commands.Values)
			{
				if (value.Count == 0)
				{
					value.Dispose();
				}
				else
				{
					tCommandsList.Add(value);
				}
			}
			foreach (ListPool<BaseSystemData> value2 in _insert_metas.Values)
			{
				if (value2.Count == 0)
				{
					value2.Dispose();
				}
				else
				{
					tMetasList.Add(value2);
				}
			}
			clearCommands();
			((SQLiteConnection)tDBConn).RunInTransaction((Action)delegate
			{
				sendToDB((SQLiteConnection)(object)tDBConn, tMetasList, tCommandsList, tDeleteCommandsList, tInsertLogsList);
			});
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static void executeCommandsAsync()
	{
		if (isLocked())
		{
			return;
		}
		if (_sql_timeout > 0f)
		{
			_sql_timeout -= Time.deltaTime;
			return;
		}
		_sql_timeout = 10f;
		if ((_thread != null && !_thread.IsCompleted) || !hasCommands())
		{
			return;
		}
		SQLiteAsyncConnection asyncConnection = DBManager.getAsyncConnection();
		if (!hasCommands())
		{
			return;
		}
		ListPool<ListPool<BaseSystemData>> tMetasList = ((_insert_metas.Values.Count > 0) ? new ListPool<ListPool<BaseSystemData>>(_insert_metas.Values.Count) : null);
		ListPool<ListPool<HistoryTable>> tCommandsList = ((_insert_commands.Values.Count > 0) ? new ListPool<ListPool<HistoryTable>>(_insert_commands.Values.Count) : null);
		ListPool<WorldLogMessage> tInsertLogsList = ((_insert_logs.Count > 0) ? new ListPool<WorldLogMessage>(_insert_logs) : null);
		ListPool<(long MetaID, Type MetaType)> tDeleteCommandsList = ((_delete_commands.Count > 0) ? new ListPool<(long, Type)>(_delete_commands) : null);
		foreach (ListPool<HistoryTable> value in _insert_commands.Values)
		{
			if (value.Count == 0)
			{
				value.Dispose();
			}
			else
			{
				tCommandsList.Add(value);
			}
		}
		foreach (ListPool<BaseSystemData> value2 in _insert_metas.Values)
		{
			if (value2.Count == 0)
			{
				value2.Dispose();
			}
			else
			{
				tMetasList.Add(value2);
			}
		}
		clearCommands();
		_thread = asyncConnection.RunInTransactionAsync((Action<SQLiteConnection>)delegate(SQLiteConnection pDBConn)
		{
			sendToDB(pDBConn, tMetasList, tCommandsList, tDeleteCommandsList, tInsertLogsList);
		});
	}

	private static void sendToDB(SQLiteConnection pDBConn, ListPool<ListPool<BaseSystemData>> tMetasList = null, ListPool<ListPool<HistoryTable>> tCommandsList = null, ListPool<(long MetaID, Type MetaType)> tDeleteCommandsList = null, ListPool<WorldLogMessage> tInsertLogsList = null)
	{
		if (tMetasList != null)
		{
			foreach (ref ListPool<BaseSystemData> tMetas in tMetasList)
			{
				ListPool<BaseSystemData> current = tMetas;
				try
				{
					pDBConn.InsertAll((IEnumerable)current, Orm.GetType((object)current[0]), false);
					current.Dispose();
				}
				catch (Exception ex)
				{
					Debug.LogError((object)ex);
				}
			}
			tMetasList.Clear();
			tMetasList.Dispose();
		}
		if (tCommandsList != null)
		{
			foreach (ref ListPool<HistoryTable> tCommands in tCommandsList)
			{
				ListPool<HistoryTable> current2 = tCommands;
				try
				{
					pDBConn.InsertAll((IEnumerable)current2, Orm.GetType((object)current2[0]), false);
					current2.Dispose();
				}
				catch (Exception ex2)
				{
					Debug.LogError((object)ex2);
				}
			}
			tCommandsList.Clear();
			tCommandsList.Dispose();
		}
		if (tDeleteCommandsList != null)
		{
			foreach (ref(long, Type) tDeleteCommands in tDeleteCommandsList)
			{
				var (num, objType) = tDeleteCommands;
				try
				{
					pDBConn.Delete("id", num, objType);
				}
				catch (Exception ex3)
				{
					Debug.LogError((object)ex3);
				}
			}
			tDeleteCommandsList.Clear();
			tDeleteCommandsList.Dispose();
		}
		if (tInsertLogsList != null && tInsertLogsList.Count > 0)
		{
			try
			{
				pDBConn.InsertAll((IEnumerable)tInsertLogsList, typeof(WorldLogMessage), false);
			}
			catch (Exception ex4)
			{
				Debug.LogError((object)ex4);
			}
			tInsertLogsList.Clear();
			TableMapping mapping = pDBConn.GetMapping<WorldLogMessage>((CreateFlags)0);
			try
			{
				pDBConn.Execute($"DELETE FROM {mapping.TableName} WHERE ROWID IN ( SELECT ROWID FROM {mapping.TableName} ORDER by timestamp DESC, ROWID DESC LIMIT {2000}, 1000 )", Array.Empty<object>());
			}
			catch (Exception ex5)
			{
				Debug.LogError((object)ex5);
			}
		}
		tInsertLogsList?.Dispose();
	}

	public static void quitting()
	{
		_sql_timeout = float.MaxValue;
		waitForAsync();
	}

	public static void waitForAsync()
	{
		if (_thread != null && !_thread.IsCompleted)
		{
			Debug.Log((object)"DBInserter thread is still running");
			_thread.WaitAndUnwrapException();
			Debug.Log((object)"DBInserter closed");
			_thread = null;
		}
	}
}
// --- End of File: DBInserter.cs ---



// --- Start of File: DBManager.cs ---
using System;
using System.IO;
using SQLite;
using UnityEngine;

namespace db;

public class DBManager : MonoBehaviour
{
	private static SQLiteAsyncConnection _dbconn;

	private static string _dbpath;

	private static void resetDataPath()
	{
		_dbpath = Application.persistentDataPath + "/stats.s3db";
	}

	public static bool loadDBFrom(string pPath)
	{
		try
		{
			closeDB();
			if (!File.Exists(pPath))
			{
				return false;
			}
			resetDataPath();
			if (File.Exists(_dbpath))
			{
				File.Delete(_dbpath);
			}
			File.Copy(pPath, _dbpath);
			openDB();
			return true;
		}
		catch (Exception ex)
		{
			Debug.Log((object)"[SQLITE] error loading db");
			Debug.LogError((object)ex);
			return false;
		}
	}

	public static void createDB()
	{
		try
		{
			closeDB();
			resetDataPath();
			if (File.Exists(_dbpath))
			{
				File.Delete(_dbpath);
			}
			Debug.Log((object)("[SQLITE] new db " + _dbpath));
			openDB();
		}
		catch (Exception ex)
		{
			Debug.Log((object)"[SQLITE] error creating db");
			Debug.Log((object)ex);
		}
	}

	public static void openDB()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (Config.disable_db || _dbconn != null)
		{
			return;
		}
		_dbconn = new SQLiteAsyncConnection(_dbpath, (SQLiteOpenFlags)32774, true);
		Debug.Log((object)("[SQLITE] opening db " + _dbconn.LibVersionNumber));
		_dbconn.Trace = false;
		SQLiteConnectionWithLock connection = _dbconn.GetConnection();
		LockWrapper val = connection.Lock();
		try
		{
			((SQLiteConnection)connection).ExecuteScalar<string>("PRAGMA temp_store=MEMORY;", Array.Empty<object>());
			((SQLiteConnection)connection).ExecuteScalar<string>("PRAGMA synchronous=OFF;", Array.Empty<object>());
			((SQLiteConnection)connection).ExecuteScalar<string>("PRAGMA cache_size=4000;", Array.Empty<object>());
			((SQLiteConnection)connection).ExecuteScalar<string>("PRAGMA journal_mode=MEMORY;", Array.Empty<object>());
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static SQLiteAsyncConnection getAsyncConnection()
	{
		openDB();
		return _dbconn;
	}

	public static SQLiteConnectionWithLock getSyncConnection()
	{
		openDB();
		return _dbconn.GetConnection();
	}

	public static void clearAndClose()
	{
		DBInserter.waitForAsync();
		DBInserter.clearCommands();
		closeDB();
	}

	public static void closeDB()
	{
		if (!Config.disable_db && _dbconn != null)
		{
			Debug.Log((object)"[SQLITE] closing db");
			try
			{
				_dbconn.CloseAsync().WaitAndUnwrapException();
			}
			catch (Exception ex)
			{
				Debug.LogError((object)"[SQLITE] error closing db");
				Debug.LogError((object)ex);
			}
			_dbconn = null;
			Debug.Log((object)"[SQLITE] db closed");
		}
	}

	private static void vacuum()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		openDB();
		SQLiteConnectionWithLock connection = _dbconn.GetConnection();
		LockWrapper val = connection.Lock();
		try
		{
			((SQLiteConnection)connection).Execute("vacuum", Array.Empty<object>());
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	private static void backupTo(string pPath)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		openDB();
		SQLiteConnectionWithLock connection = _dbconn.GetConnection();
		LockWrapper val = connection.Lock();
		try
		{
			((SQLiteConnection)connection).Backup(pPath, "main");
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static void saveToPath(string pPath)
	{
		if (File.Exists(pPath))
		{
			File.Delete(pPath);
		}
		if (Config.disable_db)
		{
			return;
		}
		string text = "Stats DB";
		string text2 = pPath + ".bak";
		bool flag = false;
		try
		{
			DBInserter.executeCommands();
			vacuum();
			backupTo(text2);
		}
		catch (IOException ex)
		{
			if (Toolbox.IsDiskFull(ex))
			{
				WorldTip.showNow("Error saving " + text + " : Disk full!", pTranslate: false, "top");
			}
			else
			{
				Debug.Log((object)("Could not save " + text + " due to hard drive / IO Error : "));
				Debug.Log((object)ex);
				WorldTip.showNow("Error saving " + text + " due to IOError! Check console for details", pTranslate: false, "top");
			}
			flag = true;
		}
		catch (Exception ex2)
		{
			Debug.Log((object)("Could not save " + text + " due to error : "));
			Debug.Log((object)ex2);
			WorldTip.showNow("Error saving " + text + "! Check console for errors", pTranslate: false, "top");
			flag = true;
		}
		if (flag)
		{
			if (File.Exists(text2))
			{
				File.Delete(text2);
			}
		}
		else
		{
			Toolbox.MoveSafely(text2, pPath);
		}
	}

	private void Awake()
	{
		ScrollWindow.addCallbackShowStarted(delegate
		{
			DBInserter.executeCommands();
		});
	}

	private void OnApplicationQuit()
	{
		DBInserter.quitting();
		closeDB();
	}
}
// --- End of File: DBManager.cs ---



// --- Start of File: DBTables.cs ---
using System;
using SQLite;
using UnityEngine;

namespace db;

public static class DBTables
{
	public static void createOrMigrateTables()
	{
		createTable<WorldLogMessage>();
		createTable<KingdomData>();
	}

	public static void createOrMigrateTable(Type pType)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			if ((int)((SQLiteConnection)syncConnection).CreateTable(pType, (CreateFlags)0) != 1)
			{
				TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(pType, (CreateFlags)0);
				string text = "SELECT sql FROM sqlite_master WHERE type='table' AND name=?";
				string text2 = ((SQLiteConnection)syncConnection).ExecuteScalar<string>(text, new object[1] { mapping.TableName });
				((SQLiteConnection)syncConnection).DropTable(mapping);
				text2 = text2[..text2.LastIndexOf(')')];
				text2 = text2.Replace(" integer ", " INT ").Trim().Replace("  ", " ")
					.Replace(" ,", ",")
					.Replace(", ", ",")
					.Replace("\"", "");
				text2 += ",\nauto INT";
				text2 += ",\nPRIMARY KEY(id, timestamp)";
				text2 += "\n)";
				((SQLiteConnection)syncConnection).Execute(text2, Array.Empty<object>());
			}
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static void checkTablesOK(bool pDropTable = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		int currentYear = Date.getCurrentYear();
		bool flag = true;
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			foreach (HistoryMetaDataAsset item in AssetManager.history_meta_data_library.list)
			{
				if (!flag)
				{
					break;
				}
				foreach (Type value in item.table_types.Values)
				{
					if (checkTableExists(value) && !checkTableOK(value, currentYear))
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				return;
			}
			if (pDropTable)
			{
				Debug.Log((object)"Statistics have future data, dropping...");
				foreach (HistoryMetaDataAsset item2 in AssetManager.history_meta_data_library.list)
				{
					foreach (Type value2 in item2.table_types.Values)
					{
						if (checkTableExists(value2))
						{
							TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(value2, (CreateFlags)0);
							((SQLiteConnection)syncConnection).DropTable(mapping);
						}
					}
				}
				if (checkTableExists<KingdomData>())
				{
					((SQLiteConnection)syncConnection).DropTable<KingdomData>();
				}
				if (checkTableExists<WorldLogMessage>())
				{
					((SQLiteConnection)syncConnection).DropTable<WorldLogMessage>();
				}
				return;
			}
			Debug.Log((object)"Statistics have future data, clearing...");
			foreach (HistoryMetaDataAsset item3 in AssetManager.history_meta_data_library.list)
			{
				foreach (Type value3 in item3.table_types.Values)
				{
					if (checkTableExists(value3))
					{
						TableMapping mapping2 = ((SQLiteConnection)syncConnection).GetMapping(value3, (CreateFlags)0);
						((SQLiteConnection)syncConnection).DeleteAll(mapping2);
					}
				}
			}
			if (checkTableExists<KingdomData>())
			{
				((SQLiteConnection)syncConnection).DeleteAll<KingdomData>();
			}
			if (checkTableExists<WorldLogMessage>())
			{
				((SQLiteConnection)syncConnection).DeleteAll<WorldLogMessage>();
			}
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static bool checkTableExists(Type pType)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(pType, (CreateFlags)0);
			string text = "SELECT count(1) FROM sqlite_master WHERE type='table' AND name=?";
			if (((SQLiteConnection)syncConnection).ExecuteScalar<int>(text, new object[1] { mapping.TableName }) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static bool checkTableOK(Type pType, int pTimestamp)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			TableMapping mapping = ((SQLiteConnection)syncConnection).GetMapping(pType, (CreateFlags)0);
			string text = "SELECT count(1) FROM '" + mapping.TableName + "' WHERE timestamp>?";
			if (((SQLiteConnection)syncConnection).ExecuteScalar<int>(text, new object[1] { pTimestamp }) == 0)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static bool checkTableExists<T>()
	{
		return checkTableExists(typeof(T));
	}

	public static void createTableIfNotExists<T>()
	{
		if (!checkTableExists<T>())
		{
			createTable<T>();
		}
	}

	public static void createTable<T>()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
		LockWrapper val = syncConnection.Lock();
		try
		{
			((SQLiteConnection)syncConnection).CreateTable<T>((CreateFlags)0);
		}
		finally
		{
			((IDisposable)(LockWrapper)(ref val)).Dispose();
		}
	}

	public static void createOrMigrateTablesLoader(bool pCreating = true)
	{
		string text = (pCreating ? "Creating" : "Migrating");
		if (!pCreating)
		{
			SmoothLoader.add(delegate
			{
				SQLiteConnectionWithLock syncConnection2 = DBManager.getSyncConnection();
				foreach (HistoryMetaDataAsset item in AssetManager.history_meta_data_library.list)
				{
					DBTriggers.dropTrigger(syncConnection2, item);
				}
			}, "Dropping Triggers");
		}
		SmoothLoader.add(delegate
		{
			createOrMigrateTables();
		}, text + " Stats");
		foreach (HistoryMetaDataAsset tHistoryAsset in AssetManager.history_meta_data_library.list)
		{
			SmoothLoader.add(delegate
			{
				foreach (Type value in tHistoryAsset.table_types.Values)
				{
					createOrMigrateTable(value);
				}
			}, text + " Stats (" + tHistoryAsset.table_type.Name + ")");
		}
		SmoothLoader.add(delegate
		{
			SQLiteConnectionWithLock syncConnection = DBManager.getSyncConnection();
			foreach (HistoryMetaDataAsset item2 in AssetManager.history_meta_data_library.list)
			{
				DBTriggers.createTrigger(syncConnection, item2);
			}
		}, text + " Triggers");
	}
}
// --- End of File: DBTables.cs ---



// --- Start of File: DBTriggers.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using SQLite;

namespace db;

public static class DBTriggers
{
	public static void createTrigger(SQLiteConnectionWithLock pDBConn, HistoryMetaDataAsset tHistoryAsset)
	{
		List<string> list = new List<string>();
		List<HistoryDataAsset> list2 = new List<HistoryDataAsset>();
		foreach (HistoryDataAsset category in tHistoryAsset.categories)
		{
			list2.Add(category);
			list.Add(category.id);
		}
		foreach (HistoryInterval key in tHistoryAsset.table_types.Keys)
		{
			Type type = tHistoryAsset.table_types[key];
			var (pYearDiviver, historyInterval) = key.fillFrom();
			if (historyInterval != 0)
			{
				Type type2 = tHistoryAsset.table_types[historyInterval];
				createInsertionTrigger(pDBConn, type.Name, list2, type2.Name, pYearDiviver);
			}
			createNullDuplicateValuesTrigger(pDBConn, type.Name, list);
			int maxTimeFrame = key.getMaxTimeFrame();
			createTrimTableTrigger(pDBConn, type.Name, list, maxTimeFrame);
		}
	}

	public static void dropTrigger(SQLiteConnectionWithLock pDBConn, HistoryMetaDataAsset tHistoryAsset)
	{
		foreach (HistoryInterval key in tHistoryAsset.table_types.Keys)
		{
			Type type = tHistoryAsset.table_types[key];
			(int tEveryYears, HistoryInterval tFromInterval) tuple = key.fillFrom();
			var (pYearDiviver, _) = tuple;
			if (tuple.tFromInterval != 0)
			{
				dropInsertionTrigger(pDBConn, type.Name, pYearDiviver);
			}
			dropNullDuplicateValuesTrigger(pDBConn, type.Name);
			dropTrimTableTrigger(pDBConn, type.Name);
		}
	}

	public static void dropTrimTableTrigger(SQLiteConnectionWithLock pDBConn, string pTableName)
	{
		((SQLiteConnection)pDBConn).ExecuteScalar<string>("DROP TRIGGER IF EXISTS DELETE_OLD_" + pTableName, Array.Empty<object>());
	}

	public static void createTrimTableTrigger(SQLiteConnectionWithLock pDBConn, string pTableName, List<string> pColumns, int pMaxYears)
	{
		string text = string.Format("CREATE TRIGGER IF NOT EXISTS DELETE_OLD_{0}\n\t\t\tAFTER INSERT ON {1}\n\t\t\tWHEN\n\t\t\t\tNEW.timestamp % {2} = 0\n\t\t\tAND\n\t\t\t\tEXISTS (\n    \t\t\t\tSELECT 1 FROM {3}\n    \t\t\t\tWHERE\n\t\t\t\t\t\tid = NEW.id AND\n\t\t\t\t\t\ttimestamp < (NEW.timestamp - {4})\n\t\t\t\t\tLIMIT 1\n\t\t\t\t)\n\t\t\tBEGIN\n\t\t\t\tINSERT OR REPLACE INTO {5}\n\t\t\t\t(\n\t\t\t\t\tid,\n\t\t\t\t\ttimestamp,\n\t\t\t\t\t{6},\n\t\t\t\t\tauto\n\t\t\t\t) VALUES (\n\t\t\t\t\tNEW.id,\n\t\t\t\t\tNEW.timestamp - {7},\n\t\t\t\t\t{8},\n\t\t\t\t\t1\n\t\t\t\t);\n\n-- \t\t\t\tUPDATE {9}\n-- \t\t\t\tSET\n-- \t\t\t\t\t{10}\n-- \t\t\t\tWHERE\n-- \t\t\t\t\tid = NEW.id AND\n-- \t\t\t\t\ttimestamp = (NEW.timestamp - {11})\n-- \t\t\t\t;\n\n\t\t\t\tDELETE FROM {12}\n\t\t\t\tWHERE\n\t\t\t\t\tid = NEW.id AND\n\t\t\t\t\ttimestamp < (NEW.timestamp - {13})\n\t\t\t\t;\n\t\t\tEND;", pTableName, pTableName, pMaxYears, pTableName, pMaxYears, pTableName, string.Join(", ", pColumns), pMaxYears, string.Join(", ", pColumns.Select((string x) => $"(SELECT {x} FROM {pTableName} WHERE id = NEW.id AND timestamp <= (NEW.timestamp - {pMaxYears}) AND {x} IS NOT NULL ORDER BY timestamp DESC LIMIT 1)")), pTableName, string.Join(", ", pColumns.Select((string x) => $"{x} = CASE WHEN {x} IS NULL THEN (SELECT {x} FROM {pTableName} WHERE id = NEW.id AND timestamp <= (NEW.timestamp - {pMaxYears}) AND {x} IS NOT NULL ORDER BY timestamp DESC LIMIT 1) ELSE {x} END")), pMaxYears, pTableName, pMaxYears);
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
	}

	public static void dropNullDuplicateValuesTrigger(SQLiteConnectionWithLock pDBConn, string pTableName)
	{
		((SQLiteConnection)pDBConn).ExecuteScalar<string>("DROP TRIGGER IF EXISTS NULL_DUPLICATES_" + pTableName, Array.Empty<object>());
	}

	public static void createNullDuplicateValuesTrigger(SQLiteConnectionWithLock pDBConn, string pTableName, List<string> pColumns)
	{
		string text = "CREATE TRIGGER IF NOT EXISTS NULL_DUPLICATES_" + pTableName + "\n\t\t\tAFTER INSERT ON " + pTableName + "\n\t\t\t\tWHEN NOT EXISTS (\n\t\t\t\t\tSELECT 1 FROM " + pTableName + " WHERE id = NEW.id AND timestamp > NEW.timestamp LIMIT 1\n\t\t\t\t)\n\t\t\tBEGIN\n\t\t\t\tUPDATE " + pTableName + "\n\t\t\t\tSET " + string.Join(", ", pColumns.Select((string x) => x + " = CASE WHEN (SELECT " + x + " FROM " + pTableName + " WHERE id = NEW.id AND " + x + " IS NOT NULL ORDER BY timestamp DESC LIMIT 1,1) = NEW." + x + " THEN NULL ELSE NEW." + x + " END")) + "\n\t\t\t\tWHERE rowid = NEW.rowid;\n\n\t\t\t\tDELETE FROM " + pTableName + " WHERE rowid = NEW.rowid AND " + string.Join(" AND ", pColumns.Select((string x) => x + " IS NULL")) + ";\n\t\t\tEND;";
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
	}

	public static void dropInsertionTrigger(SQLiteConnectionWithLock pDBConn, string pTargetTable, int pYearDiviver)
	{
		((SQLiteConnection)pDBConn).ExecuteScalar<string>($"DROP TRIGGER IF EXISTS FILL_{pTargetTable}_{pYearDiviver}", Array.Empty<object>());
	}

	public static void createInsertionTrigger(SQLiteConnectionWithLock pDBConn, string pTargetTable, List<HistoryDataAsset> pColumns, string pSourceTable, int pYearDiviver)
	{
		string text = string.Format("CREATE TRIGGER IF NOT EXISTS FILL_{0}_{1}\n\t\t\tAFTER INSERT ON {2}\n\t\t\t\tWHEN NEW.timestamp % {3} = 0 AND NEW.auto IS NOT 1\n\t\t\tBEGIN\n\t\t\tINSERT INTO\n\t\t\t\t{4}(\n\t\t\t\t\t{5},\n\t\t\t\t\tid,\n\t\t\t\t\ttimestamp\n\t\t\t\t)\n\t\t\tSELECT\n\t\t\t\t{6},\n\t\t\t\tNEW.id,\n\t\t\t\tNEW.timestamp\n\t\t\tFROM\n\t\t\t\t(\n\t\t\t\t\tSELECT\n\t\t\t\t\t\t*\n\t\t\t\t\tFROM\n\t\t\t\t\t\t{7}\n\t\t\t\t\tWHERE\n\t\t\t\t\t\tid = NEW.id\n\t\t\t\t\tAND\n\t\t\t\t\t\ttimestamp >= NEW.timestamp - {8}\n\t\t\t\t\tAND\n\t\t\t\t\t\ttimestamp < NEW.timestamp\n\t\t\t\t\tORDER BY\n\t\t\t\t\t\ttimestamp DESC\n\t\t\t\t);\n\n\t\t\tEND;", pTargetTable, pYearDiviver, pSourceTable, pYearDiviver, pTargetTable, string.Join(", ", pColumns.Select((HistoryDataAsset x) => x.id)), string.Join(", ", pColumns.Select(delegate(HistoryDataAsset x)
		{
			if (x.max)
			{
				return "MAX(" + x.id + ")";
			}
			if (x.sum)
			{
				return "SUM(" + x.id + ")";
			}
			return x.average ? ("CAST(AVG(" + x.id + ")+1-1e-1 AS INT)") : ("ROUND(AVG(" + x.id + "))");
		})), pSourceTable, pYearDiviver);
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
	}
}
// --- End of File: DBTriggers.cs ---



// --- Start of File: DeadAnimation.cs ---
using System;

[Serializable]
public delegate bool DeadAnimation(BaseSimObject pTarget, WorldTile pTile, float pElapsed);
// --- End of File: DeadAnimation.cs ---



// --- Start of File: DeadKingdom.cs ---
public class DeadKingdom : Kingdom
{
	public override void loadData(KingdomData pData)
	{
		setData(pData);
		data.load();
		ActorAsset actorAsset = getActorAsset();
		asset = AssetManager.kingdoms.get(actorAsset.kingdom_id_civilization);
	}

	public override int getAge()
	{
		int year = Date.getYear(data.created_time);
		return Date.getYear(data.died_time) - year;
	}

	public override string getMotto()
	{
		return data.motto;
	}
}
// --- End of File: DeadKingdom.cs ---



// --- Start of File: DebugActorsSpeed.cs ---
using UnityEngine;

public class DebugActorsSpeed : MonoBehaviour
{
	public int speedup = 20;

	private void Update()
	{
	}
}
// --- End of File: DebugActorsSpeed.cs ---



// --- Start of File: DebugAnimatedVariation.cs ---
using UnityEngine;

public class DebugAnimatedVariation
{
	public bool animated;

	public Sprite[] frames;

	public DebugAnimatedVariation(Sprite[] pFrames, bool pAnimated)
	{
		animated = pAnimated;
		frames = pFrames;
	}
}
// --- End of File: DebugAnimatedVariation.cs ---



// --- Start of File: DebugAnimationVariation.cs ---
using UnityEngine;
using UnityEngine.UI;

public class DebugAnimationVariation : MonoBehaviour
{
	public SpriteAnimation sprite_animation;

	public Image image;
}
// --- End of File: DebugAnimationVariation.cs ---



// --- Start of File: DebugAvatarsWindow.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class DebugAvatarsWindow : MonoBehaviour
{
	private static readonly bool _test_mutations = false;

	private static readonly bool _test_eggs = true;

	private static readonly bool _test_hand_items = false;

	private static readonly bool _test_statuses = false;

	[SerializeField]
	private Transform _avatars_parent;

	[SerializeField]
	private UnitAvatarLoader _avatar_prefab;

	[SerializeField]
	private Image _autotest_button_icon;

	[SerializeField]
	private Sprite _sprite_play;

	[SerializeField]
	private Sprite _sprite_pause;

	private ObjectPoolGenericMono<UnitAvatarLoader> _avatars;

	private List<SubspeciesTrait> _pool_mutations = new List<SubspeciesTrait>();

	private List<SubspeciesTrait> _pool_eggs = new List<SubspeciesTrait>();

	private List<PhenotypeAsset> _pool_phenotype = new List<PhenotypeAsset>();

	private List<AvatarCombineHandItem> _pool_hand_renderers = new List<AvatarCombineHandItem>();

	private List<StatusAsset> _pool_statuses = new List<StatusAsset>();

	private AvatarsCombineDataContainer _combine_data = new AvatarsCombineDataContainer();

	private HashSet<string> _statuses = new HashSet<string>();

	private HashSet<long> _check_collisions = new HashSet<long>();

	private bool _autotest_state;

	private Coroutine _autotest_routine;

	private void Awake()
	{
		init();
	}

	private void init()
	{
		_avatars = new ObjectPoolGenericMono<UnitAvatarLoader>(_avatar_prefab, _avatars_parent);
		preparePools();
	}

	private void OnEnable()
	{
		showAvatars();
	}

	private void OnDisable()
	{
		clear();
	}

	private void clear()
	{
		_avatars.clear();
	}

	private void showAvatars()
	{
		foreach (ActorAsset item in AssetManager.actor_library.list)
		{
			if (item.has_override_sprite || !item.has_sprite_renderer)
			{
				continue;
			}
			SubspeciesTrait randomMutation = getRandomMutation();
			bool randomIsAdult = getRandomIsAdult();
			ActorSex randomSex = getRandomSex();
			ColorAsset random = AssetManager.kingdom_colors_library.list.GetRandom();
			bool randomIsUnconscious = getRandomIsUnconscious();
			bool pIsLying = randomIsUnconscious || getRandomIsLying();
			bool randomIsHovering = getRandomIsHovering();
			bool pIsTouchingLiquid = getRandomIsTouchingLiquid() && !randomIsHovering;
			bool randomIsImmovable = getRandomIsImmovable();
			AvatarCombineHandItem randomItemPath = getRandomItemPath();
			bool pStopIdleAnimation;
			List<string> randomStatuses = getRandomStatuses(out pStopIdleAnimation);
			PhenotypeAsset randomPhenotype = getRandomPhenotype();
			int randomPhenotypeShade = Actor.getRandomPhenotypeShade();
			SubspeciesTrait randomEgg = getRandomEgg();
			bool pIsEgg = !randomIsAdult && randomEgg != null;
			ActorTextureSubAsset texture_asset;
			if (randomMutation != null)
			{
				texture_asset = randomMutation.texture_asset;
				BaseStats base_stats_meta = randomMutation.base_stats_meta;
				if (!base_stats_meta.isEmpty() && base_stats_meta.hasTag("always_idle_animation"))
				{
					pStopIdleAnimation = false;
				}
			}
			else
			{
				texture_asset = item.texture_asset;
			}
			DynamicActorSpriteCreatorUI.getContainerForUI(item, randomIsAdult, texture_asset, randomMutation, pIsEgg, randomEgg);
			ActorAvatarData actorAvatarData = new ActorAvatarData();
			actorAvatarData.setData(item, randomMutation, randomSex, Randy.randomInt(0, int.MaxValue), -1, null, randomPhenotype.phenotype_index, randomPhenotypeShade, random, pIsEgg, pIsKing: false, pIsWarrior: false, pIsWise: false, randomEgg, randomIsAdult, pIsLying, pIsTouchingLiquid, pIsInsideBoat: false, randomIsHovering, randomIsImmovable, randomIsUnconscious, pStopIdleAnimation, randomItemPath?.hand_renderer, 1, randomStatuses, null);
			_avatars.getNext().load(actorAvatarData);
		}
	}

	private void preparePools()
	{
		foreach (SubspeciesTrait item2 in AssetManager.subspecies_traits.list)
		{
			if (item2.is_mutation_skin)
			{
				_pool_mutations.Add(item2);
			}
			if (item2.phenotype_egg)
			{
				_pool_eggs.Add(item2);
			}
			if (item2.phenotype_skin)
			{
				PhenotypeAsset item = AssetManager.phenotype_library.get(item2.id_phenotype);
				_pool_phenotype.Add(item);
			}
		}
		foreach (EquipmentAsset item3 in AssetManager.items.pot_weapon_assets_all)
		{
			_pool_hand_renderers.Add(new AvatarCombineHandItem(item3));
		}
		foreach (ResourceAsset item4 in AssetManager.resources.list)
		{
			_pool_hand_renderers.Add(new AvatarCombineHandItem(item4));
		}
		foreach (UnitHandToolAsset item5 in AssetManager.unit_hand_tools.list)
		{
			_pool_hand_renderers.Add(new AvatarCombineHandItem(item5));
		}
		foreach (StatusAsset item6 in AssetManager.status.list)
		{
			if (item6.need_visual_render)
			{
				_pool_statuses.Add(item6);
			}
		}
	}

	private SubspeciesTrait getRandomMutation()
	{
		if (Randy.randomChance(0.75f))
		{
			return null;
		}
		return _pool_mutations.GetRandom();
	}

	private SubspeciesTrait getRandomEgg()
	{
		if (Randy.randomChance(0.9f))
		{
			return null;
		}
		return _pool_eggs.GetRandom();
	}

	private PhenotypeAsset getRandomPhenotype()
	{
		return _pool_phenotype.GetRandom();
	}

	private ActorSex getRandomSex()
	{
		if (Randy.randomChance(0.5f))
		{
			return ActorSex.Male;
		}
		return ActorSex.Female;
	}

	private bool getRandomIsAdult()
	{
		return Randy.randomBool();
	}

	private bool getRandomIsLying()
	{
		return Randy.randomChance(0.2f);
	}

	private bool getRandomIsTouchingLiquid()
	{
		return Randy.randomBool();
	}

	private bool getRandomIsHovering()
	{
		return Randy.randomChance(0.2f);
	}

	private bool getRandomIsImmovable()
	{
		return Randy.randomChance(0.2f);
	}

	private bool getRandomIsUnconscious()
	{
		return Randy.randomChance(0.2f);
	}

	private AvatarCombineHandItem getRandomItemPath()
	{
		if (Randy.randomChance(0.4f))
		{
			return null;
		}
		return _pool_hand_renderers.GetRandom();
	}

	private List<string> getRandomStatuses(out bool pStopIdleAnimation)
	{
		pStopIdleAnimation = false;
		List<string> list = new List<string>();
		foreach (StatusAsset item in AssetManager.status.list)
		{
			if (item.need_visual_render && !Randy.randomChance(0.95f))
			{
				if (item.base_stats.hasTag("stop_idle_animation"))
				{
					pStopIdleAnimation = true;
				}
				list.Add(item.id);
			}
		}
		return list;
	}

	public void toggleAutotest()
	{
		_autotest_state = !_autotest_state;
		if (_autotest_state)
		{
			_autotest_button_icon.sprite = _sprite_pause;
			_autotest_routine = ((MonoBehaviour)this).StartCoroutine(autotestRoutine());
		}
		else
		{
			_autotest_button_icon.sprite = _sprite_play;
			((MonoBehaviour)this).StopCoroutine(_autotest_routine);
		}
	}

	private T getFromPool<T>(List<T> pPool, int pGlobalIndex, string pId) where T : class
	{
		int listIndex = _combine_data.getListIndex(pGlobalIndex, pId);
		if (pPool.Count - 1 < listIndex)
		{
			return null;
		}
		return pPool[listIndex];
	}

	private bool getBool(int pGlobalIndex, string pId)
	{
		return _combine_data.getListIndex(pGlobalIndex, pId) == 1;
	}

	private IEnumerator autotestRoutine()
	{
		_combine_data.clear();
		_statuses.Clear();
		_check_collisions.Clear();
		_combine_data.add("tAdult", 2);
		_combine_data.add("tTouchingLiquid", 2);
		_combine_data.add("tLying", 2);
		_combine_data.add("tImmovable", 2);
		_combine_data.add("tUnconscious", 2);
		_combine_data.add("tSex", 2);
		if (_test_mutations)
		{
			_combine_data.add("_pool_mutations", _pool_mutations.Count);
		}
		if (_test_eggs)
		{
			_combine_data.add("_pool_eggs", _pool_eggs.Count);
		}
		if (_test_hand_items)
		{
			_combine_data.add("_pool_hand_renderers", _pool_hand_renderers.Count);
		}
		if (_test_statuses)
		{
			_combine_data.add("_pool_statuses", _pool_statuses.Count);
		}
		int tTotal = _combine_data.totalCombinations();
		for (int i = 0; i < tTotal; i++)
		{
			bool @bool = getBool(i, "tAdult");
			bool bool2 = getBool(i, "tTouchingLiquid");
			bool bool3 = getBool(i, "tLying");
			bool bool4 = getBool(i, "tImmovable");
			bool bool5 = getBool(i, "tUnconscious");
			ActorSex actorSex = ((!getBool(i, "tSex")) ? ActorSex.Female : ActorSex.Male);
			bool flag = false;
			bool flag2 = false;
			long num = (@bool ? 1 : 2) + (bool2 ? 1 : 2) * 10 + (bool3 ? 1 : 2) * 100 + (bool4 ? 1 : 2) * 1000 + (bool5 ? 1 : 2) * 10000 + ((actorSex == ActorSex.Male) ? 1 : 2) * 100000 + (flag ? 1 : 2) * 1000000;
			SubspeciesTrait subspeciesTrait = null;
			if (_test_mutations)
			{
				subspeciesTrait = getFromPool(_pool_mutations, i, "_pool_mutations");
				num += _pool_mutations.IndexOf(subspeciesTrait) * 100000000;
				BaseStats base_stats_meta = subspeciesTrait.base_stats_meta;
				if (!base_stats_meta.isEmpty() && base_stats_meta.hasTag("always_idle_animation"))
				{
					flag2 = true;
				}
			}
			SubspeciesTrait subspeciesTrait2 = null;
			if (subspeciesTrait == null && _test_eggs)
			{
				subspeciesTrait2 = getFromPool(_pool_eggs, i, "_pool_eggs");
				num += _pool_eggs.IndexOf(subspeciesTrait2) * 10000000000L;
			}
			bool flag3 = subspeciesTrait2 != null;
			IHandRenderer handRenderer;
			if (!flag3 && _test_hand_items)
			{
				AvatarCombineHandItem fromPool = getFromPool(_pool_hand_renderers, i, "_pool_hand_renderers");
				num += _pool_hand_renderers.IndexOf(fromPool) * 10000000000000L;
				handRenderer = fromPool.hand_renderer;
			}
			else
			{
				handRenderer = null;
				num += _pool_hand_renderers.Count * 10000000000000L;
			}
			StatusAsset statusAsset = null;
			if (_test_statuses)
			{
				statusAsset = getFromPool(_pool_statuses, i, "_pool_statuses");
				num += _pool_statuses.IndexOf(statusAsset) * 10000000000000000L;
			}
			int num2 = 1;
			foreach (UnitAvatarLoader item in _avatars.getListTotal())
			{
				_statuses.Clear();
				StatusAsset statusAsset2 = ((_test_statuses && Randy.randomBool()) ? _pool_statuses.GetRandom() : null);
				StatusAsset statusAsset3 = ((_test_statuses && Randy.randomBool()) ? _pool_statuses.GetRandom() : null);
				if (statusAsset != null)
				{
					_statuses.Add(statusAsset.id);
					if (statusAsset.base_stats.hasTag("stop_idle_animation"))
					{
						flag = true;
					}
				}
				if (statusAsset2 != null)
				{
					_statuses.Add(statusAsset2.id);
					if (statusAsset2.base_stats.hasTag("stop_idle_animation"))
					{
						flag = true;
					}
				}
				if (statusAsset3 != null)
				{
					_statuses.Add(statusAsset3.id);
					if (statusAsset3.base_stats.hasTag("stop_idle_animation"))
					{
						flag = true;
					}
				}
				num2++;
				ActorAvatarData data = item.getData();
				ActorAsset asset = data.asset;
				ActorTextureSubAsset pTextureAsset = ((subspeciesTrait == null) ? asset.texture_asset : subspeciesTrait.texture_asset);
				DynamicActorSpriteCreatorUI.getContainerForUI(asset, @bool, pTextureAsset, subspeciesTrait, flag3, subspeciesTrait2);
				if (flag2)
				{
					flag = false;
				}
				ActorAvatarData actorAvatarData = new ActorAvatarData();
				actorAvatarData.setData(data.asset, subspeciesTrait, actorSex, Randy.randomInt(0, int.MaxValue), -1, null, data.phenotype_index, data.phenotype_skin_shade, data.kingdom_color, flag3, pIsKing: false, pIsWarrior: false, pIsWise: false, subspeciesTrait2, @bool, bool3, bool2, pIsInsideBoat: false, data.is_hovering, bool4, bool5, flag, handRenderer, num2, _statuses, null);
				item.load(actorAvatarData);
			}
			_check_collisions.Add(num);
			Debug.Log((object)string.Format("tested: {0}/{1}, hashset: {2}/{3} adult: {4}, liquid: {5}, lying: {6}, immovable: {7}, uncon: {8}, sex: {9}, mut: {10}, egg: {11}, item: {12}, status: {13}", i + 1, tTotal, _check_collisions.Count, tTotal, @bool, bool2, bool3, bool4, bool5, actorSex, subspeciesTrait?.id ?? "null", subspeciesTrait2?.id ?? "null", handRenderer, statusAsset?.id ?? "null"));
			yield return null;
		}
	}
}
// --- End of File: DebugAvatarsWindow.cs ---



// --- Start of File: DebugButton.cs ---
using UnityEngine;

public class DebugButton : MonoBehaviour
{
	public GameObject premiumButton;
}
// --- End of File: DebugButton.cs ---



// --- Start of File: DebugConfig.cs ---
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class DebugConfig : MonoBehaviour
{
	public GameObject debugButton;

	public static DebugConfig instance;

	private static Dictionary<DebugOption, bool> _dictionary;

	private static int _pos_x = 20;

	public static List<string> default_debug_tools = new List<string>();

	public static bool debug_enabled => instance.debugButton.gameObject.activeSelf;

	private void Start()
	{
		instance = this;
		if (isOn(DebugOption.DisablePremium) || isOn(DebugOption.TestAds))
		{
			debugButton.SetActive(true);
			if (isOn(DebugOption.DisablePremium))
			{
				Debug.LogError((object)"[DEBUG] Premium is disabled via debug menu!");
				Debug.Log((object)"This option is only for beta testers. If you purchased premium, you won't have it until you disable it.");
				Debug.Log((object)"Disable this option in the debug menu and restart the game.");
			}
			if (isOn(DebugOption.TestAds))
			{
				Debug.LogError((object)"[DEBUG] Test Ads are enabled via debug menu!");
				Debug.Log((object)"This option is only for beta testers. You most likely don't want to play with it.");
				Debug.Log((object)"Disable this option in the debug menu and restart the game.");
			}
		}
	}

	private static void enableDefaultOptions()
	{
		setOption(DebugOption.GenerateNewMapOnMapLoadingError, pVal: true);
		setOption(DebugOption.LavaGlow, pVal: true);
		setOption(DebugOption.UseCameraAspect, pVal: true);
		setOption(DebugOption.UseGlobalPathLock, pVal: true);
		setOption(DebugOption.SystemBuildTick, pVal: true);
		setOption(DebugOption.SystemCityPlaceFinder, pVal: true);
		setOption(DebugOption.SystemProduceNewCitizens, pVal: true);
		setOption(DebugOption.SystemUnitPathfinding, pVal: true);
		setOption(DebugOption.SystemWorldBehaviours, pVal: true);
		setOption(DebugOption.SystemZoneGrowth, pVal: true);
		setOption(DebugOption.SystemCheckUnitAction, pVal: true);
		setOption(DebugOption.SystemUpdateUnitAnimation, pVal: true);
		setOption(DebugOption.SystemUpdateBuildings, pVal: true);
		setOption(DebugOption.SystemUpdateUnits, pVal: true);
		setOption(DebugOption.SystemUpdateCities, pVal: true);
		setOption(DebugOption.SystemRedrawMap, pVal: true);
		setOption(DebugOption.SystemUpdateDirtyChunks, pVal: true);
		setOption(DebugOption.SystemCheckGoodForBoat, pVal: false);
		setOption(DebugOption.SystemCityTasks, pVal: true);
		setOption(DebugOption.InspectObjectsOnClick, pVal: true);
		setOption(DebugOption.SystemMusic, pVal: false);
		setOption(DebugOption.Greg, pVal: false);
		setOption(DebugOption.MakeUnitsFollowCursor, pVal: false);
		setOption(DebugOption.SystemSplitAstar, pVal: true);
		setOption(DebugOption.UseCacheForRegionPath, pVal: true);
		setOption(DebugOption.ParallelJobsUpdater, pVal: true);
		setOption(DebugOption.ParallelChunks, pVal: true);
		setOption(DebugOption.ScaleEffectEnabled, pVal: true);
		if (Config.editor_devs && !Config.editor_nikon)
		{
			setOption(DebugOption.ExportAssetLibraries, pVal: true);
			setOption(DebugOption.GenerateGameplayReport, pVal: true);
			setOption(DebugOption.TesterLibs, pVal: true);
		}
		if (Config.isEditor)
		{
			setOption(DebugOption.DebugButton, pVal: true);
		}
	}

	public static void initDict()
	{
		_dictionary = new Dictionary<DebugOption, bool>();
		foreach (DebugOption value in Enum.GetValues(typeof(DebugOption)))
		{
			setOption(value, pVal: false);
		}
	}

	public static void init()
	{
		if (_dictionary != null)
		{
			return;
		}
		initDict();
		enableDefaultOptions();
		if (PlayerConfig.instance != null)
		{
			if (PlayerConfig.instance.data.premiumDisabled)
			{
				setOption(DebugOption.DisablePremium, pVal: true);
			}
			if (PlayerConfig.instance.data.testAds)
			{
				setOption(DebugOption.TestAds, pVal: true);
			}
		}
		if (Config.fmod_test_build)
		{
			Config.disable_discord = true;
			Config.disable_steam = true;
		}
		if (Config.isEditor)
		{
			Config.show_console_on_error = false;
			Config.customMapSizeDefault = "standard";
			setOption(DebugOption.Graphy, pVal: true);
		}
		if (Config.editor_maxim)
		{
			editorMaximOptions();
		}
		if (Config.editor_mastef)
		{
			editorMastefOptions();
		}
		if (Config.editor_nikon)
		{
			editorNikonOptions();
		}
	}

	private static void editorNikonOptions()
	{
		Config.show_console_on_error = false;
		Config.disable_discord = true;
		Config.disable_steam = true;
		Config.load_save_on_start = false;
		Config.load_save_on_start_slot = 8;
		Config.disable_startup_window = false;
		Config.disable_tutorial = true;
		MusicBox.debug_sounds = false;
		setOption(DebugOption.DebugButton, pVal: true);
		setOption(DebugOption.Graphy, pVal: false);
		setOption(DebugOption.PauseOnStart, pVal: true);
		setOption(DebugOption.ShowHiddenStats, pVal: true);
		setOption(DebugOption.DebugWindowHotkeys, pVal: true);
		setOption(DebugOption.DebugUnitHotkeys, pVal: true);
	}

	internal static void debugToolMastefDefaults(DebugTool pTool)
	{
		pTool.sort_order_reversed = false;
		pTool.sort_by_values = true;
		pTool.show_averages = false;
		pTool.hide_zeroes = false;
		pTool.show_counter = true;
		pTool.show_max = false;
		pTool.paused = false;
		pTool.hide_zeroes = true;
		pTool.state = DebugToolState.Values;
	}

	private static void editorMastefOptions()
	{
		Plot.DEBUG_PLOTS = false;
		Config.show_console_on_error = false;
		Config.disable_loading_logs = true;
		Config.disable_discord = true;
		Config.disable_steam = true;
		MusicBox.debug_sounds = false;
		Config.disable_startup_window = true;
		Config.disable_dispose_logs = true;
		setOption(DebugOption.OverlaySoundsActive, pVal: false);
		setOption(DebugOption.ShowLayoutGroupGrid, pVal: false);
		setOption(DebugOption.BenchAiEnabled, pVal: false);
		setOption(DebugOption.DebugTooltipUI, pVal: false);
		setOption(DebugOption.ParallelJobsUpdater, pVal: false);
		setOption(DebugOption.ParallelChunks, pVal: false);
		setOption(DebugOption.SonicSpeed, pVal: false);
		setOption(DebugOption.Graphy, pVal: false);
		MapBox.on_world_loaded = (Action)Delegate.Combine(MapBox.on_world_loaded, (Action)delegate
		{
		});
	}

	private static void debugBoats()
	{
		setOption(DebugOption.OverlayBoatTransport, pVal: true);
		setOption(DebugOption.BoatPassengerLines, pVal: true);
		setOption(DebugOption.ActorGizmosBoatTaxiRequestTargets, pVal: true);
		setOption(DebugOption.ActorGizmosBoatTaxiTarget, pVal: true);
		setOption(DebugOption.RenderIslandsTileCorners, pVal: true);
		setOption(DebugOption.RegionNeighbours, pVal: true);
		setOption(DebugOption.Region, pVal: true);
		addDebugTool("boat");
		addDebugTool("taxi");
		addDebugTool("tile_info");
	}

	private static void debugReproduction()
	{
		addDebugTool("reproduction_diagnostic_cursor");
		addDebugTool("reproduction_diagnostic_total");
		addDebugTool("city_jobs");
		addDebugTool("city_storage");
	}

	private static void debugMapChunks()
	{
		addDebugTool("map_chunks");
		addDebugTool("benchmark_chunks");
	}

	private static void editorMaximOptions()
	{
		setOption(DebugOption.GenerateNewMapOnMapLoadingError, pVal: false);
		Config.disable_discord = true;
		Config.disable_steam = true;
		Config.disable_startup_window = true;
		Config.show_console_on_error = false;
		Config.disable_tutorial = true;
		setOption(DebugOption.ControlledUnitsAttackRaycast, pVal: true);
		setOption(DebugOption.DebugWindowHotkeys, pVal: true);
		setOption(DebugOption.CivDrawCityClaimZone, pVal: true);
		setOption(DebugOption.PauseOnStart, pVal: true);
		setOption(DebugOption.ShowHiddenStats, pVal: true);
		setOption(DebugOption.DebugUnitHotkeys, pVal: true);
		setOption(DebugOption.ShowWarriorsCityText, pVal: true);
		setOption(DebugOption.ShowCityWeaponsText, pVal: true);
		setOption(DebugOption.ShowFoodCityText, pVal: true);
		setOption(DebugOption.CursorUnitAttackRange, pVal: true);
		setOption(DebugOption.ShowAmountNearArmy, pVal: true);
		for (int i = 0; i < 100; i++)
		{
			Debug.Log((object)"remember the cant");
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool isOn(DebugOption pOption)
	{
		return _dictionary[pOption];
	}

	public static void switchOption(DebugOption pOption)
	{
		setOption(pOption, !isOn(pOption));
		if (pOption == DebugOption.DisablePremium && PlayerConfig.instance != null)
		{
			PlayerConfig.instance.data.premiumDisabled = isOn(pOption);
			PlayerConfig.instance.data.clearDebugOnStart = false;
			PlayerConfig.saveData();
			PremiumElementsChecker.checkElements();
			disablePremiumNotify();
		}
		if (pOption == DebugOption.TestAds && PlayerConfig.instance != null)
		{
			PlayerConfig.instance.data.testAds = isOn(pOption);
			PlayerConfig.instance.data.clearDebugOnStart = false;
			PlayerConfig.saveData();
			PremiumElementsChecker.checkElements();
			testAdsNotify();
		}
	}

	public static void disablePremiumNotify()
	{
		if (PlayerConfig.instance != null)
		{
			if (isOn(DebugOption.DisablePremium))
			{
				WorldTip.showNow("Premium is blocked! Even after restart!", pTranslate: false, "top", 10f);
			}
			else
			{
				WorldTip.showNow("Premium is unblocked", pTranslate: false, "top");
			}
		}
	}

	public static void testAdsNotify()
	{
		if (PlayerConfig.instance != null)
		{
			if (isOn(DebugOption.TestAds))
			{
				WorldTip.showNow("Test Ads are enabled! Even after restart!", pTranslate: false, "top", 10f);
			}
			else
			{
				WorldTip.showNow("Test Ads disabled", pTranslate: false, "top");
			}
		}
	}

	public static void setOption(DebugOption pOption, bool pVal, bool pUpdateSpecialSettings = true)
	{
		if (_dictionary == null)
		{
			init();
		}
		_dictionary[pOption] = pVal;
		if (!pUpdateSpecialSettings)
		{
			return;
		}
		if (pOption == DebugOption.Graphy)
		{
			checkGraphy();
		}
		if (pOption == DebugOption.SonicSpeed && Config.game_loaded)
		{
			if (pVal)
			{
				Config.setWorldSpeed("x40", pUpdateDebug: false);
			}
			else
			{
				Config.setWorldSpeed("x1", pUpdateDebug: false);
			}
		}
	}

	public static void checkSonicTimeScales()
	{
		if (isOn(DebugOption.SonicSpeed))
		{
			Config.setWorldSpeed("x40", pUpdateDebug: false);
		}
		else
		{
			Config.setWorldSpeed("x1", pUpdateDebug: false);
		}
	}

	public static void checkGraphy()
	{
		if ((Object)(object)PrefabLibrary.instance != (Object)null)
		{
			PrefabLibrary.instance.graphy.gameObject.SetActive(isOn(DebugOption.Graphy));
		}
	}

	public static void createTool(string pID, int pX = 80, int pY = -10, int pWidth = -1)
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Bench.bench_enabled = true;
		DebugToolAsset asset = AssetManager.debug_tool_library.get(pID);
		DebugTool debugTool = Object.Instantiate<DebugTool>(PrefabLibrary.instance.debugTool, ((Component)instance).transform);
		debugTool.setAsset(asset);
		debugTool.populateOptions();
		for (int i = 0; i < debugTool.dropdown.options.Count; i++)
		{
			if (debugTool.dropdown.options[i].text == pID)
			{
				debugTool.dropdown.value = i;
				debugTool.dropdown.captionText.text = pID;
				break;
			}
		}
		((Component)debugTool).transform.localPosition = new Vector3((float)pX, (float)pY);
		_pos_x += 128;
	}

	private static void addDebugTool(string pID)
	{
		default_debug_tools.Add(pID);
	}
}
// --- End of File: DebugConfig.cs ---



// --- Start of File: DebugDropdown.cs ---
using UnityEngine;

public class DebugDropdown : MonoBehaviour
{
	[SerializeField]
	private DebugTool _debug_tool;

	private void OnEnable()
	{
		_debug_tool.active_dropdown = this;
	}
}
// --- End of File: DebugDropdown.cs ---



// --- Start of File: DebugDropdownOption.cs ---
using UnityEngine;
using UnityEngine.UI;

public class DebugDropdownOption : MonoBehaviour
{
	public Text title;
}
// --- End of File: DebugDropdownOption.cs ---



// --- Start of File: DebugHighlight.cs ---
using System.Collections.Generic;
using UnityEngine;

public static class DebugHighlight
{
	public static HashSet<DebugHighlightContainer> hashset = new HashSet<DebugHighlightContainer>();

	private static List<DebugHighlightContainer> to_remove = new List<DebugHighlightContainer>();

	public static void updateDebugHighlights()
	{
		if (hashset.Count == 0)
		{
			return;
		}
		to_remove.Clear();
		foreach (DebugHighlightContainer item in hashset)
		{
			item.timer -= World.world.delta_time;
			if (item.timer < 0f)
			{
				to_remove.Add(item);
			}
		}
		foreach (DebugHighlightContainer item2 in to_remove)
		{
			hashset.Remove(item2);
		}
	}

	public static void newHighlightList(Color pColor, List<TileZone> pZones, float pTime = 3f)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		foreach (TileZone pZone in pZones)
		{
			newHighlight(pColor, pZone, pTime);
		}
	}

	public static void newHighlightList(Color pColor, List<MapChunk> pChunks, float pTime = 3f)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		foreach (MapChunk pChunk in pChunks)
		{
			newHighlight(pColor, pChunk, pTime);
		}
	}

	public static void clear()
	{
		hashset.Clear();
	}

	public static void newHighlight(Color pColor, MapChunk pChunk, float pTime = 3f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		DebugHighlightContainer debugHighlightContainer = new DebugHighlightContainer();
		debugHighlightContainer.chunk = pChunk;
		debugHighlightContainer.color = pColor;
		debugHighlightContainer.setTimer(pTime);
		hashset.Add(debugHighlightContainer);
	}

	public static void newHighlight(Color pColor, TileZone pZone, float pTime = 3f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		DebugHighlightContainer debugHighlightContainer = new DebugHighlightContainer();
		debugHighlightContainer.zone = pZone;
		debugHighlightContainer.color = pColor;
		debugHighlightContainer.setTimer(pTime);
		hashset.Add(debugHighlightContainer);
	}
}
// --- End of File: DebugHighlight.cs ---



// --- Start of File: DebugHighlightContainer.cs ---
using UnityEngine;

public class DebugHighlightContainer
{
	public Color color;

	public float timer = 0.2f;

	public float interval = 0.2f;

	public TileZone zone;

	public MapChunk chunk;

	public WorldTile tile;

	public void setTimer(float pVal)
	{
		interval = pVal;
		timer = pVal;
	}
}
// --- End of File: DebugHighlightContainer.cs ---



// --- Start of File: DebugIconOptionAction.cs ---
using UnityEngine.UI;

public delegate void DebugIconOptionAction(Image pButton);
// --- End of File: DebugIconOptionAction.cs ---



// --- Start of File: DebugKingdomButton.cs ---
using UnityEngine;
using UnityEngine.UI;

public class DebugKingdomButton : MonoBehaviour
{
	[SerializeField]
	private Button _button;

	[SerializeField]
	private Image _image;

	internal KingdomAsset kingdom_asset;

	[SerializeField]
	private Image _discrepancy_bad;

	[SerializeField]
	private Image _discrepancy_have;

	[SerializeField]
	private Image _discrepancy_normal;

	public Image image => _image;

	public void setAsset(KingdomAsset pAsset)
	{
		kingdom_asset = pAsset;
		_image.sprite = kingdom_asset.getSprite();
		setupTooltip();
		if (kingdom_asset.assets_discrepancies_bad != null)
		{
			((Component)_discrepancy_have).gameObject.SetActive(true);
		}
		else
		{
			((Component)_discrepancy_have).gameObject.SetActive(false);
		}
	}

	public void checkSelected(KingdomAsset pAssetMain)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		((Component)_discrepancy_bad).gameObject.SetActive(false);
		((Component)_discrepancy_normal).gameObject.SetActive(false);
		if (kingdom_asset == pAssetMain)
		{
			((Graphic)image).color = Color.white;
			return;
		}
		if (kingdom_asset.assets_discrepancies != null && kingdom_asset.assets_discrepancies.Contains(pAssetMain.id))
		{
			((Component)_discrepancy_normal).gameObject.SetActive(true);
		}
		if (pAssetMain.assets_discrepancies_bad != null && pAssetMain.assets_discrepancies_bad.Contains(kingdom_asset.id))
		{
			((Component)_discrepancy_bad).gameObject.SetActive(true);
		}
		if (pAssetMain.isFoe(kingdom_asset))
		{
			((Graphic)image).color = new Color(0.2f, 0.2f, 0.2f);
		}
		else
		{
			((Graphic)image).color = Color.white;
		}
	}

	public void setupTooltip()
	{
		TipButton tipButton = default(TipButton);
		if (((Component)this).TryGetComponent<TipButton>(ref tipButton))
		{
			tipButton.hoverAction = showTooltip;
		}
	}

	private void showTooltip()
	{
		Tooltip.show(((Component)this).gameObject, "debug_kingdom_assets", new TooltipData
		{
			kingdom_asset = kingdom_asset
		});
	}

	public static void getTooltipDescription(KingdomAsset pAsset, out string pDescription, out string pDescription2)
	{
		pDescription = string.Empty;
		pDescription2 = string.Empty;
		if (pAsset.list_tags.Count > 0)
		{
			pDescription += "--- OWN TAGS ---\n".ColorHex(ColorStyleLibrary.m.color_text_grey_dark);
			foreach (string list_tag in pAsset.list_tags)
			{
				pDescription += (list_tag + "\n").ColorHex(ColorStyleLibrary.m.color_text_grey);
			}
		}
		if (pAsset.friendly_tags.Count > 0)
		{
			pDescription += "--- FRIENDLY TAGS ---\n".ColorHex(ColorStyleLibrary.m.color_text_grey_dark);
			foreach (string friendly_tag in pAsset.friendly_tags)
			{
				pDescription += (friendly_tag + "\n").ColorHex("#43FF43");
			}
		}
		if (pAsset.enemy_tags.Count > 0)
		{
			pDescription += "#--- ENEMY TAGS ---\n".ColorHex(ColorStyleLibrary.m.color_text_grey_dark);
			foreach (string enemy_tag in pAsset.enemy_tags)
			{
				pDescription += (enemy_tag + "\n").ColorHex("#FB2C21");
			}
		}
		if (pAsset.assets_discrepancies == null || pAsset.assets_discrepancies.Count <= 0)
		{
			return;
		}
		pDescription2 = $"!! Discrepancies {pAsset.assets_discrepancies.Count}!!\n".ColorHex("#D85BC5");
		int num = 0;
		foreach (string assets_discrepancy in pAsset.assets_discrepancies)
		{
			if (assets_discrepancy.Contains(pAsset.id) || pAsset.id.Contains(assets_discrepancy))
			{
				pDescription2 += assets_discrepancy.ColorHex("#FB2C21");
			}
			else
			{
				pDescription2 += assets_discrepancy;
			}
			if (pDescription2.Length > 150)
			{
				int num2 = pAsset.assets_discrepancies.Count - num;
				pDescription2 += $" and {num2} more...!!!".ColorHex("#8CFF99");
				break;
			}
			if (num < pAsset.assets_discrepancies.Count - 1)
			{
				pDescription2 += ", ";
			}
			num++;
		}
	}
}
// --- End of File: DebugKingdomButton.cs ---



// --- Start of File: DebugKingdomFoes.cs ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class DebugKingdomFoes : MonoBehaviour
{
	[SerializeField]
	private DebugKingdomButton _prefab_button;

	[SerializeField]
	private Image _selector;

	[SerializeField]
	private GridLayoutGroup _grid_main;

	[SerializeField]
	private GridLayoutGroup _grid_civs;

	[SerializeField]
	private GridLayoutGroup _grid_minicivs;

	[SerializeField]
	private GridLayoutGroup _grid_minicivs_special;

	[SerializeField]
	private GridLayoutGroup _grid_concepts;

	[SerializeField]
	private GridLayoutGroup _grid_mobs;

	[SerializeField]
	private GridLayoutGroup _grid_creeps;

	[SerializeField]
	private GridLayoutGroup _grid_others;

	private List<DebugKingdomButton> _buttons = new List<DebugKingdomButton>();

	private KingdomAsset _current_selected;

	private bool _initialized;

	private void Awake()
	{
		create();
	}

	private void create()
	{
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Expected O, but got Unknown
		if (_initialized)
		{
			return;
		}
		_initialized = true;
		AssetManager.kingdoms.checkForMissingTags();
		foreach (KingdomAsset item in AssetManager.kingdoms.list)
		{
			if (!item.isTemplateAsset())
			{
				Transform val = (item.group_main ? ((Component)_grid_main).transform : (item.group_creeps ? ((Component)_grid_creeps).transform : (item.concept ? ((Component)_grid_concepts).transform : (item.is_forced_by_trait ? ((Component)_grid_others).transform : (item.group_minicivs_cool ? ((Component)_grid_minicivs_special).transform : (item.group_miniciv ? ((Component)_grid_minicivs).transform : (item.civ ? ((Component)_grid_civs).transform : ((!item.mobs) ? ((Component)_grid_others).transform : ((Component)_grid_mobs).transform))))))));
				DebugKingdomButton tNewButton = Object.Instantiate<DebugKingdomButton>(_prefab_button, val);
				tNewButton.setAsset(item);
				_buttons.Add(tNewButton);
				((UnityEvent)((Component)tNewButton).GetComponent<Button>().onClick).AddListener((UnityAction)delegate
				{
					select(tNewButton);
				});
			}
		}
		select(_buttons.GetRandom());
	}

	private void select(DebugKingdomButton pButton)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		_current_selected = pButton.kingdom_asset;
		((Component)_selector).transform.position = ((Component)pButton).transform.position;
		updateButtons();
	}

	private void updateButtons()
	{
		foreach (DebugKingdomButton button in _buttons)
		{
			button.checkSelected(_current_selected);
		}
	}
}
// --- End of File: DebugKingdomFoes.cs ---



// --- Start of File: DebugLayer.cs ---
using System.Collections.Generic;
using UnityEngine;

public class DebugLayer : MapLayer
{
	internal static List<TileZone> fmod_zones_to_draw = new List<TileZone>();

	private HashSet<WorldTile> _tiles = new HashSet<WorldTile>();

	public Color color1 = Color.gray;

	public Color color2 = Color.white;

	public Color color_red = Color.red;

	public Color color_active_path;

	private bool used;

	private List<MapRegion> _forced_global_path = new List<MapRegion>();

	protected override void UpdateDirty(float pElapsed)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!DebugConfig.instance.debugButton.gameObject.activeSelf)
		{
			clear();
			return;
		}
		color_active_path = new Color(1f, 1f, 1f, 0.5f);
		used = false;
		clear();
		if (_forced_global_path != null && _forced_global_path.Count > 0)
		{
			drawRegionPath(_forced_global_path);
		}
		if (DebugConfig.isOn(DebugOption.CityZones))
		{
			drawZones();
		}
		else if (DebugConfig.isOn(DebugOption.Chunks))
		{
			drawChunks();
		}
		if (DebugConfig.isOn(DebugOption.PathRegions))
		{
			drawPathRegions();
		}
		if (DebugConfig.isOn(DebugOption.ActivePaths))
		{
			drawActivePaths();
		}
		if (DebugConfig.isOn(DebugOption.CityPlaces))
		{
			drawCityPlaces();
		}
		if (DebugConfig.isOn(DebugOption.RenderCityDangerZones))
		{
			drawCityDangerZones();
		}
		if (DebugConfig.isOn(DebugOption.RenderVisibleZones))
		{
			drawVisibleZones();
		}
		if (DebugConfig.isOn(DebugOption.RenderCityCenterZones))
		{
			drawCityCenterZones();
		}
		if (DebugConfig.isOn(DebugOption.RenderCityFarmPlaces))
		{
			drawCityFarmZones();
		}
		if (DebugConfig.isOn(DebugOption.Buildings))
		{
			drawBuildings();
		}
		if (DebugConfig.isOn(DebugOption.FmodZones))
		{
			drawFmodZones();
		}
		if (DebugConfig.isOn(DebugOption.ConstructionTiles))
		{
			drawConstructionTiles();
		}
		if (DebugConfig.isOn(DebugOption.UnitsInside))
		{
			drawUnitsInside();
		}
		if (DebugConfig.isOn(DebugOption.TargetedBy))
		{
			drawTargetedBy();
		}
		if (DebugConfig.isOn(DebugOption.UnitKingdoms))
		{
			drawUnitKingdoms();
		}
		if (DebugConfig.isOn(DebugOption.DisplayUnitTiles))
		{
			drawUnitTiles();
		}
		if (DebugConfig.isOn(DebugOption.ProKing))
		{
			drawProfession(UnitProfession.King);
		}
		if (DebugConfig.isOn(DebugOption.ProLeader))
		{
			drawProfession(UnitProfession.Leader);
		}
		if (DebugConfig.isOn(DebugOption.ProUnit))
		{
			drawProfession(UnitProfession.Unit);
		}
		if (DebugConfig.isOn(DebugOption.ProWarrior))
		{
			drawProfession(UnitProfession.Warrior);
		}
		if (used)
		{
			if (!((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			updatePixels();
		}
		else if (((Component)this).gameObject.activeSelf)
		{
			((Component)this).gameObject.SetActive(false);
		}
	}

	private void drawUnitKingdoms()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (Actor unit in World.world.units)
		{
			if (unit.kingdom != null && unit.kingdom.getColor() != null)
			{
				Color val = Color32.op_Implicit(unit.kingdom.getColor().getColorMain32());
				pixels[unit.current_tile.data.tile_id] = Color32.op_Implicit(val);
				_tiles.Add(unit.current_tile);
			}
		}
	}

	private void drawUnitTiles()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		WorldTile[] tiles_list = World.world.tiles_list;
		foreach (WorldTile worldTile in tiles_list)
		{
			if (worldTile.hasUnits())
			{
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(Color.blue);
				_tiles.Add(worldTile);
			}
		}
	}

	private void drawTargetedBy()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		WorldTile[] tiles_list = World.world.tiles_list;
		foreach (WorldTile worldTile in tiles_list)
		{
			if (worldTile.isTargeted())
			{
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(Color.blue);
				_tiles.Add(worldTile);
			}
		}
	}

	private void drawProfession(UnitProfession pPro)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (Actor unit in World.world.units)
		{
			if (unit.isProfession(pPro))
			{
				Color blue = Color.blue;
				pixels[unit.current_tile.data.tile_id] = Color32.op_Implicit(blue);
				_tiles.Add(unit.current_tile);
			}
		}
	}

	private void drawCitizenJobs(string pID)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (Actor unit in World.world.units)
		{
			if (unit.ai.job != null && !(pID != unit.ai.job.id))
			{
				Color red = Color.red;
				pixels[unit.current_tile.data.tile_id] = Color32.op_Implicit(red);
				_tiles.Add(unit.current_tile);
			}
		}
	}

	private void drawUnitsInside()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (Actor unit in World.world.units)
		{
			if (unit.is_inside_building)
			{
				pixels[unit.current_tile.data.tile_id] = Color32.op_Implicit(Color.green);
				_tiles.Add(unit.current_tile);
			}
		}
	}

	private void drawConstructionTiles()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		WorldTile[] tiles_list = World.world.tiles_list;
		foreach (WorldTile worldTile in tiles_list)
		{
			if (!worldTile.hasBuilding() || !worldTile.building.asset.docks)
			{
				continue;
			}
			(TileZone[], int) allZonesFromTile = Toolbox.getAllZonesFromTile(worldTile);
			TileZone[] item = allZonesFromTile.Item1;
			int item2 = allZonesFromTile.Item2;
			for (int j = 0; j < item2; j++)
			{
				TileZone pZone = item[j];
				foreach (WorldTile item3 in worldTile.building.checkZoneForDockConstruction(pZone))
				{
					pixels[item3.data.tile_id] = Color32.op_Implicit(Color.red);
					_tiles.Add(item3);
				}
			}
		}
	}

	private void drawFmodZones()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (TileZone item in fmod_zones_to_draw)
		{
			fill(item.tiles, Color.yellow);
		}
	}

	private void drawBuildings()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		WorldTile[] tiles_list = World.world.tiles_list;
		foreach (WorldTile worldTile in tiles_list)
		{
			if (worldTile.hasBuilding())
			{
				if (worldTile.building.kingdom != null && worldTile.building.isKingdomCiv())
				{
					pixels[worldTile.data.tile_id] = worldTile.building.kingdom.getColor().getColorMain32();
				}
				else
				{
					pixels[worldTile.data.tile_id] = Color32.op_Implicit(Color.red);
				}
				pixels[worldTile.building.current_tile.data.tile_id] = Color32.op_Implicit(Color.magenta);
				pixels[worldTile.building.door_tile.data.tile_id] = Color32.op_Implicit(Color.yellow);
				_tiles.Add(worldTile.building.current_tile);
				_tiles.Add(worldTile.building.door_tile);
				_tiles.Add(worldTile);
			}
		}
	}

	private void drawCityCenterZones()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (City city in World.world.cities)
		{
			WorldTile tile = city.getTile();
			if (tile != null)
			{
				fill(tile.zone.tiles, Color.red);
			}
		}
	}

	private void drawCityFarmZones()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (City city in World.world.cities)
		{
			fill(city.calculated_place_for_farms.getSimpleList(), Color.blue);
			fill(city.calculated_farm_fields.getSimpleList(), Color.cyan);
			fill(city.calculated_crops.getSimpleList(), Color.green);
			fill(city.calculated_grown_wheat.getSimpleList(), Color.yellow);
		}
	}

	private void drawVisibleZones()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		List<TileZone> visibleZones = World.world.zone_camera.getVisibleZones();
		for (int i = 0; i < visibleZones.Count; i++)
		{
			TileZone tileZone = visibleZones[i];
			if (tileZone.visible_main_centered)
			{
				fill(tileZone.tiles, Color.green);
			}
			else if (tileZone.visible)
			{
				fill(tileZone.tiles, Color.blue);
			}
		}
	}

	private void drawCityDangerZones()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (City city in World.world.cities)
		{
			foreach (TileZone danger_zone in city.danger_zones)
			{
				fill(danger_zone.tiles, Color.red);
			}
		}
	}

	private void drawCityPlaces()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (TileZone zone in World.world.zone_calculator.zones)
		{
			if (zone.city != null)
			{
				fill(zone.tiles, Color.yellow);
			}
			else if (zone.isGoodForNewCity())
			{
				fill(zone.tiles, Color.blue);
			}
		}
	}

	private void drawActivePaths()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (Actor unit in World.world.units)
		{
			if (unit.current_path_global != null)
			{
				drawRegionPath(unit.current_path_global);
				fill(unit.current_path, Color.blue);
			}
		}
	}

	public void drawRegionPath(List<MapRegion> pRegions)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (MapRegion pRegion in pRegions)
		{
			fill(pRegion.tiles, color_active_path);
		}
	}

	public void forceDrawRegionPath(List<MapRegion> pRegions)
	{
		_forced_global_path.Clear();
		_forced_global_path.AddRange(pRegions);
	}

	private void drawPathRegions()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		MapChunk[] chunks = World.world.map_chunk_manager.chunks;
		for (int i = 0; i < chunks.Length; i++)
		{
			foreach (MapRegion region in chunks[i].regions)
			{
				if (region.path_wave_id != -1)
				{
					fill(region.tiles, new Color(1f, 1f, 0f, 0.9f));
				}
			}
		}
		List<MapRegion> last_globalPath = World.world.region_path_finder.last_globalPath;
		if (last_globalPath == null || last_globalPath.Count <= 0 || World.world.region_path_finder?.tileStart?.region == null || World.world.region_path_finder?.tileTarget?.region == null)
		{
			return;
		}
		foreach (MapRegion item in World.world.region_path_finder.last_globalPath)
		{
			fill(item.tiles, Color.blue);
		}
		fill(World.world.region_path_finder.tileStart.region.tiles, Color.green);
		fill(World.world.region_path_finder.tileTarget.region.tiles, new Color(1f, 0f, 0f, 0.3f));
	}

	private void fill(List<WorldTile> pTiles, Color pColor, bool pEdge = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		createTextureNew();
		for (int i = 0; i < pTiles.Count; i++)
		{
			WorldTile worldTile = pTiles[i];
			if (!pEdge || worldTile.region != null)
			{
				_tiles.Add(worldTile);
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(pColor);
			}
		}
	}

	private void fill(WorldTile[] pTiles, Color pColor, bool pEdge = false)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		createTextureNew();
		foreach (WorldTile worldTile in pTiles)
		{
			if (!pEdge || worldTile.region != null)
			{
				_tiles.Add(worldTile);
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(pColor);
			}
		}
	}

	private void drawZones()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		foreach (TileZone zone in World.world.zone_calculator.zones)
		{
			if ((zone.x + zone.y) % 2 == 0)
			{
				zone.debug_zone_color = color1;
			}
			else
			{
				zone.debug_zone_color = color2;
			}
			fill(zone.tiles, zone.debug_zone_color);
		}
	}

	private void testCityLayout()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		DebugVariables instance = DebugVariables.instance;
		if (instance != null && !instance.layout_city_test)
		{
			return;
		}
		used = true;
		WorldTile mouseTilePos = World.world.getMouseTilePos();
		if (mouseTilePos == null)
		{
			return;
		}
		TileZone pCursorZone = mouseTilePos?.zone;
		foreach (TileZone zone in World.world.zone_calculator.zones)
		{
			bool flag = true;
			if (!TownPlans.debugVisualizeZone(zone, pCursorZone))
			{
				flag = false;
			}
			if (flag)
			{
				zone.debug_zone_color = color1;
			}
			else
			{
				zone.debug_zone_color = color_red;
			}
			fill(zone.tiles, zone.debug_zone_color);
		}
	}

	private void drawChunks()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		used = true;
		MapChunk[] chunks = World.world.map_chunk_manager.chunks;
		foreach (MapChunk mapChunk in chunks)
		{
			fill(mapChunk.tiles, mapChunk.color);
		}
	}

	internal override void clear()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		HashSet<WorldTile> tiles = _tiles;
		if (tiles.Count == 0)
		{
			return;
		}
		foreach (WorldTile item in tiles)
		{
			if (item.data.tile_id <= pixels.Length - 1)
			{
				pixels[item.data.tile_id] = Color32.op_Implicit(Color.clear);
			}
		}
		_tiles.Clear();
		createTextureNew();
	}
}
// --- End of File: DebugLayer.cs ---



// --- Start of File: DebugLayerCursor.cs ---
using System.Collections.Generic;
using UnityEngine;

public class DebugLayerCursor : MapLayer
{
	private Color color_highlight_white;

	private Color color_main;

	private Color color_neighbour;

	private Color color_neighbour_2;

	private Color color_region;

	private Color color_edges;

	private Color color_chunk_bounds;

	private Color color_edges_blink;

	private List<WorldTile> _tiles = new List<WorldTile>();

	private bool blink = true;

	private float timerBlink = 0.2f;

	private float timerRecalc = 0.1f;

	private MapChunk lastChunk;

	internal override void create()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		base.create();
		color_highlight_white = Toolbox.makeColor("#FFFFFF77");
		color_main = new Color(0f, 1f, 0f, 0.1f);
		color_neighbour = new Color(1f, 0f, 1f, 0.8f);
		color_neighbour_2 = new Color(1f, 0f, 1f, 0.3f);
		color_edges = new Color(1f, 0f, 0f, 0.5f);
		color_chunk_bounds = new Color(0f, 1f, 1f, 0.5f);
		color_edges_blink = new Color(0.1f, 0.1f, 1f, 1f);
		color_region = new Color(0f, 0f, 1f, 0.8f);
	}

	protected override void UpdateDirty(float pElapsed)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0552: Unknown result type (might be due to invalid IL or missing references)
		//IL_05dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0606: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d7: Unknown result type (might be due to invalid IL or missing references)
		if (ScrollWindow.isWindowActive())
		{
			return;
		}
		if (!Config.isEditor && !DebugConfig.instance.debugButton.gameObject.activeSelf)
		{
			clear();
			return;
		}
		if (timerBlink > 0f)
		{
			timerBlink -= Time.deltaTime;
		}
		else
		{
			timerBlink = 0.2f;
			blink = !blink;
		}
		if (timerRecalc > 0f)
		{
			timerRecalc -= pElapsed;
			clear();
			WorldTile mouseTilePos = World.world.getMouseTilePos();
			if (mouseTilePos == null)
			{
				return;
			}
			lastChunk = mouseTilePos.chunk;
			_ = mouseTilePos.chunk;
			_ = lastChunk;
			if (DebugConfig.isOn(DebugOption.RenderIslands) && mouseTilePos?.region?.island != null)
			{
				drawIsland(mouseTilePos.region.island);
			}
			if (DebugConfig.isOn(DebugOption.CursorChunk))
			{
				fill(lastChunk.tiles, color_highlight_white);
			}
			if (DebugConfig.isOn(DebugOption.RenderConnectedIslands) && mouseTilePos?.region?.island != null)
			{
				foreach (TileIsland connectedIsland in mouseTilePos.region.island.getConnectedIslands())
				{
					foreach (MapRegion region2 in connectedIsland.regions)
					{
						fill(region2.tiles, Color.blue);
					}
				}
			}
			if (DebugConfig.isOn(DebugOption.PossibleCityReach))
			{
				renderPossibleCityReach();
			}
			if (DebugConfig.isOn(DebugOption.RenderIslandsInsideRegionCorners) && mouseTilePos?.region?.island != null)
			{
				foreach (MapRegion insideRegionEdge in mouseTilePos.region.island.insideRegionEdges)
				{
					fill(insideRegionEdge.tiles, Color.magenta);
				}
			}
			if (DebugConfig.isOn(DebugOption.RenderIslandsTileCorners) && mouseTilePos?.region?.island != null)
			{
				foreach (MapRegion insideRegionEdge2 in mouseTilePos.region.island.insideRegionEdges)
				{
					fill(insideRegionEdge2.getEdgeTiles(), Color.red);
				}
			}
			if (DebugConfig.isOn(DebugOption.RenderIslandCenterRegions) && mouseTilePos?.region?.island != null)
			{
				foreach (MapRegion region3 in mouseTilePos.region.island.regions)
				{
					if (!region3.center_region)
					{
						fill(region3.tiles, Color.red);
					}
				}
			}
			if (DebugConfig.isOn(DebugOption.RenderRegionOutsideRegionCorners) && mouseTilePos?.region != null)
			{
				foreach (MapRegion edgeRegion in mouseTilePos.region.getEdgeRegions())
				{
					fill(edgeRegion.tiles, Color.yellow);
				}
			}
			if (DebugConfig.isOn(DebugOption.RenderMapRegionEdges) && mouseTilePos.region != null)
			{
				fill(mouseTilePos.region.getEdgeTiles(), Color.red);
			}
			if (DebugConfig.isOn(DebugOption.RegionNeighbours) && mouseTilePos.region != null)
			{
				HashSet<MapRegion> hashSet = new HashSet<MapRegion>();
				HashSet<MapRegion> hashSet2 = new HashSet<MapRegion>();
				hashSet.Add(mouseTilePos.region);
				foreach (MapRegion neighbour in mouseTilePos.region.neighbours)
				{
					hashSet.Add(neighbour);
				}
				foreach (MapRegion item in hashSet)
				{
					foreach (MapRegion neighbour2 in item.neighbours)
					{
						if (!hashSet.Contains(neighbour2))
						{
							hashSet2.Add(neighbour2);
						}
					}
				}
				foreach (MapRegion item2 in hashSet)
				{
					fill(item2.tiles, color_neighbour);
				}
				foreach (MapRegion item3 in hashSet2)
				{
					fill(item3.tiles, color_neighbour_2);
				}
			}
			if (DebugConfig.isOn(DebugOption.Region) && mouseTilePos.region != null)
			{
				fill(mouseTilePos.region.tiles, color_region);
			}
			if (DebugConfig.isOn(DebugOption.ConnectedZones) && mouseTilePos.zone != null)
			{
				TileZone zone = mouseTilePos.zone;
				MapRegion region = mouseTilePos.region;
				fill(zone.tiles, color_region);
				using ListPool<MapRegion> listPool = new ListPool<MapRegion>();
				TileZone[] neighbours = zone.neighbours;
				foreach (TileZone tileZone in neighbours)
				{
					listPool.Clear();
					if (TileZone.hasZonesConnectedViaRegions(zone, tileZone, region, listPool))
					{
						fill(tileZone.tiles, color_neighbour);
					}
				}
			}
			if (DebugConfig.isOn(DebugOption.ChunkEdges) && mouseTilePos.chunk != null)
			{
				fill(mouseTilePos.chunk.edges_all, color_edges);
			}
			if (DebugConfig.isOn(DebugOption.ChunkBounds) && mouseTilePos.chunk != null)
			{
				fill(mouseTilePos.chunk.chunk_bounds, color_chunk_bounds);
			}
			if (DebugConfig.isOn(DebugOption.Connections) && mouseTilePos.region != null)
			{
				drawConnections(mouseTilePos);
			}
			updatePixels();
		}
		else
		{
			timerRecalc = 0.1f;
		}
	}

	private void renderPossibleCityReach()
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		WorldTile mouseTilePos = World.world.getMouseTilePos();
		if (mouseTilePos.zone.city == null)
		{
			return;
		}
		TileIsland island = mouseTilePos.region.island;
		foreach (ref TileIsland island2 in World.world.islands_calculator.islands)
		{
			TileIsland current = island2;
			if (island == current || !island.reachableByCityFrom(current))
			{
				continue;
			}
			foreach (MapRegion region in current.regions)
			{
				fill(region.tiles, Color.blue);
			}
		}
	}

	private void drawIsland(TileIsland pIsland)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Color32 val = Color32.op_Implicit(Color.red);
		foreach (MapRegion region in pIsland.regions)
		{
			_tiles.AddRange(region.tiles);
			foreach (WorldTile tile in region.tiles)
			{
				pixels[tile.data.tile_id] = val;
			}
		}
	}

	private void drawConnections(WorldTile pTile)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (blink && pTile.region.debug_blink_edges_up != null)
		{
			fill(pTile.region.debug_blink_edges_up, color_edges_blink, pEdge: true);
			fill(pTile.region.debug_blink_edges_down, color_edges_blink, pEdge: true);
			fill(pTile.region.debug_blink_edges_left, color_edges_blink, pEdge: true);
			fill(pTile.region.debug_blink_edges_right, color_edges_blink, pEdge: true);
		}
	}

	private void fill(List<WorldTile> pTiles, Color pColor, bool pEdge = false)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		createTextureNew();
		for (int i = 0; i < pTiles.Count; i++)
		{
			WorldTile worldTile = pTiles[i];
			if (!pEdge || worldTile.region != null)
			{
				_tiles.Add(worldTile);
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(pColor);
			}
		}
	}

	private void fill(WorldTile[] pTiles, Color pColor, bool pEdge = false)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		createTextureNew();
		foreach (WorldTile worldTile in pTiles)
		{
			if (!pEdge || worldTile.region != null)
			{
				_tiles.Add(worldTile);
				pixels[worldTile.data.tile_id] = Color32.op_Implicit(pColor);
			}
		}
	}

	internal override void clear()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (_tiles.Count != 0)
		{
			_tiles.Clear();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = Color32.op_Implicit(Color.clear);
			}
			createTextureNew();
		}
	}
}
// --- End of File: DebugLayerCursor.cs ---



// --- Start of File: DebugLayerType.cs ---
public enum DebugLayerType
{
	Zones,
	Chunks
}
// --- End of File: DebugLayerType.cs ---



// --- Start of File: DebugLocales.cs ---
public class DebugLocales
{
	private const string TODO_TEXT = "TODO_TEXT";

	private const string NO_TEXT = "???";

	public static void init()
	{
		LocalizedTextManager.add("tab_technologies_description", "TODO_TEXT");
	}
}
// --- End of File: DebugLocales.cs ---



// --- Start of File: DebugMap.cs ---
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

namespace tools.debug;

public class DebugMap
{
	public static void makeDebugMap()
	{
		createDebugButtons();
		WorldTile[] tiles_list = World.world.tiles_list;
		for (int i = 0; i < tiles_list.Length; i++)
		{
			MapAction.terraformTile(tiles_list[i], TileLibrary.soil_low, TopTileLibrary.grass_low, TerraformLibrary.destroy);
		}
		int num = 10;
		int num2 = 10;
		int num3 = 0;
		int count = AssetManager.buildings.list.Count;
		while (num3 < count)
		{
			BuildingAsset buildingAsset = AssetManager.buildings.list[num3];
			if (buildingAsset.id.Contains("!"))
			{
				num3++;
				continue;
			}
			num3++;
			num += 20;
			if (num > 200)
			{
				num = 10;
				num2 += 10;
			}
			Building building = World.world.buildings.addBuilding(buildingAsset, World.world.GetTile(num, num2));
			building.kingdom = World.world.kingdoms_wild.get("nature");
			building.updateBuild(10000);
			if (!building.asset.docks)
			{
				continue;
			}
			foreach (WorldTile tile in building.tiles)
			{
				MapAction.terraformMain(tile, TileLibrary.shallow_waters, TerraformLibrary.flash);
			}
		}
		Config.paused = true;
	}

	private static void debugConstructionZone()
	{
		foreach (Building building in World.world.buildings)
		{
			building.debugConstructions();
		}
	}

	private static void debugNextFrame()
	{
	}

	private static void debugRuins()
	{
	}

	public static void createDebugButtons()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Expected O, but got Unknown
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Expected O, but got Unknown
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Expected O, but got Unknown
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		Button obj = makeNewButton("debug_next_frame", "iconBuildings");
		((UnityEvent)obj.onClick).AddListener(new UnityAction(debugNextFrame));
		((Component)obj).GetComponent<RectTransform>().anchoredPosition = new Vector2(50f, -20f);
		Button obj2 = makeNewButton("debug_ruins", "iconDemolish");
		((UnityEvent)obj2.onClick).AddListener(new UnityAction(debugRuins));
		((Component)obj2).GetComponent<RectTransform>().anchoredPosition = new Vector2(100f, -20f);
		Button obj3 = makeNewButton("debug_construction", "iconBucket");
		((UnityEvent)obj3.onClick).AddListener(new UnityAction(debugConstructionZone));
		((Component)obj3).GetComponent<RectTransform>().anchoredPosition = new Vector2(150f, -20f);
	}

	private static Button makeNewButton(string pName, string pIcon)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Expected O, but got Unknown
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Expected O, but got Unknown
		Button obj = Object.Instantiate<Button>((Button)Resources.Load("ui/PrefabWorldBoxButton", typeof(Button)), ((Component)World.world.canvas).transform);
		((Object)((Component)obj).transform).name = pName;
		((Component)obj).transform.parent = ((Component)World.world.canvas).transform;
		Sprite sprite = (Sprite)Resources.Load("ui/Icons/" + pIcon, typeof(Sprite));
		((Component)((Component)obj).transform.Find("Icon")).GetComponent<Image>().sprite = sprite;
		return obj;
	}
}
// --- End of File: DebugMap.cs ---



// --- Start of File: DebugMemory.cs ---
public static class DebugMemory
{
	public static void addMemorySnapshot(string pWhen)
	{
	}
}
// --- End of File: DebugMemory.cs ---



// --- Start of File: DebugMessage.cs ---
using System.Collections.Generic;
using UnityEngine;

public class DebugMessage : MonoBehaviour
{
	public GameObject prefab;

	public static bool log_enabled;

	public static DebugMessage instance;

	public List<DebugMessageFly> list;

	private List<DebugMessageFly> messagesToMove = new List<DebugMessageFly>();

	private void Start()
	{
		instance = this;
		list = new List<DebugMessageFly>();
	}

	public void moveAll(DebugMessageFly pMessage)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		messagesToMove.Clear();
		foreach (DebugMessageFly item in list)
		{
			if (!((Object)(object)item == (Object)(object)pMessage) && Toolbox.Dist(0f, ((Component)item).transform.localPosition.y, 0f, ((Component)pMessage).transform.localPosition.y) < 1f)
			{
				messagesToMove.Add(item);
			}
		}
		foreach (DebugMessageFly item2 in messagesToMove)
		{
			item2.moveUp();
		}
	}

	public DebugMessageFly getOldMessage(Transform pTransform)
	{
		foreach (DebugMessageFly item in list)
		{
			if ((Object)(object)item.originTransform == (Object)(object)pTransform)
			{
				return item;
			}
		}
		return null;
	}

	public static void log(Transform pTransofrm, string pMessage)
	{
		if (Debug.isDebugBuild && log_enabled)
		{
			DebugMessageFly oldMessage = instance.getOldMessage(pTransofrm);
			if ((Object)(object)oldMessage != (Object)null)
			{
				oldMessage.addString(pMessage);
				return;
			}
			TextMesh component = Object.Instantiate<GameObject>(instance.prefab).gameObject.GetComponent<TextMesh>();
			((Renderer)((Component)component).gameObject.GetComponent<MeshRenderer>()).sortingOrder = 100;
			((Component)component).transform.parent = ((Component)instance).transform;
			DebugMessageFly component2 = ((Component)component).GetComponent<DebugMessageFly>();
			component2.originTransform = pTransofrm;
			component2.addString(pMessage);
			instance.list.Add(component2);
		}
	}
}
// --- End of File: DebugMessage.cs ---



// --- Start of File: DebugMessageFly.cs ---
using System.Collections.Generic;
using UnityEngine;

public class DebugMessageFly : MonoBehaviour
{
	private List<string> listString = new List<string>();

	public Transform originTransform;

	private TextMesh textMesh;

	private void Awake()
	{
		textMesh = ((Component)this).GetComponent<TextMesh>();
	}

	public void addString(string pText)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (textMesh.color.a < 0.3f)
		{
			listString.Clear();
		}
		else if (listString.Count > 20)
		{
			listString.RemoveAt(0);
		}
		listString.Add(pText);
		Vector3 localPosition = default(Vector3);
		((Vector3)(ref localPosition))._002Ector(originTransform.localPosition.x, originTransform.localPosition.y);
		((Component)this).transform.localPosition = localPosition;
		string text = "";
		foreach (string item in listString)
		{
			text = text + item + "\n";
		}
		textMesh.text = text;
		Color color = textMesh.color;
		color.a = 1f;
		textMesh.color = color;
	}

	public void moveUp()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localPosition = ((Component)this).transform.localPosition;
		localPosition.y += 3f;
		((Component)this).transform.localPosition = localPosition;
	}

	private void Update()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localScale = ((Component)this).transform.localScale;
		localScale.x += 2f * Time.deltaTime;
		if (localScale.x > 1f)
		{
			localScale.x = 1f;
		}
		((Component)this).transform.localScale = localScale;
		Vector3 localPosition = ((Component)this).transform.localPosition;
		localPosition.y += 0.5f * Time.deltaTime;
		((Component)this).transform.localPosition = localPosition;
		Color color = textMesh.color;
		color.a -= 0.3f * Time.deltaTime;
		textMesh.color = color;
		if (color.a <= 0f)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			DebugMessage.instance.list.Remove(this);
		}
	}
}
// --- End of File: DebugMessageFly.cs ---



// --- Start of File: DebugMusicBoxData.cs ---
using FMOD.Studio;

public class DebugMusicBoxData
{
	public const float INTERVAL = 3f;

	public float timer = 3f;

	public string path;

	public float x;

	public float y;

	public EventInstance instance;

	public bool isPlaying()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		PLAYBACK_STATE val = default(PLAYBACK_STATE);
		((EventInstance)(ref instance)).getPlaybackState(ref val);
		return (int)val == 0;
	}
}
// --- End of File: DebugMusicBoxData.cs ---



// --- Start of File: DebugOption.cs ---
public enum DebugOption
{
	Nothing,
	DisablePremium,
	TestAds,
	Connections,
	LastPath,
	CursorChunk,
	Region,
	ConnectedZones,
	RegionNeighbours,
	CityZones,
	Chunks,
	ChunksDirty,
	RegionsDirty,
	CityPlaces,
	CitySettleCalc,
	ChunkEdges,
	ChunkBounds,
	PathRegions,
	ActivePaths,
	Greg,
	Graphy,
	UnlockAllTraits,
	UnlockAllEquipment,
	UnlockAllGenes,
	UnlockAllActors,
	UnlockAllPlots,
	Buildings,
	FastSpawn,
	UltraFastSpawn,
	SonicSpeed,
	KillAllUnitsOnLoad,
	PauseOnStart,
	MemoryCaptureOnClearWorld,
	ExportAssetLibraries,
	GenerateGameplayReport,
	PauseDrops,
	PauseEffects,
	DebugZones,
	TargetedBy,
	DrawCitizenJobIcons,
	DrawCitizenJobIconsAll,
	CitizenJobFireman,
	CitizenJobBuilder,
	CitizenJobGathererBushes,
	CitizenJobGathererHerbs,
	CitizenJobGathererHoney,
	CitizenJobFarmer,
	CitizenJobHunter,
	CitizenJobWoodcutter,
	CitizenJobMiner,
	CitizenJobMinerDeposit,
	CitizenJobRoadBuilder,
	CitizenJobCleaner,
	CitizenJobManureCleaner,
	CitizenJobAttacker,
	UnitsInside,
	UnitKingdoms,
	SystemUnitPathfinding,
	SystemZoneGrowth,
	SystemBuildTick,
	SystemCityPlaceFinder,
	SystemWorldBehaviours,
	SystemProduceNewCitizens,
	SystemCheckUnitAction,
	SystemUpdateUnits,
	SystemUpdateBuildings,
	SystemRedrawMap,
	SystemUpdateCities,
	SystemCityTasks,
	AddJobManagerSkips,
	ProKing,
	ProLeader,
	ProUnit,
	ProWarrior,
	SystemUpdateDirtyChunks,
	DisplayUnitTiles,
	UseGlobalPathLock,
	ConstructionTiles,
	SystemMusic,
	RenderBigItems,
	RenderFavoriteFoods,
	RenderHoldingResources,
	ShowMushInfection,
	ShowPlagueInfection,
	ShowZombieInfection,
	ShowCursed,
	ShowPopulationTotal,
	ShowDragonTargetting,
	ShowGodFingerTargetting,
	ShowSwimToIslandLogic,
	RenderMapRegionEdges,
	SystemUpdateUnitAnimation,
	RenderIslands,
	RenderConnectedIslands,
	RenderIslandsTileCorners,
	RenderIslandCenterRegions,
	RenderRegionOutsideRegionCorners,
	RenderIslandsInsideRegionCorners,
	ShowAmountNearArmy,
	ShowWarriorsCityText,
	ShowFoodCityText,
	ShowCityWeaponsText,
	RenderCityDangerZones,
	RenderCityCenterZones,
	RenderCityFarmPlaces,
	PossibleCityReach,
	RenderVisibleZones,
	ArrowsUnitsAttackTargets,
	ArrowUnitsBehActorTarget,
	ArrowsUnitsPaths,
	ArrowsUnitsNavigationTargets,
	ArrowsUnitsHeight,
	ArrowsUnitsFavoritesOnly,
	ArrowsUnitsNextStepPosition,
	ArrowsUnitsNextStepTile,
	ArrowsUnitsCurrentPosition,
	ArrowsOnlyForCursorCities,
	CursorUnitAttackRange,
	CursorUnitSize,
	CursorUnitAttackChunks,
	CursorCityZoneRange,
	CursorEnemyFinderChunks,
	KingdomDrawAttackTarget,
	CivDrawSettleTarget,
	CivDrawCityClaimZone,
	KingdomHeads,
	ActorGizmosBoatTaxiRequestTargets,
	ActorGizmosBoatTaxiTarget,
	SystemCheckGoodForBoat,
	MakeUnitsFollowCursor,
	SystemSplitAstar,
	ParallelJobsUpdater,
	ParallelChunks,
	ChunkBatches,
	UseCacheForRegionPath,
	FastCultures,
	CityFastZonesGrowth,
	FmodZones,
	CityInfiniteResources,
	CityFastConstruction,
	CityFastUpgrades,
	CityFastPopGrowth,
	CityUnlimitedHouses,
	CityUnlimitedZoneRange,
	UnitsAlwaysFast,
	OverlaySoundsAttached,
	OverlaySounds,
	OverlaySoundsActive,
	OverlayActorCivs,
	OverlayBoatTransport,
	OverlayActorMobs,
	OverlayCursorActor,
	OverlayActorFavoritesOnly,
	OverlayActorGroupLeaderOnly,
	OverlayArmies,
	OverlayCivBuildings,
	OverlayTrees,
	OverlayPlants,
	OverlayOtherBuildings,
	OverlayCity,
	OverlayCityTasks,
	OverlayKingdom,
	BoatPassengerLines,
	BuildingResidents,
	Lovers,
	ShowMoneyIcons,
	ShowKingdomIcons,
	DeadUnits,
	DrawBadLinksDiag,
	UseCameraAspect,
	ScaleEffectEnabled,
	LavaGlow,
	TesterLibs,
	ShowLayoutGroupGrid,
	ShowHiddenStats,
	OverrideUnitShooting,
	OverrideUnitWalking,
	IgnoreDamage,
	DebugTooltipUI,
	DebugTooltipActorAI,
	DebugCityReproduction,
	DebugPowerBarTooltipTaxonomy,
	DebugPowerBarTooltipStartingCivMetas,
	DebugPowerBarTooltipSpeciesTraits,
	DebugTownPlans,
	InspectObjectsOnClick,
	BenchAiEnabled,
	ArtForceSkinLeader,
	ArtForceSkinKing,
	ArtForceSkinWarrior,
	ArtForceSkinBaby,
	DebugFocusUnitTasks,
	DebugUnitHotkeys,
	DebugWindowHotkeys,
	DebugMonolith,
	DebugButton,
	ControlledUnitsAttackRaycast,
	GenerateNewMapOnMapLoadingError,
	DebugIdleSounds
}
// --- End of File: DebugOption.cs ---



// --- Start of File: DebugTextGroupSystem.cs ---
using FMOD;
using FMOD.Studio;
using UnityEngine;

public class DebugTextGroupSystem : SpriteGroupSystem<GroupSpriteObject>
{
	private Vector2 _pos;

	public override void create()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Expected O, but got Unknown
		base.create();
		((Object)((Component)this).transform).name = "Debug Text";
		GameObject val = (GameObject)Resources.Load("Prefabs/PrefabDebugText");
		prefab = val.GetComponent<GroupSpriteObject>();
	}

	protected override GroupSpriteObject createNew()
	{
		GroupSpriteObject groupSpriteObject = base.createNew();
		((Component)groupSpriteObject).GetComponent<DebugWorldText>().create();
		return groupSpriteObject;
	}

	public override void update(float pElapsed)
	{
		prepare();
		checkSoundsAttached();
		checkSounds();
		checkSoundsPlaying();
		checkActors();
		checkBoats();
		checkBuildings();
		checkCitiesOverlay();
		checkCitiesTasksOverlay();
		checkKingdoms();
		checkArmies();
		checkZones();
		base.update(pElapsed);
	}

	private void checkSoundsPlaying()
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (!DebugConfig.isOn(DebugOption.OverlaySoundsActive) || MapBox.isRenderMiniMap())
		{
			return;
		}
		foreach (DebugMusicBoxData item in MusicBox.inst.debug_box.list)
		{
			if (item.isPlaying())
			{
				GroupSpriteObject next = getNext();
				_pos.x = item.x;
				_pos.y = item.y;
				((Component)next).GetComponent<DebugWorldText>().setTextFmodSound(item, Color.green);
				next.setPosOnly(ref _pos);
			}
		}
	}

	private void checkSounds()
	{
		if (!DebugConfig.isOn(DebugOption.OverlaySounds) || MapBox.isRenderMiniMap())
		{
			return;
		}
		foreach (DebugMusicBoxData item in MusicBox.inst.debug_box.list)
		{
			GroupSpriteObject next = getNext();
			_pos.x = item.x;
			_pos.y = item.y;
			((Component)next).GetComponent<DebugWorldText>().setTextFmodSound(item);
			next.setPosOnly(ref _pos);
		}
	}

	private void checkSoundsAttached()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		if (!DebugConfig.isOn(DebugOption.OverlaySoundsAttached) || MapBox.isRenderMiniMap())
		{
			return;
		}
		ATTRIBUTES_3D val = default(ATTRIBUTES_3D);
		foreach (EventInstance value in MusicBox.inst.idle.currentAttachedSounds.Values)
		{
			EventInstance current = value;
			GroupSpriteObject next = getNext();
			((EventInstance)(ref current)).get3DAttributes(ref val);
			_pos.x = val.position.x;
			_pos.y = val.position.y;
			((Component)next).GetComponent<DebugWorldText>().setTextFmodSound(current);
			next.setPosOnly(ref _pos);
		}
		ATTRIBUTES_3D val2 = default(ATTRIBUTES_3D);
		foreach (QuantumSpriteAsset item in AssetManager.quantum_sprites.list)
		{
			int num = item.group_system.countActive();
			QuantumSprite[] all = item.group_system.getAll();
			for (int i = 0; i < num; i++)
			{
				QuantumSprite quantumSprite = all[i];
				if (((EventInstance)(ref quantumSprite.fmod_instance)).isValid())
				{
					((EventInstance)(ref quantumSprite.fmod_instance)).get3DAttributes(ref val2);
					_pos.x = val2.position.x;
					_pos.y = val2.position.y;
					GroupSpriteObject next2 = getNext();
					((Component)next2).GetComponent<DebugWorldText>().setTextFmodSound(quantumSprite.fmod_instance);
					next2.setPosOnly(ref _pos);
				}
			}
		}
		Actor[] array = World.world.units.visible_units.array;
		int count = World.world.units.visible_units.count;
		ATTRIBUTES_3D val3 = default(ATTRIBUTES_3D);
		for (int j = 0; j < count; j++)
		{
			Actor actor = array[j];
			if (actor.idle_loop_sound != null && ((EventInstance)(ref actor.idle_loop_sound.fmod_instance)).isValid())
			{
				((EventInstance)(ref actor.idle_loop_sound.fmod_instance)).get3DAttributes(ref val3);
				_pos.x = val3.position.x;
				_pos.y = val3.position.y;
				GroupSpriteObject next3 = getNext();
				((Component)next3).GetComponent<DebugWorldText>().setTextFmodSound(actor.idle_loop_sound.fmod_instance);
				next3.setPosOnly(ref _pos);
			}
		}
	}

	private void checkBoats()
	{
		if (!DebugConfig.isOn(DebugOption.OverlayBoatTransport))
		{
			return;
		}
		foreach (Actor unit in World.world.units)
		{
			bool flag = false;
			if (unit.asset.is_boat)
			{
				flag = true;
			}
			if (flag)
			{
				GroupSpriteObject next = getNext();
				_pos.x = unit.current_position.x;
				_pos.y = unit.current_position.y;
				((Component)next).GetComponent<DebugWorldText>().setTextBoat(unit);
				next.setPosOnly(ref _pos);
			}
		}
	}

	private void checkActors()
	{
		if ((!DebugConfig.isOn(DebugOption.OverlayActorCivs) && !DebugConfig.isOn(DebugOption.OverlayCursorActor) && !DebugConfig.isOn(DebugOption.OverlayActorGroupLeaderOnly) && !DebugConfig.isOn(DebugOption.OverlayActorFavoritesOnly) && !DebugConfig.isOn(DebugOption.OverlayActorMobs)) || MapBox.isRenderMiniMap())
		{
			return;
		}
		Actor[] array = World.world.units.visible_units.array;
		int count = World.world.units.visible_units.count;
		for (int i = 0; i < count; i++)
		{
			Actor actor = array[i];
			bool flag = false;
			if (DebugConfig.isOn(DebugOption.OverlayCursorActor) && UnitSelectionEffect.last_actor == actor)
			{
				flag = true;
			}
			if (DebugConfig.isOn(DebugOption.OverlayActorFavoritesOnly) && actor.isFavorite())
			{
				flag = true;
			}
			if (DebugConfig.isOn(DebugOption.OverlayActorGroupLeaderOnly) && actor.is_army_captain)
			{
				flag = true;
			}
			if (actor.isSapient() && DebugConfig.isOn(DebugOption.OverlayActorCivs))
			{
				flag = true;
			}
			if (!actor.isSapient() && DebugConfig.isOn(DebugOption.OverlayActorMobs))
			{
				flag = true;
			}
			if (flag)
			{
				GroupSpriteObject next = getNext();
				_pos.x = actor.current_position.x;
				_pos.y = actor.current_position.y;
				((Component)next).GetComponent<DebugWorldText>().setTextActor(actor);
				next.setPosOnly(ref _pos);
			}
		}
	}

	private void checkBuildings()
	{
		if ((!DebugConfig.isOn(DebugOption.OverlayTrees) && !DebugConfig.isOn(DebugOption.OverlayPlants) && !DebugConfig.isOn(DebugOption.OverlayCivBuildings) && !DebugConfig.isOn(DebugOption.OverlayOtherBuildings)) || MapBox.isRenderMiniMap())
		{
			return;
		}
		int num = World.world.buildings.countVisibleBuildings();
		Building[] visibleBuildings = World.world.buildings.getVisibleBuildings();
		for (int i = 0; i < num; i++)
		{
			Building building = visibleBuildings[i];
			if (building.asset.city_building)
			{
				if (!DebugConfig.isOn(DebugOption.OverlayCivBuildings))
				{
					continue;
				}
			}
			else if (building.asset.building_type == BuildingType.Building_Tree)
			{
				if (!DebugConfig.isOn(DebugOption.OverlayTrees))
				{
					continue;
				}
			}
			else if (building.asset.building_type == BuildingType.Building_Plant)
			{
				if (!DebugConfig.isOn(DebugOption.OverlayPlants))
				{
					continue;
				}
			}
			else if (!DebugConfig.isOn(DebugOption.OverlayOtherBuildings))
			{
				continue;
			}
			GroupSpriteObject next = getNext();
			_pos.x = building.current_position.x;
			_pos.y = building.current_position.y;
			((Component)next).GetComponent<DebugWorldText>().setTextBuilding(building);
			next.setPosOnly(ref _pos);
		}
	}

	private void checkZones()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (!DebugConfig.isOn(DebugOption.DebugZones))
		{
			return;
		}
		foreach (TileZone zone in World.world.zone_calculator.zones)
		{
			if (zone.debug_show)
			{
				GroupSpriteObject next = getNext();
				ref Vector2 pos = ref _pos;
				Vector2Int pos2 = zone.centerTile.pos;
				pos.x = ((Vector2Int)(ref pos2)).x;
				ref Vector2 pos3 = ref _pos;
				pos2 = zone.centerTile.pos;
				pos3.y = ((Vector2Int)(ref pos2)).y;
				((Component)next).GetComponent<DebugWorldText>().setTextZone(zone);
				next.setPosOnly(ref _pos);
			}
		}
	}

	private void checkArmies()
	{
		if (!DebugConfig.isOn(DebugOption.OverlayArmies) || MapBox.isRenderMiniMap())
		{
			return;
		}
		foreach (Army army in World.world.armies)
		{
			if (army.hasCaptain())
			{
				Actor captain = army.getCaptain();
				GroupSpriteObject next = getNext();
				_pos.x = captain.current_position.x;
				_pos.y = captain.current_position.y;
				((Component)next).GetComponent<DebugWorldText>().setTextArmy(army);
				next.setPosOnly(ref _pos);
			}
		}
	}

	private void checkCitiesOverlay()
	{
		if (!DebugConfig.isOn(DebugOption.OverlayCity))
		{
			return;
		}
		foreach (City city in World.world.cities)
		{
			GroupSpriteObject next = getNext();
			_pos.x = city.city_center.x;
			_pos.y = city.city_center.y;
			((Component)next).GetComponent<DebugWorldText>().setTextCity(city);
			next.setPosOnly(ref _pos);
		}
	}

	private void checkCitiesTasksOverlay()
	{
		if (!DebugConfig.isOn(DebugOption.OverlayCityTasks))
		{
			return;
		}
		foreach (City city in World.world.cities)
		{
			GroupSpriteObject next = getNext();
			_pos.x = city.city_center.x;
			_pos.y = city.city_center.y;
			((Component)next).GetComponent<DebugWorldText>().setTextCityTasks(city);
			next.setPosOnly(ref _pos);
		}
	}

	private void checkKingdoms()
	{
		if (!DebugConfig.isOn(DebugOption.OverlayKingdom))
		{
			return;
		}
		foreach (Kingdom kingdom in World.world.kingdoms)
		{
			if (kingdom.hasCapital())
			{
				GroupSpriteObject next = getNext();
				_pos.x = kingdom.capital.city_center.x;
				_pos.y = kingdom.capital.city_center.y;
				((Component)next).GetComponent<DebugWorldText>().setTextKingdom(kingdom);
				next.setPosOnly(ref _pos);
			}
		}
	}
}
// --- End of File: DebugTextGroupSystem.cs ---



// --- Start of File: DebugTool.cs ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class DebugTool : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class _003C_003Ec
	{
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();

		public static UnityAction _003C_003E9__30_24;

		internal void _003CinitButtons_003Eb__30_24()
		{
			Bench.bench_enabled = !Bench.bench_enabled;
		}
	}

	public const int DT_WIDTH = 126;

	public const int DT_HEIGHT = 60;

	protected ObjectPoolGenericMono<DebugToolTextElement> pool_texts;

	public DebugToolTextElement element_prefab;

	internal int textCount;

	public Dropdown dropdown;

	internal bool sort_order_reversed;

	internal bool sort_by_names;

	internal bool sort_by_values = true;

	internal bool show_averages = true;

	internal bool percentage_slowest;

	internal bool hide_zeroes = true;

	internal bool show_counter = true;

	internal bool show_max = true;

	internal DebugToolState state = DebugToolState.FrameBudget;

	public DebugToolType type;

	internal bool paused;

	internal DebugToolAsset asset;

	[HideInInspector]
	public DebugDropdown active_dropdown;

	private double last_update_timestamp;

	private List<DebugIconOptionAction> list_actions = new List<DebugIconOptionAction>();

	private List<Image> list_icons = new List<Image>();

	private Transform transform_texts;

	private Transform benchmark_icons;

	private string _latest_text;

	private void Awake()
	{
		populateOptions();
		benchmark_icons = ((Component)this).transform.FindRecursive("Benchmark Icons");
		initButtons();
		initElements();
	}

	private void initElements()
	{
		transform_texts = ((Component)this).transform.FindRecursive("Texts");
		pool_texts = new ObjectPoolGenericMono<DebugToolTextElement>(element_prefab, transform_texts);
		((Component)element_prefab).gameObject.SetActive(false);
	}

	private float calculateLineHeight(Text pText)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Rect rectExtents = pText.cachedTextGenerator.rectExtents;
		Vector2 val = ((Rect)(ref rectExtents)).size * 0.5f;
		return pText.cachedTextGeneratorForLayout.GetPreferredHeight("A", pText.GetGenerationSettings(val));
	}

	internal void populateOptions()
	{
		dropdown.ClearOptions();
		List<string> list = new List<string>();
		foreach (DebugToolAsset item in AssetManager.debug_tool_library.list)
		{
			if (item.type == type)
			{
				list.Add(item.name);
			}
		}
		dropdown.AddOptions(list);
		((UnityEvent<int>)(object)dropdown.onValueChanged).RemoveListener((UnityAction<int>)switchTool);
		((UnityEvent<int>)(object)dropdown.onValueChanged).AddListener((UnityAction<int>)switchTool);
	}

	public void filterOptions(string pInput)
	{
		DebugDropdownOption[] componentsInChildren = ((Component)((Component)active_dropdown).transform).GetComponentsInChildren<DebugDropdownOption>(true);
		foreach (DebugDropdownOption debugDropdownOption in componentsInChildren)
		{
			string text = debugDropdownOption.title.text;
			if (text == "Debug option")
			{
				((Component)debugDropdownOption).gameObject.SetActive(false);
			}
			else if (!string.IsNullOrEmpty(pInput) && !text.ToLower().Contains(pInput.ToLower()))
			{
				((Component)debugDropdownOption).gameObject.SetActive(false);
			}
			else
			{
				((Component)debugDropdownOption).gameObject.SetActive(true);
			}
		}
	}

	private void initButtons()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected O, but got Unknown
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Expected O, but got Unknown
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Expected O, but got Unknown
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Expected O, but got Unknown
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Expected O, but got Unknown
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Expected O, but got Unknown
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Expected O, but got Unknown
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Expected O, but got Unknown
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Expected O, but got Unknown
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Expected O, but got Unknown
		newButton("SortByName", new UnityAction(clickSortByName), delegate(Image pIcon)
		{
			checkIcon(pIcon, sort_by_names);
		});
		newButton("SortByValues", new UnityAction(clickSortByValues), delegate(Image pIcon)
		{
			checkIcon(pIcon, sort_by_values);
		});
		newButton("SortReversed", (UnityAction)delegate
		{
			sort_order_reversed = !sort_order_reversed;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, sort_order_reversed);
		});
		newButton("ShowAverages", (UnityAction)delegate
		{
			show_averages = !show_averages;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, isValueAverage());
		});
		newButton("PercentBasedOnSlowest", (UnityAction)delegate
		{
			percentage_slowest = !percentage_slowest;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, percentage_slowest);
		});
		newButton("HideZeroes", (UnityAction)delegate
		{
			hide_zeroes = !hide_zeroes;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, hide_zeroes);
		});
		newButton("ShowCounter", (UnityAction)delegate
		{
			show_counter = !show_counter;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, show_counter);
		});
		newButton("ShowMax", (UnityAction)delegate
		{
			show_max = !show_max;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, show_max);
		});
		newButton("ShowSeconds", (UnityAction)delegate
		{
			state = DebugToolState.Values;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, state == DebugToolState.Values);
		});
		newButton("ShowPercentages", (UnityAction)delegate
		{
			state = DebugToolState.Percent;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, state == DebugToolState.Percent);
		});
		newButton("ShowTimeSpent", (UnityAction)delegate
		{
			state = DebugToolState.TimeSpent;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, state == DebugToolState.TimeSpent);
		});
		newButton("ShowFrameBudget", (UnityAction)delegate
		{
			state = DebugToolState.FrameBudget;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, state == DebugToolState.FrameBudget);
		});
		newButton("Paused", (UnityAction)delegate
		{
			paused = !paused;
		}, delegate(Image pIcon)
		{
			checkIcon(pIcon, paused);
		});
		object obj = _003C_003Ec._003C_003E9__30_24;
		if (obj == null)
		{
			UnityAction val = delegate
			{
				Bench.bench_enabled = !Bench.bench_enabled;
			};
			_003C_003Ec._003C_003E9__30_24 = val;
			obj = (object)val;
		}
		newButton("EnableBenchmarks", (UnityAction)obj, delegate(Image pIcon)
		{
			checkIcon(pIcon, Bench.bench_enabled);
		});
	}

	private void newButton(string pID, UnityAction pAction, DebugIconOptionAction pCheckIcon)
	{
		Transform val = ((Component)this).transform.FindRecursive(pID);
		((UnityEvent)((Component)val).GetComponent<Button>().onClick).AddListener(pAction);
		list_actions.Add(pCheckIcon);
		list_icons.Add(((Component)val).GetComponent<Image>());
	}

	public bool isValueAverage()
	{
		return show_averages;
	}

	public bool isState(DebugToolState pState)
	{
		return state == pState;
	}

	private void updateIcons()
	{
		for (int i = 0; i < list_actions.Count; i++)
		{
			DebugIconOptionAction debugIconOptionAction = list_actions[i];
			Image pButton = list_icons[i];
			debugIconOptionAction(pButton);
		}
	}

	private void checkIcon(Image pImageIcon, bool pValue)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		if (pValue)
		{
			((Graphic)pImageIcon).color = Color.white;
		}
		else
		{
			((Graphic)pImageIcon).color = Color32.op_Implicit(Toolbox.color_transparent_grey);
		}
	}

	private void switchTool(int pIndex)
	{
		string text = dropdown.options[pIndex].text;
		DebugToolAsset debugToolAsset = AssetManager.debug_tool_library.get(text);
		setAsset(debugToolAsset);
	}

	public void setAsset(DebugToolAsset pAsset)
	{
		asset = pAsset;
		type = asset.type;
		((Component)benchmark_icons).gameObject.SetActive(asset.show_benchmark_buttons);
		if (asset.action_start != null)
		{
			asset.action_start(this);
		}
	}

	private void Update()
	{
		if (SmoothLoader.isLoading())
		{
			return;
		}
		updateIcons();
		double curSessionTime = World.world.getCurSessionTime();
		if (!(curSessionTime < last_update_timestamp + (double)asset.update_timeout) && !paused)
		{
			if (asset.action_update != null)
			{
				asset.action_update(this);
			}
			clearTexts();
			_ = dropdown.captionText.text;
			last_update_timestamp = curSessionTime;
			if (asset.action_1 != null)
			{
				asset.action_1(this);
			}
			if (asset.action_2 != null)
			{
				asset.action_2(this);
			}
			updateSize();
			pool_texts.disableInactive();
			((MonoBehaviour)this).StartCoroutine(updateSizeAfterFrame());
		}
	}

	public IEnumerator updateSizeAfterFrame()
	{
		yield return CoroutineHelper.wait_for_end_of_frame;
		updateSize();
	}

	private void updateSize()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		float num = LayoutUtility.GetPreferredWidth(((Component)transform_texts).GetComponent<RectTransform>()) * 1.2f;
		float num2 = LayoutUtility.GetPreferredHeight(((Component)transform_texts).GetComponent<RectTransform>()) + 40f;
		if (num < 126f)
		{
			num = 126f;
		}
		if (num2 < 60f)
		{
			num2 = 60f;
		}
		((Component)this).GetComponent<RectTransform>().sizeDelta = new Vector2(num, num2);
	}

	public void clickSortByName()
	{
		sort_by_names = !sort_by_names;
		sort_by_values = !sort_by_names;
	}

	public void clickSortByValues()
	{
		sort_by_values = !sort_by_values;
		sort_by_names = !sort_by_values;
	}

	public int kingdomSorter(Kingdom k1, Kingdom k2)
	{
		return k2.units.Count.CompareTo(k1.units.Count);
	}

	public int citySorter(City c1, City c2)
	{
		return c2.getPopulationPeople().CompareTo(c1.getPopulationPeople());
	}

	internal void setText(string pT1, object pT2, float pBarValue = 0f, bool pShowBar = false, long pCounter = 0L, bool pShowCounter = false, bool pShowMax = false, string pMaxValue = "")
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		DebugToolTextElement next = pool_texts.getNext();
		string text = ((pT2 == null) ? "-" : pT2.ToString());
		if (pT2 != null)
		{
			if (pShowCounter && show_counter && (asset.split_benchmark || asset.show_last_count))
			{
				text = pCounter + " | " + text;
			}
			if (pShowMax)
			{
				text = pMaxValue + " | " + text;
			}
		}
		next.text_left.text = pT1;
		next.text_right.text = text;
		textCount++;
		if (pShowBar)
		{
			((Component)next.text_bar).gameObject.SetActive(true);
			if (pBarValue > 100f)
			{
				pBarValue = 101f;
			}
			float num = pBarValue * 0.5f;
			((Component)next.text_bar).GetComponent<RectTransform>().sizeDelta = new Vector2(num, 4.2f);
			if (pBarValue > 70f && pBarValue != 100f)
			{
				((Graphic)next.text_bar).color = Color32.op_Implicit(Toolbox.color_debug_bar_red);
			}
			else
			{
				((Graphic)next.text_bar).color = Color32.op_Implicit(Toolbox.color_debug_bar_blue);
			}
		}
		else
		{
			((Component)next.text_bar).gameObject.SetActive(false);
		}
	}

	internal void setSeparator()
	{
		DebugToolTextElement next = pool_texts.getNext();
		next.text_left.text = string.Empty;
		next.text_right.text = string.Empty;
		((Component)next.text_bar).gameObject.SetActive(false);
	}

	private void clearTexts()
	{
		textCount = 0;
		pool_texts.clear(pDisable: false);
	}

	public void clickClose()
	{
		Object.Destroy((Object)(object)((Component)this).gameObject, 0.01f);
	}

	public void clickDuplicate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		int pX = (int)((Component)this).transform.localPosition.x + 126 + 2;
		int pY = (int)((Component)this).transform.localPosition.y;
		DebugConfig.createTool(asset.id, pX, pY);
	}
}
// --- End of File: DebugTool.cs ---



// --- Start of File: DebugToolAsset.cs ---
using System;

[Serializable]
public class DebugToolAsset : Asset
{
	public string name;

	public string benchmark_group_id = string.Empty;

	public string benchmark_total = string.Empty;

	public string benchmark_total_group = string.Empty;

	public string path_icon;

	public int priority;

	public DebugToolType type;

	public DebugToolAssetAction action_1;

	public DebugToolAssetAction action_2;

	public DebugToolAssetAction action_start;

	public DebugToolUpdateDelegate action_update;

	public float update_timeout = 0.1f;

	public bool show_on_start;

	public bool show_benchmark_buttons;

	public bool split_benchmark;

	public bool show_last_count;

	public void showForMaxim()
	{
		if (Config.editor_maxim)
		{
			show_on_start = Config.editor_maxim;
		}
	}

	public void showForMastef()
	{
		if (Config.editor_mastef)
		{
			show_on_start = Config.editor_mastef;
		}
	}

	public void showForNikon()
	{
		if (Config.editor_nikon)
		{
			show_on_start = Config.editor_nikon;
		}
	}
}
// --- End of File: DebugToolAsset.cs ---



// --- Start of File: DebugToolAssetAction.cs ---
public delegate void DebugToolAssetAction(DebugTool pTool);
// --- End of File: DebugToolAssetAction.cs ---



// --- Start of File: DebugToolLibrary.cs ---
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using UnityEngine.Rendering;
using UnityPools;
using life.taxi;

public class DebugToolLibrary : AssetLibrary<DebugToolAsset>
{
	private UtilityBasedDecisionSystem _decision_system_debug;

	public override void init()
	{
		base.init();
		initBenchmarks();
		initMain();
		initGameplay();
		initMap();
		initAI();
		initCity();
		initSystems();
		initSubSystems();
		initFmod();
		initDiagnosticGameplay();
		initUI();
		initDebugConfigDefaults();
	}

	private void initDebugConfigDefaults()
	{
		foreach (string default_debug_tool in DebugConfig.default_debug_tools)
		{
			DebugToolAsset debugToolAsset = get(default_debug_tool);
			if (debugToolAsset != null)
			{
				debugToolAsset.show_on_start = true;
			}
		}
	}

	private void initDiagnosticGameplay()
	{
		add(new DebugToolAsset
		{
			id = "hotkeys_nanoobjects",
			action_1 = delegate(DebugTool pTool)
			{
				HotkeyTabsData hotkey_tabs_data = World.world.hotkey_tabs_data;
				Dictionary<string, PlayerOptionData> dictionary3 = PlayerConfig.dict;
				pTool.setText("#map:", "-------------", 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_1:", hotkey_tabs_data.hotkey_data_1, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_2:", hotkey_tabs_data.hotkey_data_2, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_3:", hotkey_tabs_data.hotkey_data_3, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_4:", hotkey_tabs_data.hotkey_data_4, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_5:", hotkey_tabs_data.hotkey_data_5, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_6:", hotkey_tabs_data.hotkey_data_6, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_7:", hotkey_tabs_data.hotkey_data_7, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_8:", hotkey_tabs_data.hotkey_data_8, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_9:", hotkey_tabs_data.hotkey_data_9, 0f, pShowBar: false, 0L);
				pTool.setText("hotkey_data_0:", hotkey_tabs_data.hotkey_data_0, 0f, pShowBar: false, 0L);
				pTool.setText("#global_config:", "-------------", 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_1:", dictionary3["hotkey_1"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_2:", dictionary3["hotkey_2"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_3:", dictionary3["hotkey_3"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_4:", dictionary3["hotkey_4"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_5:", dictionary3["hotkey_5"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_6:", dictionary3["hotkey_6"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_7:", dictionary3["hotkey_7"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_8:", dictionary3["hotkey_8"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_9:", dictionary3["hotkey_9"].stringVal, 0f, pShowBar: false, 0L);
				pTool.setText("global_hotkey_0:", dictionary3["hotkey_0"].stringVal, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "reproduction_diagnostic_cursor",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					if (Zones.showCityZones())
					{
						City city = mouseTilePos.zone.city;
						if (city != null)
						{
							Subspecies mainSubspecies = city.getMainSubspecies();
							if (mainSubspecies != null)
							{
								showReproductionDebugInfo(pTool, mainSubspecies);
							}
						}
					}
					else if (Zones.showKingdomZones())
					{
						City city2 = mouseTilePos.zone.city;
						if (city2 != null)
						{
							Subspecies mainSubspecies2 = city2.kingdom.getMainSubspecies();
							if (mainSubspecies2 != null)
							{
								showReproductionDebugInfo(pTool, mainSubspecies2);
							}
						}
					}
					else if (Zones.showSpeciesZones())
					{
						ZoneMetaData zoneMetaData = ZoneMetaDataVisualizer.getZoneMetaData(mouseTilePos.zone);
						if (zoneMetaData.meta_object != null && zoneMetaData.meta_object.isAlive())
						{
							showReproductionDebugInfo(pTool, zoneMetaData.meta_object as Subspecies);
						}
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "reproduction_diagnostic_total",
			action_1 = delegate(DebugTool pTool)
			{
				Dictionary<string, int> dictionary = UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Get();
				Dictionary<string, int> dictionary2 = UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Get();
				foreach (Subspecies subspecy in World.world.subspecies)
				{
					foreach (RateCounter list_counter in subspecy.list_counters)
					{
						dictionary[list_counter.id] = dictionary.GetValueOrDefault(list_counter.id) + list_counter.getTotal();
						dictionary2[list_counter.id] = dictionary2.GetValueOrDefault(list_counter.id) + list_counter.getEventsPerMinute();
					}
				}
				foreach (KeyValuePair<string, int> item in dictionary)
				{
					pTool.setText(item.Key + ":", $"{dictionary2[item.Key]} | tot: {item.Value}", 0f, pShowBar: false, 0L);
				}
				UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Release(dictionary);
				UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Release(dictionary2);
			}
		});
	}

	private void showReproductionDebugInfo(DebugTool pTool, Subspecies pSubspecies)
	{
		pSubspecies.debugReproductionEvents(pTool);
	}

	private void initCity()
	{
		add(new DebugToolAsset
		{
			id = "Cities",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_012d: Unknown result type (might be due to invalid IL or missing references)
				List<City> obj2 = new List<City>(World.world.cities);
				obj2.Sort(pTool.citySorter);
				foreach (City item in obj2)
				{
					if (pTool.textCount > 0)
					{
						pTool.setSeparator();
					}
					pTool.setText("#name:", item.name, 0f, pShowBar: false, 0L);
					pTool.setText("pep:", item.getPopulationPeople(), 0f, pShowBar: false, 0L);
					pTool.setText("units:", item.getUnitsTotal(), 0f, pShowBar: false, 0L);
					pTool.setText("boats:", item.countBoats(), 0f, pShowBar: false, 0L);
					pTool.setText("zones:", item.zones.Count, 0f, pShowBar: false, 0L);
					pTool.setText("buildings:", item.buildings.Count, 0f, pShowBar: false, 0L);
					pTool.setText("city_center:", item.city_center, 0f, pShowBar: false, 0L);
					if (pTool.textCount > 30)
					{
						pTool.setSeparator();
						pTool.setText("more...", "...", 0f, pShowBar: false, 0L);
						break;
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City Loyalty",
			action_1 = delegate(DebugTool pTool)
			{
				List<City> obj = new List<City>(World.world.cities);
				obj.Sort(pTool.citySorter);
				int num8 = 0;
				int num9 = 0;
				foreach (City item2 in obj)
				{
					if (item2.getCachedLoyalty() >= 0)
					{
						num8++;
					}
					else
					{
						num9++;
					}
				}
				pTool.setText("cities with loyalty above 0:", num8, 0f, pShowBar: false, 0L);
				pTool.setText("cities with loyalty below 0:", num9, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "City Capture",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos7 = World.world.getMouseTilePos();
				if (mouseTilePos7 != null)
				{
					City city7 = mouseTilePos7.zone.city;
					if (city7 != null)
					{
						if (city7.being_captured_by != null && city7.being_captured_by.isAlive())
						{
							pTool.setText("capturing by:", city7.being_captured_by.name, 0f, pShowBar: false, 0L);
						}
						pTool.setText("ticks:", city7.getCaptureTicks(), 0f, pShowBar: false, 0L);
						city7.debugCaptureUnits(pTool);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City Tasks",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos6 = World.world.getMouseTilePos();
				if (mouseTilePos6 != null)
				{
					City city6 = mouseTilePos6.zone.city;
					if (city6 != null)
					{
						pTool.setText("trees:", city6.tasks.trees, 0f, pShowBar: false, 0L);
						pTool.setText("stone:", city6.tasks.minerals, 0f, pShowBar: false, 0L);
						pTool.setText("minerals:", city6.tasks.minerals, 0f, pShowBar: false, 0L);
						pTool.setText("bushes:", city6.tasks.bushes, 0f, pShowBar: false, 0L);
						pTool.setText("plants:", city6.tasks.plants, 0f, pShowBar: false, 0L);
						pTool.setText("hives:", city6.tasks.hives, 0f, pShowBar: false, 0L);
						pTool.setText("farm_fields:", city6.tasks.farm_fields, 0f, pShowBar: false, 0L);
						pTool.setText("wheats:", city6.tasks.wheats, 0f, pShowBar: false, 0L);
						pTool.setText("ruins:", city6.tasks.ruins, 0f, pShowBar: false, 0L);
						pTool.setText("poops:", city6.tasks.poops, 0f, pShowBar: false, 0L);
						pTool.setText("roads:", city6.tasks.roads, 0f, pShowBar: false, 0L);
						pTool.setText("fire:", city6.tasks.fire, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "city_jobs",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos5 = World.world.getMouseTilePos();
				if (mouseTilePos5 != null)
				{
					City city5 = mouseTilePos5.zone.city;
					if (city5 != null)
					{
						int num3 = 0;
						int num4 = 0;
						foreach (CitizenJobAsset key in city5.jobs.jobs.Keys)
						{
							int num5 = city5.jobs.jobs[key];
							int num6 = 0;
							if (city5.jobs.occupied.ContainsKey(key))
							{
								num6 = city5.jobs.occupied[key];
							}
							num3 += num5;
							num4 += num6;
							pTool.setText(key.id + ":", num6 + "/" + num5, 0f, pShowBar: false, 0L);
						}
						foreach (CitizenJobAsset key2 in city5.jobs.occupied.Keys)
						{
							if (!city5.jobs.jobs.ContainsKey(key2))
							{
								int num7 = city5.jobs.occupied[key2];
								num4 += num7;
								pTool.setText(key2.id + ":", num7 + "/" + 0, 0f, pShowBar: false, 0L);
							}
						}
						pTool.setSeparator();
						pTool.setText("total JOBS:", num4 + "/" + num3, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("pop:", city5.getPopulationPeople() + " / " + city5.getPopulationMaximum(), 0f, pShowBar: false, 0L);
						pTool.setText("adults/children:", city5.countAdults() + "/" + city5.countChildren(), 0f, pShowBar: false, 0L);
						pTool.setText("food:", city5.countFood(), 0f, pShowBar: false, 0L);
						pTool.setText("hungry/starving:", city5.countHungry() + "/" + city5.countStarving(), 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City Info",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos4 = World.world.getMouseTilePos();
				if (mouseTilePos4 != null)
				{
					City city4 = mouseTilePos4.zone.city;
					if (city4 != null)
					{
						pTool.setText("#name:", city4.name, 0f, pShowBar: false, 0L);
						pTool.setText("city units all:", city4.getUnitsTotal(), 0f, pShowBar: false, 0L);
						pTool.setText("city people:", city4.getPopulationPeople(), 0f, pShowBar: false, 0L);
						pTool.setText("units:", city4.getPopulationPeople() + "/" + city4.getPopulationMaximum(), 0f, pShowBar: false, 0L);
						if (city4.getPopulationMaximum() != city4.status.housing_total)
						{
							pTool.setText("unit housing:", city4.getPopulationPeople() + "/" + city4.status.housing_total, 0f, pShowBar: false, 0L);
						}
						pTool.setText("in houses:", city4.countInHouses(), 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						if (city4.hasLeader())
						{
							pTool.setText("leader:", city4.leader.getName(), 0f, pShowBar: false, 0L);
						}
						if (city4.hasKingdom())
						{
							pTool.setText("kingdom:", city4.kingdom.name, 0f, pShowBar: false, 0L);
						}
						if (city4.hasKingdom())
						{
							pTool.setText("#name:", city4.kingdom.id, 0f, pShowBar: false, 0L);
						}
						pTool.setSeparator();
						pTool.setText("zones:", city4.zones.Count, 0f, pShowBar: false, 0L);
						pTool.setText("buildings:", city4.buildings.Count, 0f, pShowBar: false, 0L);
						pTool.setText("homes free:", city4.status.housing_free, 0f, pShowBar: false, 0L);
						pTool.setText("homes occupied:", city4.status.housing_occupied, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setSeparator();
						pTool.setText("roads to build:", city4.road_tiles_to_build.Count, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setSeparator();
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "city_storage",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos3 = World.world.getMouseTilePos();
				if (mouseTilePos3 != null)
				{
					City city3 = mouseTilePos3.zone.city;
					if (city3 != null && city3.hasStorages())
					{
						for (int i = 0; i < city3.storages.Count; i++)
						{
							foreach (string key3 in city3.storages[i].resources.getKeys())
							{
								pTool.setText("stock_" + i + ":" + key3 + ":", city3.getResourcesAmount(key3), 0f, pShowBar: false, 0L);
							}
						}
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City Buildings",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos2 = World.world.getMouseTilePos();
				if (mouseTilePos2 != null)
				{
					City city2 = mouseTilePos2.zone.city;
					if (city2 != null)
					{
						pTool.setSeparator();
						int num = 0;
						int num2 = 0;
						pTool.setText("#type", "", 0f, pShowBar: false, 0L);
						foreach (string key4 in city2.buildings_dict_type.Keys)
						{
							pTool.setText(key4 + ":", city2.buildings_dict_type[key4].Count, 0f, pShowBar: false, 0L);
							num += city2.buildings_dict_type[key4].Count;
						}
						pTool.setSeparator();
						pTool.setText("#name", "", 0f, pShowBar: false, 0L);
						foreach (string key5 in city2.buildings_dict_id.Keys)
						{
							pTool.setText(key5 + ":", city2.buildings_dict_id[key5].Count, 0f, pShowBar: false, 0L);
							num2 += city2.buildings_dict_id[key5].Count;
						}
						pTool.setSeparator();
						pTool.setText("total:", city2.buildings.Count, 0f, pShowBar: false, 0L);
						pTool.setText("total by type:", num, 0f, pShowBar: false, 0L);
						pTool.setText("total by name:", num2, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City Professions",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					City city = mouseTilePos.zone.city;
					if (city != null)
					{
						pTool.setSeparator();
						pTool.setText("total:", city.units.Count, 0f, pShowBar: false, 0L);
						pTool.setText("king:", city.countProfession(UnitProfession.King), 0f, pShowBar: false, 0L);
						pTool.setText("leader:", city.countProfession(UnitProfession.Leader), 0f, pShowBar: false, 0L);
						pTool.setText("units:", city.countProfession(UnitProfession.Unit), 0f, pShowBar: false, 0L);
						pTool.setText("babies:", city.countChildren(), 0f, pShowBar: false, 0L);
						pTool.setText("warriors:", city.countProfession(UnitProfession.Warrior), 0f, pShowBar: false, 0L);
						pTool.setText("null:", city.countProfession(UnitProfession.Nothing), 0f, pShowBar: false, 0L);
					}
				}
			}
		});
	}

	private void initSystems()
	{
		add(new DebugToolAsset
		{
			id = "Effects",
			action_1 = delegate(DebugTool pTool)
			{
				ExplosionChecker.debug(pTool);
				foreach (BaseEffectController item in World.world.stack_effects.list)
				{
					item.debug(pTool);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Auto Tester",
			action_1 = delegate(DebugTool pTool)
			{
				if ((Object)(object)World.world.auto_tester != (Object)null)
				{
					pTool.setText("active:", World.world.auto_tester.active, 0f, pShowBar: false, 0L);
					pTool.setText("d_string:", World.world.auto_tester.debugString, 0f, pShowBar: false, 0L);
					World.world.auto_tester.ai.debug(pTool);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Controllable Units",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_0160: Unknown result type (might be due to invalid IL or missing references)
				pTool.setText("isOverUI:", World.world.isOverUI(), 0f, pShowBar: false, 0L);
				pTool.setText("isGameplayControlsLocked:", World.world.isGameplayControlsLocked(), 0f, pShowBar: false, 0L);
				pTool.setText("controlsLocked:", MapBox.controlsLocked(), 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("IsselectedUnit:", SelectedUnit.isSet(), 0f, pShowBar: false, 0L);
				pTool.setText("Total Selected:", SelectedUnit.getAllSelected().Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("ControllableUnit:", ControllableUnit.isControllingUnit(), 0f, pShowBar: false, 0L);
				pTool.setText("Total Controlled:", ControllableUnit.getCotrolledUnits().Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("Square Selection:", World.world.player_control.square_selection_started, 0f, pShowBar: false, 0L);
				pTool.setText("Square Selection Pos:", World.world.player_control.square_selection_position_current, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Selected Unit",
			action_1 = delegate(DebugTool pTool)
			{
				Actor unit = SelectedUnit.unit;
				if (unit != null)
				{
					Actor actorNearCursor = World.world.getActorNearCursor();
					if (actorNearCursor != null)
					{
						float num = unit.distanceToObjectTarget(actorNearCursor);
						pTool.setText("dist to target:", num, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Window",
			action_1 = delegate(DebugTool pTool)
			{
				ScrollWindow.debug(pTool);
				pTool.setSeparator();
				WindowHistory.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Selected Meta",
			action_1 = delegate(DebugTool pTool)
			{
				AssetManager.meta_type_library.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Camera",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_059d: Unknown result type (might be due to invalid IL or missing references)
				//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
				//IL_0654: Unknown result type (might be due to invalid IL or missing references)
				//IL_072b: Unknown result type (might be due to invalid IL or missing references)
				//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
				//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
				//IL_0302: Unknown result type (might be due to invalid IL or missing references)
				//IL_0307: Unknown result type (might be due to invalid IL or missing references)
				//IL_030a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0340: Unknown result type (might be due to invalid IL or missing references)
				//IL_0345: Unknown result type (might be due to invalid IL or missing references)
				//IL_0348: Unknown result type (might be due to invalid IL or missing references)
				//IL_037e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0383: Unknown result type (might be due to invalid IL or missing references)
				//IL_0386: Unknown result type (might be due to invalid IL or missing references)
				//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
				//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
				//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
				//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
				//IL_0438: Unknown result type (might be due to invalid IL or missing references)
				//IL_043d: Unknown result type (might be due to invalid IL or missing references)
				World.world.move_camera.debug(pTool);
				pTool.setSeparator();
				pTool.setText("zoom", World.world.camera.orthographicSize, 0f, pShowBar: false, 0L);
				pTool.setText("aspect", World.world.camera.aspect, 0f, pShowBar: false, 0L);
				pTool.setText("zoom_bound_mod", World.world.quality_changer.getZoomRateBoundLow(), 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("visible zones", World.world.zone_camera.countVisibleZones() + "/" + World.world.zone_calculator.zones.Count, 0f, pShowBar: false, 0L);
				pTool.setText("Input.touchCount", Input.touchCount, 0f, pShowBar: false, 0L);
				pTool.setText("origin_touch_dist", World.world.player_control.getDistanceBetweenOriginAndCurrentTouch(), 0f, pShowBar: false, 0L);
				pTool.setText("getDebugDragThreshold", World.world.player_control.getCurrentDragDistance().ToString("F3") + " / " + 0.007f, 0f, pShowBar: false, 0L);
				pTool.setText("getDebugDragThreshold %", (World.world.player_control.getCurrentDragDistance() * 100f).ToString("F3") + "%", 0f, pShowBar: false, 0L);
				pTool.setText("isTouchMoreThanDragThreshold %", World.world.player_control.isTouchMoreThanDragThreshold(), 0f, pShowBar: false, 0L);
				pTool.setText("already_used_camera_drag", World.world.player_control.already_used_camera_drag, 0f, pShowBar: false, 0L);
				pTool.setText("inspect_timer_click", World.world.player_control.inspect_timer_click, 0f, pShowBar: false, 0L);
				pTool.setText("touch_timer", World.world.player_control.touch_ticks_skip, 0f, pShowBar: false, 0L);
				if (Input.touchCount > 0)
				{
					for (int i = 0; i < Input.touchCount; i++)
					{
						string pT = "Touch.fingerId[" + i + "]";
						Touch touch = Input.GetTouch(i);
						pTool.setText(pT, ((Touch)(ref touch)).fingerId, 0f, pShowBar: false, 0L);
						string pT2 = "Touch.rawPosition[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT2, ((Touch)(ref touch)).rawPosition, 0f, pShowBar: false, 0L);
						string pT3 = "Touch.pos[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT3, ((Touch)(ref touch)).position, 0f, pShowBar: false, 0L);
						string pT4 = "Touch.dpos[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT4, ((Touch)(ref touch)).deltaPosition, 0f, pShowBar: false, 0L);
						string pT5 = "Touch.delta[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT5, ((Touch)(ref touch)).deltaTime, 0f, pShowBar: false, 0L);
						string pT6 = "Touch.radius[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT6, ((Touch)(ref touch)).radius, 0f, pShowBar: false, 0L);
						string pT7 = "Touch.pressure[" + i + "]";
						touch = Input.GetTouch(i);
						pTool.setText(pT7, ((Touch)(ref touch)).pressure, 0f, pShowBar: false, 0L);
					}
				}
				pTool.setText("Axis Vertical", Input.GetAxis("Vertical"), 0f, pShowBar: false, 0L);
				pTool.setText("Axis Horizontal", Input.GetAxis("Horizontal"), 0f, pShowBar: false, 0L);
				pTool.setText("Input.touchSupported", Input.touchSupported, 0f, pShowBar: false, 0L);
				pTool.setText("Input.touchPressureSupported", Input.touchPressureSupported, 0f, pShowBar: false, 0L);
				pTool.setText("Input.multiTouchEnabled", Input.multiTouchEnabled, 0f, pShowBar: false, 0L);
				pTool.setText("Input.stylusTouchSupported", Input.stylusTouchSupported, 0f, pShowBar: false, 0L);
				pTool.setText("Input.simulateMouseWithTouches", Input.simulateMouseWithTouches, 0f, pShowBar: false, 0L);
				pTool.setText("Input.mousePresent", Input.mousePresent, 0f, pShowBar: false, 0L);
				pTool.setText("Input.mousePosition", Input.mousePosition, 0f, pShowBar: false, 0L);
				pTool.setText("Input.mouseScrollDelta", Input.mouseScrollDelta, 0f, pShowBar: false, 0L);
				pTool.setText("Button 0", Input.GetMouseButton(0), 0f, pShowBar: false, 0L);
				pTool.setText("Button 1", Input.GetMouseButton(1), 0f, pShowBar: false, 0L);
				pTool.setText("Button 2", Input.GetMouseButton(2), 0f, pShowBar: false, 0L);
				pTool.setText("Axis ScrollWheel", Input.mouseScrollDelta.y, 0f, pShowBar: false, 0L);
				pTool.setText("Axis Mouse X", Input.GetAxis("Mouse X"), 0f, pShowBar: false, 0L);
				pTool.setText("Axis Mouse Y", Input.GetAxis("Mouse Y"), 0f, pShowBar: false, 0L);
				pTool.setText("Raw Mouse X", Input.GetAxisRaw("Mouse X"), 0f, pShowBar: false, 0L);
				pTool.setText("Raw Mouse Y", Input.GetAxisRaw("Mouse Y"), 0f, pShowBar: false, 0L);
				pTool.setText("Velocity", World.world.move_camera.getVelocity(), 0f, pShowBar: false, 0L);
			}
		});
	}

	private void initMap()
	{
		add(new DebugToolAsset
		{
			id = "tile_info",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos6 = World.world.getMouseTilePos();
				if (mouseTilePos6 != null)
				{
					pTool.setText("x", mouseTilePos6.x, 0f, pShowBar: false, 0L);
					pTool.setText("y", mouseTilePos6.y, 0f, pShowBar: false, 0L);
					pTool.setText("id", mouseTilePos6.data.tile_id, 0f, pShowBar: false, 0L);
					pTool.setText("height", mouseTilePos6.data.height, 0f, pShowBar: false, 0L);
					pTool.setText("type", mouseTilePos6.Type.id, 0f, pShowBar: false, 0L);
					pTool.setText("layer", mouseTilePos6.Type.layer_type, 0f, pShowBar: false, 0L);
					pTool.setText("main tile", (mouseTilePos6.main_type != null) ? mouseTilePos6.main_type.id : "-", 0f, pShowBar: false, 0L);
					pTool.setText("cap tile", (mouseTilePos6.top_type != null) ? mouseTilePos6.top_type.id : "-", 0f, pShowBar: false, 0L);
					pTool.setText("burned", mouseTilePos6.burned_stages, 0f, pShowBar: false, 0L);
					pTool.setText("targetedBy", mouseTilePos6.isTargeted(), 0f, pShowBar: false, 0L);
					pTool.setText("units", mouseTilePos6.countUnits(), 0f, pShowBar: false, 0L);
					pTool.setText("good_for_boat", mouseTilePos6.isGoodForBoat(), 0f, pShowBar: false, 0L);
					pTool.setText("heat", mouseTilePos6.heat, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("--zone:", "", 0f, pShowBar: false, 0L);
					TileZone zone = mouseTilePos6.zone;
					if (zone.hasAnyBuildingsInSet(BuildingList.Civs))
					{
						pTool.setText("buildings:", zone.getHashset(BuildingList.Civs).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Ruins))
					{
						pTool.setText("ruins:", zone.getHashset(BuildingList.Ruins).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Trees))
					{
						pTool.setText("trees:", zone.getHashset(BuildingList.Trees).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Minerals))
					{
						pTool.setText("stone:", zone.getHashset(BuildingList.Minerals).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Food))
					{
						pTool.setText("fruits:", zone.getHashset(BuildingList.Food).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Hives))
					{
						pTool.setText("hives:", zone.getHashset(BuildingList.Hives).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.hasAnyBuildingsInSet(BuildingList.Poops))
					{
						pTool.setText("poops:", zone.getHashset(BuildingList.Poops).Count, 0f, pShowBar: false, 0L);
					}
					if (zone.isZoneOnFire())
					{
						pTool.setText("fire:", WorldBehaviourActionFire.countFires(zone), 0f, pShowBar: false, 0L);
					}
					if (zone.tiles_with_liquid > 0)
					{
						pTool.setText("water tiles:", zone.tiles_with_liquid, 0f, pShowBar: false, 0L);
					}
					if (zone.tiles_with_ground > 0)
					{
						pTool.setText("ground tiles:", zone.tiles_with_ground, 0f, pShowBar: false, 0L);
					}
					if (zone.city != null)
					{
						pTool.setText("city:", zone.city.name, 0f, pShowBar: false, 0L);
					}
					if (zone.city != null && zone.city.kingdom != null)
					{
						pTool.setText("kingdom:", zone.city.kingdom.name, 0f, pShowBar: false, 0L);
					}
					if (mouseTilePos6.hasBuilding())
					{
						pTool.setSeparator();
						pTool.setText("--building:", "", 0f, pShowBar: false, 0L);
						pTool.setText("resources:", mouseTilePos6.building.hasResourcesToCollect(), 0f, pShowBar: false, 0L);
						pTool.setText("alive:", mouseTilePos6.building.isAlive(), 0f, pShowBar: false, 0L);
						pTool.setText("is_usable:", mouseTilePos6.building.isUsable(), 0f, pShowBar: false, 0L);
						pTool.setText("city:", (mouseTilePos6.building.city != null) ? mouseTilePos6.building.city.name : "-", 0f, pShowBar: false, 0L);
						pTool.setText("kingdom:", (mouseTilePos6.building.city?.kingdom != null) ? mouseTilePos6.building.city.kingdom.name : "-", 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Connections",
			action_1 = delegate(DebugTool pTool)
			{
				RegionLinkHashes.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Region",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos4 = World.world.getMouseTilePos();
				if (mouseTilePos4 != null && mouseTilePos4.region != null)
				{
					WorldTile mouseTilePos5 = World.world.getMouseTilePos();
					if (mouseTilePos5 != null)
					{
						MapRegion region = mouseTilePos5.region;
						if (region != null)
						{
							bool flag = false;
							string pT = "";
							foreach (MapRegion neighbour in region.neighbours)
							{
								if (neighbour.tiles.Count == 0)
								{
									flag = true;
									pT = neighbour.id.ToString();
									break;
								}
							}
							pTool.setText("- region id:", region.id, 0f, pShowBar: false, 0L);
							pTool.setText("-chunk id:", region.chunk.id, 0f, pShowBar: false, 0L);
							pTool.setText("-chunk xy:", region.chunk.x + " " + region.chunk.y, 0f, pShowBar: false, 0L);
							pTool.setText("- tEmptyRegionNeighbour:", flag, 0f, pShowBar: false, 0L);
							if (flag)
							{
								pTool.setText("- tEmptyRegionNeighbourID:", pT, 0f, pShowBar: false, 0L);
							}
							pTool.setText("- getEdgeTiles :", region.getEdgeTiles().Count, 0f, pShowBar: false, 0L);
							pTool.setText("- used in path :", region.used_by_path_lock + " " + region.region_path_id, 0f, pShowBar: false, 0L);
							pTool.setText("- region wave:", region.path_wave_id, 0f, pShowBar: false, 0L);
							pTool.setText("- centerRegion:", region.center_region, 0f, pShowBar: false, 0L);
							pTool.setText("- region tiles:", region.tiles.Count, 0f, pShowBar: false, 0L);
							pTool.setText("- region neigbours:", region.neighbours.Count, 0f, pShowBar: false, 0L);
							pTool.setText("- created:", region.created, 0f, pShowBar: false, 0L);
							pTool.setText("- island:", region.island == null, 0f, pShowBar: false, 0L);
							pTool.setText("- getEdgeRegions:", region.getEdgeRegions().Count, 0f, pShowBar: false, 0L);
							pTool.setText("- island connections:", region.island.getConnectedIslands().Count, 0f, pShowBar: false, 0L);
							pTool.setText("- debug_connections_left:", region.debug_blink_edges_left?.Count, 0f, pShowBar: false, 0L);
							pTool.setText("- debug_connections_right:", region.debug_blink_edges_right?.Count, 0f, pShowBar: false, 0L);
							pTool.setText("- debug_connections_up:", region.debug_blink_edges_up?.Count, 0f, pShowBar: false, 0L);
							pTool.setText("- debug_connections_down:", region.debug_blink_edges_down?.Count, 0f, pShowBar: false, 0L);
							mouseTilePos5.region.debugLinks(pTool);
						}
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Zone Info",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.zone_calculator.debug(pTool);
				WorldTile mouseTilePos3 = World.world.getMouseTilePos();
				if (mouseTilePos3 != null)
				{
					_ = mouseTilePos3.chunk;
					pTool.setText("visible:", mouseTilePos3.zone.visible, 0f, pShowBar: false, 0L);
					pTool.setText("buildings:", mouseTilePos3.zone.getHashset(BuildingList.Civs)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("types:", mouseTilePos3.zone.countNotNullTypes(), 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("id:", mouseTilePos3.zone.id, 0f, pShowBar: false, 0L);
					pTool.setText("pos:", "x: " + mouseTilePos3.zone.x + ", y: " + mouseTilePos3.zone.y, 0f, pShowBar: false, 0L);
					pTool.setText("city:", mouseTilePos3.zone.hasCity(), 0f, pShowBar: false, 0L);
					pTool.setText("bushes:", mouseTilePos3.zone.getHashset(BuildingList.Food)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("hives:", mouseTilePos3.zone.getHashset(BuildingList.Hives)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("trees:", mouseTilePos3.zone.getHashset(BuildingList.Trees)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("poops:", mouseTilePos3.zone.getHashset(BuildingList.Poops)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("deposits:", mouseTilePos3.zone.getHashset(BuildingList.Minerals)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("flore:", mouseTilePos3.zone.getHashset(BuildingList.Flora)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("buildings:", mouseTilePos3.zone.getHashset(BuildingList.Civs)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("buildings all:", mouseTilePos3.zone.buildings_all.Count, 0f, pShowBar: false, 0L);
					pTool.setText("abandoned:", mouseTilePos3.zone.getHashset(BuildingList.Abandoned)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("ruins:", mouseTilePos3.zone.getHashset(BuildingList.Ruins)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("tilesWithGround:", mouseTilePos3.zone.tiles_with_ground, 0f, pShowBar: false, 0L);
					pTool.setText("count deep ocean:", mouseTilePos3.zone.getTilesOfType(TileLibrary.deep_ocean)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("count soil:", mouseTilePos3.zone.getTilesOfType(TileLibrary.soil_low)?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("count fuse:", mouseTilePos3.zone.getTilesOfType(TopTileLibrary.fuse)?.Count, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "map_chunks",
			action_1 = delegate(DebugTool pTool)
			{
				int num = World.world.map_chunk_manager.chunks.Length;
				if (num >= 1)
				{
					int num2 = int.MaxValue;
					int num3 = 0;
					int num4 = 0;
					int num5 = int.MaxValue;
					int num6 = 0;
					int num7 = 0;
					MapChunk[] chunks = World.world.map_chunk_manager.chunks;
					foreach (MapChunk mapChunk in chunks)
					{
						int count = mapChunk.objects.kingdoms.Count;
						if (count < num2)
						{
							num2 = count;
						}
						if (count > num3)
						{
							num3 = count;
						}
						num4 += count;
						foreach (List<Actor> debugUnit in mapChunk.objects.getDebugUnits())
						{
							int count2 = debugUnit.Count;
							if (count2 < num5)
							{
								num5 = count2;
							}
							if (count2 > num6)
							{
								num6 = count2;
							}
							num7 += count2;
						}
						foreach (List<Building> debugBuilding in mapChunk.objects.getDebugBuildings())
						{
							int count3 = debugBuilding.Count;
							if (count3 < num5)
							{
								num5 = count3;
							}
							if (count3 > num6)
							{
								num6 = count3;
							}
							num7 += count3;
						}
					}
					pTool.setText("batches:", DebugConfig.isOn(DebugOption.ChunkBatches), 0f, pShowBar: false, 0L);
					pTool.setText("debug_batch_size:", ParallelHelper.DEBUG_BATCH_SIZE, 0f, pShowBar: false, 0L);
					pTool.setText("chunks:", num, 0f, pShowBar: false, 0L);
					pTool.setText("objects:", num4, 0f, pShowBar: false, 0L);
					pTool.setText("objects min:", num2, 0f, pShowBar: false, 0L);
					pTool.setText("objects max:", num3, 0f, pShowBar: false, 0L);
					pTool.setText("objects avg:", num4 / num, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("kingdom objects:", num7, 0f, pShowBar: false, 0L);
					pTool.setText("kingdom objects min:", num5, 0f, pShowBar: false, 0L);
					pTool.setText("kingdom objects max:", num6, 0f, pShowBar: false, 0L);
					pTool.setText("kingdom objects avg:", num7 / num, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Map Chunk",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos2 = World.world.getMouseTilePos();
				if (mouseTilePos2 != null)
				{
					MapChunk chunk = mouseTilePos2.chunk;
					pTool.setText("chunk_id:", chunk.id, 0f, pShowBar: false, 0L);
					pTool.setText("chunk_x/y:", chunk.x + "/" + chunk.y, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("kingdoms:", chunk.objects.kingdoms.Count, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setSeparator();
					pTool.setText("total_units:", chunk.objects.total_units, 0f, pShowBar: false, 0L);
					pTool.setText("total_buildings:", chunk.objects.total_buildings, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("total:", chunk.objects.total_units + chunk.objects.total_buildings, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Island Info",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null && mouseTilePos.region != null)
				{
					TileIsland island = mouseTilePos.region.island;
					if (island != null)
					{
						pTool.setText("islands:", World.world.islands_calculator.islands.Count, 0f, pShowBar: false, 0L);
						pTool.setText("regions:", island.regions.Count, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("id:", island.id, 0f, pShowBar: false, 0L);
						pTool.setText("hash:", island.debug_hash_code, 0f, pShowBar: false, 0L);
						pTool.setText("tiles:", island.getTileCount(), 0f, pShowBar: false, 0L);
						pTool.setText("unit limit:", island.regions.Count * 4, 0f, pShowBar: false, 0L);
						pTool.setText("created:", island.created, 0f, pShowBar: false, 0L);
						pTool.setText("type:", island.type, 0f, pShowBar: false, 0L);
						pTool.setText("docks:", island.docks?.Count, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Tilemap Renderer",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.tilemap.debug(pTool);
			}
		});
	}

	private void initSubSystems()
	{
		add(new DebugToolAsset
		{
			id = "boat",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					Actor actor = null;
					int num2 = int.MaxValue;
					foreach (Actor unit in World.world.units)
					{
						int num3 = Toolbox.SquaredDistTile(unit.current_tile, mouseTilePos);
						if (unit.asset.is_boat && num3 < num2)
						{
							actor = unit;
							num2 = num3;
						}
					}
					if (actor != null)
					{
						Boat simpleComponent = actor.getSimpleComponent<Boat>();
						pTool.setSeparator();
						pTool.setText("units:", simpleComponent.countPassengers(), 0f, pShowBar: false, 0L);
						pTool.setText("passengerWaitCounter:", simpleComponent.passengerWaitCounter, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "taxi",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("requests:", TaxiManager.list.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				TaxiManager.list.Sort((TaxiRequest a, TaxiRequest b) => b.countActors().CompareTo(a.countActors()));
				TaxiManager.list.ForEach(delegate(TaxiRequest tRequest)
				{
					int num = 0;
					if (tRequest.hasAssignedBoat())
					{
						num = tRequest.getBoat().countPassengers();
					}
					pTool.setText("state", tRequest.state.ToString() + " " + num + "/" + tRequest.countActors() + " | " + tRequest.hasAssignedBoat(), 0f, pShowBar: false, 0L);
				});
			}
		});
	}

	private void initGameplay()
	{
		add(new DebugToolAsset
		{
			id = "World Laws",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (WorldLawAsset item in AssetManager.world_laws_library.list)
				{
					pTool.setText(item.id, item.isEnabled() + " : " + item.isEnabledRaw(), 0f, pShowBar: false, 0L);
				}
				pTool.setSeparator();
			}
		});
		add(new DebugToolAsset
		{
			id = "Building Manager",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("buildings:", World.world.buildings.Count, 0f, pShowBar: false, 0L);
				int num11 = 0;
				int num12 = 0;
				int num13 = 0;
				foreach (Building building4 in World.world.buildings)
				{
					if (building4.is_visible)
					{
						num11++;
					}
					if (building4.scale_helper.active)
					{
						num13++;
					}
				}
				pTool.setText("visible:", num11 + "/" + World.world.buildings.Count, 0f, pShowBar: false, 0L);
				pTool.setText("tweens:", num12 + "/" + World.world.buildings.Count, 0f, pShowBar: false, 0L);
				pTool.setText("tween_active:", num13 + "/" + World.world.buildings.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
			}
		});
		add(new DebugToolAsset
		{
			id = "Cultures",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("cultures:", World.world.cultures.Count, 0f, pShowBar: false, 0L);
				foreach (Culture culture in World.world.cultures)
				{
					culture.debug(pTool);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Tile Types",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("tumor_low", TopTileLibrary.tumor_low.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("tumor_high", TopTileLibrary.tumor_high.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("biomass_low", TopTileLibrary.biomass_low.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("biomass_high", TopTileLibrary.biomass_high.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("pumpkin_low", TopTileLibrary.pumpkin_low.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("pumpkin_high", TopTileLibrary.pumpkin_high.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("cybertile_low", TopTileLibrary.cybertile_low.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("cybertile_high", TopTileLibrary.cybertile_high.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("deep_ocean", TileLibrary.deep_ocean.hashset.Count, 0f, pShowBar: false, 0L);
				pTool.setText("pit_deep_ocean", TileLibrary.pit_deep_ocean.hashset.Count, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Jobs Buildings",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.buildings.debugJobManager(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Jobs Actors",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.units.debugJobManager(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Building Info",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos4 = World.world.getMouseTilePos();
				if (mouseTilePos4 != null)
				{
					Building building3 = mouseTilePos4.building;
					if (building3 != null)
					{
						if (building3.asset.docks)
						{
							pTool.setText("boats_fishing:", building3.component_docks.countBoatTypes("boat_type_fishing"), 0f, pShowBar: false, 0L);
							pTool.setText("boats_transport:", building3.component_docks.countBoatTypes("boat_type_transport"), 0f, pShowBar: false, 0L);
							pTool.setText("boats_trading:", building3.component_docks.countBoatTypes("boat_type_trading"), 0f, pShowBar: false, 0L);
						}
						pTool.setText("id:", building3.data.id, 0f, pShowBar: false, 0L);
						pTool.setText("hash:", building3.GetHashCode(), 0f, pShowBar: false, 0L);
						pTool.setText("animData_index:", building3.animData_index, 0f, pShowBar: false, 0L);
						pTool.setText("residents:", building3.countResidents() + "/" + building3.asset.housing_slots, 0f, pShowBar: false, 0L);
						pTool.setText("kingdom:", building3.kingdom.id, 0f, pShowBar: false, 0L);
						pTool.setText("kingdom civ:", building3.isKingdomCiv(), 0f, pShowBar: false, 0L);
						pTool.setText("animationState:", building3.animation_state, 0f, pShowBar: false, 0L);
						pTool.setText("ownership:", building3.state_ownership, 0f, pShowBar: false, 0L);
						pTool.setText("state:", building3.data.state, 0f, pShowBar: false, 0L);
						pTool.setText("template:", building3.data.asset_id, 0f, pShowBar: false, 0L);
						pTool.setText("health:", building3.getHealth(), 0f, pShowBar: false, 0L);
						pTool.setText("health cur:", building3.getMaxHealth(), 0f, pShowBar: false, 0L);
						if (building3.hasKingdom())
						{
							pTool.setText("kingdom:", building3.kingdom.name, 0f, pShowBar: false, 0L);
						}
						pTool.setSeparator();
						pTool.setText("tiles:", building3.tiles.Count, 0f, pShowBar: false, 0L);
						pTool.setText("zones:", building3.zones.Count, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("alive:", building3.isAlive(), 0f, pShowBar: false, 0L);
						pTool.setText("usable:", building3.isUsable(), 0f, pShowBar: false, 0L);
						pTool.setText("under construction:", building3.isUnderConstruction(), 0f, pShowBar: false, 0L);
						pTool.setText("progress:", building3.getConstructionProgress(), 0f, pShowBar: false, 0L);
						if (building3.city != null)
						{
							pTool.setText("city:", building3.city.name, 0f, pShowBar: false, 0L);
						}
						pTool.setSeparator();
						pTool.setText("tween_active:", building3.scale_helper.active, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("state:", building3.animation_state, 0f, pShowBar: false, 0L);
						pTool.setText("has_resources:", building3.hasResourcesToCollect(), 0f, pShowBar: false, 0L);
						pTool.setText("is_visible:", building3.is_visible, 0f, pShowBar: false, 0L);
						pTool.setText("scale_start:", building3.scale_helper.scale_start, 0f, pShowBar: false, 0L);
						pTool.setText("currentScale.y:", building3.current_scale.y, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("flip.x:", building3.flip_x, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Debug Buildings Render",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos3 = World.world.getMouseTilePos();
				if (mouseTilePos3 != null)
				{
					Building building = mouseTilePos3.building;
					if (building != null)
					{
						pTool.setText("flip.x:", building.flip_x, 0f, pShowBar: false, 0L);
						if (building.is_visible && !World.world.quality_changer.isLowRes())
						{
							int num7 = World.world.buildings.countVisibleBuildings();
							int num8 = 0;
							int num9 = 0;
							int num10 = 0;
							Building[] visibleBuildings = World.world.buildings.getVisibleBuildings();
							HashSet<Building> hashSet = UnsafeCollectionPool<HashSet<Building>, Building>.Get();
							for (int i = 0; i < num7; i++)
							{
								Building building2 = visibleBuildings[i];
								if (building2 != null)
								{
									if (building2 == building)
									{
										num8 = i;
										pTool.setText("visible id:", i + "/" + visibleBuildings.Length, 0f, pShowBar: false, 0L);
									}
									hashSet.Add(building2);
									if (building2.isAlive())
									{
										num9++;
									}
									else
									{
										num10++;
									}
								}
							}
							pTool.setText("alive:", num9 + "/" + visibleBuildings.Length, 0f, pShowBar: false, 0L);
							pTool.setText("dead:", num10 + "/" + visibleBuildings.Length, 0f, pShowBar: false, 0L);
							pTool.setText("_visible_buildings_count:", num7, 0f, pShowBar: false, 0L);
							pTool.setText("tUniqueBuildings:", hashSet.Count, 0f, pShowBar: false, 0L);
							UnsafeCollectionPool<HashSet<Building>, Building>.Release(hashSet);
							BuildingRenderData render_data = World.world.buildings.render_data;
							pTool.setText("render_data_flip:", render_data.flip_x_states[num8].ToString(), 0f, pShowBar: false, 0L);
							QuantumSpriteAsset quantumSpriteAsset = AssetManager.quantum_sprites.get("draw_buildings");
							QuantumSpriteCacheData cacheData = quantumSpriteAsset.group_system.getCacheData(num7);
							if (cacheData != null)
							{
								if (cacheData.flip_x_states.Length <= num8)
								{
									return;
								}
								pTool.setText("render_data_flip:", cacheData.flip_x_states[num8].ToString(), 0f, pShowBar: false, 0L);
							}
							QuantumSprite[] fastActiveList = quantumSpriteAsset.group_system.getFastActiveList(num7);
							if (fastActiveList.Length > num8)
							{
								pTool.setText("q flip x:", fastActiveList[num8].sprite_renderer.flipX.ToString(), 0f, pShowBar: false, 0L);
							}
						}
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Actor Statistics",
			action_1 = delegate(DebugTool pTool)
			{
				Actor actorNearCursor2 = World.world.getActorNearCursor();
				if (actorNearCursor2 != null)
				{
					pTool.setText("getSecondsLife:", StatTool.getStringSecondsLife(actorNearCursor2), 0f, pShowBar: false, 0L);
					pTool.setText("getAmountBreeding:", StatTool.getStringAmountBreeding(actorNearCursor2), 0f, pShowBar: false, 0L);
					pTool.setText("getAmountFood:", StatTool.getAmountFood(actorNearCursor2), 0f, pShowBar: false, 0L);
					pTool.setText("getDPS:", StatTool.getDPS(actorNearCursor2), 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Biome Adaptation",
			action_1 = delegate(DebugTool pTool)
			{
				Actor unit = SelectedUnit.unit;
				if (unit != null && unit.hasSubspecies())
				{
					WorldTile mouseTilePos2 = World.world.getMouseTilePos();
					if (mouseTilePos2 != null)
					{
						mouseTilePos2.zone.checkCanSettleInThisBiomes(unit.subspecies);
						pTool.setText("adapted:", TileZone.debug_adapted, 0f, pShowBar: false, 0L);
						pTool.setText("not_adapted:", TileZone.debug_not_adapted, 0f, pShowBar: false, 0L);
						pTool.setText("soil:", TileZone.debug_soil, 0f, pShowBar: false, 0L);
						pTool.setText("can_settle:", TileZone.debug_can_settle, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Kingdoms Wild",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("#wild_kingdoms:", World.world.kingdoms_wild.Count, 0f, pShowBar: false, 0L);
				foreach (Kingdom item2 in World.world.kingdoms_wild)
				{
					if (item2.hasUnits() || item2.hasBuildings())
					{
						pTool.setText(item2.name, item2.units.Count + " " + item2.buildings.Count, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Buildings Check",
			action_1 = delegate(DebugTool pTool)
			{
				int num5 = 0;
				int num6 = 0;
				foreach (Building building5 in World.world.buildings)
				{
					if (building5.getHealth() <= building5.getMaxHealth())
					{
						num5++;
					}
					else
					{
						num6++;
					}
				}
				pTool.setText("within max health:", num5, 0f, pShowBar: false, 0L);
				pTool.setText("higher than max health:", num6, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				foreach (Kingdom kingdom in World.world.kingdoms)
				{
					bool flag = kingdom.buildings.Count == kingdom.countBuildings();
					pTool.setText(kingdom.name, flag + " | " + kingdom.buildings.Count + " " + kingdom.countBuildings(), 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Kingdoms Civ",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("#kingdoms:", World.world.kingdoms.Count, 0f, pShowBar: false, 0L);
				pTool.setText("- units total:", World.world.units.Count, 0f, pShowBar: false, 0L);
				int num4 = 0;
				foreach (Actor unit2 in World.world.units)
				{
					if (unit2.kingdom == null)
					{
						num4++;
					}
				}
				pTool.setText("- units no kingdom:", num4, 0f, pShowBar: false, 0L);
				List<Kingdom> obj = new List<Kingdom>(World.world.kingdoms);
				obj.Sort(pTool.kingdomSorter);
				foreach (Kingdom item3 in obj)
				{
					if (pTool.textCount > 0)
					{
						pTool.setSeparator();
					}
					pTool.setText("#id", item3.id, 0f, pShowBar: false, 0L);
					pTool.setText("#name", item3.name, 0f, pShowBar: false, 0L);
					pTool.setText("age", item3.getAge(), 0f, pShowBar: false, 0L);
					pTool.setText("units", item3.units.Count, 0f, pShowBar: false, 0L);
					pTool.setText("army", item3.countTotalWarriors() + "/" + item3.countWarriorsMax(), 0f, pShowBar: false, 0L);
					pTool.setText("buildings", item3.buildings.Count, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Behaviours",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.drop_manager.debug(pTool);
				pTool.setText("dirty last:", World.world.dirty_tiles_last, 0f, pShowBar: false, 0L);
				pTool.setText("dirty tiles:", World.world.tiles_dirty.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("tiles:", World.world.tiles_list.Length, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("water:", WorldBehaviourOcean.tiles.Count, 0f, pShowBar: false, 0L);
				pTool.setText("burned_tiles:", WorldBehaviourActionBurnedTiles.countBurnedTiles(), 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("grey goo:", World.world.grey_goo_layer.hashset?.Count, 0f, pShowBar: false, 0L);
				pTool.setText("conway", World.world.conway_layer.hashsetTiles?.Count, 0f, pShowBar: false, 0L);
				pTool.setText("flash effect:", World.world.flash_effects.pixels_to_update.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("explosion layer:", World.world.explosion_layer.hashsetTiles?.Count, 0f, pShowBar: false, 0L);
				pTool.setText("bombDict:", World.world.explosion_layer.hashset_bombs.Count, 0f, pShowBar: false, 0L);
				pTool.setText("nextWave:", World.world.explosion_layer.nextWave.Count, 0f, pShowBar: false, 0L);
				pTool.setText("delayedBombs:", World.world.explosion_layer.nextWave.Count, 0f, pShowBar: false, 0L);
				pTool.setText("timedBombs:", World.world.explosion_layer.timedBombs.Count, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Unit Info",
			action_1 = delegate(DebugTool pTool)
			{
				Actor actorNearCursor = World.world.getActorNearCursor();
				if (actorNearCursor != null)
				{
					if (actorNearCursor.hasAnyStatusEffect())
					{
						pTool.setText("status effects", actorNearCursor.countStatusEffects(), 0f, pShowBar: false, 0L);
					}
					pTool.setText("profession:", actorNearCursor.getProfession(), 0f, pShowBar: false, 0L);
					if (actorNearCursor.ai.job != null)
					{
						pTool.setText("current_job:", actorNearCursor.ai.job.id, 0f, pShowBar: false, 0L);
					}
					else
					{
						pTool.setText("job:", "-", 0f, pShowBar: false, 0L);
					}
					pTool.setText("id:", actorNearCursor.data.id, 0f, pShowBar: false, 0L);
					if (actorNearCursor.hasTask())
					{
						pTool.setText("task:", actorNearCursor.ai.task.id, 0f, pShowBar: false, 0L);
					}
					else
					{
						pTool.setText("task:", "-", 0f, pShowBar: false, 0L);
					}
					pTool.setSeparator();
					pTool.setText("name:", actorNearCursor.getName(), 0f, pShowBar: false, 0L);
					pTool.setText("is_moving:", actorNearCursor.is_moving, 0f, pShowBar: false, 0L);
					pTool.setText("next_step:", actorNearCursor.next_step_position.x, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("stayingInBuilding:", actorNearCursor.inside_building != null, 0f, pShowBar: false, 0L);
					pTool.setText("bag.hasResources:", actorNearCursor.isCarryingResources(), 0f, pShowBar: false, 0L);
					pTool.setText("ignore:", actorNearCursor.countTargetsToIgnore(), 0f, pShowBar: false, 0L);
					pTool.setText("path global:", actorNearCursor.current_path_global?.Count, 0f, pShowBar: false, 0L);
					pTool.setText("path local:", actorNearCursor.current_path.Count, 0f, pShowBar: false, 0L);
					pTool.setText("path local index:", actorNearCursor.current_path_index, 0f, pShowBar: false, 0L);
					pTool.setText("path split status:", actorNearCursor.split_path.ToString(), 0f, pShowBar: false, 0L);
					pTool.setText("health:", actorNearCursor.getHealth() + "/" + actorNearCursor.getMaxHealth(), 0f, pShowBar: false, 0L);
					pTool.setText("damage:", actorNearCursor.asset.base_stats["damage"] + "/" + actorNearCursor.stats["damage"], 0f, pShowBar: false, 0L);
					pTool.setText("city:", (actorNearCursor.city == null) ? "-" : actorNearCursor.city.name, 0f, pShowBar: false, 0L);
					pTool.setText("kingdom:", (actorNearCursor.kingdom == null) ? "-" : actorNearCursor.kingdom.name, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("nutrition:", actorNearCursor.getNutrition() + "/" + actorNearCursor.getMaxNutrition(), 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					if (actorNearCursor.animation_container != null)
					{
						pTool.setText("actorAnimationData:", actorNearCursor.animation_container.id, 0f, pShowBar: false, 0L);
					}
					pTool.setText("stats name:", actorNearCursor.asset.id, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("timer_action:", actorNearCursor.timer_action, 0f, pShowBar: false, 0L);
					pTool.setText("_timeout_targets:", actorNearCursor._timeout_targets, 0f, pShowBar: false, 0L);
					pTool.setText("unitAttackTarget:", actorNearCursor.has_attack_target ? (actorNearCursor.isEnemyTargetAlive().ToString() ?? "") : "-", 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("attackTimer:", actorNearCursor.attack_timer, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setSeparator();
					pTool.setText("moveJumpOffset:", actorNearCursor.move_jump_offset.y, 0f, pShowBar: false, 0L);
					pTool.setText("alive:", actorNearCursor.isAlive(), 0f, pShowBar: false, 0L);
					pTool.setText("zPosition:", actorNearCursor.position_height, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("phenotype_index:", actorNearCursor.data.phenotype_index, 0f, pShowBar: false, 0L);
					pTool.setText("shade_id:", actorNearCursor.data.phenotype_shade, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Actor Stats",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					int num2 = int.MaxValue;
					Actor actor = null;
					foreach (Actor unit3 in World.world.units)
					{
						int num3 = Toolbox.SquaredDistTile(unit3.current_tile, mouseTilePos);
						if (num3 < num2)
						{
							actor = unit3;
							num2 = num3;
						}
					}
					if (actor != null)
					{
						pTool.setText("name:", actor.getName(), 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						List<BaseStatsContainer> list = actor.stats.getList();
						foreach (BaseStatsContainer item4 in list)
						{
							pTool.setText(item4.id, actor.stats[item4.id], 0f, pShowBar: false, 0L);
						}
						if (list.Count > 0)
						{
							pTool.setSeparator();
						}
						Dictionary<string, string> dictionary = actor.data.debug();
						foreach (string key in dictionary.Keys)
						{
							pTool.setText(key, dictionary[key], 0f, pShowBar: false, 0L);
						}
						if (dictionary.Count > 0)
						{
							pTool.setSeparator();
						}
						pTool.setText("currentTile:", (actor.current_tile == null) ? "-" : (actor.current_tile?.ToString() ?? ""), 0f, pShowBar: false, 0L);
						if (actor.current_tile != null)
						{
							pTool.setText("x / y", actor.current_tile.x + " " + actor.current_tile.y, 0f, pShowBar: false, 0L);
							pTool.setText("id", actor.current_tile.data.tile_id, 0f, pShowBar: false, 0L);
							pTool.setText("height", actor.current_tile.data.height, 0f, pShowBar: false, 0L);
							pTool.setText("type", actor.current_tile.Type.id, 0f, pShowBar: false, 0L);
							pTool.setText("layer", actor.current_tile.Type.layer_type, 0f, pShowBar: false, 0L);
							pTool.setText("main type", (actor.current_tile.main_type != null) ? actor.current_tile.main_type.id : "-", 0f, pShowBar: false, 0L);
							pTool.setText("top type", (actor.current_tile.top_type != null) ? actor.current_tile.top_type.id : "-", 0f, pShowBar: false, 0L);
							pTool.setText("targetedBy", actor.current_tile.isTargeted(), 0f, pShowBar: false, 0L);
							pTool.setText("units", actor.current_tile.countUnits(), 0f, pShowBar: false, 0L);
							pTool.setSeparator();
						}
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Unit Temperature",
			action_1 = delegate(DebugTool pTool)
			{
				WorldBehaviourUnitTemperatures.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Zoom",
			action_1 = delegate(DebugTool pTool)
			{
				World.world.quality_changer.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Mouse Cursor",
			action_1 = delegate(DebugTool pTool)
			{
				MouseCursor.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Selected Power",
			action_1 = delegate(DebugTool pTool)
			{
				if (!World.world.isAnyPowerSelected())
				{
					pTool.setText("no power selected", "", 0f, pShowBar: false, 0L);
				}
				else
				{
					pTool.setText("selectedPower:", World.world.getSelectedPowerID(), 0f, pShowBar: false, 0L);
					GodPower selectedPowerAsset = World.world.getSelectedPowerAsset();
					pTool.setText("type:", selectedPowerAsset.type, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("show_tool_sizes:", selectedPowerAsset.show_tool_sizes, 0f, pShowBar: false, 0L);
					pTool.setText("unselect_when_window:", selectedPowerAsset.unselect_when_window, 0f, pShowBar: false, 0L);
					pTool.setText("ignore_cursor_icon:", selectedPowerAsset.ignore_cursor_icon, 0f, pShowBar: false, 0L);
					pTool.setText("hold_action:", selectedPowerAsset.hold_action, 0f, pShowBar: false, 0L);
					pTool.setText("click_interval:", selectedPowerAsset.click_interval, 0f, pShowBar: false, 0L);
					pTool.setText("particle_interval:", selectedPowerAsset.particle_interval, 0f, pShowBar: false, 0L);
					pTool.setText("falling_chance:", selectedPowerAsset.falling_chance, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("click_brush_action:", selectedPowerAsset.click_brush_action, 0f, pShowBar: false, 0L);
					pTool.setText("click_action:", selectedPowerAsset.click_action, 0f, pShowBar: false, 0L);
					pTool.setText("click_special_action:", selectedPowerAsset.click_special_action, 0f, pShowBar: false, 0L);
					pTool.setText("click_power_brush_action:", selectedPowerAsset.click_power_brush_action, 0f, pShowBar: false, 0L);
					pTool.setText("click_power_action:", selectedPowerAsset.click_power_action, 0f, pShowBar: false, 0L);
					pTool.setText("select_button_action:", selectedPowerAsset.select_button_action, 0f, pShowBar: false, 0L);
					pTool.setText("toggle_action:", selectedPowerAsset.toggle_action, 0f, pShowBar: false, 0L);
					pTool.setSeparator();
					pTool.setText("actor_asset_id:", selectedPowerAsset.actor_asset_id, 0f, pShowBar: false, 0L);
					pTool.setText("actor_asset_ids:", selectedPowerAsset.actor_asset_ids, 0f, pShowBar: false, 0L);
					pTool.setText("toggle_name:", selectedPowerAsset.toggle_name, 0f, pShowBar: false, 0L);
					pTool.setText("map_modes_switch:", selectedPowerAsset.map_modes_switch, 0f, pShowBar: false, 0L);
					pTool.setText("show_spawn_effect:", selectedPowerAsset.show_spawn_effect, 0f, pShowBar: false, 0L);
					pTool.setText("activate_on_hotkey_select:", selectedPowerAsset.activate_on_hotkey_select, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Hotkeys",
			action_1 = delegate(DebugTool pTool)
			{
				AssetManager.hotkey_library.debug(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Armies",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("groups:", World.world.armies.Count, 0f, pShowBar: false, 0L);
				foreach (Army army in World.world.armies)
				{
					pTool.setText(": " + army.id, army.getDebug(), 0f, pShowBar: false, 0L);
				}
				pTool.setSeparator();
			}
		});
		add(new DebugToolAsset
		{
			id = "Magnet Debug",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("hasUnits():", World.world.magnet.hasUnits(), 0f, pShowBar: false, 0L);
				pTool.setText("countUnits():", World.world.magnet.countUnits(), 0f, pShowBar: false, 0L);
				pTool.setText("magnetUnits.Count:", World.world.magnet.magnet_units.Count, 0f, pShowBar: false, 0L);
				int num = 0;
				foreach (Actor unit4 in World.world.units)
				{
					if (unit4.isAlive() && unit4.is_in_magnet)
					{
						num++;
					}
				}
				pTool.setText("tUnitsWithMagnetStatus:", num, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Mindmap Debug",
			action_1 = NeuronsOverview.debugTool
		});
	}

	private void initMain()
	{
		add(new DebugToolAsset
		{
			id = "Game Info",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("selected_unit?:", SelectedUnit.isSet(), 0f, pShowBar: false, 0L);
				pTool.setText("selected_unit_name:", SelectedUnit.isSet() ? SelectedUnit.unit.getName() : "-", 0f, pShowBar: false, 0L);
				pTool.setText("elapsed:", World.world.elapsed, 0f, pShowBar: false, 0L);
				pTool.setText("delta time:", World.world.delta_time, 0f, pShowBar: false, 0L);
				pTool.setText("actor0:", Bench.getBenchResult("actor0"), 0f, pShowBar: false, 0L);
				pTool.setText("actor1:", Bench.getBenchResult("actor1"), 0f, pShowBar: false, 0L);
				pTool.setText("actor2:", Bench.getBenchResult("actor2"), 0f, pShowBar: false, 0L);
				pTool.setText("actor_total:", Bench.getBenchResult("actor_total"), 0f, pShowBar: false, 0L);
				pTool.setText("test_follow:", Bench.getBenchResult("test_follow"), 0f, pShowBar: false, 0L);
				pTool.setText("rightClickTimer:", World.world.player_control.inspect_timer_click, 0f, pShowBar: false, 0L);
				pTool.setText("cache g paths:", World.world.region_path_finder.debug(), 0f, pShowBar: false, 0L);
				pTool.setText("units:", World.world.units.debugContainer(), 0f, pShowBar: false, 0L);
				pTool.setText("buildings:", World.world.buildings.debugContainer(), 0f, pShowBar: false, 0L);
				pTool.setText("cities:", World.world.cities.Count, 0f, pShowBar: false, 0L);
				pTool.setText("civ kingdoms:", World.world.kingdoms.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("(d)gameTime:", World.world.game_stats.data.gameTime, 0f, pShowBar: false, 0L);
				pTool.setText("(f)gameTime:", (float)World.world.game_stats.data.gameTime, 0f, pShowBar: false, 0L);
				World.world.map_stats.debug(pTool);
				pTool.setText("gameLaunches:", World.world.game_stats.data.gameLaunches, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("size tiles:", World.world.tiles_map.Length, 0f, pShowBar: false, 0L);
				pTool.setText("chunks:", World.world.map_chunk_manager.chunks.Length, 0f, pShowBar: false, 0L);
				pTool.setText("- regions:", World.world.map_chunk_manager.countRegions(), 0f, pShowBar: false, 0L);
				pTool.setText("- hashes:", RegionLinkHashes.getCount(), 0f, pShowBar: false, 0L);
				pTool.setText("- islands:", World.world.islands_calculator.islands.Count, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				int count = World.world.units.visible_units.count;
				int num27 = 0;
				foreach (Building building in World.world.buildings)
				{
					if (building.is_visible)
					{
						num27++;
					}
				}
				pTool.setSeparator();
				pTool.setText("visible buildings:", num27 + "/" + World.world.buildings.Count, 0f, pShowBar: false, 0L);
				pTool.setText("visible buildings:", World.world.buildings.countVisibleBuildings() + "/" + World.world.buildings.getVisibleBuildings().Length, 0f, pShowBar: false, 0L);
				pTool.setText("visible actors:", count + "/" + World.world.units.Count, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Basic Info",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
				//IL_0155: Unknown result type (might be due to invalid IL or missing references)
				//IL_015a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0241: Unknown result type (might be due to invalid IL or missing references)
				//IL_0265: Unknown result type (might be due to invalid IL or missing references)
				pTool.setText("Game Version:", Application.version, 0f, pShowBar: false, 0L);
				pTool.setText("Version Code:", Config.versionCodeText, 0f, pShowBar: false, 0L);
				pTool.setText("Git:", Config.gitCodeText, 0f, pShowBar: false, 0L);
				pTool.setText("Modded:", Config.MODDED, 0f, pShowBar: false, 0L);
				pTool.setText("operatingSystemFamily:", SystemInfo.operatingSystemFamily, 0f, pShowBar: false, 0L);
				pTool.setText("deviceModel:", SystemInfo.deviceModel, 0f, pShowBar: false, 0L);
				pTool.setText("deviceName:", SystemInfo.deviceName, 0f, pShowBar: false, 0L);
				pTool.setText("deviceType:", SystemInfo.deviceType, 0f, pShowBar: false, 0L);
				pTool.setText("systemMemorySize:", SystemInfo.systemMemorySize, 0f, pShowBar: false, 0L);
				pTool.setText("graphicsDeviceID:", SystemInfo.graphicsDeviceID, 0f, pShowBar: false, 0L);
				GraphicsTier activeTier = Graphics.activeTier;
				pTool.setText("graphicsActiveTier:", ((object)(GraphicsTier)(ref activeTier)).ToString(), 0f, pShowBar: false, 0L);
				pTool.setText("GC.GetTotalMemory:", GC.GetTotalMemory(forceFullCollection: false) / 1000000 + " mb", 0f, pShowBar: false, 0L);
				pTool.setText("graphicsMemorySize:", SystemInfo.graphicsMemorySize, 0f, pShowBar: false, 0L);
				pTool.setText("maxTextureSize:", SystemInfo.maxTextureSize, 0f, pShowBar: false, 0L);
				pTool.setText("operatingSystem:", SystemInfo.operatingSystem, 0f, pShowBar: false, 0L);
				pTool.setText("processorType:", SystemInfo.processorType, 0f, pShowBar: false, 0L);
				pTool.setText("installMode:", Application.installMode, 0f, pShowBar: false, 0L);
				pTool.setText("sandboxType:", Application.sandboxType, 0f, pShowBar: false, 0L);
				pTool.setText("FPS:", FPS.getFPS(), 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "sprite_atlas_manager",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					int num25 = int.MaxValue;
					Actor actor = null;
					foreach (Actor unit in World.world.units)
					{
						int num26 = Toolbox.SquaredDistTile(unit.current_tile, mouseTilePos);
						if (num26 < num25)
						{
							actor = unit;
							num25 = num26;
						}
					}
					if (actor != null)
					{
						AssetManager.dynamic_sprites_library.debug(pTool, actor);
						pTool.setSeparator();
						pTool.setText("sex:", actor.data.sex, 0f, pShowBar: false, 0L);
						pTool.setText("head:", actor.has_rendered_sprite_head ? ((Object)actor.cached_sprite_head).name : "-", 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Subspecies",
			action_1 = delegate(DebugTool pTool)
			{
				using ListPool<Subspecies> listPool = new ListPool<Subspecies>(World.world.subspecies.list);
				listPool.Sort((Subspecies a, Subspecies b) => b.units.Count.CompareTo(a.units.Count));
				foreach (ref Subspecies item4 in listPool)
				{
					Subspecies current20 = item4;
					pTool.setText("[" + current20.getActorAsset().id + "] " + current20.name + ": ", current20.units.Count, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Items",
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("total: ", World.world.items.Count, 0f, pShowBar: false, 0L);
				int num13 = 0;
				int num14 = 0;
				int num15 = 0;
				int num16 = 0;
				int num17 = 0;
				int num18 = 0;
				int num19 = 0;
				int num20 = 0;
				int num21 = 0;
				int num22 = 0;
				int num23 = 0;
				int num24 = 0;
				foreach (Item item5 in World.world.items)
				{
					if (item5.unit_has_it)
					{
						num19++;
					}
					if (item5.city_has_it)
					{
						num20++;
					}
					if (item5.isRekt())
					{
						num13++;
					}
					else
					{
						num14++;
						if (item5.hasActor())
						{
							num15++;
							if (item5.getActor().isRekt())
							{
								num17++;
							}
							else if (item5.getActor().hasEquipment())
							{
								num21++;
								bool flag = false;
								foreach (Item item6 in item5.getActor().equipment.getItems())
								{
									if (item6 == item5)
									{
										flag = true;
										break;
									}
								}
								if (flag)
								{
									num23++;
								}
								else
								{
									num24++;
								}
							}
							else
							{
								num22++;
							}
						}
						if (item5.hasCity())
						{
							num16++;
							if (item5.getCity().isRekt())
							{
								num18++;
							}
						}
					}
				}
				pTool.setSeparator();
				pTool.setText("alive: ", num14, 0f, pShowBar: false, 0L);
				pTool.setText("dead: ", num13, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("has actor: ", num15, 0f, pShowBar: false, 0L);
				pTool.setText("has unit has it: ", num19, 0f, pShowBar: false, 0L);
				pTool.setText("has dead actor: ", num17, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("has city: ", num16, 0f, pShowBar: false, 0L);
				pTool.setText("has city has it: ", num20, 0f, pShowBar: false, 0L);
				pTool.setText("has dead city: ", num18, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("unit has equipment: ", num21, 0f, pShowBar: false, 0L);
				pTool.setText("unit w/o equipment: ", num22, 0f, pShowBar: false, 0L);
				pTool.setText("unit has item equipped: ", num23, 0f, pShowBar: false, 0L);
				pTool.setText("unit missing equipped item: ", num24, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Decisions Globals Use",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (KeyValuePair<string, int> item7 in UtilityBasedDecisionSystem.debug_counter)
				{
					pTool.setText(item7.Key, item7.Value, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Actor Decisions",
			action_1 = delegate(DebugTool pTool)
			{
				Actor actorNearCursor = World.world.getActorNearCursor();
				if (actorNearCursor != null)
				{
					if (_decision_system_debug == null)
					{
						_decision_system_debug = new UtilityBasedDecisionSystem();
					}
					_decision_system_debug.debug(actorNearCursor, pTool);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Items Errors",
			action_1 = delegate(DebugTool pTool)
			{
				Dictionary<Item, string> dictionary2 = new Dictionary<Item, string>();
				foreach (Item item8 in World.world.items)
				{
					dictionary2.Add(item8, "nobody");
				}
				Dictionary<Item, int> dictionary3 = new Dictionary<Item, int>();
				foreach (Actor unit2 in World.world.units)
				{
					if (unit2.hasEquipment())
					{
						foreach (ActorEquipmentSlot item9 in unit2.equipment)
						{
							if (!item9.isEmpty())
							{
								Item item3 = item9.getItem();
								dictionary2[item3] = "unit";
								if (!dictionary3.ContainsKey(item3))
								{
									dictionary3.Add(item3, 0);
								}
								dictionary3[item3]++;
							}
						}
					}
				}
				foreach (City city in World.world.cities)
				{
					foreach (List<long> allEquipmentList in city.data.equipment.getAllEquipmentLists())
					{
						foreach (long item10 in allEquipmentList)
						{
							Item key = World.world.items.get(item10);
							dictionary2[key] = "city";
							if (!dictionary3.ContainsKey(key))
							{
								dictionary3.Add(key, 0);
							}
							dictionary3[key]++;
						}
					}
				}
				foreach (KeyValuePair<Item, string> item11 in dictionary2)
				{
					if (item11.Value == "nobody")
					{
						Item key2 = item11.Key;
						pTool.setText(key2.id.ToString(), "nobody", 0f, pShowBar: false, 0L);
					}
				}
				foreach (KeyValuePair<Item, int> item12 in dictionary3)
				{
					if (item12.Value > 1)
					{
						pTool.setText(item12.Key.id.ToString(), item12.Value, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Items Duplicates",
			action_1 = delegate(DebugTool pTool)
			{
				Dictionary<Item, int> dictionary = new Dictionary<Item, int>();
				foreach (Actor unit3 in World.world.units)
				{
					if (unit3.hasEquipment())
					{
						foreach (ActorEquipmentSlot item13 in unit3.equipment)
						{
							if (item13.getItem() != null)
							{
								Item item = item13.getItem();
								if (!dictionary.ContainsKey(item))
								{
									dictionary.Add(item, 0);
								}
								dictionary[item]++;
							}
						}
					}
				}
				foreach (KeyValuePair<Item, int> item14 in dictionary)
				{
					if (item14.Value >= 2)
					{
						pTool.setText("Item " + (item14.Key.data?.id.ToString() ?? "(dead)") + " shared between units: ", item14.Value, 0f, pShowBar: false, 0L);
					}
				}
				dictionary.Clear();
				foreach (City city2 in World.world.cities)
				{
					foreach (List<long> allEquipmentList2 in city2.data.equipment.getAllEquipmentLists())
					{
						foreach (long item15 in allEquipmentList2)
						{
							Item item2 = World.world.items.get(item15);
							if (item2 != null)
							{
								if (!dictionary.ContainsKey(item2))
								{
									dictionary.Add(item2, 0);
								}
								dictionary[item2]++;
							}
						}
					}
				}
				foreach (KeyValuePair<Item, int> item16 in dictionary)
				{
					if (item16.Value >= 2)
					{
						pTool.setText("Item " + (item16.Key.data?.id.ToString() ?? "(dead)") + " shared between : ", item16.Value, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Items Ownership",
			action_1 = delegate(DebugTool pTool)
			{
				int num5 = 0;
				int num6 = 0;
				int num7 = 0;
				int num8 = 0;
				int num9 = 0;
				int num10 = 0;
				int num11 = 0;
				int num12 = 0;
				new Dictionary<Item, string>();
				foreach (Item item17 in World.world.items)
				{
					if (!item17.unit_has_it && !item17.city_has_it)
					{
						num10++;
						if (item17.isRekt())
						{
							num12++;
						}
						else
						{
							if (item17.isFavorite())
							{
								num5++;
							}
							if (item17.isEternal())
							{
								num7++;
							}
							if (item17.isFavorite() && item17.isEternal())
							{
								num9++;
							}
							else if (item17.isFavorite())
							{
								num6++;
							}
							else if (item17.isEternal())
							{
								num8++;
							}
							else
							{
								num11++;
							}
						}
					}
				}
				pTool.setText("total: ", World.world.items.Count, 0f, pShowBar: false, 0L);
				pTool.setText("total ownerless: ", num10, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless favorited: ", num5, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless favorited only: ", num6, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless eternal: ", num7, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless eternal only: ", num8, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless favorited eternal: ", num9, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless error: ", num11, 0f, pShowBar: false, 0L);
				pTool.setText("ownerless rekt: ", num12, 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "Families",
			action_1 = delegate(DebugTool pTool)
			{
				float num2 = 0f;
				float num3 = 0f;
				foreach (Actor item18 in World.world.units.units_only_alive)
				{
					if (item18.hasFamily())
					{
						num2 += 1f;
					}
					else
					{
						num3 += 1f;
					}
				}
				int num4 = 0;
				foreach (Family family in World.world.families)
				{
					if (family.units.Count == 1)
					{
						num4++;
					}
				}
				pTool.setText("total families", World.world.families.Count, 0f, pShowBar: false, 0L);
				pTool.setText("lonely families", num4, 0f, pShowBar: false, 0L);
				pTool.setText("total units", num2 + num3, 0f, pShowBar: false, 0L);
				pTool.setText("fam/no fam", num2 + "/" + num3, 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				List<Family> obj = new List<Family>(World.world.families);
				obj.Sort((Family a, Family b) => b.units.Count.CompareTo(a.units.Count));
				foreach (Family item19 in obj)
				{
					if (item19.units.Count >= 2)
					{
						pTool.setText("[" + item19.data.species_id + "] " + item19.name + ": ", item19.units.Count, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Languages",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (Language language in World.world.languages)
				{
					pTool.setText("[] " + language.name + ": ", language.units.Count, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Religions",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (Religion religion in World.world.religions)
				{
					pTool.setText("[] " + religion.name + ": ", religion.units.Count, 0f, pShowBar: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Actor Asset Units",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (ActorAsset item20 in AssetManager.actor_library.list)
				{
					if (item20.units.Count != 0)
					{
						pTool.setText(item20.id + ": ", item20.units.Count, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Population",
			action_1 = delegate(DebugTool pTool)
			{
				int num = 0;
				foreach (City city3 in World.world.cities)
				{
					num += city3.getPopulationPeople();
				}
				pTool.setText("city units:", num, 0f, pShowBar: false, 0L);
				pTool.setText("unit list:", World.world.units.debugContainer(), 0f, pShowBar: false, 0L);
			}
		});
		add(new DebugToolAsset
		{
			id = "System Managers",
			action_1 = delegate(DebugTool pTool)
			{
				foreach (BaseSystemManager list_all_sim_manager in World.world.list_all_sim_managers)
				{
					list_all_sim_manager.showDebugTool(pTool);
				}
			}
		});
	}

	private void initAI()
	{
		add(new DebugToolAsset
		{
			id = "Actor AI",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_00de: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
				//IL_011c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0121: Unknown result type (might be due to invalid IL or missing references)
				WorldTile mouseTilePos4 = World.world.getMouseTilePos();
				if (mouseTilePos4 != null)
				{
					int num3 = int.MaxValue;
					Actor actor2 = null;
					foreach (Actor unit in World.world.units)
					{
						if (!unit.isInsideSomething())
						{
							int num4 = Toolbox.SquaredDistTile(unit.current_tile, mouseTilePos4);
							if (num4 < num3)
							{
								actor2 = unit;
								num3 = num4;
							}
						}
					}
					if (actor2 != null)
					{
						pTool.setText("timer_action:", actor2.timer_action, 0f, pShowBar: false, 0L);
						pTool.setText("stat id:", actor2.asset.id, 0f, pShowBar: false, 0L);
						actor2.ai.debug(pTool);
						WorldTile beh_tile_target = actor2.beh_tile_target;
						int? obj;
						Vector2Int pos2;
						if (beh_tile_target == null)
						{
							obj = null;
						}
						else
						{
							pos2 = beh_tile_target.pos;
							obj = ((Vector2Int)(ref pos2))[0];
						}
						int? num5 = obj;
						string? text3 = num5.ToString();
						WorldTile beh_tile_target2 = actor2.beh_tile_target;
						int? obj2;
						if (beh_tile_target2 == null)
						{
							obj2 = null;
						}
						else
						{
							pos2 = beh_tile_target2.pos;
							obj2 = ((Vector2Int)(ref pos2))[1];
						}
						num5 = obj2;
						pTool.setText("beh_tile_target", text3 + ":" + num5, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Boat AI",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_0140: Unknown result type (might be due to invalid IL or missing references)
				//IL_0145: Unknown result type (might be due to invalid IL or missing references)
				//IL_015f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0164: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
				//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
				//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
				WorldTile mouseTilePos3 = World.world.getMouseTilePos();
				if (mouseTilePos3 != null)
				{
					int num = int.MaxValue;
					Actor actor = null;
					foreach (Actor unit2 in World.world.units)
					{
						if (!unit2.isInsideSomething() && unit2.asset.is_boat)
						{
							int num2 = Toolbox.SquaredDistTile(unit2.current_tile, mouseTilePos3);
							if (num2 < num)
							{
								actor = unit2;
								num = num2;
							}
						}
					}
					if (actor != null)
					{
						pTool.setText("action_timer:", actor.timer_action, 0f, pShowBar: false, 0L);
						pTool.setText("stat id:", actor.asset.id, 0f, pShowBar: false, 0L);
						TaxiRequest taxi_request = actor.getSimpleComponent<Boat>().taxi_request;
						if (taxi_request != null)
						{
							pTool.setText("taxi state:", taxi_request.state, 0f, pShowBar: false, 0L);
							pTool.setText("taxi actors:", taxi_request.countActors(), 0f, pShowBar: false, 0L);
							WorldTile tileTarget = taxi_request.getTileTarget();
							object pT;
							Vector2Int pos;
							if (tileTarget == null)
							{
								pT = "-";
							}
							else
							{
								pos = tileTarget.pos;
								string text = ((Vector2Int)(ref pos))[0].ToString();
								pos = tileTarget.pos;
								pT = text + ":" + ((Vector2Int)(ref pos))[1];
							}
							pTool.setText("taxi target:", pT, 0f, pShowBar: false, 0L);
							WorldTile tileStart = taxi_request.getTileStart();
							object pT2;
							if (tileStart == null)
							{
								pT2 = "-";
							}
							else
							{
								pos = tileStart.pos;
								string text2 = ((Vector2Int)(ref pos))[0].ToString();
								pos = tileStart.pos;
								pT2 = text2 + ":" + ((Vector2Int)(ref pos))[1];
							}
							pTool.setText("taxi start:", pT2, 0f, pShowBar: false, 0L);
						}
						actor.ai.debug(pTool);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "City AI",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos2 = World.world.getMouseTilePos();
				if (mouseTilePos2 != null)
				{
					City city2 = mouseTilePos2.zone.city;
					if (city2 != null)
					{
						pTool.setText("warrior_timer:", city2.getTimerForNewWarrior(), 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						if (city2.ai != null)
						{
							city2.ai.debug(pTool);
						}
						pTool.setSeparator();
						pTool.setText("action_timer:", city2.timer_action, 0f, pShowBar: false, 0L);
					}
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Kingdom AI",
			action_1 = delegate(DebugTool pTool)
			{
				WorldTile mouseTilePos = World.world.getMouseTilePos();
				if (mouseTilePos != null)
				{
					City city = mouseTilePos.zone.city;
					if (city != null)
					{
						Kingdom kingdom = city.kingdom;
						if (kingdom.hasKing())
						{
							pTool.setText("personality:", kingdom.king.s_personality.id, 0f, pShowBar: false, 0L);
							pTool.setText("agression:", kingdom.king.stats["personality_aggression"], 0f, pShowBar: false, 0L);
							pTool.setText("administration:", kingdom.king.stats["personality_administration"], 0f, pShowBar: false, 0L);
							pTool.setText("diplomatic:", kingdom.king.stats["personality_diplomatic"], 0f, pShowBar: false, 0L);
							pTool.setSeparator();
						}
						pTool.setText("timer_action:", kingdom.timer_action, 0f, pShowBar: false, 0L);
						pTool.setText("timer_new_king:", kingdom.data.timer_new_king, 0f, pShowBar: false, 0L);
						pTool.setSeparator();
						pTool.setText("action_timer:", kingdom.timer_action, 0f, pShowBar: false, 0L);
						if (kingdom.ai != null)
						{
							kingdom.ai.debug(pTool);
						}
					}
				}
			}
		});
	}

	private void initFmod()
	{
		add(new DebugToolAsset
		{
			id = "FMOD",
			action_1 = delegate(DebugTool pTool)
			{
				MusicBox.debug_fmod(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "FMOD World Params",
			action_1 = delegate(DebugTool pTool)
			{
				MusicBox.inst.debug_world_params(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "FMOD Unit Params",
			action_1 = delegate(DebugTool pTool)
			{
				MusicBox.inst.debug_unit_params(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "FMOD Params",
			action_1 = delegate(DebugTool pTool)
			{
				MusicBox.inst.debug_params(pTool);
			}
		});
		add(new DebugToolAsset
		{
			id = "Cursor Speed",
			action_1 = delegate(DebugTool pTool)
			{
				MapBox.cursor_speed.debug(pTool);
			}
		});
	}

	private void initUI()
	{
		add(new DebugToolAsset
		{
			id = "screen_orientation",
			action_1 = delegate(DebugTool pTool)
			{
				//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
				pTool.setText("width:", Screen.width, 0f, pShowBar: false, 0L);
				pTool.setText("height:", Screen.height, 0f, pShowBar: false, 0L);
				pTool.setText("last width:", CanvasMain.instance.getLastWidth(), 0f, pShowBar: false, 0L);
				pTool.setText("last height:", CanvasMain.instance.getLastHeight(), 0f, pShowBar: false, 0L);
				pTool.setText("orientation:", Screen.orientation, 0f, pShowBar: false, 0L);
				pTool.setText("saved orientation:", (object)(ScreenOrientation)(PlayerConfig.optionBoolEnabled("portrait") ? 1 : 3), 0f, pShowBar: false, 0L);
				pTool.setText("rotation to portrait:", Screen.autorotateToPortrait, 0f, pShowBar: false, 0L);
				pTool.setText("rotation to landscape left:", Screen.autorotateToLandscapeLeft, 0f, pShowBar: false, 0L);
				pTool.setText("rotation to landscape right:", Screen.autorotateToLandscapeRight, 0f, pShowBar: false, 0L);
				pTool.setText("rotation to portrait reversed:", Screen.autorotateToPortraitUpsideDown, 0f, pShowBar: false, 0L);
			}
		});
	}

	public override void post_init()
	{
		base.post_init();
		list.Sort((DebugToolAsset a, DebugToolAsset b) => a.priority.CompareTo(b.priority));
		list.Sort((DebugToolAsset a, DebugToolAsset b) => string.Compare(a.id, b.id, StringComparison.InvariantCultureIgnoreCase));
		TextInfo textInfo = CultureInfo.InvariantCulture.TextInfo;
		foreach (DebugToolAsset item in list)
		{
			if (item.id.ToLower() == item.id)
			{
				item.name = textInfo.ToTitleCase(item.id.Replace('_', ' '));
			}
			else
			{
				item.name = item.id;
			}
		}
	}

	public override DebugToolAsset get(string pId)
	{
		foreach (DebugToolAsset item in list)
		{
			if (item.name == pId)
			{
				return item;
			}
		}
		return base.get(pId);
	}

	private void initBenchmarks()
	{
		add(new DebugToolAsset
		{
			id = "Benchmark All",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			priority = 1,
			benchmark_group_id = "game_total",
			benchmark_total = "game_total",
			benchmark_total_group = "main",
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Test Decisions",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			priority = 50,
			benchmark_group_id = "decisions_test",
			benchmark_total = "decisions_test",
			benchmark_total_group = "decisions_test_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_update = delegate
			{
				if (World.world.units.Count != 0)
				{
					Actor pActor = World.world.units.getSimpleList()[0];
					Bench.bench("decisions_test", "decisions_test_total");
					Bench.bench("decisions", "decisions_test");
					for (int i = 0; i < 5000; i++)
					{
						DecisionHelper.runSimulation(pActor);
					}
					Bench.benchEnd("decisions", "decisions_test", pSaveCounter: false, 0L);
					Bench.benchEnd("decisions_test", "decisions_test_total", pSaveCounter: false, 0L);
				}
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Zone Camera",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "zone_camera",
			benchmark_total = "zone_camera",
			benchmark_total_group = "zone_camera_total",
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "benchmark_chunks",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "chunks",
			benchmark_total = "chunks",
			benchmark_total_group = "chunks_total",
			split_benchmark = true,
			action_1 = delegate(DebugTool pTool)
			{
				double totalFrameBudget = getTotalFrameBudget();
				double benchResultAsDouble = Bench.getBenchResultAsDouble(pTool.asset.benchmark_total, pTool.asset.benchmark_total_group, pTool.isValueAverage());
				pTool.setText("group total:", trim(benchResultAsDouble, pAddMS: true), 100f, pShowBar: true, 0L);
				double num = benchResultAsDouble / (double)Time.deltaTime * 100.0;
				pTool.setText("total frame time spent:", trimPercent(num), (float)num, pShowBar: true, 0L);
				double num2 = benchResultAsDouble * 1000.0 / totalFrameBudget * 100.0;
				pTool.setText("total budget time spent:", trimPercent(num2), (float)num2, pShowBar: true, 0L);
				pTool.setSeparator();
				pTool.setText("########### last_dirty:", null, 0f, pShowBar: false, 0L);
				pTool.setText("chunks:", Bench.getBenchValue("m_dirtyChunks", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("new regions:", Bench.getBenchValue("m_newRegions", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("new links:", Bench.getBenchValue("m_newLinks", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("new islands:", Bench.getBenchValue("m_newIslands", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("last dirty islands:", Bench.getBenchValue("m_dirtyIslands", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("last dirty corners:", Bench.getBenchValue("m_dirtyCorners", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setText("dirty islands neighb:", Bench.getBenchValue("m_dirtyIslandNeighb", "chunks"), 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("########### last_bench:", null, 0f, pShowBar: false, 0L);
			},
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				pTool.show_averages = false;
				pTool.show_counter = true;
				pTool.show_max = false;
				pTool.hide_zeroes = false;
				pTool.state = DebugToolState.Percent;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Quantum Sprites",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "quantum_sprites",
			benchmark_total = "quantum_sprites",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Cache Manager",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "world_cache_manager",
			benchmark_total = "world_cache_manager",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.Values;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Sim Zones",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "sim_zones",
			benchmark_total = "sim_zones",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.Values;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark MusicBox",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "music_box",
			benchmark_total = "music_box",
			benchmark_total_group = "music_box_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.Values;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Nameplates",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "nameplates",
			benchmark_total = "nameplates",
			benchmark_total_group = "nameplates_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.FrameBudget;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Borderers Renderer",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "borders_renderer",
			benchmark_total = "borders_renderer",
			benchmark_total_group = "borders_renderer_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.FrameBudget;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Fluid Zones Data",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "fluid_zones_data",
			benchmark_total = "fluid_zones_data",
			benchmark_total_group = "fluid_zones_data_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = false;
				pTool.hide_zeroes = false;
				pTool.show_max = false;
				pTool.state = DebugToolState.FrameBudget;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark World Beh",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "world_beh",
			benchmark_total = "world_beh",
			benchmark_total_group = "game_total",
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Buildings",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "buildings",
			benchmark_total = "buildings",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		DebugToolAsset debugToolAsset = t;
		debugToolAsset.action_1 = (DebugToolAssetAction)Delegate.Combine(debugToolAsset.action_1, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			JobManagerBuildings jobManager2 = World.world.buildings.getJobManager();
			pTool.setText("batches total/free:", jobManager2.debugBatchCount(), 0f, pShowBar: false, 0L);
			pTool.setText("active jobs:", jobManager2.debugJobCount(), 0f, pShowBar: false, 0L);
			pTool.setSeparator();
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Actors",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "actors",
			benchmark_total = "actors",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		DebugToolAsset debugToolAsset2 = t;
		debugToolAsset2.action_1 = (DebugToolAssetAction)Delegate.Combine(debugToolAsset2.action_1, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			JobManagerActors jobManager = World.world.units.getJobManager();
			pTool.setText("batches total/free:", jobManager.debugBatchCount(), 0f, pShowBar: false, 0L);
			pTool.setText("active jobs:", jobManager.debugJobCount(), 0f, pShowBar: false, 0L);
			pTool.setSeparator();
		});
		add(new DebugToolAsset
		{
			id = "Benchmark AI Actions",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "ai_actions",
			benchmark_total = "ai_actions",
			benchmark_total_group = "ai_actions_total",
			split_benchmark = true,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_max = false;
				pTool.show_averages = true;
				pTool.hide_zeroes = true;
				pTool.show_max = false;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		t.show_on_start = DebugConfig.isOn(DebugOption.BenchAiEnabled);
		add(new DebugToolAsset
		{
			id = "Benchmark AI Tasks",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "ai_tasks",
			benchmark_total = "ai_tasks",
			benchmark_total_group = "ai_tasks_total",
			split_benchmark = true,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_max = false;
				pTool.show_averages = true;
				pTool.hide_zeroes = true;
				pTool.show_max = false;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		t.show_on_start = DebugConfig.isOn(DebugOption.BenchAiEnabled);
		add(new DebugToolAsset
		{
			id = "$benchmark_loops$",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "loops_test_100",
			benchmark_total = "loops_test_100",
			benchmark_total_group = "loops_test_total_100",
			show_last_count = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = true;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_update = delegate(DebugTool pTool)
			{
				BenchmarkLoops.update(pTool.asset);
			}
		});
		clone("Benchmark Loops 10", "$benchmark_loops$");
		t.benchmark_group_id = "loops_test_10";
		t.benchmark_total = "loops_test_10";
		t.benchmark_total_group = "loops_test_total_10";
		DebugToolAsset debugToolAsset3 = t;
		debugToolAsset3.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset3.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkLoops(pTool.asset, 10);
		});
		clone("Benchmark Loops 100", "$benchmark_loops$");
		t.benchmark_group_id = "loops_test_100";
		t.benchmark_total = "loops_test_100";
		t.benchmark_total_group = "loops_test_total_100";
		DebugToolAsset debugToolAsset4 = t;
		debugToolAsset4.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset4.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkLoops(pTool.asset, 100);
		});
		clone("Benchmark Loops 1000", "$benchmark_loops$");
		t.benchmark_group_id = "loops_test_1000";
		t.benchmark_total = "loops_test_1000";
		t.benchmark_total_group = "loops_test_total_1000";
		DebugToolAsset debugToolAsset5 = t;
		debugToolAsset5.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset5.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkLoops(pTool.asset, 1000);
		});
		clone("Benchmark Loops 10000", "$benchmark_loops$");
		t.benchmark_group_id = "loops_test_10000";
		t.benchmark_total = "loops_test_10000";
		t.benchmark_total_group = "loops_test_total_10000";
		DebugToolAsset debugToolAsset6 = t;
		debugToolAsset6.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset6.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkLoops(pTool.asset, 10000);
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Distance",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "dist_test",
			benchmark_total = "dist_test",
			benchmark_total_group = "dist_test_total",
			show_last_count = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Percent;
				new BenchmarkDist();
			},
			action_update = delegate
			{
				BenchmarkDist.update();
			}
		});
		clone("$benchmark_shuffle_loops$", "$benchmark_loops$");
		t.action_update = delegate(DebugTool pTool)
		{
			BenchmarkShuffle.update(pTool.asset);
		};
		clone("Benchmark Shuffle Loops 10", "$benchmark_shuffle_loops$");
		t.benchmark_group_id = "shuffle_test_10";
		t.benchmark_total = "shuffle_test_10";
		t.benchmark_total_group = "shuffle_test_total_10";
		DebugToolAsset debugToolAsset7 = t;
		debugToolAsset7.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset7.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkShuffle(pTool.asset, 10, 50);
		});
		clone("Benchmark Shuffle Loops 100", "$benchmark_shuffle_loops$");
		t.benchmark_group_id = "shuffle_test_100";
		t.benchmark_total = "shuffle_test_100";
		t.benchmark_total_group = "shuffle_test_total_100";
		DebugToolAsset debugToolAsset8 = t;
		debugToolAsset8.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset8.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkShuffle(pTool.asset, 100, 500);
		});
		clone("Benchmark Shuffle Loops 1000", "$benchmark_shuffle_loops$");
		t.benchmark_group_id = "shuffle_test_1000";
		t.benchmark_total = "shuffle_test_1000";
		t.benchmark_total_group = "shuffle_test_total_1000";
		DebugToolAsset debugToolAsset9 = t;
		debugToolAsset9.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset9.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkShuffle(pTool.asset, 1000, 5000);
		});
		clone("Benchmark Shuffle Loops 10000", "$benchmark_shuffle_loops$");
		t.benchmark_group_id = "shuffle_test_10000";
		t.benchmark_total = "shuffle_test_10000";
		t.benchmark_total_group = "shuffle_test_total_10000";
		DebugToolAsset debugToolAsset10 = t;
		debugToolAsset10.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset10.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		{
			new BenchmarkShuffle(pTool.asset, 10000, 25000);
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Field Acess",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "field_acess_test",
			benchmark_total = "field_acess_test",
			benchmark_total_group = "field_acess_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_update = delegate
			{
				BenchmarkFieldAccess.start();
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Sprites",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "sprites_test",
			benchmark_total = "sprites_test",
			benchmark_total_group = "sprites_test_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_update = delegate
			{
				BenchmarkSprites.start();
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Struct Loops",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "loops_struct_test",
			benchmark_total = "loops_struct_test",
			benchmark_total_group = "loops_struct_test_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.Values;
			},
			action_update = delegate
			{
				BenchmarkStructLoops.start();
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark ECS",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "ecs_test",
			benchmark_total = "ecs_test",
			benchmark_total_group = "ecs_test_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = false;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = true;
				pTool.state = DebugToolState.Percent;
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Blacklist",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "blacklist_test",
			benchmark_total = "blacklist_test",
			benchmark_total_group = "blacklist_test_total",
			split_benchmark = true,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom,
			action_start = delegate(DebugTool pTool)
			{
				setBenchmarksDefaultValue(pTool);
				pTool.show_counter = true;
				pTool.show_averages = true;
				pTool.hide_zeroes = false;
				pTool.show_max = true;
				pTool.sort_by_names = false;
				pTool.sort_by_values = true;
				pTool.state = DebugToolState.TimeSpent;
			},
			action_update = delegate
			{
				BenchmarkBlacklist.start();
			}
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Trait Effects",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "effects_traits",
			benchmark_total = "effects_traits",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "Benchmark Item Effects",
			show_benchmark_buttons = true,
			type = DebugToolType.Benchmarks,
			benchmark_group_id = "effects_items",
			benchmark_total = "effects_items",
			benchmark_total_group = "game_total",
			split_benchmark = true,
			action_start = setBenchmarksDefaultValue,
			action_1 = showGroupBenchmarkTop,
			action_2 = showGroupBenchmarkBottom
		});
		add(new DebugToolAsset
		{
			id = "Benchmark",
			type = DebugToolType.Benchmarks,
			priority = 2,
			action_1 = delegate(DebugTool pTool)
			{
				pTool.setText("CityBehCheckSettleTarget_tick:", Bench.getBenchResult("CityBehCheckSettleTarget", "main", pAverage: false), 0f, pShowBar: false, 0L);
				pTool.setSeparator();
				pTool.setText("test_follow:", Bench.getBenchResult("test_follow"), 0f, pShowBar: false, 0L);
			}
		});
	}

	private void setBenchmarksDefaultValue(DebugTool pTool)
	{
		pTool.sort_order_reversed = false;
		pTool.sort_by_names = false;
		pTool.sort_by_values = false;
		pTool.show_averages = true;
		pTool.hide_zeroes = true;
		pTool.show_counter = true;
		pTool.show_max = true;
		pTool.state = DebugToolState.FrameBudget;
		pTool.paused = false;
		pTool.percentage_slowest = false;
		if (Config.editor_mastef)
		{
			DebugConfig.debugToolMastefDefaults(pTool);
		}
	}

	private void showGroupBenchmarkTop(DebugTool pTool)
	{
		float deltaTime = Time.deltaTime;
		double totalFrameBudget = getTotalFrameBudget();
		double benchResultAsDouble = Bench.getBenchResultAsDouble("game_total", "main", pTool.isValueAverage());
		pTool.setText("game total:", trim(benchResultAsDouble, pAddMS: true), 0f, pShowBar: false, 0L);
		pTool.setText("fps:", FPS.getFPS(), 0f, pShowBar: false, 0L);
		pTool.setSeparator();
		double benchResultAsDouble2 = Bench.getBenchResultAsDouble(pTool.asset.benchmark_total, pTool.asset.benchmark_total_group, pTool.isValueAverage());
		if (pTool.asset.benchmark_total != "game_total")
		{
			pTool.setText("group total:", trim(benchResultAsDouble2, pAddMS: true), 100f, pShowBar: true, 0L);
			double num = benchResultAsDouble2 / benchResultAsDouble * 100.0;
			pTool.setText("usage from total:", trimPercent(num), (float)num, pShowBar: true, 0L);
		}
		else
		{
			pTool.setSeparator();
			pTool.setSeparator();
		}
		double num2 = benchResultAsDouble2 / (double)deltaTime * 100.0;
		pTool.setText("total frame time spent:", trimPercent(num2), (float)num2, pShowBar: true, 0L);
		double num3 = benchResultAsDouble2 * 1000.0 / totalFrameBudget * 100.0;
		pTool.setText("total budget time spent:", trimPercent(num3), (float)num3, pShowBar: true, 0L);
		pTool.setSeparator();
	}

	private void showGroupBenchmarkBottom(DebugTool pTool)
	{
		double totalFrameBudget = getTotalFrameBudget();
		float deltaTime = Time.deltaTime;
		List<ToolBenchmarkData> list = new List<ToolBenchmarkData>(Bench.getGroup(pTool.asset.benchmark_group_id).dict_data.Values);
		if (!pTool.percentage_slowest)
		{
			double benchResultAsDouble = Bench.getBenchResultAsDouble(pTool.asset.benchmark_total, pTool.asset.benchmark_total_group, pTool.isValueAverage());
			foreach (ToolBenchmarkData item in list)
			{
				double num = item.latest_result;
				if (pTool.isValueAverage())
				{
					num = item.getAverage();
				}
				double calculated_percentage = num / benchResultAsDouble * 100.0;
				item.calculated_percentage = calculated_percentage;
			}
		}
		else
		{
			double num2 = 0.0;
			foreach (ToolBenchmarkData item2 in list)
			{
				double num3 = (pTool.isValueAverage() ? item2.getAverage() : item2.latest_result);
				if (num3 > num2)
				{
					num2 = num3;
				}
			}
			foreach (ToolBenchmarkData item3 in list)
			{
				double num4 = (pTool.isValueAverage() ? item3.getAverage() : item3.latest_result) / num2 * 100.0;
				if (((float)num4).Equals(100f))
				{
					num4 += 1.0;
				}
				item3.calculated_percentage = num4;
			}
		}
		if (pTool.sort_by_names)
		{
			list.Sort((ToolBenchmarkData a, ToolBenchmarkData b) => b.id.CompareTo(a.id));
		}
		else if (pTool.isState(DebugToolState.Percent))
		{
			list.Sort((ToolBenchmarkData a, ToolBenchmarkData b) => a.calculated_percentage.CompareTo(b.calculated_percentage));
		}
		else if (pTool.isValueAverage())
		{
			list.Sort((ToolBenchmarkData a, ToolBenchmarkData b) => a.getAverage().CompareTo(b.getAverage()));
		}
		else
		{
			list.Sort((ToolBenchmarkData a, ToolBenchmarkData b) => a.latest_result.CompareTo(b.latest_result));
		}
		if (!pTool.sort_order_reversed)
		{
			list.Reverse();
		}
		foreach (ToolBenchmarkData item4 in list)
		{
			double num5 = item4.latest_result;
			if (pTool.isValueAverage())
			{
				num5 = item4.getAverage();
			}
			long pCounter = 0L;
			bool pShowCounter = false;
			bool show_max = pTool.show_max;
			string pMaxValue = string.Empty;
			if (pTool.asset.split_benchmark && pTool.show_counter)
			{
				pCounter = item4.getAverageCount();
				pShowCounter = true;
			}
			else if (pTool.asset.show_last_count && pTool.show_counter)
			{
				pCounter = item4.getLastCount();
				pShowCounter = true;
			}
			string pT = string.Empty;
			string pT2 = string.Empty;
			double num6 = 0.0;
			switch (pTool.state)
			{
			case DebugToolState.Percent:
				if (pTool.hide_zeroes && item4.calculated_percentage < 0.1)
				{
					continue;
				}
				pT = item4.id + ":";
				pT2 = trimPercent(item4.calculated_percentage);
				num6 = item4.calculated_percentage;
				item4.saveLastMaxValue(item4.calculated_percentage);
				pMaxValue = trimPercent(item4.last_max_value);
				break;
			case DebugToolState.Values:
				if (pTool.hide_zeroes && num5 < 1E-06)
				{
					continue;
				}
				pT = item4.id + ":";
				pT2 = trim(num5);
				num6 = item4.calculated_percentage;
				item4.saveLastMaxValue(num5);
				pMaxValue = trim(item4.last_max_value);
				break;
			case DebugToolState.FrameBudget:
			{
				double num8 = num5 * 1000.0 / totalFrameBudget * 100.0;
				if (pTool.hide_zeroes && num8 < 0.1)
				{
					continue;
				}
				pT = item4.id + ":";
				pT2 = trimPercent(num8);
				num6 = num8;
				item4.saveLastMaxValue(num8);
				pMaxValue = trimPercent(item4.last_max_value);
				break;
			}
			case DebugToolState.TimeSpent:
			{
				double num7 = num5 / (double)deltaTime * 100.0;
				if (pTool.hide_zeroes && num7 < 0.1)
				{
					continue;
				}
				pT = item4.id + ":";
				pT2 = trimPercent(num7);
				num6 = num7;
				item4.saveLastMaxValue(num7);
				pMaxValue = trimPercent(item4.last_max_value);
				break;
			}
			}
			pTool.setText(pT, pT2, (float)num6, pShowBar: true, pCounter, pShowCounter, show_max, pMaxValue);
		}
	}

	private string trim(double pValue, bool pAddMS = false)
	{
		pValue *= 1000.0;
		string text = pValue.ToString("F5");
		if (pAddMS)
		{
			text += " ms";
		}
		return text;
	}

	private string trimPercent(double pValue, bool pAddPercent = true)
	{
		string text = pValue.ToString("F1");
		if (pAddPercent)
		{
			text += "%";
		}
		return text;
	}

	private double getTotalFrameBudget()
	{
		double num = 60.0;
		if (Config.fps_lock_30)
		{
			num = 30.0;
		}
		return 1000.0 / num * 0.6499999761581421;
	}
}
// --- End of File: DebugToolLibrary.cs ---



// --- Start of File: DebugToolState.cs ---
public enum DebugToolState
{
	Values,
	Percent,
	TimeSpent,
	FrameBudget
}
// --- End of File: DebugToolState.cs ---



// --- Start of File: DebugToolTextElement.cs ---
using UnityEngine;
using UnityEngine.UI;

public class DebugToolTextElement : MonoBehaviour
{
	public Text text_left;

	public Text text_right;

	public Image text_bar;
}
// --- End of File: DebugToolTextElement.cs ---



// --- Start of File: DebugToolType.cs ---
public enum DebugToolType
{
	Default,
	Benchmarks
}
// --- End of File: DebugToolType.cs ---



// --- Start of File: DebugToolUpdateDelegate.cs ---
public delegate void DebugToolUpdateDelegate(DebugTool pTool);
// --- End of File: DebugToolUpdateDelegate.cs ---



// --- Start of File: DebugUiDrag.cs ---
using UnityEngine;
using UnityEngine.EventSystems;

public class DebugUiDrag : EventTrigger
{
	private bool dragging;

	private Transform mainTransform;

	private Transform canvasContainer;

	private DebugTool _tool;

	private Canvas _canvas;

	private void Start()
	{
		_tool = ((Component)((Component)this).transform).GetComponentInParent<DebugTool>();
		_canvas = ((Component)((Component)this).transform).GetComponentInParent<Canvas>();
		mainTransform = ((Component)_tool).transform;
		canvasContainer = mainTransform.parent;
	}

	public void Update()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (dragging)
		{
			Vector3 position = Vector2.op_Implicit(new Vector2(Input.mousePosition.x, Input.mousePosition.y));
			mainTransform.SetParent((Transform)null, true);
			mainTransform.SetParent(canvasContainer, true);
			Vector2 sizeDelta = ((Component)_tool).GetComponent<RectTransform>().sizeDelta;
			position.x += sizeDelta.x / 2f - 75f;
			position.y += 20f;
			mainTransform.position = position;
		}
	}

	public override void OnPointerDown(PointerEventData eventData)
	{
		dragging = true;
	}

	public override void OnPointerUp(PointerEventData eventData)
	{
		dragging = false;
	}
}
// --- End of File: DebugUiDrag.cs ---



// --- Start of File: DebugVariables.cs ---
using UnityEngine;

public class DebugVariables : MonoBehaviour
{
	public static DebugVariables instance;

	[Range(1f, 1000f)]
	public float multiplier = 1f;

	[Range(1f, 10000000f)]
	public float bonus = 1f;

	public float time;

	[Range(0f, 1000f)]
	public float gravity = 9.8f;

	[Range(0f, 10f)]
	public float unit_force_multiplier = 1f;

	[Range(0f, 10f)]
	public float test_mass = 2f;

	public bool layout_city_test;

	public bool layout_lines_horizontal;

	public bool layout_lines_vertical;

	public bool layout_cross;

	public bool layout_diagonal;

	public bool layout_lattice_small;

	public bool layout_lattice_medium;

	public bool layout_lattice_big;

	public bool layout_clusters_small;

	public bool layout_clusters_medium;

	public bool layout_clusters_big;

	public bool layout_ring;

	public bool layout_diamond;

	public bool layout_diamond_cluster;

	public bool layout_honeycomb;

	public bool layout_brick_vertical;

	public bool layout_brick_horizontal;

	public bool layout_madman_labyrinth;

	public bool layout_map_ring;
}
// --- End of File: DebugVariables.cs ---



// --- Start of File: DebugWorldText.cs ---
using FMOD.Studio;
using UnityEngine;
using life.taxi;

public class DebugWorldText : MonoBehaviour
{
	public TextMesh text_mesh;

	public TextMesh text_mesh_bg_clone;

	private string _color_sounds_attached = "#FF1F44";

	private string _color_sounds = "#607BFF";

	private string _color_actors = "#FF8F44";

	private string _color_building = "#00FFFF";

	private string _color_city = "#A0FF93";

	private string _color_kingdom = "#FF4242";

	private string cur_string;

	private string cur_color;

	public void create()
	{
		((Component)text_mesh_bg_clone).GetComponent<Renderer>().sortingLayerID = SortingLayer.NameToID("Debug");
		((Component)text_mesh_bg_clone).GetComponent<Renderer>().sortingOrder = 1;
		((Component)text_mesh).GetComponent<Renderer>().sortingLayerID = SortingLayer.NameToID("Debug");
		((Component)text_mesh).GetComponent<Renderer>().sortingOrder = 2;
	}

	private void prepare(string pID, string pColor, float pSize = 0.25f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		text_mesh.color = Color.white;
		cur_string = pID;
		cur_color = "<color=" + pColor + ">";
		text_mesh_bg_clone.characterSize = pSize;
		text_mesh.characterSize = pSize;
	}

	private void add(string pTitle, object pText)
	{
		cur_string = cur_string + pTitle + ": " + cur_color + pText?.ToString() + "</color>\n";
	}

	public void setTextFmodSound(DebugMusicBoxData pData)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		setTextFmodSound(pData, Color.white);
	}

	public void setTextFmodSound(DebugMusicBoxData pData, Color pColor)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float a = pData.timer / 3f;
		prepare("#fmod\n", _color_sounds, 0.5f);
		cur_string = "mb:" + pData.path;
		Color color = pColor;
		color.a = a;
		fin();
		text_mesh.color = color;
		text_mesh_bg_clone.color = color;
	}

	public void setTextFmodSound(EventInstance pInstance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		EventDescription val = default(EventDescription);
		((EventInstance)(ref pInstance)).getDescription(ref val);
		string pText = default(string);
		((EventDescription)(ref val)).getPath(ref pText);
		prepare("#fmod\n", _color_sounds_attached, 0.5f);
		add("name", pText);
		fin();
	}

	public void setTextZone(TileZone pZone)
	{
		prepare("#zone\n", _color_actors, 0.5f);
		(string, int)[] debug_args = pZone.debug_args;
		for (int i = 0; i < debug_args.Length; i++)
		{
			(string, int) tuple = debug_args[i];
			add(tuple.Item1, tuple.Item2);
		}
		fin();
	}

	public void setTextBoat(Actor pActor)
	{
		Boat simpleComponent = pActor.getSimpleComponent<Boat>();
		TaxiRequest taxi_request = simpleComponent.taxi_request;
		if (simpleComponent.hasPassengers() || taxi_request != null)
		{
			prepare("#boat\n", _color_kingdom, 0.8f);
		}
		else
		{
			prepare("#boat\n", _color_actors, 0.4f);
		}
		if (pActor.ai.job != null)
		{
			add("job", pActor.ai.job.id + "(" + pActor.ai.task_index + "/" + pActor.ai.job.tasks.Count + ")");
		}
		if (pActor.hasTask())
		{
			string text = " [" + pActor.ai.action_index + "/" + pActor.ai.task?.list.Count + "]";
			add("task", pActor.ai.task.id + " " + text);
			string text2 = pActor.ai.action?.GetType().ToString();
			if (text2 != null)
			{
				text2 = text2.Replace("ai.behaviours.", "");
			}
			add("action", text2);
		}
		add("timer", simpleComponent.actor.timer_action);
		fin();
	}

	private void debugForce(Actor pActor)
	{
		add("force xy", pActor.velocity.x + "-" + pActor.velocity.y);
		add("force z", pActor.velocity.z);
		add("zPosition", pActor.position_height);
		add("force_speed", pActor.velocity_speed);
		add("under_force", pActor.under_forces);
		add("mass", pActor.stats["mass"]);
	}

	public void setTextActor(Actor pActor)
	{
		prepare("#unit\n", _color_actors, 0.2f);
		add("name", pActor.data.name);
		add("timer_action", pActor.timer_action);
		if (pActor.isCarryingResources())
		{
			add("inv.count", pActor.inventory.countResources());
			add("inv.render", pActor.inventory.getItemIDToRender());
		}
		add("stats", pActor.asset.id);
		add("id", pActor.data.id);
		add("alive", pActor.isAlive());
		add("health", pActor.getHealth() + "/" + pActor.getMaxHealth());
		add("traits", pActor.countTraits());
		if (pActor.hasAnyStatusEffect())
		{
			add("statuses", pActor.countStatusEffects());
		}
		if (pActor.ai.job != null)
		{
			add("job", pActor.ai.job.id + "(" + pActor.ai.task_index + "/" + pActor.ai.job.tasks.Count + ")");
		}
		if (pActor.hasTask())
		{
			add("task", pActor.ai.task.id);
			string text = pActor.ai.action?.GetType().ToString();
			if (text != null)
			{
				text = text.Replace("ai.behaviours.", "");
			}
			text = text + pActor.ai.action_index + "/" + pActor.ai.task?.list.Count;
			add("action", text);
		}
		fin();
	}

	public void setTextArmy(Army pArmy)
	{
		prepare("#army\n", _color_building, 0.3f);
		add("captain", pArmy.getCaptain().getName());
		add("id", pArmy.id);
		add("units", pArmy.countUnits());
		add("alive", pArmy.isAlive());
		if (pArmy.getCity().isAlive())
		{
			add("city", pArmy.getCity().name);
		}
		else
		{
			add("city", "DESTROYED, SHOULD BE NULL");
		}
		fin();
	}

	public void setTextBuilding(Building pObj)
	{
		prepare("#build\n", _color_building, 0.3f);
		add("objectID", pObj.data.id);
		add("state", pObj.data.state);
		add("animationState", pObj.animation_state);
		add("ownership", pObj.state_ownership);
		add("kingdom", pObj.kingdom.id);
		if (pObj.asset.hasHousingSlots())
		{
			add("housing", pObj.countResidents() + "/" + pObj.asset.housing_slots);
		}
		fin();
	}

	public void setTextCity(City pObj)
	{
		prepare("#city\n", _color_city, 1.5f);
		bool flag = false;
		string text = "";
		foreach (string key in pObj.buildings_dict_id.Keys)
		{
			if (flag)
			{
				break;
			}
			foreach (Building item in pObj.buildings_dict_id[key])
			{
				if (!item.isAlive())
				{
					flag = true;
					text += "dead,";
				}
				if (item.asset.id != key)
				{
					flag = true;
					text = text + "wrong stats " + item.asset.id;
				}
				if (flag)
				{
					break;
				}
			}
		}
		int num = 0;
		foreach (Actor unit in pObj.units)
		{
			if (unit.isTask("put_out_fire"))
			{
				num++;
			}
		}
		add("on_fire", pObj.isCityUnderDangerFire());
		add("danger", pObj.isInDanger());
		add("firemen", num);
		add("total", pObj.status.population + "/" + pObj.getPopulationMaximum());
		add("units", pObj.units.Count);
		add("buildings", pObj.buildings.Count);
		add("orders_psbl", pObj._debug_last_possible_build_orders);
		add("orders_no_res", pObj._debug_last_possible_build_orders_no_resources);
		add("order_last", pObj._debug_last_build_order_try);
		add("house_zone_limit", pObj.getHouseCurrent() + "/" + pObj.getHouseLimit());
		if (pObj.ai.job != null)
		{
			add("job", pObj.ai.job.id + "(" + pObj.ai.task_index + "/" + pObj.ai.job.tasks.Count + ")");
		}
		if (pObj.ai.task != null)
		{
			add("task", pObj.ai.task.id);
		}
		else
		{
			add("task", "-");
		}
		if (flag)
		{
			add("ERROR", text);
		}
		fin();
	}

	public void setTextCityTasks(City pCity)
	{
		prepare("#city_tasks\n", _color_city, 0.5f);
		add("trees:", pCity.tasks.trees);
		add("stone:", pCity.tasks.minerals);
		add("minerals:", pCity.tasks.minerals);
		add("bushes:", pCity.tasks.bushes);
		add("plants:", pCity.tasks.plants);
		add("hives:", pCity.tasks.hives);
		add("farm_fields:", pCity.tasks.farm_fields);
		add("wheats:", pCity.tasks.wheats);
		add("ruins:", pCity.tasks.ruins);
		add("poops:", pCity.tasks.poops);
		add("roads:", pCity.tasks.roads);
		add("fire:", pCity.tasks.fire);
		add("", "");
		int num = 0;
		int num2 = 0;
		foreach (CitizenJobAsset key in pCity.jobs.jobs.Keys)
		{
			int num3 = pCity.jobs.jobs[key];
			int num4 = 0;
			if (pCity.jobs.occupied.ContainsKey(key))
			{
				num4 = pCity.jobs.occupied[key];
			}
			num += num3;
			num2 += num4;
			add(key.id + ":", num4 + "/" + num3);
		}
		foreach (CitizenJobAsset key2 in pCity.jobs.occupied.Keys)
		{
			if (!pCity.jobs.jobs.ContainsKey(key2))
			{
				int num5 = pCity.jobs.occupied[key2];
				num2 += num5;
				add(key2.id + ":", num5 + "/" + 0);
			}
		}
		int num6 = 0;
		int num7 = 0;
		foreach (Actor unit in pCity.units)
		{
			if (unit.isAdult())
			{
				num6++;
			}
			if (unit.hasTask() && unit.citizen_job != null)
			{
				num7++;
			}
		}
		add("total:", num2 + "/" + num);
		add("pop|adults|workers:", pCity.units.Count + " | " + num6 + " | " + num7);
		fin();
	}

	public void setTextKingdom(Kingdom pObj)
	{
		prepare("#kingdom\n", _color_kingdom, 2f);
		add("total", pObj.getPopulationPeople() + "/" + pObj.getPopulationTotalPossible());
		add("units", pObj.units.Count);
		add("buildings", pObj.buildings.Count);
		add("timer_action", pObj.timer_action);
		add("timer_new_king", pObj.data.timer_new_king);
		if (pObj.ai.job != null)
		{
			add("job", pObj.ai.job.id + "(" + pObj.ai.task_index + "/" + pObj.ai.job.tasks.Count + ")");
		}
		if (pObj.ai.task != null)
		{
			add("task", pObj.ai.task.id);
		}
		else
		{
			add("task", "-");
		}
		fin();
	}

	private void fin()
	{
		text_mesh.text = cur_string;
		text_mesh_bg_clone.text = cur_string;
	}
}
// --- End of File: DebugWorldText.cs ---



// --- Start of File: DebugZonesTool.cs ---
using UnityEngine;

public static class DebugZonesTool
{
	public static void actionGrowBorder()
	{
		WorldTile mouseTilePos = World.world.getMouseTilePos();
		if (mouseTilePos != null)
		{
			TileZone zone = mouseTilePos.zone;
			if (zone.hasCity())
			{
				World.world.city_zone_helper.city_growth.getZoneToClaim(null, zone.city);
			}
		}
	}

	public static void actionAbandonZones()
	{
		WorldTile mouseTilePos = World.world.getMouseTilePos();
		if (mouseTilePos != null)
		{
			TileZone zone = mouseTilePos.zone;
			if (zone.hasCity())
			{
				Bench.bench("abandon_stuff", "meh");
				World.world.city_zone_helper.city_abandon.check(zone.city, pDebug: true);
				Debug.Log((object)("bench abandon: " + Bench.benchEnd("abandon_stuff", "meh", pSaveCounter: false, 0L)));
			}
		}
	}
}
// --- End of File: DebugZonesTool.cs ---



// --- Start of File: DecisionAction.cs ---
public delegate bool DecisionAction(Actor pActor);
// --- End of File: DecisionAction.cs ---



// --- Start of File: DecisionActionWeight.cs ---
public delegate float DecisionActionWeight(Actor pActor);
// --- End of File: DecisionActionWeight.cs ---



// --- Start of File: DecisionAsset.cs ---
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

[Serializable]
public class DecisionAsset : Asset, ILocalizedAsset
{
	public DecisionAction action_check_launch;

	public float weight = 1f;

	[NonSerialized]
	public bool has_weight_custom;

	public DecisionActionWeight weight_calculate_custom;

	public string task_id;

	public int decision_index;

	public int cooldown;

	public string path_icon;

	public NeuroLayer priority;

	[NonSerialized]
	public int priority_int_cached;

	public bool cooldown_on_launch_failure;

	public bool only_special;

	public bool unique;

	public bool list_civ;

	public bool list_baby;

	public bool list_animal;

	public bool only_adult;

	public bool only_mob;

	public bool only_herd;

	public bool only_sapient;

	public bool only_safe;

	public bool only_hungry;

	public bool city_must_be_safe;

	[NonSerialized]
	public Sprite cached_sprite;

	public virtual Sprite getSprite()
	{
		if (cached_sprite == null)
		{
			cached_sprite = SpriteTextureLoader.getSprite(path_icon);
		}
		return cached_sprite;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isPossible(Actor pActor)
	{
		if (only_hungry && !pActor.isHungry())
		{
			return false;
		}
		if (only_safe && pActor.isFighting())
		{
			return false;
		}
		if (only_herd && !pActor.asset.follow_herd)
		{
			return false;
		}
		if (only_adult && !pActor.isAdult())
		{
			return false;
		}
		if (only_mob && pActor.isKingdomCiv())
		{
			return false;
		}
		if (only_sapient && !pActor.isSapient())
		{
			return false;
		}
		if (city_must_be_safe && pActor.inOwnCityBorders())
		{
			ProfessionAsset profession_asset = pActor.profession_asset;
			if (profession_asset != null && profession_asset.can_capture)
			{
				City city = pActor.current_zone.city;
				if (city != null && city.isInDanger())
				{
					return false;
				}
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool isPossible(ref DecisionChecks pChecks)
	{
		if (only_hungry && !pChecks.is_hungry)
		{
			return false;
		}
		if (only_safe && pChecks.is_fighting)
		{
			return false;
		}
		if (only_herd && !pChecks.is_herd)
		{
			return false;
		}
		if (only_adult && !pChecks.is_adult)
		{
			return false;
		}
		if (only_mob && pChecks.is_civ)
		{
			return false;
		}
		if (only_sapient && !pChecks.is_sapient)
		{
			return false;
		}
		if (city_must_be_safe && pChecks.can_capture_city && pChecks.city_is_in_danger)
		{
			return false;
		}
		return true;
	}

	public string getLocalizedText()
	{
		return getLocaleID().Localize();
	}

	public string getLocaleID()
	{
		string pID = ((!string.IsNullOrEmpty(task_id)) ? task_id : id);
		return AssetManager.tasks_actor.get(pID).getLocaleID();
	}

	public string getFiringRate()
	{
		if (cooldown <= 0)
		{
			return "N/A";
		}
		float num = 1f / (float)cooldown;
		if (num < 0.1f)
		{
			return $"{num:0.000} Hz";
		}
		return $"{num:0.00} Hz";
	}
}
// --- End of File: DecisionAsset.cs ---



// --- Start of File: DecisionChecks.cs ---
public readonly ref struct DecisionChecks
{
	public readonly bool is_hungry;

	public readonly bool is_fighting;

	public readonly bool is_herd;

	public readonly bool is_adult;

	public readonly bool is_civ;

	public readonly bool is_sapient;

	public readonly bool city_is_in_danger;

	public readonly bool can_capture_city;

	public DecisionChecks(bool pIsHungry, bool pIsFighting, bool pIsHerd, bool pIsAdult, bool pIsCiv, bool pIsSapient, bool pCityIsInDanger, bool pCanCaptureCity)
	{
		is_hungry = pIsHungry;
		is_fighting = pIsFighting;
		is_herd = pIsHerd;
		is_adult = pIsAdult;
		is_civ = pIsCiv;
		is_sapient = pIsSapient;
		city_is_in_danger = pCityIsInDanger;
		can_capture_city = pCanCaptureCity;
	}

	public DecisionChecks(Actor pActor)
	{
		is_hungry = pActor.isHungry();
		is_fighting = pActor.isFighting();
		is_herd = pActor.asset.follow_herd;
		is_adult = pActor.isAdult();
		is_sapient = pActor.isSapient();
		is_civ = pActor.isKingdomCiv();
		city_is_in_danger = pActor.inOwnCityBorders() && pActor.city.isInDanger();
		can_capture_city = pActor.profession_asset?.can_capture ?? false;
	}
}
// --- End of File: DecisionChecks.cs ---



// --- Start of File: DecisionHelper.cs ---
public class DecisionHelper
{
	internal static UtilityBasedDecisionSystem decision_system = new UtilityBasedDecisionSystem();

	public static bool makeDecisionFor(Actor pActor, out string pLastDecisionID)
	{
		pLastDecisionID = string.Empty;
		if (pActor.isStatsDirty())
		{
			pActor.setTask("wait");
			return false;
		}
		DecisionAsset decisionAsset = decision_system.useOn(pActor);
		if (decisionAsset == null)
		{
			return false;
		}
		pLastDecisionID = decisionAsset.id;
		string pTaskId = decisionAsset.id;
		if (!string.IsNullOrEmpty(decisionAsset.task_id))
		{
			pTaskId = decisionAsset.task_id;
		}
		pActor.setTask(pTaskId);
		return true;
	}

	public static void runSimulation(Actor pActor)
	{
		decision_system.useOn(pActor, pGameplay: false);
	}

	public static void runSimulationForMindTab(Actor pActor)
	{
		decision_system.useOn(pActor, pGameplay: false);
	}
}
// --- End of File: DecisionHelper.cs ---



// --- Start of File: DecisionsLibrary.cs ---
public class DecisionsLibrary : AssetLibrary<DecisionAsset>
{
	public DecisionAsset[] list_only_civ;

	public DecisionAsset[] list_only_children;

	public DecisionAsset[] list_only_city;

	public DecisionAsset[] list_only_animal;

	public DecisionAsset[] list_others;

	public override void init()
	{
		base.init();
		initDecisionsGeneral();
		initDecisionsTraits();
		initDecisionsChildren();
		initDecisionsAnimals();
		initDecisionDiets();
		initDecisionSleep();
		initDecisionsHerd();
		initDecisionsCivs();
		initDecisionsKings();
		initDecisionsWarriors();
		initDecisionsLeaders();
		initDecisionsBoats();
		initDecisionsBees();
		initDecisionsOther();
		initDecisionsUnique();
		initDecisionsSocialize();
		initDecisionsReproduction();
		initDecisionsClans();
		initDecisionsNomads();
		initDecisionsStatusRelated();
	}

	private void initDecisionsWarriors()
	{
		add(new DecisionAsset
		{
			id = "warrior_try_join_army_group",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconSoldier",
			cooldown = 5,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				return !pActor.hasArmy();
			},
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "check_warrior_limit",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconArmyList",
			cooldown = 60,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				return pActor.inOwnCityBorders() ? true : false;
			},
			weight = 0.7f
		});
		add(new DecisionAsset
		{
			id = "city_walking_to_danger_zone",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconArrowAttackTarget",
			cooldown = 5,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.city.isInDanger())
				{
					return false;
				}
				return pActor.inOwnCityBorders() ? true : false;
			},
			weight = 2.7f
		});
		add(new DecisionAsset
		{
			id = "warrior_army_captain_idle_walking_city",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconArmyList",
			cooldown = 20,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isArmyGroupLeader())
				{
					return false;
				}
				return !pActor.city.hasAttackZoneOrder();
			},
			weight = 1.3f
		});
		add(new DecisionAsset
		{
			id = "warrior_army_captain_waiting",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconClock",
			cooldown = 20,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isArmyGroupLeader())
				{
					return false;
				}
				return !pActor.city.hasAttackZoneOrder();
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "warrior_army_leader_move_random",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 1,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				return pActor.isArmyGroupLeader() ? true : false;
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "warrior_army_leader_move_to_attack_target",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconArrowAttackTarget",
			cooldown = 1,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isArmyGroupLeader())
				{
					return false;
				}
				return pActor.city.hasAttackZoneOrder() ? true : false;
			},
			weight = 2f
		});
		add(new DecisionAsset
		{
			id = "warrior_army_follow_leader",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconLoyalty",
			cooldown = 1,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isArmyGroupWarrior())
				{
					return false;
				}
				if (!pActor.army.hasCaptain())
				{
					return false;
				}
				WorldTile current_tile2 = pActor.army.getCaptain().current_tile;
				if (!pActor.current_tile.isSameIsland(current_tile2))
				{
					return false;
				}
				return pActor.city.hasAttackZoneOrder() ? true : false;
			},
			weight = 5f
		});
		add(new DecisionAsset
		{
			id = "warrior_random_move",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 4,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isArmyGroupWarrior())
				{
					return false;
				}
				if (!pActor.army.hasCaptain())
				{
					return true;
				}
				WorldTile current_tile = pActor.army.getCaptain().current_tile;
				return !pActor.current_tile.isSameIsland(current_tile);
			},
			weight = 1.6f
		});
		add(new DecisionAsset
		{
			id = "check_warrior_transport",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 6,
			unique = true,
			weight = 2f
		});
		add(new DecisionAsset
		{
			id = "warrior_train_with_dummy",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconWarfare",
			cooldown = 100,
			unique = true,
			city_must_be_safe = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.inOwnCityBorders())
				{
					return false;
				}
				return pActor.city.hasBuildingType("type_training_dummies", pCountOnlyFinished: true, pActor.current_island) ? true : false;
			},
			weight = 1.1f
		});
	}

	private void initDecisionsStatusRelated()
	{
		add(new DecisionAsset
		{
			id = "check_swearing",
			priority = NeuroLayer.Layer_3_High,
			task_id = "swearing",
			path_icon = "ui/Icons/iconSwearing",
			cooldown_on_launch_failure = true,
			cooldown = 60,
			unique = true,
			action_check_launch = (Actor _) => Randy.randomChance(0.1f) ? true : false,
			weight = 0.1f
		});
		add(new DecisionAsset
		{
			id = "do_tantrum",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconTantrum",
			cooldown = 1,
			unique = true,
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "possessed_following",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconPossessed",
			cooldown = 1,
			unique = true,
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "status_confused",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconConfused",
			cooldown = 1,
			unique = true,
			weight = 3.5f
		});
		add(new DecisionAsset
		{
			id = "run_to_water_when_on_fire",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconFire",
			cooldown = 1,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.asset.run_to_water_when_on_fire ? true : false,
			weight = 5f
		});
	}

	private void initDecisionsNomads()
	{
		add(new DecisionAsset
		{
			id = "try_to_start_new_civilization",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconKingdom",
			cooldown_on_launch_failure = true,
			cooldown = 30,
			unique = true,
			only_sapient = true,
			only_safe = true,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isKing())
				{
					return false;
				}
				if (pActor.hasCity())
				{
					return false;
				}
				if (pActor.current_zone.hasCity())
				{
					if (!pActor.current_zone.city.isNeutral())
					{
						return false;
					}
				}
				else if (!pActor.canBuildNewCity())
				{
					return false;
				}
				return true;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "check_join_city",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCity",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasCity())
				{
					return false;
				}
				if (pActor.kingdom.asset.is_forced_by_trait)
				{
					return false;
				}
				return pActor.current_zone.hasCity() ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "check_join_empty_nearby_city",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCity",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasCity())
				{
					return false;
				}
				return !pActor.kingdom.asset.is_forced_by_trait;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "build_civ_city_here",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCity",
			cooldown = 60,
			only_adult = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isKingdomCiv())
				{
					return false;
				}
				if (pActor.hasCity())
				{
					return false;
				}
				return !Finder.isEnemyNearOnSameIsland(pActor);
			},
			weight = 1f
		});
	}

	private void initDecisionsHerd()
	{
		add(new DecisionAsset
		{
			id = "family_check_existence",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconFamily",
			cooldown = 60,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.family.countUnits() <= 1,
			weight = 2f
		});
		add(new DecisionAsset
		{
			id = "family_alpha_move",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconFamily",
			cooldown = 200,
			unique = true,
			only_herd = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isSapient())
				{
					return false;
				}
				return pActor.family.isAlpha(pActor) ? true : false;
			},
			weight = 0.8f
		});
		add(new DecisionAsset
		{
			id = "family_group_follow",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconFamily",
			cooldown = 5,
			unique = true,
			only_herd = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isSapient())
				{
					return false;
				}
				return !pActor.family.isAlpha(pActor);
			},
			weight = 0.7f
		});
		add(new DecisionAsset
		{
			id = "family_group_leave",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconFamily",
			cooldown = 20,
			unique = true,
			only_herd = true,
			only_adult = true,
			only_safe = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isSapient())
				{
					return false;
				}
				if (!pActor.family.isFull())
				{
					return false;
				}
				return !pActor.family.isAlpha(pActor);
			},
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "family_group_join_or_new_herd",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconFamily",
			cooldown = 60,
			only_herd = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isSapient())
				{
					return false;
				}
				return !pActor.hasFamily();
			},
			weight = 0.3f
		});
	}

	private void initDecisionSleep()
	{
		add(new DecisionAsset
		{
			id = "bored_sleep",
			priority = NeuroLayer.Layer_0_Minimal,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			cooldown = 90,
			only_safe = true,
			city_must_be_safe = true,
			weight = 0.05f
		});
		add(new DecisionAsset
		{
			id = "polyphasic_sleep",
			priority = NeuroLayer.Layer_1_Low,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 90,
			only_safe = true,
			city_must_be_safe = true,
			weight = 0.8f
		});
		add(new DecisionAsset
		{
			id = "monophasic_sleep",
			priority = NeuroLayer.Layer_1_Low,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 200,
			only_safe = true,
			city_must_be_safe = true,
			weight = 0.75f
		});
		add(new DecisionAsset
		{
			id = "sleep_at_winter_age",
			priority = NeuroLayer.Layer_2_Moderate,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 30,
			only_safe = true,
			city_must_be_safe = true,
			action_check_launch = (Actor _) => World.world.era_manager.isWinter() ? true : false,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "sleep_at_dark_age",
			priority = NeuroLayer.Layer_2_Moderate,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 30,
			only_safe = true,
			city_must_be_safe = true,
			action_check_launch = (Actor _) => World.world.era_manager.isNight() ? true : false,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "sleep_when_not_chaos_age",
			priority = NeuroLayer.Layer_2_Moderate,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 30,
			only_safe = true,
			city_must_be_safe = true,
			action_check_launch = (Actor _) => !World.world.era_manager.isChaosAge(),
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "sleep_at_light_age",
			priority = NeuroLayer.Layer_2_Moderate,
			task_id = "decide_where_to_sleep",
			path_icon = "ui/Icons/iconSleep",
			unique = true,
			cooldown = 30,
			only_safe = true,
			city_must_be_safe = true,
			action_check_launch = (Actor _) => World.world.era_manager.isLightAge() ? true : false,
			weight = 1f
		});
	}

	private void initDecisionDiets()
	{
		add(new DecisionAsset
		{
			id = "diet_wood",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_xylophagy",
			unique = true,
			cooldown = 30,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_tiles",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_geophagy",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_minerals",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_lithotroph",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_algae",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_algivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_fish",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_piscivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_fruits",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_frugivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_flowers",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_florivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_nectar",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_nectarivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_crops",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_granivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_vegetation",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_folivore",
			unique = true,
			cooldown = 10,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_grass",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_graminivore",
			unique = true,
			cooldown = 20,
			only_safe = true,
			only_hungry = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "diet_meat",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_carnivore",
			unique = true,
			cooldown = 55,
			only_safe = true,
			only_hungry = true,
			cooldown_on_launch_failure = true,
			weight = 0.96f
		});
		add(new DecisionAsset
		{
			id = "diet_blood",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_hematophagy",
			unique = true,
			cooldown = 55,
			only_safe = true,
			only_hungry = true,
			cooldown_on_launch_failure = true,
			weight = 0.96f
		});
		add(new DecisionAsset
		{
			id = "diet_meat_insect",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_insectivore",
			unique = true,
			cooldown = 55,
			only_safe = true,
			only_hungry = true,
			cooldown_on_launch_failure = true,
			weight = 0.96f
		});
		add(new DecisionAsset
		{
			id = "diet_same_species",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_diet_cannibalism",
			unique = true,
			cooldown = 60,
			only_safe = true,
			only_hungry = true,
			cooldown_on_launch_failure = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.getNutritionRatio() >= 0.1f)
				{
					return false;
				}
				return pActor.hasStatus("starving") ? true : false;
			},
			weight = 0.3f
		});
	}

	private void initDecisionsAnimals()
	{
		add(new DecisionAsset
		{
			id = "run_away_from_carnivore",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/actor_traits/iconAgile",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isAnimal())
				{
					return false;
				}
				bool flag = false;
				if (!pActor.isCarnivore())
				{
					flag = Finder.isEnemyNearOnSameIslandAndCarnivore(pActor);
				}
				return flag ? true : false;
			},
			weight = 2f
		});
		add(new DecisionAsset
		{
			id = "check_if_stuck_on_small_land",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconTileSoil",
			cooldown = 90,
			action_check_launch = (Actor pActor) => !pActor.current_tile.region.island.isGoodIslandForActor(pActor),
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "run_away",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/actor_traits/iconAgile",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isFighting())
				{
					return false;
				}
				return pActor.getHealthRatio() > 0.2f;
			},
			weight = 3.1f
		});
		add(new DecisionAsset
		{
			id = "run_away_being_sus",
			priority = NeuroLayer.Layer_3_High,
			task_id = "run_away",
			path_icon = "ui/Icons/actor_traits/iconAgile",
			cooldown = 10,
			unique = true,
			action_check_launch = (Actor pActor) => true,
			weight = 5f
		});
	}

	private void initDecisionsSocialize()
	{
		add(new DecisionAsset
		{
			id = "socialize_initial_check",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/culture_traits/culture_trait_gossip_lovers",
			cooldown = 30,
			unique = true,
			cooldown_on_launch_failure = true,
			action_check_launch = (Actor pActor) => pActor.canSocialize() ? true : false,
			weight = 0.5f
		});
	}

	private void initDecisionsReproduction()
	{
		add(new DecisionAsset
		{
			id = "sexual_reproduction_try",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_sexual",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 20,
			only_adult = true,
			only_safe = true,
			city_must_be_safe = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (!pActor.hasLover())
				{
					return false;
				}
				if (pActor.isHungry())
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_divine",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_divine",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 60,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (pActor.hasLover())
				{
					return false;
				}
				if (pActor.hasTrait("miracle_bearer"))
				{
					return false;
				}
				if (pActor.getAgeRatio() < 0.6f)
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "status_soul_harvested",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconSoulHarvested",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 40,
			only_safe = true,
			action_check_launch = delegate(Actor pActor)
			{
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_fission",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_fission",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 20,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (pActor.getHealthRatio() < 0.9f)
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_budding",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_budding",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 50,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (pActor.getHealthRatio() < 0.9f)
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_parthenogenesis",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_parthenogenesis",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 40,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isSexFemale())
				{
					return false;
				}
				if (!pActor.canBreed())
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_spores",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_spores",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 60,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (!pActor.hasStatus("just_ate"))
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight_calculate_custom = (Actor pActor) => (!pActor.hasReachedOffspringLimit()) ? 2f : 0.1f
		});
		add(new DecisionAsset
		{
			id = "asexual_reproduction_vegetative",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_reproduction_vegetative",
			unique = true,
			cooldown_on_launch_failure = true,
			cooldown = 30,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.canBreed())
				{
					return false;
				}
				if (pActor.hasStatus("taking_roots"))
				{
					return false;
				}
				pActor.subspecies.countReproductionNeuron();
				return true;
			},
			weight = 2.5f
		});
	}

	private void initDecisionsClans()
	{
		add(new DecisionAsset
		{
			id = "try_new_plot",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconPlot",
			cooldown = 40,
			list_civ = true,
			only_adult = true,
			only_safe = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasPlot())
				{
					return false;
				}
				return pActor.hasClan() ? true : false;
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "check_plot",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconPlot",
			cooldown = 3,
			only_safe = true,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.hasPlot() ? true : false,
			weight = 5f
		});
	}

	private void initDecisionsKings()
	{
		add(new DecisionAsset
		{
			id = "king_check_new_city_foundation",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCity",
			cooldown = 60,
			unique = true,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!WorldLawLibrary.world_law_kingdom_expansion.isEnabled())
				{
					return false;
				}
				return !pActor.kingdom.hasEnemies();
			},
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "king_change_kingdom_language",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconLanguage",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasLanguage())
				{
					return false;
				}
				return (pActor.kingdom.getLanguage() != pActor.language) ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "king_change_kingdom_culture",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCulture",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCulture())
				{
					return false;
				}
				return (pActor.kingdom.getCulture() != pActor.culture) ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "king_change_kingdom_religion",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconReligion",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasReligion())
				{
					return false;
				}
				return (pActor.kingdom.getReligion() != pActor.religion) ? true : false;
			},
			weight = 1f
		});
	}

	private void initDecisionsLeaders()
	{
		add(new DecisionAsset
		{
			id = "leader_change_city_language",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconLanguage",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.hasLanguage())
				{
					return false;
				}
				return (pActor.city.getLanguage() != pActor.language) ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "leader_change_city_culture",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconCulture",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.hasCulture())
				{
					return false;
				}
				return (pActor.city.getCulture() != pActor.culture) ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "leader_change_city_religion",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconReligion",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.hasReligion())
				{
					return false;
				}
				return (pActor.city.getReligion() != pActor.religion) ? true : false;
			},
			weight = 1f
		});
	}

	private void initDecisionsCivs()
	{
		add(new DecisionAsset
		{
			id = "try_to_return_to_home_city",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconHoused",
			cooldown = 15,
			unique = true,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (pActor.inOwnCityBorders())
				{
					return false;
				}
				return !pActor.inOwnCityIsland();
			},
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "random_move_near_house",
			priority = NeuroLayer.Layer_0_Minimal,
			path_icon = "ui/Icons/iconLivingHouse",
			cooldown = 30,
			action_check_launch = (Actor pActor) => pActor.hasHouse() ? true : false,
			weight = 0.3f
		});
		add(new DecisionAsset
		{
			id = "try_to_read",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBooks",
			cooldown = 120,
			only_adult = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (pActor.stats["intelligence"] <= 5f)
				{
					return false;
				}
				return pActor.city.hasBooksToRead(pActor) ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "try_affect_dreams",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/subspecies_traits/subspecies_trait_dreamweavers",
			cooldown = 120,
			only_adult = true,
			unique = true,
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "try_to_take_city_item",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconEquipmentEditor2",
			cooldown = 180,
			unique = true,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.inOwnCityBorders())
				{
					return false;
				}
				return pActor.city.data.equipment.hasAnyItem() ? true : false;
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "make_items",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconReforge",
			cooldown = 90,
			unique = true,
			only_adult = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasHouse())
				{
					return false;
				}
				if (!pActor.inOwnCityBorders())
				{
					return false;
				}
				return pActor.city.hasResourcesForNewItems() ? true : false;
			},
			weight = 0.4f
		});
		add(new DecisionAsset
		{
			id = "city_idle_walking",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconCity",
			cooldown = 5,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.city.hasZones() ? true : false,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "store_resources",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconCityInventory",
			cooldown = 5,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isCarryingResources())
				{
					return false;
				}
				if (!pActor.city.hasStorageBuilding())
				{
					return false;
				}
				return (!pActor.isWarrior() || pActor.inOwnCityBorders()) ? true : false;
			},
			weight = 3.1f
		});
		add(new DecisionAsset
		{
			id = "stay_in_own_home",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconHoused",
			cooldown = 15,
			list_civ = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasHouse())
				{
					return false;
				}
				if (pActor.getHappinessRatio() > 0.5f)
				{
					return false;
				}
				return Randy.randomChance(0.2f) ? true : false;
			},
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "generate_loot",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconLoot",
			cooldown = 60,
			list_civ = true,
			action_check_launch = (Actor pActor) => pActor.hasHouse() ? true : false,
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "try_to_eat_city_food",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconHunger",
			cooldown = 10,
			unique = true,
			only_hungry = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				return pActor.city.hasSuitableFood(pActor.subspecies) ? true : false;
			},
			weight = 2.6f
		});
		add(new DecisionAsset
		{
			id = "find_city_job",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconShowTasks",
			cooldown = 50,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!pActor.isInCityIsland())
				{
					return false;
				}
				if (!pActor.city.jobs.hasAnyTask())
				{
					return false;
				}
				if (!pActor.canWork())
				{
					return false;
				}
				return (pActor.city.getPopulationPeople() <= 30 || !pActor.isWarrior()) ? true : false;
			},
			weight_calculate_custom = delegate(Actor pActor)
			{
				float result = 2f;
				if (pActor.isStarving())
				{
					result = 0.3f;
				}
				else if (pActor.isHungry())
				{
					result = 1f;
				}
				return result;
			}
		});
		add(new DecisionAsset
		{
			id = "claim_land",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/citizen_jobs/iconCitizenLandClaimer",
			cooldown = 60,
			unique = true,
			cooldown_on_launch_failure = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				return pActor.city.canGrowZones() ? true : false;
			},
			weight_calculate_custom = (Actor pActor) => 2f + pActor.stats["stewardship"] / 5f * 0.1f
		});
		add(new DecisionAsset
		{
			id = "put_out_fire",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconMoney",
			cooldown = 1,
			cooldown_on_launch_failure = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.inOwnCityBorders())
				{
					return false;
				}
				if (!pActor.city.isCityUnderDangerFire())
				{
					return false;
				}
				return !pActor.hasStatus("burning");
			},
			weight = 4f
		});
		add(new DecisionAsset
		{
			id = "give_tax",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconMoney",
			cooldown = 90,
			cooldown_on_launch_failure = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.inOwnCityBorders())
				{
					return false;
				}
				return (pActor.data.loot >= pActor.kingdom.getLootMin()) ? true : false;
			},
			weight = 2.55f
		});
		add(new DecisionAsset
		{
			id = "check_city_destroyed",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconWar",
			cooldown = 10,
			list_civ = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasCity())
				{
					return false;
				}
				if (pActor.profession_asset == null)
				{
					return false;
				}
				return pActor.profession_asset.cancel_when_no_city ? true : false;
			},
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "check_lover_city",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconCity",
			cooldown = 30,
			only_adult = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isKing())
				{
					return false;
				}
				if (pActor.isCityLeader())
				{
					return false;
				}
				if (pActor.isSexMale())
				{
					return false;
				}
				if (!pActor.hasLover())
				{
					return false;
				}
				if (!pActor.lover.hasCity())
				{
					return false;
				}
				if (!pActor.lover.hasHouse())
				{
					return false;
				}
				return !pActor.hasSameCity(pActor.lover);
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "find_lover",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconArrowLover",
			cooldown = 50,
			only_adult = true,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasLover())
				{
					return false;
				}
				return pActor.isBreedingAge() ? true : false;
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "find_house",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBuildings",
			cooldown = 10,
			unique = true,
			action_check_launch = (Actor pActor) => !pActor.hasHouse(),
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "replenish_energy",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconStamina",
			cooldown = 30,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isStaminaFull() && pActor.isManaFull())
				{
					return false;
				}
				return pActor.getCity().hasBuildingType("type_well", pCountOnlyFinished: true, pActor.current_island) ? true : false;
			},
			weight = 0.3f
		});
		add(new DecisionAsset
		{
			id = "repair_equipment",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconReforge",
			cooldown = 300,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasEquipment())
				{
					return false;
				}
				return pActor.getCity().hasBuildingType("type_barracks", pCountOnlyFinished: true, pActor.current_island) ? true : false;
			},
			weight = 0.3f
		});
	}

	private void initDecisionsBoats()
	{
		add(new DecisionAsset
		{
			id = "boat_check_existence",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 5,
			unique = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "boat_danger_check",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 5,
			unique = true,
			weight = 1.25f
		});
		add(new DecisionAsset
		{
			id = "boat_idle",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 5,
			unique = true,
			weight = 0.75f
		});
		add(new DecisionAsset
		{
			id = "boat_check_limits",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 15,
			unique = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "boat_fishing",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconResFish",
			cooldown = 1,
			unique = true,
			weight = 1.3f
		});
		add(new DecisionAsset
		{
			id = "boat_trading",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconCityInventory",
			cooldown = 1,
			unique = true,
			weight = 1.3f
		});
		add(new DecisionAsset
		{
			id = "boat_transport_check",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBoat",
			cooldown = 1,
			unique = true,
			weight = 1.3f
		});
	}

	private void initDecisionsBees()
	{
		add(new DecisionAsset
		{
			id = "pollinate",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconBee",
			cooldown = 10,
			unique = true,
			weight = 1.3f,
			action_check_launch = (Actor pActor) => (!(pActor.asset.id == "bee") || pActor.hasHomeBuilding()) ? true : false
		});
		add(new DecisionAsset
		{
			id = "bee_find_hive",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBeehive",
			cooldown = 20,
			only_mob = true,
			unique = true,
			weight = 1.5f,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.isKingdomCiv())
				{
					return false;
				}
				return !pActor.hasHomeBuilding();
			}
		});
		add(new DecisionAsset
		{
			id = "bee_create_hive",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBeehive",
			cooldown = 200,
			unique = true,
			only_mob = true,
			cooldown_on_launch_failure = true,
			weight = 1.5f,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.hasHomeBuilding())
				{
					return false;
				}
				return pActor.isSexFemale() ? true : false;
			}
		});
	}

	private void initDecisionsGeneral()
	{
		add(new DecisionAsset
		{
			id = "swim_to_island",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconTileShallowWater",
			cooldown = 1,
			action_check_launch = (Actor pActor) => !pActor.isInStablePlace(),
			weight = 4f
		});
		add(new DecisionAsset
		{
			id = "move_to_water",
			priority = NeuroLayer.Layer_4_Critical,
			path_icon = "ui/Icons/iconTileShallowWater",
			cooldown = 1,
			action_check_launch = (Actor pActor) => !pActor.isInStablePlace(),
			weight = 4f
		});
		add(new DecisionAsset
		{
			id = "random_move",
			priority = NeuroLayer.Layer_0_Minimal,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 1,
			weight = 0.2f
		});
		add(new DecisionAsset
		{
			id = "random_fun_move",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 10,
			list_animal = true,
			weight = 0.2f
		});
		add(new DecisionAsset
		{
			id = "wait5",
			priority = NeuroLayer.Layer_0_Minimal,
			path_icon = "ui/Icons/iconClock",
			cooldown = 10,
			weight = 0.1f
		});
	}

	private void initDecisionsTraits()
	{
		add(new DecisionAsset
		{
			id = "follow_desire_target",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconGoldBrain",
			cooldown = 5,
			unique = true,
			weight = 4f
		});
		add(new DecisionAsset
		{
			id = "try_to_poop",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconPoop",
			cooldown = 60,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.asset.actor_size == ActorSize.S0_Bug)
				{
					return false;
				}
				return !pActor.hasSubspeciesTrait("reproduction_spores");
			},
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "try_to_launch_fireworks",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconFireworks",
			cooldown = 60,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.hasEnoughMoney(SimGlobals.m.festive_fireworks_cost) ? true : false,
			weight = 1.5f
		});
		add(new DecisionAsset
		{
			id = "reflection",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconBre",
			cooldown = 100,
			unique = true,
			action_check_launch = (Actor pActor) => pActor.subspecies.can_process_emotions ? true : false,
			weight = 2.5f
		});
		add(new DecisionAsset
		{
			id = "madness_random_emotion",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/actor_traits/iconMadness",
			cooldown = 60,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasSubspecies())
				{
					return false;
				}
				return pActor.subspecies.can_process_emotions ? true : false;
			},
			weight = 2.5f
		});
		add(new DecisionAsset
		{
			id = "try_to_steal_money",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/actor_traits/iconThief",
			cooldown = 60,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.isHungry())
				{
					return false;
				}
				return pActor.canGetFoodFromCity() ? true : false;
			},
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "kill_unruly_clan_members",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/clan_traits/clan_trait_deathbound",
			cooldown = 200,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.clan.getChief() != pActor)
				{
					return false;
				}
				return pActor.kingdom.hasEnemies() ? true : false;
			},
			weight = 3f
		});
		add(new DecisionAsset
		{
			id = "banish_unruly_clan_members",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/clan_traits/clan_trait_blood_pact",
			cooldown = 200,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (pActor.clan.getChief() != pActor)
				{
					return false;
				}
				return pActor.kingdom.hasEnemies() ? true : false;
			},
			weight = 3f
		});
	}

	private void initDecisionsUnique()
	{
		add(new DecisionAsset
		{
			id = "check_heal",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconHealth",
			cooldown = 5,
			unique = true,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "make_skeleton",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconSkeleton",
			cooldown = 10,
			unique = true,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "spawn_fertilizer",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconFertilizerPlants",
			cooldown = 10,
			unique = true,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "random_teleport",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 20,
			unique = true,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "teleport_back_home",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 60,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.hasCity())
				{
					return false;
				}
				if (!Randy.randomChance(0.3f))
				{
					return false;
				}
				WorldTile tile = pActor.city.getTile();
				if (tile == null)
				{
					return false;
				}
				return !tile.isSameIsland(pActor.current_tile);
			},
			unique = true,
			weight = 1f
		});
		add(new DecisionAsset
		{
			id = "check_cure",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconHealth",
			cooldown = 15,
			unique = true,
			action_check_launch = (Actor _) => Randy.randomChance(0.3f) ? true : false,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "burn_tumors",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconFire",
			cooldown = 10,
			unique = true,
			action_check_launch = (Actor _) => Randy.randomChance(0.5f) ? true : false,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "random_move_towards_civ_building",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconArrowDestination",
			cooldown = 10,
			unique = true,
			weight = 0.5f
		});
		add(new DecisionAsset
		{
			id = "random_swim",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconTileShallowWater",
			cooldown = 10,
			unique = true,
			weight = 2f
		});
	}

	private void initDecisionsOther()
	{
		add(new DecisionAsset
		{
			id = "attack_golden_brain",
			priority = NeuroLayer.Layer_3_High,
			path_icon = "ui/Icons/iconGoldBrain",
			cooldown = 60,
			only_mob = true,
			unique = true,
			weight = 1f
		});
	}

	private void initDecisionsChildren()
	{
		add(new DecisionAsset
		{
			id = "child_random_flips",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconChildren",
			cooldown = 5,
			list_baby = true,
			weight = 0.1f
		});
		add(new DecisionAsset
		{
			id = "child_play_at_one_spot",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconChildren",
			cooldown = 5,
			list_baby = true,
			weight = 0.1f
		});
		add(new DecisionAsset
		{
			id = "child_random_jump",
			priority = NeuroLayer.Layer_1_Low,
			path_icon = "ui/Icons/iconChildren",
			cooldown = 5,
			list_baby = true,
			weight = 0.1f
		});
		add(new DecisionAsset
		{
			id = "child_follow_parent",
			priority = NeuroLayer.Layer_2_Moderate,
			path_icon = "ui/Icons/iconAdults",
			cooldown = 10,
			unique = true,
			action_check_launch = delegate(Actor pActor)
			{
				if (!pActor.family.hasFounders())
				{
					return false;
				}
				return pActor.isBaby() ? true : false;
			},
			weight = 0.2f
		});
	}

	public override void editorDiagnosticLocales()
	{
		base.editorDiagnosticLocales();
		foreach (DecisionAsset item in list)
		{
			checkLocale(item, item.getLocaleID());
		}
	}

	public override void linkAssets()
	{
		using ListPool<DecisionAsset> listPool3 = new ListPool<DecisionAsset>();
		using ListPool<DecisionAsset> listPool = new ListPool<DecisionAsset>();
		using ListPool<DecisionAsset> listPool5 = new ListPool<DecisionAsset>();
		using ListPool<DecisionAsset> listPool2 = new ListPool<DecisionAsset>();
		using ListPool<DecisionAsset> listPool4 = new ListPool<DecisionAsset>();
		int num = 0;
		foreach (DecisionAsset item in list)
		{
			item.decision_index = num++;
			item.priority_int_cached = (int)item.priority;
			item.has_weight_custom = item.weight_calculate_custom != null;
			if (!item.unique)
			{
				if (item.list_baby)
				{
					listPool.Add(item);
				}
				else if (item.list_animal)
				{
					listPool2.Add(item);
				}
				else if (item.list_civ)
				{
					listPool3.Add(item);
				}
				else
				{
					listPool4.Add(item);
				}
			}
		}
		list_only_civ = listPool3.ToArray();
		list_only_children = listPool.ToArray();
		list_only_city = listPool5.ToArray();
		list_only_animal = listPool2.ToArray();
		list_others = listPool4.ToArray();
		base.linkAssets();
	}

	public override void editorDiagnostic()
	{
		foreach (DecisionAsset item in list)
		{
			checkSpriteExists("path_icon", item.path_icon, item);
		}
		foreach (DecisionAsset item2 in list)
		{
			int num = 0;
			if (item2.unique && (item2.list_civ || item2.list_baby || item2.list_animal))
			{
				BaseAssetLibrary.logAssetError("<e>" + item2.id + "</e>: Unique but also has list setting?");
			}
			if (list_only_civ.Contains(item2))
			{
				num++;
			}
			if (list_only_children.Contains(item2))
			{
				num++;
			}
			if (list_only_city.Contains(item2))
			{
				num++;
			}
			if (list_only_animal.Contains(item2))
			{
				num++;
			}
			if (list_others.Contains(item2))
			{
				num++;
			}
			if (item2.unique && num > 0)
			{
				BaseAssetLibrary.logAssetError("<e>" + item2.id + "</e>: Unique but also in a list?");
			}
			if (!item2.unique && num == 0)
			{
				BaseAssetLibrary.logAssetError("<e>" + item2.id + "</e>: Not unique but not in any list?");
			}
			if (num > 1)
			{
				BaseAssetLibrary.logAssetError("<e>" + item2.id + "</e>: In multiple lists?");
			}
		}
		base.editorDiagnostic();
	}
}
// --- End of File: DecisionsLibrary.cs ---



=== END OF SOURCE 1 ===

