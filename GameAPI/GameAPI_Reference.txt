public class Achievement : Asset, IDescriptionAsset, ILocalizedAsset
	public string play_store_id;
	public string steam_id;
	public bool hidden;
	public string group = "miscellaneous";
	public string icon;
	public string locale_key;
	public AchievementCheck action;
	public bool unlocks_something;
	public List<BaseUnlockableAsset> unlock_assets;
	protected Sprite cached_sprite;
	private SignalAsset _signal;
	public bool has_signal;
	public void checkBySignal(object pCheckData = null)
	public bool check(object pCheckData = null)
		bool flag = true;
	private void checkUnlockables()
	public bool isUnlocked()
	public string getLocaleID()
	public string getDescriptionID()
	public Sprite getIcon()
	public void setSignal(SignalAsset pSignal)
	public SignalAsset getSignal()
public class AchievementButton : MonoBehaviour
	private Achievement _achievement;
	private Image _icon;
	private Image _background_completed;
	private Image _background_legendary;
	private GameObject _background_default;
	private GameObject _icon_medal;
	public void Load(Achievement pAchievement)
	private void Start()
	private void showHoverTooltip()
	private void showTooltip()
public delegate bool AchievementCheck(object pCheckData);
public class AchievementGoodie : MonoBehaviour
	private Image _icon;
	private Text _name;
	public void load(BaseUnlockableAsset pAsset, bool pUnlocked)
	private void loadLocked(BaseUnlockableAsset pAsset)
	private void loadUnlocked(BaseUnlockableAsset pAssets)
public class AchievementGroup : MonoBehaviour
	public AchievementButton achievementButtonPrefab;
	private List<AchievementButton> _elements = new List<AchievementButton>();
	public Text title;
	public Text counter;
	public Transform transformContent;
	public void showGroup(AchievementGroupAsset pAchievementGroup)
		int num = 0;
public class AchievementGroupAsset : BaseCategoryAsset, ILocalizedAsset
	public List<Achievement> achievements_list = new List<Achievement>();
	public override string getLocaleID()
public class AchievementGroupLibrary : AssetLibrary<AchievementGroupAsset>
	public override void init()
			id = "destruction",
	public override void linkAssets()
	public override void editorDiagnosticLocales()
public class AchievementLibrary : AssetLibrary<Achievement>
	private const int ZOO_SPECIES_NEED = 33;
	private const int SPECIES_EXPLORER_ASSETS = 52;
	private const int TRAITS_EXPLORER_AMOUNT_FIRST = 40;
	private const int TRAITS_EXPLORER_AMOUNT_SECOND = 60;
	private const int TRAITS_EXPLORER_AMOUNT_THIRD = 90;
	private const int SUBSPECIES_TRAITS_EXPLORER_AMOUNT = 190;
	private const int CULTURE_TRAITS_EXPLORER_AMOUNT = 70;
	private const int LANGUAGE_TRAITS_EXPLORER_AMOUNT = 20;
	private const int CLAN_TRAITS_EXPLORER_AMOUNT = 25;
	private const int RELIGION_TRAITS_EXPLORER_AMOUNT = 33;
	private const int EQUIPMENT_EXPLORER_AMOUNT = 80;
	private const int GENES_EXPLORER_AMOUNT = 35;
	private const int PLOTS_EXPLORER_AMOUNT = 20;
	private const string ONOMASTICS_NAME_FOR_ACHIEVEMENT = "Mako Mako";
	private const int NOT_JUST_A_CULT_UNITS = 7777;
	private const int MULTIPLY_SPOKEN_UNITS = 5555;
	public static Achievement lava_strike;
	public static Achievement baby_tornado;
	public static Achievement rain_tornado;
	public static Achievement many_bombs;
	public static Achievement megapolis;
	public static Achievement wilhelm_scream;
	public static Achievement burger;
	public static Achievement mayday;
	public static Achievement destroy_worldbox;
	public static Achievement custom_world;
	public static Achievement four_race_cities;
	public static Achievement piranha_land;
	public static Achievement print_heart;
	public static Achievement sacrifice;
	public static Achievement final_resolution;
	public static Achievement tnt_and_heat;
	public static Achievement god_finger_lightning;
	public static Achievement ten_thousands_creatures;
	public static Achievement ant_world;
	public static Achievement traits_explorer_40;
	public static Achievement traits_explorer_60;
	public static Achievement traits_explorer_90;
	public static Achievement trait_explorer_subspecies;
	public static Achievement trait_explorer_culture;
	public static Achievement trait_explorer_language;
	public static Achievement trait_explorer_clan;
	public static Achievement trait_explorer_religion;
	public static Achievement equipment_explorer;
	public static Achievement genes_explorer;
	public static Achievement creatures_explorer;
	public static Achievement plots_explorer;
	public static Achievement the_builder;
	public static Achievement the_dwarf;
	public static Achievement the_creator;
	public static Achievement the_light;
	public static Achievement the_sky;
	public static Achievement the_land;
	public static Achievement the_sun;
	public static Achievement the_moon;
	public static Achievement the_living;
	public static Achievement the_rest_day;
	public static Achievement life_is_a_sim;
	public static Achievement gen_5_worlds;
	public static Achievement gen_50_worlds;
	public static Achievement gen_100_worlds;
	public static Achievement the_corrupted_trees;
	public static Achievement the_hell;
	public static Achievement lets_not;
	public static Achievement world_war;
	public static Achievement planet_of_apes;
	public static Achievement super_mushroom;
	public static Achievement the_princess;
	public static Achievement oh_my_crab;
	public static Achievement tornado;
	public static Achievement god_mode;
	public static Achievement greg;
	public static Achievement ninja_turtle;
	public static Achievement great_plague;
	public static Achievement no_hope_only_mush;
	public static Achievement touch_the_grass;
	public static Achievement the_broken;
	public static Achievement the_king;
	public static Achievement the_demon;
	public static Achievement the_accomplished;
	public static Achievement cursed_world;
	public static Achievement boats_disposal;
	public static Achievement engineered_evolution;
	public static Achievement simple_stupid_genetics;
	public static Achievement fast_living;
	public static Achievement long_living;
	public static Achievement ancient_war_of_geometry_and_evil;
	public static Achievement cant_be_too_much;
	public static Achievement zoo;
	public static Achievement mindless_husk;
	public static Achievement master_weaver;
	public static Achievement not_just_a_cult;
	public static Achievement succession;
	public static Achievement multiply_spoken;
	public static Achievement child_named_toto;
	public static Achievement flick_it;
	public static Achievement segregator;
	public static Achievement swarm;
	public static Achievement eternal_chaos;
	public static Achievement minefield;
	public static Achievement godly_smithing;
	public static Achievement master_of_combat;
	public static Achievement clannibals;
	public static Achievement social_network;
	public static Achievement not_on_my_watch;
	public static Achievement may_i_interrupt;
	public static Achievement watch_your_mouth;
	public static Achievement smelly_city;
	public static Achievement ball_to_ball;
	public static Achievement back_to_beta_testing;
	public static Achievement clone_wars;
	public static Achievement sword_with_shotgun;
	public static Achievement tldr;
	public const float LIFE_IS_SIM_HOURS = 24f;
	public override void init()
			group = "destruction"
			group = "destruction"
			group = "destruction"
			group = "destruction"
			group = "destruction"
		print_heart = add(new Achievement
			group = "destruction"
			group = "destruction"
			group = "destruction"
			group = "destruction",
		may_i_interrupt = add(new Achievement
			group = "destruction",
	private void standaloneAchievements()
	public override void post_init()
	public override void linkAssets()
	private void addAsUnlockAssets(Achievement pAchievement, ILibraryWithUnlockables pLibrary)
	public static void unlock(string pID)
	public static void unlock(Achievement pAchievement)
	public static bool isUnlocked(Achievement pAchievement)
	public static bool isUnlocked(string pID)
	private static bool checkTraitsExplorer(int pAmount)
		int num = 0;
	private static bool checkUnlockAugmentations(int pAmount, ILibraryWithUnlockables pLibrary)
		int num = 0;
	private static bool checkAntWorld(object pCheckData = null)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		for (int i = 0; i < units.Count; i++)
	private static bool checkCursedWorld(object pCheckData = null)
	private static bool checkBoatDisposal(object pCheckData = null)
	private static bool check10000Creatures(object pCheckData = null)
	private static bool checkManyBombs(object pCheckData = null)
	private static bool checkMegapolis(object pCheckData = null)
	private static bool check4RaceCities(object pCheckData = null)
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		using (IEnumerator<City> enumerator = World.world.cities.GetEnumerator())
			while (enumerator.MoveNext())
				switch (enumerator.Current.getSpecies())
	private static bool checkPiranhaLand(object pCheckData = null)
		if (!actor.mustAvoidGround())
	private static bool checkPrintHeart(object pCheckData = null)
		if (((GodPower)pCheckData).printers_print == "heart")
	internal static void checkSteamMapUploads()
	internal static void checkSteamMapDownloads(int pDownloads)
	private static bool checkLifeIsASim(object pCheckData = null)
	private static bool checkTheDemon(object pCheckData = null)
	private static bool checkTheKing(object pCheckData = null)
	private static bool checkTheAccomplished(object pCheckData = null)
	private static bool checkTheBroken(object pCheckData = null)
	private static bool checkMapCreations100(object pCheckData = null)
	private static bool checkMapCreations50(object pCheckData = null)
	private static bool checkMapCreations5(object pCheckData = null)
	private static bool checkTheHell(object pCheckData = null)
		float num = TopTileLibrary.infernal_high.hashset.Count + TopTileLibrary.infernal_low.hashset.Count;
		float num2 = World.world.tiles_list.Length;
	private static bool checkLetsNot(object pCheckData = null)
		float num = TopTileLibrary.wasteland_high.hashset.Count + TopTileLibrary.wasteland_low.hashset.Count;
		float num2 = World.world.tiles_list.Length;
	private static bool checkWorldWar(object pCheckData = null)
		int num = 0;
	private static bool checkPlanetOfTheApes(object pCheckData = null)
		float num = TopTileLibrary.wasteland_high.hashset.Count + TopTileLibrary.wasteland_low.hashset.Count;
		float num2 = TopTileLibrary.jungle_high.hashset.Count + TopTileLibrary.jungle_low.hashset.Count;
		float num3 = World.world.tiles_list.Length;
		float num4 = num / num3;
		float num5 = num2 / num3;
		float num6 = num4 + num5;
	private static bool checkGreatPlague(object pCheckData = null)
	private static bool checkRainTornado(object pCheckData = null)
	private static bool checkSimpleStupidGenetics(object pCheckData = null)
	private static bool checkFastLiving(object pCheckData = null)
		int num = 2;
		float num2 = selected_subspecies.base_stats["lifespan"];
		float num3 = selected_subspecies.base_stats["lifespan"] + num2;
		float num4 = selected_subspecies.base_stats_female["lifespan"] + num2;
		if (num3 <= (float)num && num4 <= (float)num)
	private static bool checkLongLiving(object pCheckData = null)
		int num = 3000;
		float num2 = selected_subspecies.base_stats["lifespan"];
		float num3 = selected_subspecies.base_stats_male["lifespan"] + num2;
		float num4 = selected_subspecies.base_stats_female["lifespan"] + num2;
		if (num3 >= (float)num && num4 >= (float)num)
	private static bool checkAncientWarOfGeometryAndEvil(object pCheckData = null)
	private static bool checkCantBeTooMuch(object pCheckData = null)
		int num = 10;
		int num2 = 0;
	private static bool checkZoo(object pCheckData = null)
		using ListPool<string> listPool = new ListPool<string>();
		using (IEnumerator<City> enumerator = World.world.cities.GetEnumerator())
			if (enumerator.MoveNext())
				City current = enumerator.Current;
	private static bool checkMindlessHusk(object pCheckData = null)
		int counter = decision_system.getCounter();
		for (int i = 0; i < counter; i++)
	private static bool checkMasterWeaver(object pCheckData = null)
	private static bool checkNotJustACult(object pCheckData = null)
	private static bool checkMultiplySpoken(object pCheckData = null)
	private static bool checkChildNamedMakoMako(object pCheckData = null)
		if ((string)pCheckData != "Mako Mako")
	private static bool checkSegregator(object pCheckData = null)
	private static bool checkEternalChaos(object pCheckData = null)
		if ((float)Date.getYearsSince(World.world.map_stats.same_world_age_started_at) < 1000f)
	private static bool checkMinefield(object pCheckData = null)
		if ((float)Date.getYearsSince(World.world.map_stats.exploding_mushrooms_enabled_at) < 1000f)
	private static bool checkWatchYourMouth(object pCheckData = null)
	private static bool checkCloneWars(object pCheckData = null)
	private static bool checkCreaturesExplorer(object pCheckData = null)
		int num = 0;
		int num2 = 0;
	private static bool checkMasterOfCombat(object pCheckData = null)
		int num = 0;
	private static bool checkClannibals(object pCheckData = null)
	private static bool checkSmellyCity(object pCheckData = null)
	private static bool checkNotOnMyWatch(object pCheckData = null)
	private static bool checkMayIInterrupt(object pCheckData = null)
		if ((string)pCheckData != "socialize_do_talk")
	private static bool checkBallToBall(object pCheckData = null)
	private static bool checkSwordWithShotgun(object pCheckData = null)
	private static bool checkBackToBetaTesting(object pCheckData = null)
	private static bool checkSwarm(object pCheckData = null)
	public static void checkCityAchievements(City pCity)
	public static void checkUnitAchievements(Actor pActor)
	public static void checkSubspeciesAchievements(Subspecies pSubspecies)
	public static void login()
	public override void editorDiagnosticLocales()
	public static int countUnlocked()
		int num = 0;
	public static bool isAllUnlocked()
		int num = countUnlocked();
		int count = AssetManager.achievements.list.Count;
public class AchievementPopup : MonoBehaviour
	private static AchievementPopup _instance;
	private Image _icon_left;
	private Image _icon_right;
	private Text _popup_text;
	private Text _popup_description;
	private AchievementGoodie _goodie_prefab;
	private Transform _goodies_parent;
	private ObjectPoolGenericMono<AchievementGoodie> _goodie_pool;
	private Tweener _tween;
	private void Awake()
	internal static void show(string pAchievementID)
	internal static void show(Achievement pAchievement)
	private void Update()
	internal void showByID(string pAchievementID)
		float num = Screen.height;
		float num2 = (num - ((Rect)(ref safeArea)).height) / CanvasMain.instance.canvas_ui.scaleFactor;
	public void forceHide()
	private void tweenHide()
	private void hide()
	private void checkPool()
public class AchievementWindow : MonoBehaviour
	public AchievementGroup achievementGroupPrefab;
	private List<AchievementGroup> _elements = new List<AchievementGroup>();
	public Transform transformContent;
	public StatBar achievementBar;
	private void OnEnable()
	internal void showList()
		for (int i = 0; i < _elements.Count; i++)
	private void updateTotalBar()
		int count = AssetManager.achievements.list.Count;
		int num = AchievementLibrary.countUnlocked();
	private void showElement(AchievementGroupAsset pAchievementGroup)
public static class ActionExtensions
	public static bool[] Run(this WorldAction pAction, BaseSimObject pTarget = null, WorldTile pTile = null)
		bool[] array = new bool[invocationList.Length];
		int num = 0;
		for (int i = 0; i < array2.Length; i++)
	public static bool RunAnyTrue(this WorldAction pAction, BaseSimObject pTarget = null, WorldTile pTile = null)
		bool result = false;
		for (int i = 0; i < array.Length; i++)
	public static bool[] Run(this AttackAction pAction, BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		bool[] array = new bool[invocationList.Length];
		int num = 0;
		for (int i = 0; i < array2.Length; i++)
	public static bool RunAnyTrue(this AttackAction pAction, BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		bool result = false;
		for (int i = 0; i < array.Length; i++)
public delegate string ActionFormatCounterOptionAsset(OptionAsset pAsset);
public static class ActionLibrary
	public static bool unluckyMeteorite(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool unluckyFall(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool flamingWeapon(BaseSimObject pTarget, WorldTile pTile = null)
		Vector3 point = default(Vector3);
		point.x = a.cur_transform_position.x + animationFrameData.pos_item.x * a.current_scale.x;
		point.y = a.cur_transform_position.y + animationFrameData.pos_item.y * a.current_scale.y;
		point.z = -0.01f;
		float num = ((Rect)(ref rect)).height * a.current_scale.y;
	public static bool shiny(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool restoreHealthOnHit(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		int maxHealthPercent = pTarget.getMaxHealthPercent(0.05f);
	public static void throwTorchAtTile(BaseSimObject pSelf, WorldTile pTile)
		float pDist = Vector2.Distance(Vector2.op_Implicit(val), Vector2Int.op_Implicit(pos));
		Vector3 newPoint = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pDist);
		Vector3 newPoint2 = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pSelf.a.stats["size"]);
		newPoint2.y += 0.5f;
		World.world.projectiles.spawn(pSelf, null, "torch", newPoint2, newPoint);
	public static bool canThrowBomb(BaseSimObject pTarget, WorldTile pTile)
		float x = pTarget.a.current_position.x;
		float y = pTarget.a.current_position.y;
		float x2 = ((Vector2Int)(ref pos)).x;
		float num = Toolbox.Dist(x, y, x2, ((Vector2Int)(ref pos)).y);
	public static void throwBombAtTile(BaseSimObject pSelf, WorldTile pTile)
		float pDist = Vector2.Distance(Vector2.op_Implicit(val), Vector2Int.op_Implicit(pos));
		Vector3 newPoint = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pDist);
		Vector3 newPoint2 = Toolbox.getNewPoint(val.x, val.y, ((Vector2Int)(ref pos)).x, ((Vector2Int)(ref pos)).y, pSelf.a.stats["size"]);
		newPoint2.y += 0.5f;
		World.world.projectiles.spawn(pSelf, null, "firebomb", newPoint2, newPoint);
	public static bool zombieInfectAttack(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		if (pTarget.a.asset.can_turn_into_zombie && Randy.randomChance(0.5f))
	public static bool zombieEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool infectedEffect(BaseSimObject pTarget, WorldTile pTile = null)
		int num = pTarget.getHealth() / 10;
	public static bool mushSporesEffect(BaseSimObject pTarget, WorldTile pTile = null)
		int num = 3;
	public static bool tumorEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool healingAuraEffect(BaseSimObject pSelf, WorldTile pTile = null)
	public static bool heliophobiaEffect(BaseSimObject pTarget, WorldTile pTile = null)
		int num = (int)((float)a.getMaxHealth() * 0.1f) + 1;
	public static bool regenerationEffect(BaseSimObject pTarget, WorldTile pTile = null)
	private static void checkRegenerationTraits(Actor pActorTarget)
	public static bool regenerationEffectClan(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool suprisedByArchitector(BaseSimObject _, WorldTile pTile)
	public static bool coldAuraEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool megaHeartbeat(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool thornsDefense(BaseSimObject pSelf, BaseSimObject pAttackedBy, WorldTile pTile = null)
	public static bool bubbleDefense(BaseSimObject pSelf, BaseSimObject pAttackedBy, WorldTile pTile = null)
	public static bool plagueEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool energizedLightning(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool contagiousEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool deathMark(BaseSimObject pTarget, WorldTile pTile = null)
	private static void tickPlagueInfection(Actor pActor)
		int num = 3;
	public static bool burningFeetEffectTileDraw(WorldTile pTile, string pPowerID)
	public static bool burningFeetEffect(BaseSimObject pSelf, WorldTile pTile = null)
		for (int i = 0; i < current_tile.neighbours.Length; i++)
	public static bool flowerPrintsEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool acidBloodEffect(BaseSimObject pTarget, WorldTile pTile = null)
		for (int i = 0; i < 5; i++)
		for (int j = 0; j < 25; j++)
	public static bool acidTouchEffect(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool sunblessedEffect(BaseSimObject pTarget, WorldTile pTile = null)
		float pVal = Randy.randomFloat(0.05f, 0.1f);
	public static bool castSpawnSkeleton(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		int num = 0;
	public static bool spawnSkeleton(BaseSimObject pCaster, WorldTile pTile = null)
		bool tNeedNewSkeletonForm = false;
		baseEffect.setCallback(19, delegate
	public static bool castFire(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
		for (int i = 0; i < 3; i++)
	public static bool castSpellSilence(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castBloodRain(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castSpawnGrassSeeds(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castSpawnFertilizer(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castCurses(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castLightning(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castTornado(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castCure(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool castShieldOnHimself(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addShieldEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addBurningEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addFrozenEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addStunnedEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addStunnedEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addFrozenEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addSlowEffectOnTarget20(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addSlowEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static bool addPoisonedEffectOnTarget(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static void increaseDroppedBombsCounter(WorldTile pTile = null, string pDropID = null)
	public static bool giveCursed(WorldTile pTile, Actor pActor)
		bool num = pActor.addStatusEffect("cursed");
	public static bool singularityTeleportation(WorldTile pTile, Actor pActor)
	public static bool timeParadox(WorldTile pTile, Actor pActor)
	public static bool giveEnchanted(WorldTile pTile, Actor pActor)
	public static bool spawnGhost(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool tryToGrowBiomeGrass(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool tryToGrowTree(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool tryToCreatePlants(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool startNuke(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool clearCrabzilla(BaseSimObject pTarget, WorldTile pTile = null)
		MusicBox.inst.stopDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaLazer");
		MusicBox.inst.stopDrawingSound("event:/SFX/UNIQUE/Crabzilla/CrabzillaVoice");
	public static bool startCrabzillaNuke(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool deathNuke(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool deathBomb(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool spawnAliens(BaseSimObject pTarget, WorldTile pTile = null)
		int num = 1;
		for (int i = 0; i < num; i++)
	public static bool fireDropsSpawn(BaseSimObject pTarget, WorldTile pTile = null)
		for (int i = 0; i < 5; i++)
		for (int j = 0; j < 25; j++)
	public static bool snowDropsSpawn(BaseSimObject pTarget, WorldTile pTile = null)
		for (int i = 0; i < 20; i++)
	public static bool teleportRandom(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
	public static void teleportEffect(Actor pActor, WorldTile pTile)
		string text = pActor.asset.effect_teleport;
		if (string.IsNullOrEmpty(text))
	public static bool metamorphInto(Actor pTarget, string pAsset, bool pRemoveAcquiredTraits = false, bool pUseCurrentSubspecies = false)
	public static bool turnIntoMush(BaseSimObject pTarget, WorldTile pTile = null)
		if (!a.asset.can_turn_into_mush)
	public static Actor turnIntoMetamorph(BaseSimObject pTarget, string pAssetID)
	public static Actor turnIntoIceOne(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool turnIntoDemon(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool turnIntoTumorMonster(BaseSimObject pTarget, WorldTile pTile = null)
		if (!a.asset.can_turn_into_tumor)
	public static bool turnIntoZombie(BaseSimObject pTarget, WorldTile pTile = null)
		if (!a.asset.can_turn_into_zombie)
		string zombieID = a.asset.getZombieID();
	public static bool turnIntoSkeleton(BaseSimObject pTarget, WorldTile pTile = null)
		if (string.IsNullOrEmpty(a.asset.skeleton_id))
		string skeleton_id = a.asset.skeleton_id;
	public static Actor getActorNearPos(Vector2 pPos)
		float num = float.MaxValue;
		int count = World.world.units.visible_units.count;
		for (int i = 0; i < count; i++)
	public static Actor getActorFromTile(WorldTile pTile = null)
		float num = float.MaxValue;
		for (int i = 0; i < simpleList.Count; i++)
	public static void openUnitWindow(Actor pActor)
	public static bool inspectUnit(WorldTile pTile = null, string pPower = null)
	public static bool inspectUnitSelectedMeta(WorldTile pTile = null, string pPower = null)
	public static bool inspectCity(WorldTile pTile = null, string pPower = null)
	public static bool inspectKingdom(WorldTile pTile = null, string pPower = null)
	public static bool inspectAlliance(WorldTile pTile = null, string pPower = null)
	public static bool inspectCulture(WorldTile pTile, string pPower = null)
	public static bool inspectReligion(WorldTile pTile, string pPower = null)
	public static bool inspectSubspecies(WorldTile pTile, string pPower = null)
	public static bool inspectFamily(WorldTile pTile, string pPower = null)
	public static bool inspectArmy(WorldTile pTile, string pPower = null)
	public static bool inspectLanguage(WorldTile pTile, string pPower = null)
	public static bool inspectClan(WorldTile pTile, string pPower = null)
	public static bool burnTile(BaseSimObject pSelf, BaseSimObject pTarget = null, WorldTile pTile = null)
	public static bool tryToEvolveUnitViaMonolith(Actor pActor)
		float pVal = 1f;
		if (pActor.asset.can_evolve_into_new_species)
	public static bool tryToEvolveUnitViaAscension(Actor pActor, out Actor pEvolvedActorForm)
	public static void startBurningObjects(BaseSimObject pSelf, BaseSimObject pTarget = null, WorldTile pTile = null)
		for (int i = 0; i < allObjectsInChunks.Count; i++)
	public static void action_growTornadoes(WorldTile pTile = null, string pDropID = null)
	public static void action_shrinkTornadoes(WorldTile pTile = null, string pDropID = null)
	public static bool dragonSlayer(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool mageSlayerCheck(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool checkPiranhaAchievement(BaseSimObject pTarget, WorldTile pTile = null)
	public static bool clickRelations(WorldTile pTile, string pPowerID)
	public static bool clickWhisperOfWar(WorldTile pTile, string pPowerID)
	public static bool clickUnity(WorldTile pTile, string pPowerID)
	private static void showWhisperTip(string pText)
		string text = LocalizedTextManager.getText(pText);
	public static bool selectWhisperOfWar(string pPowerID)
	public static bool selectUnity(string pPowerID)
	public static bool selectRelations(string pPowerID)
	public static bool whirlwind(BaseSimObject pSelf, WorldTile pTile)
	public static void removeUnit(Actor pActor)
	public static bool breakBones(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile)
	public static bool restoreMana(WorldTile pTile, Actor pSelf)
		int pValue = (int)((float)pSelf.getMaxMana() * 0.01f);
	public static bool restoreStamina(WorldTile pTile, Actor pSelf)
		int pValue = (int)((float)pSelf.getMaxStamina() * 0.01f);
	public static bool restoreFullStats(NanoObject pTarget, BaseAugmentationAsset pTrait)
		((Actor)pTarget).event_full_stats = true;
	public static bool forcedKingdomAdd(NanoObject pTarget, BaseAugmentationAsset pTrait)
	public static bool forcedKingdomEffectRemove(NanoObject pTarget, BaseAugmentationAsset pTrait)
	public static bool madnessEffectLoad(NanoObject pTarget, BaseAugmentationAsset pTrait)
	public static bool tryToMakeBuildingAlive(Building pBuilding)
		if (pBuilding.isUnderConstruction())
	public static bool tryToMakeFloraAlive(Building pBuilding, bool pFullyGrownOnly = true)
		if (pBuilding.isUnderConstruction())
	public static void growRandomVegetation(WorldTile pTile, BiomeAsset pBiomeAsset)
	private static NanoObject getNanoObjectFromTile(WorldTile pTile, MetaTypeAsset pMetaTypeAsset)
public delegate void ActionOptionAsset(OptionAsset pAsset);
public class Actor : BaseSimObject, ILoadable<ActorData>, ITraitsOwner<ActorTrait>, IEquatable<Actor>, IComparable<Actor>, IFavoriteable
	internal ActorIdleLoopSound idle_loop_sound;
	internal bool is_forced_socialize_icon;
	internal double is_forced_socialize_timestamp;
	internal string ate_last_item_id;
	internal double timestamp_session_ate_food;
	internal double timestamp_tween_session_social;
	private double _last_color_effect_timestamp;
	private double _last_stamina_reduce_timestamp;
	internal double timestamp_profession_set;
	internal List<BaseActorComponent> children_special;
	private Dictionary<Type, BaseActorComponent> _dict_special;
	private List<ActorSimpleComponent> children_pre_behaviour;
	private Dictionary<Type, ActorSimpleComponent> dict_pre_behaviour;
	private UnitProfession _profession;
	public GameObject avatar;
	private double _timestamp_augmentation_effects;
	internal bool show_shadow;
	internal Vector2 current_shadow_position = Vector2.op_Implicit(Globals.POINT_IN_VOID);
	private double[] _decision_cooldowns;
	private bool[] _decision_disabled;
	public DecisionAsset[] decisions = new DecisionAsset[64];
	public int decisions_counter;
	private int _current_children;
	private readonly Queue<HappinessHistory> _last_happiness_history = new Queue<HappinessHistory>();
	private HashSet<long> _aggression_targets = new HashSet<long>();
	private HoverState _hover_state;
	private float _hover_timer;
	public BatchActors batch;
	internal WorldTile beh_tile_target;
	internal Building beh_building_target;
	internal BaseSimObject beh_actor_target;
	internal Book beh_book_target;
	internal Building inside_building;
	internal bool is_inside_building;
	internal Boat inside_boat;
	internal bool is_inside_boat;
	internal BaseSimObject attackedBy;
	public Actor lover;
	public readonly HashSet<ActorTrait> traits = new HashSet<ActorTrait>();
	private readonly CombatActionHolder _combat_actions = new CombatActionHolder();
	private readonly SpellHolder _spells = new SpellHolder();
	private readonly Dictionary<string, bool> _traits_cache = new Dictionary<string, bool>();
	internal ActorData data;
	internal ProfessionAsset profession_asset;
	private bool _state_adult;
	private bool _state_baby;
	private bool _state_egg;
	public ActorAsset asset;
	public Vector2 next_step_position;
	public Vector2 next_step_position_possession;
	internal Vector2 shake_offset;
	public static readonly Vector2 sprite_offset = new Vector2(0.5f, 0.5f);
	public Vector2 move_jump_offset;
	private bool _shake_horizontal;
	private bool _shake_vertical;
	private float _shake_timer;
	private bool _shake_active;
	private float _shake_volume;
	private bool _is_moving;
	private bool _possessed_movement;
	private bool _is_in_liquid;
	internal bool is_visible;
	internal bool last_sprite_renderer_enabled;
	internal AnimationFrameData frame_data;
	internal bool dirty_current_tile;
	internal WorldTile tile_target;
	private WorldTile _next_step_tile;
	public SplitPathStatus split_path;
	public int current_path_index;
	public readonly List<WorldTile> current_path = new List<WorldTile>();
	public List<MapRegion> current_path_global;
	public BaseActionActor callbacks_on_death;
	public BaseActionActor callbacks_landed;
	public BaseActionActor callbacks_cancel_path_movement;
	public BaseActionActor callbacks_magnet_update;
	internal float actor_scale;
	internal float target_scale;
	internal BaseSimObject attack_target;
	internal bool has_attack_target;
	internal float timer_action;
	internal float timer_jump_animation;
	internal float hitbox_bonus_height;
	internal Vector3 velocity;
	internal float velocity_speed;
	internal bool under_forces;
	protected WorldTimer targets_to_ignore_timer;
	private bool _flying;
	internal bool is_in_magnet;
	internal float attack_timer;
	internal double last_attack_timestamp;
	internal EquipmentAsset _attack_asset;
	internal PersonalityAsset s_personality;
	private readonly List<BaseAugmentationAsset> _s_special_effect_augmentations = new List<BaseAugmentationAsset>();
	private readonly Dictionary<BaseAugmentationAsset, double> _s_special_effect_augmentations_timers = new Dictionary<BaseAugmentationAsset, double>();
	internal AttackAction s_action_attack_target;
	internal GetHitAction s_get_hit_action;
	protected static readonly List<BaseAugmentationAsset> _tempAugmentationList = new List<BaseAugmentationAsset>();
	private bool _has_emotions;
	private bool _has_tag_unconscious;
	public bool has_tag_immunity_cold;
	private bool _has_status_strange_urge;
	private bool _has_status_possessed;
	private bool _has_status_sleeping;
	private bool _has_status_tantrum;
	private bool _has_status_drowning;
	private bool _has_status_invincible;
	private bool _cache_check_has_status_removed_on_damage;
	private bool _has_trait_weightless;
	private bool _has_trait_peaceful;
	private bool _has_trait_clone;
	internal bool has_tag_generate_light;
	private bool _has_any_sick_trait;
	internal bool is_immovable;
	internal bool is_ai_frozen;
	private bool _has_stop_idle_animation;
	private bool _ignore_fights;
	protected bool should_check_land_cancel;
	internal WorldTile scheduled_tile_target;
	internal bool _action_wait_after_land;
	internal float _action_wait_after_land_timer;
	internal AiSystemActor ai;
	public CitizenJobAsset citizen_job;
	protected Building _home_building;
	private float _death_timer_color_stage_1;
	private float _death_timer_alpha_stage_2;
	private float _jump_time;
	private float lastX;
	private float lastY;
	public float flip_angle;
	internal bool flip;
	private int _precalc_movement_speed_skips;
	private float _current_combined_movement_speed;
	internal float _timeout_targets;
	internal Vector3 target_angle;
	internal float rotation_cooldown;
	private RotationDirection _rotation_direction;
	private Sprite _last_topic_sprite;
	public Color color;
	internal bool dirty_sprite_main;
	private Sprite _cached_sprite_item;
	private IHandRenderer _cached_hand_renderer_asset;
	internal Sprite cached_sprite_head;
	internal bool dirty_sprite_head;
	internal AnimationContainerUnit animation_container;
	private Sprite _last_main_sprite;
	private Sprite _last_colored_sprite;
	private ColorAsset _last_color_asset;
	private bool _dirty_sprite_item;
	private bool _has_animated_item;
	public SpriteAnimation sprite_animation;
	private const float POSSESSION_ATTACK_SECONDS = 0.5f;
	private double _possession_attack_happened_frame;
	private AttackType _last_attack_type;
	public ActorEquipment equipment;
	public Army army;
	public City city;
	public Clan clan;
	public Culture culture;
	public Family family;
	public Language language;
	public Plot plot;
	public Religion religion;
	public Subspecies subspecies;
	private const float FIND_TILE_SQ_DIST = 4f;
	private const float CUR_SQ_DIST = 0.16000001f;
	private const float NEW_SQ_DIST = 0.09f;
	private bool _beh_skip;
	private bool _update_done;
	private string _last_decision_id;
	public Queue<HappinessHistory> happiness_change_history => _last_happiness_history;
	public string coloredName
	public bool is_invincible => _has_status_invincible;
	public override string name
		protected set
	public Building home_building => _home_building;
	public int age => getAge();
	public bool is_army_captain
	public bool is_profession_nothing => _profession == UnitProfession.Nothing;
	public bool is_profession_king => _profession == UnitProfession.King;
	public bool is_profession_leader => _profession == UnitProfession.Leader;
	public bool is_profession_warrior => _profession == UnitProfession.Warrior;
	public bool is_profession_citizen => _profession == UnitProfession.Unit;
	public bool is_looking_left => !flip;
	public ResourceAsset favorite_food_asset => AssetManager.resources.get(data.favorite_food);
	public int current_children_count => _current_children;
	public bool is_unconscious => _has_tag_unconscious;
	public int loot => data.loot;
	public int money => data.money;
	public int renown => data.renown;
	public int level => data.level;
	public int intelligence => (int)stats["intelligence"];
	public int diplomacy => (int)stats["diplomacy"];
	public int warfare => (int)stats["warfare"];
	public int stewardship => (int)stats["stewardship"];
	protected override MetaType meta_type => MetaType.Unit;
	public bool is_moving
	public bool has_rendered_sprite_head => cached_sprite_head != null;
	public WorldTile debug_next_step_tile => _next_step_tile;
	public ActorBag inventory
	protected sealed override void setDefaultValues()
		_last_decision_id = string.Empty;
		ate_last_item_id = string.Empty;
	public void setShowShadow(bool pShadow)
	private void updateChildrenList(List<BaseActorComponent> pList, float pElapsed)
	private void updateChildrenListSimple(List<ActorSimpleComponent> pList, float pElapsed)
	public void setAsset(ActorAsset pAsset)
	internal override void create()
		ai.next_job_delegate = getNextJob;
		ai.clear_action_delegate = clearBeh;
	public bool canSeeTileBasedOnDirection(WorldTile pTile)
		bool flag = isTileOnTheLeft(pTile);
	public void setParent1(Actor pParentActor, bool pIncreaseChildren = true)
	public void setParent2(Actor pActor, bool pIncreaseChildren = true)
	internal void setProfession(UnitProfession pType, bool pCancelBeh = true)
	private void addChildren()
		if (asset.avatar_prefab != string.Empty)
	private void addChild(BaseActorComponent pObject)
	private void addChildSimple(ActorSimpleComponent pObject)
	public T getActorComponent<T>() where T : BaseActorComponent
	public T getSimpleComponent<T>() where T : ActorSimpleComponent
	private void playDeathSound(Actor pActor)
	public void playIdleSound()
	public void startShake(float pTimer = 0.3f, float pVol = 0.1f, bool pHorizontal = true, bool pVertical = true)
	public Vector3 getThrowStartPosition()
		float num = 0f;
		float num2 = 0f;
		float num3 = val.x + num * val2.x;
		float num4 = val.y + num2 * val2.y;
		Vector3 point = default(Vector3);
		((Vector3)(ref point))._002Ector(num3, num4, -0.01f);
		return point;
	public void checkDefaultProfession()
	public void addAfterglowStatus()
		float pOverrideTimer = (float)asset.months_breeding_timeout * 5f;
	public void updateHover(float pElapsed)
	public void updatePollinate(float pElapsed)
	private void checkCalibrateTargetPosition()
	internal override bool addStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer = 0f, bool pColorEffect = true)
		bool num = base.addStatusEffect(pStatusAsset, pOverrideTimer, pColorEffect);
	public void setTargetAngleZ(float pValue)
	public void lookTowardsPosition(Vector2 pDirection)
	public override void setStatsDirty()
	private void checkRageDemon()
	internal void updateChangeScale(float pElapsed)
	internal void newCreature()
		event_full_stats = true;
		event_full_stats = true;
	public void clearTraits()
	public override void Dispose()
	private void checkComponentListDispose(List<BaseActorComponent> pList)
	private void checkSimpleComponentListDispose(List<ActorSimpleComponent> pList)
	public void showTooltip(object pUiObject)
		string pType = (isKing() ? "actor_king" : ((!isCityLeader()) ? "actor" : "actor_leader"));
	public override ColorAsset getColor()
	public void setHoverState(HoverState pState)
	public override string ToString()
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[Actor:{base.id} ");
		if (!string.IsNullOrEmpty(data.name))
		return stringBuilderPool.ToString().Trim() + "]";
	private int getMaxPossibleLevel()
	internal void addExperience(int pValue)
		int maxPossibleLevel = getMaxPossibleLevel();
	public void addRenown(int pValue)
	public void addRenown(int pAmount, float pPercent)
		int pValue = (int)((float)pAmount * pPercent);
	internal void updateAge()
		float num = getAge();
	private void updateAttributes()
	public void setMaxHappiness()
	public void setHappiness(int pValue, bool pClamp = true)
	public void restoreHealthPercent(float pVal)
	public void restoreHealth(int pVal)
	public bool changeHappiness(string pID, int pValue = 0)
		int num = pValue + happinessAsset.value;
		int num2 = getHappiness() + num;
	public void spendNutritionOnBirth()
	public void addNutritionFromEating(int pVal = 100, bool pSetMaxNutrition = false, bool pSetJustAte = false)
	public void updateNutritionDecay(bool pDoStarvationDamage = true)
		int metabolicRate = subspecies.getMetabolicRate();
	public void decreaseNutrition(int pValue = -1)
	public void setNutrition(int pVal, bool pClamp = true)
	public void updateMana()
	public void addMana(int pValue)
		int maxMana = getMaxMana();
		int num = getMana();
	public int getMaxManaPercent(float pPercent)
		int num = (int)((float)getMaxMana() * pPercent);
	public void restoreManaPercent(float pVal)
	public void changeMana(int pValue)
		int num = data.mana + pValue;
	public void restoreMana(int pVal)
	public void setMana(int pValue, bool pClamp = true)
	public void spendMana(int pValueSpend)
	public int getMaxStaminaPercent(float pPercent)
		int num = (int)((float)getMaxStamina() * pPercent);
	public void restoreStaminaPercent(float pVal)
	public void changeStamina(int pValue)
		int num = data.stamina + pValue;
	public void restoreStamina(int pVal)
	public void updateStamina()
	public void addStamina(int pValue)
		int maxStamina = getMaxStamina();
		int num = getStamina();
	public void setStamina(int pValue, bool pClamp = true)
	public void spendStamina(int pValueSpend)
	public void spendStaminaWithCooldown(int pValueSpend)
	public bool hasHappinessEntry(string pID, float pTime = 0f)
	public void finishScale()
	public void setActorScale(float pVal)
	public void setData(ActorData pData)
	public void loadData(ActorData pData)
	public void generateSex()
	protected void generatePersonality()
	public void calcIsEgg()
	public void calcIsBaby()
		if (hasSubspecies() && asset.has_baby_form && !((float)getAge() >= subspecies.age_adult))
	public void setCheckLanding()
	public void addForce(float pX, float pY, float pHeight, bool pCheckLandCancelAllActions = false, bool pIgnorePosHeight = false)
	public void setFlying(bool pVal)
	internal void checkIsInLiquid()
		bool is_in_liquid = current_tile.is_liquid && move_jump_offset.y == 0f && position_height <= 0f && isAlive();
	private void addDefaultItemAttackActions(ItemAsset pItemAsset)
	private void addItemActions(ItemAsset pItemAsset)
	internal void attackTargetActions(BaseSimObject pTarget, WorldTile pTile)
	protected void calcAgeStates()
	internal override void updateStats()
		stats["intelligence"] += data["intelligence"];
		float num2 = (float)data.level * SimGlobals.m.level_mod_bonus_health * stats["health"];
		float num3 = (float)data.level * SimGlobals.m.level_mod_bonus_mana * stats["mana"];
		float num4 = (float)data.level * SimGlobals.m.level_mod_bonus_stamina * stats["stamina"];
		stats["skill_combat"] += (float)(int)(stats["warfare"] / 5f) * 0.01f;
		stats["skill_spell"] += (float)(int)(stats["intelligence"] / 5f) * 0.01f;
		bool has_tag_unconscious = _has_tag_unconscious;
		stats["cities"] += (int)stats["stewardship"] / 6 + 1;
		stats["bonus_towers"] += (int)(stats["warfare"] / 10f);
		stats["mana"] += (int)(stats["intelligence"] * SimGlobals.m.MANA_PER_INTELLIGENCE);
		if (event_full_stats)
	public void resetAttackTimeout()
	public void setActionTimeout(float pTimeout)
	private void addSpecialEffectAugmentations(IEnumerable<BaseAugmentationAsset> pAssets)
	private void addSpecialEffectsFromMetas(List<BaseAugmentationAsset> pAugmentations)
	private void calculateOffspringBasedOnAge()
	internal virtual void updateFall()
		float elapsed = World.world.elapsed;
		float num = SimGlobals.m.gravity * stats.get("mass");
	private void stopForce()
	internal virtual void actionLanded()
	public void updateShake(float pElapsed)
	internal void updateFlipRotation(float pElapsed)
	internal bool flipAnimationActive()
	private void updateRotations(float pElapsed)
	private void updateRotationFall(float pElapsed)
		if (getTextureAsset().prevent_unconscious_rotation)
	private void updateRotationBack(float pElapsed)
	public Vector3 updateRotation()
	internal void updateDeadBlackAnimation(float pElapsed)
	internal virtual void spawnOn(WorldTile pTile, float pZHeight = 0f)
	public string getName()
		if (string.IsNullOrEmpty(data.name))
	public string generateName(MetaType pType, long pSeed, ActorSex pSex = ActorSex.None)
	private void generateNewName()
		string pName = NameGenerator.generateName(this, MetaType.Unit, pSeed, pSex);
	public override void trackName(bool pPostChange = false)
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
	public void setHomeBuilding(Building pBuilding)
		World.world.buildings.event_houses = true;
	public bool hasHomeBuilding()
	public Building getHomeBuilding()
	public void checkHomeBuilding()
	public void cloneTopicSprite(Sprite pSprite)
	public void clearLastTopicSprite()
	public Sprite getTopicSpriteTrait()
	public Sprite getSocializeTopic()
	public void forceSocializeTopic(string pPath)
	public void clearHomeBuilding()
		World.world.buildings.event_houses = true;
	public override void setAlive(bool pValue)
	internal bool isProfession(UnitProfession pType)
	public bool isAnimal()
	public bool isNomad()
	public bool isSapient()
	public bool isPrettyOld()
		int num = getAge();
		if ((float)num < subspecies.age_adult)
	public bool isBaby()
	public bool isAdult()
	public bool isBreedingAge()
		return (float)getAge() >= subspecies.age_breeding;
	public bool isEgg()
	public int getAge()
	public string getBirthday()
	public bool isKing()
	public float getMaturationTimeSeconds()
	public float getMaturationTimeMonths()
		float num = 0f;
	public bool isFavorite()
	public void switchFavorite()
	public override City getCity()
	public bool canBuildNewCity()
	public bool isCityLeader()
	public override bool hasDied()
	internal bool isPollinator()
	internal bool isAffectedByLiquid()
	internal override bool isInAir()
	internal override bool isFlying()
	internal bool ignoresBlocks()
	internal bool isInMagnet()
	internal bool isHovering()
	public ActorAsset getActorAsset()
	public IReadOnlyCollection<ActorTrait> getTraits()
	public bool isWaterCreature()
	public bool mustAvoidGround()
	public bool isInStablePlace()
		if (mustAvoidGround())
	internal bool hasWeapon()
	internal Item getWeapon()
	internal EquipmentAsset getWeaponAsset()
	public bool isWeaponFirearm()
	public bool isArmyGroupLeader()
	public bool isArmyGroupWarrior()
	public bool hasTraits()
	public bool isSexMale()
	public bool isSexFemale()
	public bool hasEquipment()
	public bool hasHouse()
	public bool hasLover()
	public bool hasBestFriend()
	public Actor getBestFriend()
	public bool isChildOf(Actor pActor)
	public bool isChildOf(long pID)
	public bool isParentOf(long pID, Actor pActor)
	public bool isParentOf(Actor pActor)
	public IEnumerable<Actor> getParents()
	public IEnumerable<Actor> getChildren(bool pOnlyCurrentFamily = true)
		int tCurrentLivingChildren = current_children_count;
	public bool hasSuitableBookTraits()
	public bool canBeSurprised(WorldTile pFromTile = null)
	public bool isTileOnTheLeft(WorldTile pTile)
	public bool isFighting()
	public UnitProfession getProfession()
	public int getNutrition()
	public bool isHungry()
	public float getNutritionRatio()
		float num = getNutrition();
		float num2 = getMaxNutrition();
	public float getHealthRatio()
		float num = getHealth();
		float num2 = getMaxHealth();
	public bool hasMaxHealth()
	public bool hasMaxMana()
	public bool isStarving()
	public bool hasFavoriteFood()
		return !string.IsNullOrEmpty(data.favorite_food);
	public bool hasEmotions()
	public bool canHavePrejudice()
	public bool hasHappinessHistory()
	public bool isUnhappy()
	public int getHappiness()
	public bool isHappy()
	public int getMinHappiness()
	public int getMaxHappiness()
	public float getHappinessRatio()
		return ((float)getHappiness() + 100f) / 200f;
	internal bool isSameSpecies(string pID)
	internal bool isSameSpecies(Actor pActor)
	internal bool isSameSubspecies(Subspecies pSubspecies)
	public bool isAllowedToLookForEnemies()
	private bool shouldSkipFightCheck()
	public bool isInWaterAndCantAttack()
	public bool hasReachedOffspringLimit()
		int maxOffspring = getMaxOffspring();
	public int getMaxOffspring()
		return (int)Math.Ceiling(stats["offspring"]);
	public bool haveNutritionForNewBaby()
	public bool isInsideSomething()
	public bool isOnSameIsland(Actor pActor)
	public bool hasSameCity(Actor pActorTarget)
	public bool canBreed()
	public bool canProduceBabies()
	public bool isPlacePrivateForBreeding()
		int num = Toolbox.countUnitsInChunk(current_tile);
	public bool isOnGround()
	internal bool isInAttackRange(BaseSimObject pObject)
		float num = getAttackRange() + pObject.stats["size"];
	internal bool isAttackReady()
	public float getAttackCooldownRatio()
		float attackCooldown = getAttackCooldown();
	internal bool isAttackPossible()
	public bool canUseSpells()
	public bool hasSpells()
	public bool canUseReligionSpells()
	public SpellAsset getRandomSpell()
	internal override float getHeight()
	public float getScaleMod()
	public bool isCameraFollowingUnit()
	internal bool isTargetOkToAttack(Actor pTarget)
	private float getLastColorEffectTime()
	private float getLastStaminaReduceTime()
	public bool isUnderDamageCooldown()
	private bool isUnderStaminaCooldown()
	private bool haveMetallicArmor()
	private bool haveMetallicWeapon()
	public bool isSameKingdomAndAlmostDead(Actor pActor, float pDamage)
		if (isSameKingdom(pActor) && (float)getHealth() - pDamage <= 0f)
	public bool isSameKingdom(BaseSimObject pSimObject)
	public bool isInCityIsland()
	public bool isClone()
	public bool isClonedFrom(Actor pActor)
	public bool isSameClones(Actor pActor)
	public bool isUnitFitToRule()
	public bool Equals(Actor pObject)
	public int CompareTo(Actor pTarget)
	public bool canTalkWith(Actor pTarget)
	public bool canFallInLoveWith(Actor pTarget)
	public bool hasHouseCityInBordersAndSameIsland()
	public bool inOwnHouseIsland()
	public bool inOwnCityBorders()
	public bool inOwnCityIsland()
	public bool isReadyToTalk()
	public bool canSocialize()
	public int getConstructionSpeed()
		int num = 2;
			num += (int)subspecies.base_stats_meta["construction_speed"];
	private bool combatActionOnTimeout()
	private bool hasSpellCastCooldownStatus()
	public bool hasEnoughMana(int pCostMana)
	public int getMana()
	public int getMaxMana()
		return (int)stats["mana"];
	public void setMaxMana()
	public bool isManaFull()
	public bool hasEnoughStamina(int pCostStamina)
	public int getStamina()
	public int getMaxStamina()
		return (int)stats["stamina"];
	public void setMaxStamina()
	public bool isStaminaFull()
	public bool isWarrior()
	public bool isCarnivore()
	public bool isHerbivore()
	public bool hasStatusStunned()
	public bool isLying()
	public override bool hasStatusTantrum()
	public bool hasAnyCash()
	public bool hasEnoughMoney(int pCost)
	public int getHappinessPercent()
		int maxHappiness = getMaxHappiness();
		int minHappiness = getMinHappiness();
	public float distanceToObjectTarget(BaseSimObject pBaseSimObject)
	public float distanceToActorTile(Actor pActor)
	public float distanceToActorTile(WorldTile pTile)
	public bool isRelatedTo(Actor pTarget)
	public bool isImportantTo(Actor pTarget)
	public bool canWork()
	public bool hasCultureTrait(string pTraitID)
	public bool canBePossessed()
	public float getAttackRange()
	public float getAttackRangeSquared()
	public float getStaminaRatio()
		float num = getMaxStamina();
		return (float)getStamina() / num;
	public float getManaRatio()
		float num = getMaxMana();
		return (float)getMana() / num;
	public bool canGetFoodFromCity()
	public bool isFoodFreeForThisPerson()
	public int getMaxNutrition()
		float num = asset.nutrition_max;
		return (int)num;
	public int getExpToLevelup()
	private bool calculateIsSick()
		if (hasTrait("mush_spores") && asset.can_turn_into_mush)
		if (hasTrait("tumor_infection") && asset.can_turn_into_tumor)
	public bool isSick()
	public bool canTakeItems()
	public bool understandsHowToUseItems()
	public bool canUseItems()
	public bool canEditEquipment()
	public bool canTurnIntoColdOne()
		if (!asset.can_turn_into_ice_one)
	public bool canTurnIntoDemon()
		return asset.can_turn_into_demon_in_age_of_chaos;
	public override BaseObjectData getData()
	public bool isCarryingResources()
	public bool needsFood()
	public bool isDamagedByRain()
	public bool isDamagedByOcean()
	public int getWaterDamage()
		int num = (int)((float)getMaxHealth() * SimGlobals.m.water_damage_multiplier);
	public bool hasSubspeciesTrait(string pTraitID)
	public bool hasSubspeciesMetaTag(string pTagID)
	public bool hasTag(string pTag)
	public bool isImmuneToFire()
	public bool isImmuneToCold()
	public bool isImmovable()
	public bool isAiFrozen()
	public bool isIgnoreFights()
	public bool hasStopIdleAnimation()
	public bool hasDivineScar()
	public bool hasTelepathicLink()
	public float getResourceThrowDistance()
	internal bool isFalling()
	public float getAgeRatio()
		float num = stats["lifespan"];
		return (float)getAge() / num;
	public int getMassKG()
		float num = target_scale / 0.1f;
		int num2 = (int)(stats["mass_2"] * num);
	public IEnumerable<ResourceContainer> getResourcesFromActor()
		int tMass = getMassKG();
	public bool hasXenophobic()
	public bool hasXenophiles()
	public bool hasCannibalism()
	public bool isOneCityKingdom()
	public bool isImportantPerson()
	public bool canCurrentTaskBeCancelledByReproduction()
	public bool isAbleToSkipPriorityLevels()
	public void makeSpawnSound(bool pFromUI)
	public void makeSoundAttack()
	public string getTaskText()
		string localizedText = ai.task.getLocalizedText();
		string taskTime = ai.getTaskTime();
	public void afterEvolutionEvents()
	public void generatePhenotypeAndShade()
	public static int getRandomPhenotypeShade()
	public bool isRendered()
	public bool checkHasRenderedItem()
		if (hasTask() && ai.task.force_hand_tool != string.Empty)
	internal Sprite getSpriteToRender()
	public bool hasColoredSprite()
	public bool isColoredSpriteNeedsCheck(Sprite pMainSprite)
	public Sprite calculateColoredSprite(Sprite pMainSprite, bool pUpdateFrameData = true)
	public Sprite getLastColoredSprite()
	public bool canParallelSetColoredSprite()
	public Sprite calculateMainSprite()
		float num = asset.animation_walk_speed;
		bool flag = false;
	internal Sprite checkSpriteToRender()
	protected void setItemSpriteRenderDirty()
	public Sprite getRenderedItemSprite()
	public IHandRenderer getCachedHandRendererAsset()
	public IHandRenderer getHandRendererAsset()
	private IHandRenderer getRenderedToolOrItem()
	public bool isItemInHandAnimated()
	public void clearSprites()
	public void clearGraphicsFully()
	public AnimationFrameData getAnimationFrameData()
	public Vector3 getHeadOffsetPositionForFunRendering()
	public IHandRenderer getWeaponTextureId()
	private ActorTextureSubAsset getTextureAsset()
	public string getUnitTexturePath()
	internal void checkAnimationContainer()
	public SpriteAnimation getSpriteAnimation()
	public Vector2 getRenderedItemPosition()
	public void clearLastColorCache()
	public void startColorEffect(ActorColorEffect pColorType = ActorColorEffect.White)
	protected void checkSpriteHead()
		bool flag = false;
		string pPath;
	internal void checkHeadID(Sprite[] pListHeads, bool pCheckSavedHead = true)
	private void setHeadSprite(Sprite pSprite)
	protected void updateDeadAnimation(float pElapsed)
	public double[] getDecisionsCooldowns()
	public bool[] getDecisionsDisabled()
	public bool isDecisionOnCooldown(int pIndex, double pCooldown)
	public void setupRandomDecisionCooldowns()
		for (int i = 0; i < decisions_counter; i++)
	public void setDecisionCooldown(DecisionAsset pAsset)
	public bool isDecisionEnabled(int pIndex)
	public bool switchDecisionState(int pIndex)
	public void setDecisionState(int pIndex, bool pState)
	public void setTask(string pTaskId, bool pClean = true, bool pCleanJob = false, bool pForceAction = false)
	public void cancelAllBeh()
	public void endJob()
	protected virtual void clearTasks()
	public void setCitizenJob(CitizenJobAsset pJobAsset)
	internal void clearBeh()
	public string getNextJob()
	public static string nextJobActor(Actor pActor)
		string result = null;
	public bool isTask(string pID)
	public bool hasTask()
	public void clearDecisions()
		_last_decision_id = string.Empty;
	public void scheduleTask(string pTask, WorldTile pTile)
	private void registerDecisions()
	public void debugFav()
	public void clearWait()
	public void makeWait(float pValue = 10f)
	public void stopSleeping()
	private void checkStepActionForTile(WorldTile pTile)
	public void setLover(Actor pActor)
	public void setBestFriend(Actor pActor, bool pNew)
	public void becomeLoversWith(Actor pTarget)
	public void resetSocialize()
	public void addActionWaitAfterLand(float pTimer)
	private void actionMagnetAnimation(Actor pActor)
	private bool isSurprisedJump(WorldTile pTile)
		bool num = canSeeTileBasedOnDirection(pTile);
		bool result = false;
	private void checkLand(Actor pActor)
	private void checkDeathOutsideMap(Actor pActor)
	public void tryToGetSurprised(WorldTile pTile, bool pForceJump = false)
	public void getSurprised(WorldTile pTile, bool pForceJump = false)
		float num = 1f + Randy.randomFloat(0f, 2f);
		bool num2 = !hasStatus("surprised");
		bool flag = pForceJump || isSurprisedJump(pTile);
		float num3 = 0.3f;
	public bool makeSleep(float pTime)
		bool num = addStatusEffect("sleeping", pTime);
	public void makeStunned(float pTime = 5f)
	public void makeStunnedFromUI()
	public void justAte()
	public void poop(bool pApplyForce)
		float num = 1f;
		string pAssetID;
	public void donePooping()
	public void birthEvent(string pAddSpecialTrait = null, string pAddSpecialStatus = null)
		if (!string.IsNullOrEmpty(pAddSpecialTrait))
		if (!string.IsNullOrEmpty(pAddSpecialStatus))
	public void consumeTopTile(WorldTile pTile)
	public void countConsumed()
	public void consumeFoodResource(ResourceAsset pAsset)
		int num = pAsset.restore_nutrition;
		float num2 = pAsset.restore_health;
	internal void justBorn()
	public void stopBeingWarrior()
	public void pokeFromAvatarUI()
	public void finishPossessionStatus()
	public void madePeace(War pWar)
	public void warWon(War pWar)
	public void warLost(War pWar)
	public void setTransformed()
	public bool isAlreadyTransformed()
	public void makeConfused(float pConfusedTimer = -1f, bool pColorEffect = false)
	public void checkShouldBeEgg()
		if (hasSubspecies() && subspecies.has_egg_form && (float)age < subspecies.age_adult)
	public void leavePlot()
	private void levelUp()
		int expToLevelup = getExpToLevelup();
		int maxPossibleLevel = getMaxPossibleLevel();
	private void checkGrowthEvent()
		bool flag = isBaby();
		bool num = isEgg();
	internal void eventHatchFromEgg()
		batch.c_events_hatched.Remove(this);
	internal void eventBecomeAdult()
		batch.c_events_become_adult.Remove(this);
	private void growthStateEvent()
		event_full_stats = true;
	private void triggerHatchFromEggAction()
	public bool checkNaturalDeath()
		float num = getAge();
		float num2 = stats["lifespan"];
		float num3 = num - num2;
		float num4 = 5f;
	public void spawnParticle(Color pColor)
	private void checkActionsFromAllMetas()
	private void recalcCombatActions()
	private void recalcSpells()
	private void checkSpells(SpellHolder pSpellsHolder)
	private void checkCombatActions(CombatActionHolder pHolder)
	public List<CombatActionAsset> getCombatActionPool(CombatActionPool pPool)
	private void clearCombatActions()
	private void clearSpells()
	private bool checkCurrentEnemyTarget()
	private bool checkEnemyTargets()
	public void startFightingWith(BaseSimObject pSimObject)
	internal void startAttackCooldown()
	internal bool isJustAttacked()
	internal bool tryToAttack(BaseSimObject pTarget, bool pDoChecks = true, Action pKillAction = null, Vector3 pAttackPosition = default(Vector3), Kingdom pForceKingdom = null, WorldTile pTileTarget = null, float pBonusAreOfEffect = 0f)
		float num = 0f;
		float num2 = 0f;
		bool has_status_possessed = _has_status_possessed;
		float num3 = Vector2.Distance(Vector2.op_Implicit(val3), Vector2.op_Implicit(val)) + num;
		Vector3 newPoint = Toolbox.getNewPoint(val3.x, val3.y, val2.x, val2.y, num3 - num2);
		string projectile = getWeaponAsset().projectile;
		bool pProjectile = hasRangeAttack();
		AttackData pData = new AttackData(this, pHitTile, newPoint, pInitiatorPosition, pTarget, pKingdom, AttackType.Weapon, haveMetallicWeapon(), pSkipShake: true, pProjectile, projectile, pKillAction, pBonusAreOfEffect);
		bool flag = false;
		float num4 = stats.get("recoil");
	internal override void getHitFullHealth(AttackType pAttackType)
	internal override void getHit(float pDamage, bool pFlash, AttackType pAttackType, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
		changeHealth((int)(0f - pDamage));
	private void pickupResourcesFromKill(Actor pAttacker)
	private void checkSpecialAttackLogic(Actor pAttacker, AttackType pAttackType, float pInitialDamage, out float pDamageFinal)
		bool flag = isSameKingdom(pAttacker);
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = pAttacker.hasStatus("tantrum") && !flag;
		bool flag5 = pAttacker.hasStatus("possessed");
		bool num = kingdom.isEnemy(pAttacker.kingdom);
		float pVal = 0.1f;
		bool flag6 = false;
	private void damageEquipmentOnGetHit(Actor pAttacker)
		int num = 4;
		float pVal = 0.35f;
		int rigidity_rating = equipmentAsset.rigidity_rating;
		int num2 = 0;
		bool flag = false;
	public void addInjuryTrait(string pTraitID)
	private void checkAggroAgainst(Actor pAttackedBy, bool pCheckAllLists = false)
	internal void newKillAction(Actor pDeadUnit, Kingdom pPrevKingdom, AttackType pAttackType)
	internal void applyRandomForce(float pMinHeight = 1.5f, float pMaxHeight = 2f)
		float pForceAmountDirection = Randy.randomFloat(1.5f, 2f);
		float pForceHeight = Randy.randomFloat(pMinHeight, pMaxHeight);
	internal void calculateForce(float pStartX, float pStartY, float pTargetX, float pTargetY, float pForceAmountDirection, float pForceHeight = 0f, bool pCheckCancelJobOnLand = false)
	public bool tryToUseAdvancedCombatAction(List<CombatActionAsset> pCombatActionAssetsCategory, BaseSimObject pAttackTarget, out CombatActionAsset pResultCombatAsset)
	public void addAggro(long pActorID)
	public void addAggro(Actor pActor)
	public void finishAngryStatus()
	public void spawnSlashPunch(Vector2 pTowardsPosition)
	public void spawnSlashSteal(Vector2 pTowardsPosition)
	public void spawnSlashYell(Vector2 pTowardsPosition)
	public void spawnSlashTalk(Vector2 pTowardsPosition)
	public void spawnSlashKick(Vector2 pTowardsPosition)
	public void spawnSlash(Vector2 pTowardsPosition, string pSlashType = null, float pDistMod = 2f, float pTargetZ = 0f, float pStartZ = 0f, float? pAngle = null)
	public float getSlashAngle(Vector2 pSlashVector, Vector2 pAttackPosition)
	public Vector2 getSlashPosition(Actor pActor, Vector2 pAttackPosition, float pDistMod, float pTargetZ = 0f, float pStartZ = 0f)
		float scaleMod = pActor.getScaleMod();
		float num = pActor.stats["size"];
		float pDist = num * scaleMod * pDistMod;
		return Toolbox.getNewPointVec2(val.x, val.y, pAttackPosition.x, pAttackPosition.y + pTargetZ, pDist);
	public void doCastAnimation()
	internal void punchTargetAnimation(Vector3 pDirection, bool pFlip = true, bool pReverse = false, float pAngle = 40f)
	private void addToAttackPool(CombatActionAsset pAsset, ListPool<CombatActionAsset> pPool)
		for (int i = 0; i < pAsset.rate; i++)
	private void checkHappinessChangeFromDeathEvent()
	private void checkCallbacksOnDeath()
		for (int i = 0; i < listPool.Count; i++)
	public void checkDeath()
	public void dieSimpleNone()
	public void dieAndDestroy(AttackType pType)
	public void removeByMetamorphosis()
	private void die(bool pDestroy = false, AttackType pType = AttackType.Other, bool pCountDeath = true, bool pLogFavorite = true)
	public void checkDieOnGroundBoat()
	public void copyAggroFrom(Actor pTarget)
	public bool isInAggroList(Actor pActor)
	public bool shouldContinueToAttackTarget()
	public void clearAttackTarget()
	public bool isEnemyTargetAlive()
	public void setAttackTarget(BaseSimObject pAttackTarget)
	public bool hasRangeAttack()
	public bool hasMeleeAttack()
	private void checkAttackTypes()
	private bool isEquipmentMeleeAttack()
	public float getAttackCooldown()
	private void takeAwayItems()
	public bool isInDangerZone()
	public void setPossessionAttackHappened()
	public bool isPossessionAttackJustHappened()
	public void addLoot(int pLootValue)
	public void addMoney(int pValue)
	public int giveAllLoot()
		int result = data.loot;
	public int giveAllMoney()
		int result = data.money;
	public void spendMoney(int pCost)
	public int getMoneyForGift()
		float num = Randy.randomFloat(0.05f, 0.1f);
		int num2 = Mathf.RoundToInt((float)money * num);
	public void takeAllOwnLoot()
	public int giveAllLootAndMoney()
	public void paidTax(float pTaxRate, string pEffect)
		int pValue = -5;
	public void lootEmpty()
	public void giveInventoryResourcesToCity()
	public void generateDefaultSpawnWeapons(bool pUseOwnerless)
		string[] default_weapons = asset.default_weapons;
	public bool createNewWeapon(string pItemId)
	internal void reloadInventory()
	public void stealActionFrom(Actor pTarget, float pTargetStunnedTimer = 5f, float pWaitTimerForThief = 1f, bool pAddAggro = true, bool pPossessedSteal = false)
		bool flag = false;
		int num = pTarget.giveAllLootAndMoney();
	public bool tryToStealItems(Actor pActorTarget, bool pPossessedSteal = false)
		float pChance = 0.5f;
	public bool tryToAcceptGift(Actor pActorTarget)
	public void takeAllResources(Actor pActorTarget)
		foreach (KeyValuePair<string, ResourceContainer> resource in pActorTarget.inventory.getResources())
	public bool takeItems(Actor pActorTarget, float pChance = 1f, int pMaxItems = 0)
		bool result = false;
	public void addToInventory(string pResourceID, int pAmount)
	public void addToInventory(ResourceContainer pResourceContainer)
	public void takeFromInventory(string pID, int pAmount)
	public void setSubspecies(Subspecies pObject)
	public void joinLanguage(Language pLanguage)
	public void setLanguage(Language pObject)
	public void setPlot(Plot pObject)
	public void setReligion(Religion pObject)
	public void setFamily(Family pObject)
	public void setClan(Clan pObject)
	public void setCulture(Culture pCulture)
	internal void removeFromArmy()
	public void setArmy(Army pObject)
	internal void setCity(City pCity)
	public void setMetasFromCity(City pCity)
	public bool hasClan()
	public bool hasSubspecies()
	public bool hasArmy()
	public bool hasFamily()
	public bool hasLanguage()
	public bool hasPlot()
	public bool hasReligion()
	public bool tryToConvertToReligion(Religion pReligion)
	public bool tryToConvertToCulture(Culture pCulture)
		bool num = hasCulture();
	public bool tryToConvertToLanguage(Language pLanguage)
	public void saveOriginFamily(long pID)
	private void clearManagers()
	internal bool isCitizenJob(string pJob)
	public void forgetCulture()
	public void forgetReligion()
	public void forgetLanguage()
	public void forgetClan()
	public void forgetKingdomAndCity()
	public void tryToConvertActorToMetaFromActor(Actor pActor, bool pStunOnSuccess = true)
		int num = 0;
	public void joinCity(City pCity)
		bool flag = !asset.is_boat;
	public void joinKingdom(Kingdom pKingdom)
	internal void setKingdom(Kingdom pKingdomToSet)
	private void checkKingdom()
	public void setForcedKingdom(Kingdom pForcedKingdom)
	public bool hasCulture()
	public bool buildCityAndStartCivilization()
	public void createDefaultCultureAndLanguageAndClan(string pCultureName = null)
	public void checkDefaultKingdom()
	public void setDefaultKingdom()
	public void removeFromPreviousFaction()
	public bool wantsToSplitMeta()
	public NanoObject getMetaObjectOfType(MetaType pType)
	internal void setFlip(bool pFlip)
	public void precalcMovementSpeed(bool pForce = false)
		bool flag = isInAir();
		bool flag2 = isWaterCreature();
		float num = 1f;
		else if (!string.IsNullOrEmpty(current_tile.Type.ignore_walk_multiplier_if_tag) && !stats.hasTag(current_tile.Type.ignore_walk_multiplier_if_tag))
		float num2 = stats["speed"] * num;
	internal bool checkFlip()
	protected void updateMovement(float pElapsed, float pWalkedDistance = 0f)
		float num = Toolbox.DistVec2Float(current_position, next_step_position);
		float movementDelta = getMovementDelta(pElapsed, pWalkedDistance);
	private float getMovementDelta(float pElapsed, float pWalkedDistance = 0f)
		float current_combined_movement_speed = _current_combined_movement_speed;
	internal void updateMovementPossessedFlip()
	public void checkFlipAgainstTargetPosition(Vector2 pPosition)
	internal float updatePossessedMovementTowards(float pElapsed, Vector2 pMovementPoint)
		float movementDelta = getMovementDelta(pElapsed);
		Vector2 pNewPos = Vector2.MoveTowards(current_position, pMovementPoint, movementDelta);
	public Vector2 getPossessionControlTargetPosition()
	public Vector2 getPossessionControlTargetPositionMovementVector()
	private float getMismatchFactorForSideMovement(Vector2 pMovementPoint)
		bool flag = current_position.x < mousePos.x;
		bool flag2 = current_position.x < pMovementPoint.x;
		bool num = current_position.y < mousePos.y;
		bool flag3 = current_position.y < pMovementPoint.y;
		float num2 = Mathf.Abs(pMovementPoint.x - current_position.x);
		float num3 = Mathf.Abs(pMovementPoint.y - current_position.y);
		float num4 = 0f;
	internal void findCurrentTile(bool pCheckNeighbours = true)
		bool flag = mustAvoidGround();
	internal void checkFindCurrentTile()
		if (dirty_current_tile || (_next_step_tile != null && (float)Toolbox.SquaredDistTile(current_tile, _next_step_tile) > 4f))
	internal void setTileTarget(WorldTile pTile)
	internal void clearTileTarget()
	internal void clearOldPath()
	public virtual void updatePathMovement()
		bool flag = true;
	internal bool isFollowingLocalPath()
	internal bool isUsingPath()
	public ExecuteEvent goTo(WorldTile pTile, bool pPathOnWater = false, bool pWalkOnBlocks = false, bool pWalkOnLava = false, int pLimitPathfindingRegions = 0)
	public void clearPathForCalibration()
	private void finishStrangeUrgeMovement()
	public void stopMovement()
	private void setIsMoving()
	private void setNotMoving()
	public void setPossessedMovement(bool pValue)
	public void moveTo(WorldTile pTileTarget)
		if ((float)Toolbox.SquaredDistTile(current_tile, pTileTarget) > 4f)
	public Vector3 updatePos()
		float num = val.x + val3.x + val2.x;
		float num2 = val.y + val3.y + val2.y;
		float num3 = position_height;
	public void stayInBuilding(Building pBuilding)
	internal void exitBuilding()
	internal void embarkInto(Boat pBoat)
	internal void disembarkTo(Boat pBoat, WorldTile pTile)
	internal void exitBoat()
	internal void changeMoveJumpOffset(float pValue)
	internal void setCurrentTile(WorldTile pTile)
	internal void setCurrentTilePosition(WorldTile pTile)
	protected void updateWalkJump(float pElapsed)
	public bool inMapBorder()
	protected virtual void updateVelocity()
	private Vector2 checkVelocityAgainstBlock(Vector2 pNewPos)
		float num = 0.8f;
		float num2 = velocity.x * wallNormal.x + velocity.y * wallNormal.y;
		float num3 = velocity.x - 2f * num2 * wallNormal.x;
		float num4 = velocity.y - 2f * num2 * wallNormal.y;
	private Vector2 getWallNormal(Vector2 pPosition, Vector2 pBlockPosition)
	public void prepareForSave()
	private void saveCoordinates()
	private void saveAssetID()
	private void saveProfession()
	private void saveHomeBuilding()
	private void saveEquipment()
	private void saveLover()
	private void saveCity()
	private void saveKingdomCiv()
	private void saveCulture()
	private void saveClan()
	private void saveSubspecies()
	private void saveFamily()
	private void saveArmy()
	private void saveLanguage()
	private void savePlot()
	private void saveReligion()
	private void saveTraits()
	private void finishSaving()
	public void loadFromSave()
	private void countDeath(AttackType pType)
	public void increaseEvolutions()
	private void increaseKills()
	public void increaseChildren()
	public void decreaseChildren()
	public void increaseBirths()
	public void applyForcedKingdomTrait()
	public string getTraitsAsLocalizedString()
		string text = "";
	public void sortTraits(IReadOnlyCollection<ActorTrait> pTraits)
	public void traitModifiedEvent()
	public void removeTrait(string pTraitID)
	public bool removeTrait(ActorTrait pTrait)
		bool num = traits.Remove(pTrait);
	public void removeTraits(ICollection<ActorTrait> pTraits)
		bool flag = false;
	public void clearTraitCache()
	private void removeOppositeTraits(ActorTrait pTrait)
	public bool addTrait(string pTraitID, bool pRemoveOpposites = false)
	public bool addTrait(ActorTrait pTrait, bool pRemoveOpposites = false)
	internal bool hasOppositeTrait(string pTraitID)
	internal bool hasOppositeTrait(ActorTrait pTrait)
	public void generateRandomSpawnTraits(ActorAsset pAsset)
	public void checkTraitMutationOnBirth()
		int amountOfRandomMutationsActorTraits = subspecies.getAmountOfRandomMutationsActorTraits();
		for (int i = 0; i < amountOfRandomMutationsActorTraits; i++)
	public void checkTraitMutationGrowUp()
		int num = Randy.randomInt(0, 3);
		for (int i = 0; i < num; i++)
	public int countTraits()
	public bool hasTrait(string pTraitID)
	public bool hasTrait(ActorTrait pTrait)
	public void updateParallelChecks(float pElapsed)
	public void skipUpdates()
	public void skipBehaviour()
	public void u1_checkInside(float pElapsed)
	public void u2_updateChildren(float pElapsed)
	public void u3_spriteAnimation(float pElapsed)
	public void u4_deadCheck(float pElapsed)
	public void u5_curTileAction()
	public void u6_checkFrozen(float pElapsed)
	public void u8_checkUpdateTimers(float pElapsed)
	public void u7_checkAugmentationEffects()
		int i = 0;
		for (int count = _s_special_effect_augmentations.Count; i < count; i++)
		int j = 0;
		for (int count2 = tempAugmentationList.Count; j < count2; j++)
	public void b1_checkUnderForce(float pElapsed)
	public void b2_checkCurrentEnemyTarget(float pElapsed)
	public void b3_findEnemyTarget(float pElapsed)
	public void b4_checkTaskVerifier(float pElapsed)
	public void b5_checkPathMovement(float pElapsed)
	public void b6_0_updateDecision(float pElapsed)
	public string getLastDecisionForMindOverview()
	public void b6_updateAI(float pElapsed)
	public void b55_updateNaturalDeaths(float pElapsed)
	public void u10_checkSmoothMovement(float pElapsed)
public class ActorAnimation
	public int id;
	internal Sprite[] frames;
public static class ActorAnimationLoader
	public static readonly Dictionary<Sprite, int> int_ids_heads = new Dictionary<Sprite, int>();
	private static readonly Dictionary<string, AnimationContainerUnit> _dict_units = new Dictionary<string, AnimationContainerUnit>();
	private static readonly Dictionary<string, AnimationDataBoat> _dict_boats = new Dictionary<string, AnimationDataBoat>();
	private static readonly Dictionary<string, Sprite> _dict_civ_heads = new Dictionary<string, Sprite>();
	public static int count_units => _dict_units.Count;
	public static int count_boats => _dict_boats.Count;
	public static int count_heads => _dict_civ_heads.Count;
	public static Sprite getHeadSpecial(string pPath)
	public static Sprite getHead(string pPath, int pHeadIndex)
		string key = $"{pPath}_head_{pHeadIndex}";
	public static AnimationDataBoat loadAnimationBoat(string pTexturePath)
	private static void createBoatAnimationArray(AnimationDataBoat pAnimationData, Dictionary<string, Sprite> pDict, string pID, float pTimeBetween = 0.2f)
		int key = int.Parse(pID.Split('@')[0]);
	public static AnimationContainerUnit getAnimationContainer(string pTexturePath, ActorAsset pAsset, SubspeciesTrait pEggAsset = null, SubspeciesTrait pMutationSkinAsset = null)
	private static AnimationContainerUnit createAnimationContainer(string pTexturePath, ActorAsset pAsset, SubspeciesTrait pEggAsset, SubspeciesTrait pMutationSkinAsset = null)
		string[] animation_walk;
		string[] animation_swim;
		string[] animation_idle;
		if (actorTextureSubAsset.texture_heads != string.Empty)
		if (actorTextureSubAsset.texture_heads_male != string.Empty)
		if (actorTextureSubAsset.texture_heads_female != string.Empty)
	private static void generateFrameData(string pFrameString, AnimationContainerUnit pAnimContainer, Dictionary<string, Sprite> pFrames, string[] pStringIDs)
		if (string.IsNullOrEmpty(pFrameString) || pStringIDs == null)
		foreach (string text in pStringIDs)
	private static ActorAnimation createAnim(int pID, Dictionary<string, Sprite> pDict, string[] pStringIDs)
	private static Sprite[] createArray(Dictionary<string, Sprite> pDict, string[] pStringIDs)
		foreach (string key in pStringIDs)
public static class ActorAnimationSequences
	public static readonly string[] walk_0 = Toolbox.a<string>("walk_0");
	public static readonly string[] walk_0_1 = Toolbox.a<string>("walk_0", "walk_1");
	public static readonly string[] walk_0_2 = Toolbox.a<string>("walk_0", "walk_1", "walk_2");
	public static readonly string[] walk_0_3 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3");
	public static readonly string[] walk_0_4 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3", "walk_4");
	public static readonly string[] walk_0_5 = Toolbox.a<string>("walk_0", "walk_1", "walk_2", "walk_3", "walk_4", "walk_5");
	public static readonly string[] swim_0 = Toolbox.a<string>("swim_0");
	public static readonly string[] swim_0_1 = Toolbox.a<string>("swim_0", "swim_1");
	public static readonly string[] swim_0_2 = Toolbox.a<string>("swim_0", "swim_1", "swim_2");
	public static readonly string[] swim_0_3 = Toolbox.a<string>("swim_0", "swim_1", "swim_2", "swim_3");
	public static readonly string[] swim_0_5 = Toolbox.a<string>("swim_0", "swim_1", "swim_2", "swim_3", "swim_4", "swim_5");
	public static readonly string[] idle_0_3 = Toolbox.a<string>("idle_0", "idle_1", "idle_2", "idle_3");
public class ActorAsset : BaseUnlockableAsset, IDescriptionAsset, ILocalizedAsset, IAnimationFrames
	public bool split_ai_update = true;
	public bool has_ai_system = true;
	public int item_making_skill = 1;
	public bool affected_by_dust;
	public string sound_idle;
	public string sound_idle_loop;
	public string sound_spawn;
	public string sound_death;
	public string sound_attack;
	[DefaultValue("event:/SFX/HIT/HitGeneric")]
	public string sound_hit = "event:/SFX/HIT/HitGeneric";
	public bool show_controllable_tip = true;
	public bool show_task_icon = true;
	public string music_theme;
	public string music_theme_civ;
	public UnitTextureAtlasID texture_atlas;
	public bool ignored_by_infinity_coin;
	public string name_taxonomic_kingdom = "";
	public string name_taxonomic_phylum = "";
	public string name_taxonomic_class = "";
	public string name_taxonomic_order = "";
	public string name_taxonomic_family = "";
	public string name_taxonomic_genus = "";
	public string name_taxonomic_species = "";
	public bool name_subspecies_add_biome_suffix = true;
	public bool auto_civ;
	public string name_locale = "";
	public StatusTier allowed_status_tiers = StatusTier.Advanced;
	public bool render_status_effects = true;
	public ActorSize actor_size = ActorSize.S13_Human;
	public string[] animation_walk;
	public float animation_walk_speed = 10f;
	public string[] animation_swim;
	public float animation_swim_speed = 8f;
	public string[] animation_idle = ActorAnimationSequences.walk_0;
	public float animation_idle_speed = 10f;
	public float max_shake_timer = 10f;
	public bool animation_speed_based_on_walk_speed = true;
	public string default_attack = "base_attack";
	public bool immune_to_tumor;
	public bool immune_to_slowness;
	public int aggression;
	public bool shadow = true;
	public string shadow_texture = "unitShadow_5";
	public string shadow_texture_egg = "unitShadow_2";
	public string shadow_texture_baby = "unitShadow_4";
	public bool hit_fx_alternative_offset = true;
	public bool can_level_up = true;
	public bool can_talk_with = true;
	public float base_throwing_range;
	public bool use_tool_items = true;
	public bool use_items;
	public bool take_items;
	public bool control_can_jump = true;
	public bool control_can_talk = true;
	public bool control_can_dash = true;
	public bool control_can_backstep = true;
	public bool control_can_steal = true;
	public bool control_can_swear = true;
	public bool control_can_kick = true;
	public bool use_phenotypes;
	public Dictionary<string, List<string>> phenotypes_dict;
	public List<string> phenotypes_list;
	public List<string> generated_subspecies_names_prefixes;
	public bool can_be_killed_by_stuff;
	public bool can_be_killed_by_life_eraser;
	public bool can_be_killed_by_divine_light;
	public bool show_on_meta_layer = true;
	public bool ignore_tile_speed_multiplier;
	public bool skip_fight_logic;
	public bool can_attack_buildings;
	public bool can_attack_brains;
	public bool count_as_unit = true;
	public bool only_melee_attack;
	public bool flag_ufo;
	public bool flag_finger;
	public bool flag_turtle;
	public bool default_animal;
	public bool civ;
	public bool unit_other;
	public string kingdom_id_wild = "";
	public string kingdom_id_civilization = "";
	public bool special;
	public bool show_in_taxonomy_tooltip = true;
	public bool render_budding = true;
	public string family_banner_frame_generation_exclusion = "families/frame_11";
	public string family_banner_frame_generation_inclusion;
	public bool family_banner_frame_only_inclusion;
	public string texture_id = "";
	public string architecture_id = "";
	public string texture_path_zombie_for_auto_loader_main;
	public string texture_path_zombie_for_auto_loader_heads;
	public ActorTextureSubAsset texture_asset;
	public bool prevent_unconscious_rotation;
	public bool render_heads_for_babies;
	private string _debug_phenotype_color = "";
	public bool body_separate_part_hands;
	public bool has_baby_form;
	public bool has_advanced_textures;
	public List<string> decision_ids;
	private DecisionAsset[] _cached_assets_decisions;
	private int _cached_assets_decisions_counter;
	private HashSet<SubspeciesTrait> _cached_assets_subspecies_traits;
	private Sprite _cached_sprite;
	private BaseStats _cached_overview_stats;
	public float hovering_min = 0.5f;
	public float hovering_max = 1.2f;
	public bool hovering;
	public bool flying;
	public bool very_high_flyer;
	public bool disable_jump_animation;
	public bool rotating_animation;
	public bool die_on_blocks = true;
	public bool ignore_blocks;
	public bool move_from_block = true;
	public bool run_to_water_when_on_fire = true;
	public bool damaged_by_ocean;
	public bool cancel_beh_on_land = true;
	public bool force_ocean_creature;
	public bool force_land_creature;
	public bool is_humanoid;
	public bool is_boat;
	public bool is_boat_transport;
	public bool draw_boat_mark;
	public bool draw_boat_mark_big;
	public string boat_type = "";
	public int animal_breeding_close_units_limit = 6;
	public string avatar_prefab = "";
	public bool has_avatar_prefab;
	public bool ignore_generic_render;
	public bool need_colored_sprite;
	public bool die_from_dispel;
	public bool die_in_lava = true;
	public bool can_be_moved_by_powers;
	public bool can_be_hurt_by_powers;
	public bool can_turn_into_ice_one;
	public bool can_turn_into_mush;
	public bool can_turn_into_tumor;
	public bool can_evolve_into_new_species;
	public bool has_soul;
	public bool can_receive_traits = true;
	public string base_asset_id;
	public string power_id;
	public bool zombie_auto_asset;
	public bool can_turn_into_zombie;
	public string zombie_id_internal = "";
	public string zombie_color_hex = "#3B8130";
	public bool unit_zombie;
	public bool dynamic_sprite_zombie;
	public string skeleton_id = "";
	public string mush_id = "";
	public string tumor_id = "";
	public string evolution_id = "";
	public bool can_turn_into_demon_in_age_of_chaos;
	public bool show_icon_inspect_window;
	public string show_icon_inspect_window_id = "";
	public bool hide_favorite_icon;
	public bool can_be_favorited = true;
	public bool can_be_inspected;
	public float inspect_avatar_scale = 2.5f;
	public float inspect_avatar_offset_x;
	public float inspect_avatar_offset_y;
	public int nutrition_max = 100;
	public int months_breeding_timeout = 3;
	public int age_spawn = 18;
	public bool can_edit_traits = true;
	public bool can_edit_equipment;
	public bool finish_scale_on_creation = true;
	public float path_movement_timeout = 2f;
	public bool source_meat;
	public bool source_meat_insect;
	public float default_height = 0.3f;
	public bool update_z;
	public bool visible_on_minimap;
	public bool follow_herd;
	public bool inspect_stats = true;
	public bool inspect_children = true;
	public bool inspect_generation = true;
	public bool inspect_sex = true;
	public bool inspect_kills = true;
	public bool inspect_experience = true;
	public bool inspect_show_species = true;
	public bool inspect_mind = true;
	public bool inspect_genealogy = true;
	public bool allow_possession = true;
	public bool allow_strange_urge_movement = true;
	public bool inspect_home;
	public bool immune_to_injuries;
	public bool can_be_cloned = true;
	public int experience_given = 10;
	public string[] job;
	public string[] job_citizen;
	public string[] job_kingdom;
	public string[] job_baby;
	public string[] job_attacker;
	public string effect_cast_top = "fx_cast_top_blue";
	public string effect_cast_ground = "fx_cast_ground_blue";
	public string effect_teleport = "fx_teleport_blue";
	public List<string> spell_ids;
	public bool effect_damage;
	public bool can_flip;
	public bool special_dead_animation;
	public bool death_animation_angle;
	public StatusTier status_tiers = StatusTier.Advanced;
	public bool has_sprite_renderer = true;
	public bool die_by_lightning;
	public bool has_skin = true;
	public string grow_into_id = "";
	public string icon = "iconQuestionMark";
	public bool skip_save;
	public string color_hex;
	public Color32? color;
	public ConstructionCost cost;
	public int species_spawn_radius = 40;
	public bool can_have_subspecies;
	public int genome_size;
	public int family_spawn_radius = 30;
	public int family_limit = 20;
	public bool create_family_at_spawn;
	public FamilyParentsMode family_show_parents;
	public string collective_term = "COLLECTIVE_NAME";
	public int language_spawn_radius = 50;
	public List<string> traits;
	public HashSet<string> traits_ignore;
	public List<string> preferred_attribute;
	public HashSet<string> preferred_colors;
	public string[] production;
	public string[] name_template_sets;
	public string name_template_unit = "default_name";
	public string banner_id = "";
	public string build_order_template_id = "";
	public int civ_base_cities = 4;
	public float civ_base_army_multiplier = 0.35f;
	public List<string> default_subspecies_traits;
	public List<string> default_clan_traits;
	public List<string> default_culture_traits;
	public List<string> default_language_traits;
	public List<string> default_kingdom_traits;
	public List<string> default_religion_traits;
	public List<string> trait_filter_subspecies;
	public List<string> trait_group_filter_subspecies;
	public List<ResourceContainer> resources_given;
	public string[] skin_citizen_male;
	public string[] skin_citizen_female;
	public string[] skin_warrior;
	public string[] default_weapons;
	public ActorGetSprite get_override_sprite;
	public bool has_override_sprite;
	public ActorGetSprites get_override_avatar_frames;
	public bool has_override_avatar_frames;
	public List<string> chromosomes_first;
	public HashSet<GenomePart> genome_parts = new HashSet<GenomePart>();
	public int max_random_amount = 3;
	public bool can_be_surprised = true;
	public HashSet<Actor> units = new HashSet<Actor>();
	public ArchitectureAsset architecture_asset;
	public SpellHolder spells;
	public BaseActionActor action_on_load;
	public WorldAction action_click;
	public WorldAction action_death;
	public DeadAnimation action_dead_animation;
	public GetHitAction action_get_hit;
	public WorldAction check_flip;
	public bool force_hide_stamina;
	public bool force_hide_mana;
	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_actors;
	public bool has_sound_idle => sound_idle != null;
	public bool has_sound_idle_loop => sound_idle_loop != null;
	public bool has_sound_spawn => sound_spawn != null;
	public bool has_sound_death => sound_death != null;
	public bool has_sound_attack => sound_attack != null;
	public bool has_sound_hit => sound_hit != null;
	public bool has_music_theme => music_theme != null;
	public bool has_music_theme_civ => music_theme_civ != null;
	public string debug_phenotype_colors
	public string skin_civ_default_male => "male_1";
	public string skin_civ_default_female => "female_1";
	public int decisions_counter => _cached_assets_decisions_counter;
	public string boat_texture_id => id;
	public void addSubspeciesNamePrefix(string pName)
	public bool hasDefaultEggForm()
	public string getDefaultEggID()
		string result = "egg_shell_plain";
		foreach (string default_subspecies_trait in default_subspecies_traits)
	public void setZombie(bool pAnimal = true)
		kingdom_id_civilization = string.Empty;
		architecture_id = string.Empty;
		build_order_template_id = string.Empty;
		can_turn_into_zombie = false;
		can_turn_into_mush = false;
		zombie_id_internal = string.Empty;
		job = Toolbox.a<string>("decision");
		can_evolve_into_new_species = false;
		sound_hit = "event:/SFX/HIT/HitFlesh";
	public void setCanTurnIntoZombieAsset(string pZombieID, bool pAutoZombieAsset)
		can_turn_into_zombie = true;
		zombie_id_internal = pZombieID;
	public string getZombieID()
		return zombie_id_internal;
	public void cloneTaxonomyFromForSapiens(string pFrom)
		name_taxonomic_class = actorAsset.name_taxonomic_class;
	public string getTaxonomyRank(string pType)
			"taxonomy_class" => name_taxonomic_class,
	public bool isTaxonomyRank(string pType, string pID)
	public void setSocialStructure(string pTerm, int pLimit, bool pCreateOnSpawn = true, bool pFollowHerd = true, FamilyParentsMode pShowParents = FamilyParentsMode.Alpha)
	public void generateFmodPaths(string pID)
		string text = "event:/SFX/UNITS/" + pID;
	public void clonePhenotype(string pFrom)
	public PhenotypeAsset getDefaultPhenotypeAsset()
		string pID = phenotypes_list[0];
	public void clearTraits()
	public string getCollectiveTermID()
	public override string getLocaleID()
	public string getDescriptionID()
	public string getLocalizedName()
	public string getLocalizedDescription()
	public void addPreferredColors(params string[] pColors)
		preferred_colors = new HashSet<string>(pColors);
	public string getTranslatedName()
	public void addGenome(params (string, float)[] pListGenomePartsIDs)
		for (int i = 0; i < pListGenomePartsIDs.Length; i++)
	public string getIconPath()
	public Sprite getSpriteIcon()
	public override Sprite getSprite()
	public bool hasBiomePhenotype(string pBiomeID)
	public BaseStats getStatsForOverview()
	public bool hasDecisions()
		List<string> list = decision_ids;
	public DecisionAsset[] getDecisions()
	public string getDefaultKingdom()
	public HashSet<SubspeciesTrait> getDefaultSubspeciesTraits()
	public int countPopulation()
	public int countSubspecies()
		int num = 0;
	public int countFamilies()
		int num = 0;
	public void addSpell(string pID)
	public void addTraitGroupFilter(string pTrait)
	public void addTrait(string pTraitID)
	public void addTraitIgnore(string pTraitID)
	public void removeTrait(string pTrait)
		List<string> list = traits;
	public void addSubspeciesTrait(string pTrait)
	public void addCultureTrait(string pTrait)
	public void addLanguageTrait(string pTrait)
	public void addKingdomTrait(string pTrait)
	public void addClanTrait(string pTrait)
	public void addReligionTrait(string pTrait)
	public void addDecision(string pDecision)
	public override bool unlock(bool pSaveData = true)
		string text = (string.IsNullOrEmpty(base_asset_id) ? id : base_asset_id);
	protected override bool isDebugUnlockedAll()
	public bool canEditItem(EquipmentAsset pItem)
	public void addResource(string pID, int pAmount, bool pNewList = false)
	public BuildingAsset getBuildingDockAsset()
		string pID = "docks_" + architecture_id;
	public void setSimpleCivSettings()
		skin_citizen_male = Toolbox.a<string>("male_1");
		skin_citizen_female = Toolbox.a<string>("female_1");
		skin_warrior = Toolbox.a<string>("warrior_1");
		production = new string[1] { "bread" };
		name_template_sets = Toolbox.a<string>("default_name");
		job = Toolbox.a<string>("decision");
		job_citizen = Toolbox.a<string>("unit_citizen");
		job_kingdom = Toolbox.a<string>("decision");
		job_baby = Toolbox.a<string>("decision");
		job_attacker = Toolbox.a<string>("attacker");
	public bool canBecomeSapient()
		return !string.IsNullOrEmpty(kingdom_id_civilization);
	public bool hasDefaultSpells()
	public TooltipData getTooltip()
	public GodPower getGodPower()
		string pID = power_id ?? base_asset_id ?? id;
	public string getNameTemplate(MetaType pType)
		string text = name_template_sets?.GetRandom();
		if (!string.IsNullOrEmpty(text))
	public string[] getWalk()
	public string[] getIdle()
	public string[] getSwim()
public class ActorAssetElementPlace : BaseAssetElementPlace<ActorAsset, ActorDebugAssetElement>
public delegate bool ActorAssetFilter(ActorAsset pAsset);
using strings;
public class ActorAssetLibrary : BaseLibraryWithUnlockables<ActorAsset>
	public List<ActorAsset> list_only_boat_assets;
	private int _humanoids_amount;
	private const string TEMPLATE_BASIC_UNIT = "$basic_unit$";
	private const string TEMPLATE_BASIC_UNIT_COLORED = "$basic_unit_colored$";
	private const string TEMPLATE_ANIMAL_BASE = "$animal_base$";
	private const string TEMPLATE_ANIMAL = "$animal$";
	private const string TEMPLATE_ANIMAL_FUR = "$animal_fur$";
	private const string TEMPLATE_ANIMAL_SKIN = "$animal_skin$";
	private const string TEMPLATE_PEACEFUL_ANIMAL = "$peaceful_animal$";
	private const string TEMPLATE_CARNIVORE = "$carnivore$";
	private const string TEMPLATE_HERBIVORE = "$herbivore$";
	private const string TEMPLATE_OMNIVORE = "$omnivore$";
	private const string TEMPLATE_CIV_UNIT = "$civ_unit$";
	private const string TEMPLATE_CIV_ADVANCED_UNIT = "$civ_advanced_unit$";
	private const string TEMPLATE_BOAT = "$boat$";
	private const string TEMPLATE_BOAT_TRADING = "$boat_trading$";
	private const string TEMPLATE_BOAT_TRANSPORT = "$boat_transport$";
	private const string TEMPLATE_MOB_NO_GENES = "$mob_no_genes$";
	private const string TEMPLATE_MOB = "$mob$";
	private const string TEMPLATE_CREEP_MOB = "$creep_mob$";
	private const string TEMPLATE_ANIMAL_CIV = "$animal_civ$";
	private const string TEMPLATE_INSECT = "$insect$";
	private const string TEMPLATE_FLYING_INSECT = "$flying_insect$";
	public int getHumanoidsAmount()
	public override void init()
	private void initSpecial()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("greg_set");
		t.name_taxonomic_class = "gregia";
		t.addReligionTrait("echo_of_the_void");
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("living_plant_set");
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.action_on_load = delegate(Actor pActor)
		t.get_override_sprite = delegate(Actor pActor)
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("living_house_set");
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.job = AssetLibrary<ActorAsset>.a<string>("dragon_job");
		t.prevent_unconscious_rotation = true;
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.action_dead_animation = delegate(BaseSimObject pTarget, WorldTile _, float _)
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
	private void initAnts()
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_black");
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_green");
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_blue");
		t.job = AssetLibrary<ActorAsset>.a<string>("ant_red");
		t.job = AssetLibrary<ActorAsset>.a<string>("sandspider_job");
		t.job = AssetLibrary<ActorAsset>.a<string>("worm_job");
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		clone("printer", "ant_black");
		t.job = AssetLibrary<ActorAsset>.a<string>("printer_job");
		t.name_locale = "Printer";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
	private void initCreepMobs()
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("default_set");
		t.can_turn_into_ice_one = false;
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		t.name_taxonomic_class = "sordariomycetes";
		t.can_turn_into_zombie = false;
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("default_set");
		t.name_taxonomic_class = "malignomorpha";
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("pumpkin_set");
		t.name_taxonomic_class = "dicotyledonae";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("assimilator_set");
		t.name_taxonomic_class = "slowupdata";
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("shotgun");
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bioblob_set");
		t.name_taxonomic_class = "myxogastria";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.prevent_unconscious_rotation = true;
	public void clearPhenotypes()
	public void addPhenotype(string pID, string pType = "default_color")
	public void clear()
		for (int i = 0; i < list.Count; i++)
	internal void addTrait(string pTrait)
	internal void addTraitIgnore(string pTrait)
	internal void removeTrait(string pTrait)
	public override void post_init()
	private void linkSpells()
	public override void linkAssets()
	private void linkArchitectures()
	public override ActorAsset add(ActorAsset pAsset)
	private void fillOnlyBoatsList()
	private void setupBoolSpriteOverrides()
	private void setupBoolsAvatarPrefabs()
	private void loadAutoTextures(IEnumerable<ActorAsset> pAssetsList)
	private void generateFmodPaths()
	private void loadTexturesAndSprites(ActorAsset pAsset)
		string text = "actors/species/";
		string texture_id = pAsset.id;
		if (pAsset.texture_id != string.Empty)
		if (pAsset.can_turn_into_zombie)
	private void generateZombieAssets()
	private void loadShadows()
	private void createDefaultZombieAsset()
		actorAsset.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
	private void setDefaultZombieFields(ActorAsset pAsset, ActorAsset pDefaultCreatureAsset, bool pAnimal = false)
		pAsset.banner_id = string.Empty;
		pAsset.job = AssetLibrary<ActorAsset>.a<string>("decision");
	public override void editorDiagnostic()
	private void phenotypeChecks()
		using ListPool<string> listPool = new ListPool<string>();
		HashSet<string> hashSet = new HashSet<string>();
		foreach (ref string item2 in listPool)
		foreach (string item4 in hashSet)
	private void editorNameSetChecks()
	private void editorErrorChecks()
	public void preloadMainUnitSprites()
	public override void editorDiagnosticLocales()
	private void initAnimalsNormal()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fox_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("buffalo_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("hyena_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crocodile_set");
		t.name_taxonomic_class = "reptilia";
		t.prevent_unconscious_rotation = true;
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("monkey_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rhino_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("frog_set");
		t.name_taxonomic_class = "amphibia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snake_set");
		t.name_taxonomic_class = "reptilia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bear_set");
		t.addSubspeciesTrait("winter_slumberers");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("piranha_set");
		t.name_taxonomic_class = "actinopterygii";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rabbit_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cat_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("raccoon_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("seal_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("ostrich_set");
		t.name_taxonomic_class = "aves";
		t.can_evolve_into_new_species = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("unicorn_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rat_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("chicken_set");
		t.name_taxonomic_class = "aves";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("sheep_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cow_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("penguin_set");
		t.name_taxonomic_class = "aves";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("armadillo_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alpaca_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("capybara_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("goat_set");
		t.name_taxonomic_class = "mammalia";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("scorpion_set");
		t.name_taxonomic_class = "arachnida";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("turtle_set");
		t.name_taxonomic_class = "reptilia";
		t.can_evolve_into_new_species = true;
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crab_set");
		t.name_taxonomic_class = "malacostraca";
		t.can_evolve_into_new_species = true;
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
	private void initAnimalsWeird()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crystal_sword_set");
		t.name_taxonomic_class = "anthozoa";
		t.sound_hit = "event:/SFX/HIT/HitStone";
		t.can_evolve_into_new_species = true;
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("smore_set");
		t.name_taxonomic_class = "magnoliopsida";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("acid_blob_set");
		t.name_taxonomic_class = "myxogastria";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.can_evolve_into_new_species = true;
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("flower_set");
		t.name_taxonomic_class = "liliopsida";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("lemon_man_set");
		t.name_taxonomic_class = "magnoliopsida";
		t.can_evolve_into_new_species = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("garlic_man_set");
		t.name_taxonomic_class = "liliopsida";
		t.can_evolve_into_new_species = true;
	private void initInsects()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.name_taxonomic_class = "insecta";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.name_taxonomic_class = "insecta";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.name_taxonomic_class = "insecta";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.name_taxonomic_class = "insecta";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.can_evolve_into_new_species = true;
		t.name_taxonomic_class = "insecta";
	private void initBoats()
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.job = AssetLibrary<ActorAsset>.a<string>("decision");
		t.prevent_unconscious_rotation = true;
		t.get_override_sprite = delegate(Actor pActor)
		t.cost = new ConstructionCost(10, 0, 0, 10);
		t.cost = new ConstructionCost(5, 0, 2, 20);
		t.cost = new ConstructionCost(5, 0, 0, 5);
	private void initCivsClassic()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("human_default_set", "human_slavic_set", "human_germanic_set", "human_rus_set", "human_posh_set", "human_folk_set", "human_pomeranian_set", "human_frankish_set", "human_rome_set", "human_iberian_set", "human_monolux_set");
		t.name_taxonomic_class = "mammalia";
		t.addGenome(("health", 100f), ("stamina", 100f), ("mutation", 1f), ("bonus_sex_random", 2f), ("bad", 2f), ("lifespan", 70f), ("damage", 15f), ("speed", 15f), ("offspring", 5f), ("diplomacy", 3f), ("warfare", 3f), ("stewardship", 3f), ("intelligence", 3f));
		t.addLanguageTrait("nicely_structured_grammar");
		t.production = new string[2] { "bread", "pie" };
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("elf_default_set");
		t.name_taxonomic_class = "mammalia";
		t.addGenome(("health", 70f), ("bonus_sex_random", 1f), ("stamina", 200f), ("lifespan", 500f), ("mutation", 2f), ("damage", 10f), ("speed", 20f), ("offspring", 2f), ("diplomacy", 5f), ("warfare", 2f), ("stewardship", 2f), ("intelligence", 6f));
		t.production = new string[4] { "bread", "jam", "sushi", "cider" };
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("orc_default_set");
		t.name_taxonomic_class = "mammalia";
		t.addGenome(("health", 150f), ("bonus_sex_random", 1f), ("stamina", 130f), ("lifespan", 50f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 10f), ("diplomacy", 2f), ("warfare", 5f), ("birth_rate", 5f), ("stewardship", 3f), ("intelligence", 2f));
		t.production = new string[3] { "bread", "burger", "tea" };
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("dwarf_default_set", "dwarf_nordic_set");
		t.name_taxonomic_class = "mammalia";
		t.addGenome(("health", 150f), ("bonus_sex_random", 1f), ("stamina", 40f), ("lifespan", 220f), ("mutation", 2f), ("damage", 18f), ("speed", 12f), ("offspring", 3f), ("diplomacy", 2f), ("warfare", 3f), ("stewardship", 5f), ("intelligence", 2f));
		t.production = new string[2] { "bread", "ale" };
	private void initCivsNew()
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cat_set");
		t.addGenome(("health", 80f), ("stamina", 150f), ("lifespan", 100f), ("mutation", 2f), ("damage", 20f), ("speed", 17f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.addGenome(("health", 120f), ("stamina", 130f), ("lifespan", 80f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("chicken_set");
		t.addGenome(("health", 60f), ("stamina", 30f), ("lifespan", 80f), ("mutation", 3f), ("damage", 10f), ("speed", 7f), ("offspring", 12f), ("diplomacy", 4f), ("warfare", 2f), ("stewardship", 4f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rabbit_set");
		t.addGenome(("health", 60f), ("stamina", 150f), ("lifespan", 90f), ("mutation", 3f), ("damage", 10f), ("speed", 12f), ("offspring", 12f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("monkey_set");
		t.addGenome(("health", 90f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 2f), ("damage", 20f), ("speed", 14f), ("offspring", 8f), ("diplomacy", 4f), ("warfare", 3f), ("stewardship", 2f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fox_set");
		t.addGenome(("health", 80f), ("stamina", 120f), ("lifespan", 120f), ("mutation", 2f), ("damage", 20f), ("speed", 12f), ("offspring", 4f), ("diplomacy", 4f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("sheep_set");
		t.addGenome(("health", 90f), ("stamina", 30f), ("lifespan", 100f), ("mutation", 2f), ("damage", 10f), ("speed", 12f), ("offspring", 2f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 3f));
		t.addLanguageTrait("nicely_structured_grammar");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cow_set");
		t.addGenome(("health", 120f), ("stamina", 20f), ("lifespan", 100f), ("mutation", 2f), ("damage", 10f), ("speed", 11f), ("offspring", 2f), ("diplomacy", 4f), ("warfare", 1f), ("stewardship", 4f), ("intelligence", 3f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("armadillo_set");
		t.addGenome(("health", 200f), ("stamina", 50f), ("lifespan", 100f), ("mutation", 1f), ("damage", 20f), ("armor", 20f), ("speed", 17f), ("offspring", 2f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 4f), ("intelligence", 3f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("wolf_set");
		t.addGenome(("health", 130f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 20f), ("offspring", 4f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bear_set");
		t.addGenome(("health", 180f), ("stamina", 150f), ("lifespan", 80f), ("mutation", 3f), ("damage", 30f), ("armor", 5f), ("speed", 14f), ("offspring", 2f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.addSubspeciesTrait("winter_slumberers");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rhino_set");
		t.addGenome(("health", 230f), ("stamina", 110f), ("lifespan", 80f), ("mutation", 1f), ("damage", 35f), ("armor", 15f), ("speed", 16f), ("offspring", 2f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 2f), ("intelligence", 2f));
		t.addClanTrait("void_ban");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("buffalo_set");
		t.addGenome(("health", 160f), ("stamina", 120f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 16f), ("offspring", 2f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("hyena_set");
		t.addGenome(("health", 130f), ("stamina", 140f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("armor", 5f), ("speed", 20f), ("offspring", 6f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("rat_set");
		t.addGenome(("health", 80f), ("stamina", 50f), ("lifespan", 80f), ("mutation", 4f), ("damage", 12f), ("speed", 16f), ("armor", 5f), ("offspring", 15f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alpaca_set");
		t.addGenome(("health", 110f), ("stamina", 50f), ("lifespan", 150f), ("mutation", 1f), ("damage", 18f), ("speed", 12f), ("offspring", 3f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("capybara_set");
		t.addGenome(("health", 130f), ("stamina", 30f), ("lifespan", 90f), ("mutation", 1f), ("damage", 18f), ("speed", 10f), ("offspring", 4f), ("diplomacy", 4f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("goat_set");
		t.addGenome(("health", 110f), ("stamina", 100f), ("lifespan", 80f), ("mutation", 1f), ("damage", 15f), ("speed", 16f), ("offspring", 3f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("scorpion_set");
		t.addGenome(("health", 130f), ("stamina", 30f), ("lifespan", 150f), ("mutation", 3f), ("damage", 30f), ("speed", 11f), ("armor", 25f), ("offspring", 25f), ("diplomacy", 1f), ("warfare", 5f), ("stewardship", 2f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crab_set");
		t.addGenome(("health", 130f), ("stamina", 20f), ("lifespan", 80f), ("mutation", 1f), ("damage", 18f), ("speed", 12f), ("armor", 25f), ("offspring", 30f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 3f), ("intelligence", 3f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("penguin_set");
		t.addGenome(("health", 110f), ("stamina", 100f), ("lifespan", 80f), ("mutation", 1f), ("damage", 12f), ("speed", 10f), ("offspring", 2f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("turtle_set");
		t.addGenome(("health", 180f), ("stamina", 50f), ("lifespan", 500f), ("mutation", 1f), ("damage", 12f), ("speed", 8f), ("armor", 25f), ("offspring", 20f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crocodile_set");
		t.addGenome(("health", 130f), ("stamina", 60f), ("lifespan", 90f), ("mutation", 1f), ("damage", 20f), ("speed", 10f), ("armor", 10f), ("offspring", 10f), ("diplomacy", 2f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 3f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snake_set");
		t.addGenome(("health", 80f), ("stamina", 40f), ("lifespan", 150f), ("mutation", 1f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 10f), ("diplomacy", 3f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("frog_set");
		t.addGenome(("health", 80f), ("stamina", 50f), ("lifespan", 90f), ("mutation", 3f), ("damage", 12f), ("speed", 7f), ("offspring", 15f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("piranha_set");
		t.addGenome(("health", 40f), ("stamina", 50f), ("lifespan", 30f), ("mutation", 1f), ("damage", 30f), ("speed", 7f), ("armor", 5f), ("offspring", 20f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 1f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("flower_set");
		t.addGenome(("health", 40f), ("stamina", 100f), ("lifespan", 400f), ("mutation", 2f), ("damage", 5f), ("speed", 10f), ("offspring", 10f), ("diplomacy", 6f), ("warfare", 1f), ("stewardship", 6f), ("intelligence", 5f));
		t.addLanguageTrait("nicely_structured_grammar");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("garlic_man_set");
		t.addGenome(("health", 80f), ("stamina", 100f), ("lifespan", 250f), ("mutation", 2f), ("damage", 12f), ("speed", 20f), ("armor", 5f), ("offspring", 9f), ("diplomacy", 3f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("lemon_man_set");
		t.addGenome(("health", 80f), ("stamina", 100f), ("lifespan", 150f), ("mutation", 4f), ("damage", 12f), ("speed", 14f), ("offspring", 5f), ("diplomacy", 6f), ("warfare", 2f), ("stewardship", 5f), ("intelligence", 5f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("acid_blob_set");
		t.addGenome(("health", 80f), ("stamina", 30f), ("lifespan", 150f), ("mutation", 10f), ("damage", 18f), ("speed", 9f), ("armor", 5f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 4f), ("stewardship", 2f), ("intelligence", 5f));
		t.addCultureTrait("city_layout_madman_labyrinth");
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("crystal_golem_set");
		t.addGenome(("health", 250f), ("stamina", 60f), ("lifespan", 1000f), ("mutation", 1f), ("damage", 30f), ("speed", 12f), ("armor", 30f), ("offspring", 2f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 2f), ("intelligence", 4f));
		t.addCultureTrait("city_layout_titan_footprints");
		t.sound_hit = "event:/SFX/HIT/HitStone";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("candy_man_set");
		t.addGenome(("health", 85f), ("stamina", 60f), ("lifespan", 150f), ("mutation", 5f), ("damage", 12f), ("speed", 10f), ("offspring", 4f), ("diplomacy", 6f), ("warfare", 2f), ("stewardship", 3f), ("intelligence", 5f));
		t.sound_hit = "event:/SFX/HIT/HitStone";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("insect_set");
		t.addGenome(("health", 100f), ("stamina", 70f), ("lifespan", 50f), ("mutation", 1f), ("damage", 10f), ("speed", 12f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 4f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("seal_set");
		t.addGenome(("health", 100f), ("stamina", 70f), ("lifespan", 50f), ("mutation", 1f), ("damage", 10f), ("speed", 12f), ("offspring", 10f), ("diplomacy", 1f), ("warfare", 6f), ("stewardship", 4f), ("intelligence", 4f));
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("unicorn_set");
	private void initMobsOther()
		t.can_turn_into_ice_one = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("cold_one_set");
		t.name_taxonomic_class = "anthozoa";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("ice_hammer");
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("necromancer_set");
		t.name_taxonomic_class = "pucciniomycetes";
		t.addGenome(("health", 300f), ("stamina", 50f), ("mutation", 1f), ("lifespan", 550f), ("damage", 15f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 6f), ("warfare", 8f), ("stewardship", 6f), ("intelligence", 7f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("necromancer_staff");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("druid_set");
		t.name_taxonomic_class = "agaricomycetes";
		t.addGenome(("health", 100f), ("stamina", 100f), ("lifespan", 200f), ("mutation", 2f), ("damage", 12f), ("speed", 12f), ("armor", 4f), ("offspring", 8f), ("diplomacy", 7f), ("warfare", 5f), ("stewardship", 8f), ("intelligence", 6f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("druid_staff");
		addTrait("flower_prints");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("plague_doctor_set");
		t.name_taxonomic_class = "eurotiomycetes";
		t.addGenome(("health", 500f), ("stamina", 100f), ("lifespan", 100f), ("mutation", 2f), ("damage", 1f), ("speed", 20f), ("armor", 4f), ("offspring", 6f), ("diplomacy", 7f), ("warfare", 5f), ("stewardship", 8f), ("intelligence", 6f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("plague_doctor_staff");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("white_mage_set");
		t.addSubspeciesTrait("gift_of_void");
		t.name_taxonomic_class = "agaricomycetes";
		t.addGenome(("health", 300f), ("stamina", 50f), ("lifespan", 500f), ("mutation", 1f), ("damage", 5f), ("speed", 10f), ("armor", 3f), ("offspring", 2f), ("diplomacy", 8f), ("warfare", 4f), ("stewardship", 7f), ("intelligence", 7f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("white_staff");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("evil_mage_set");
		t.addSubspeciesTrait("gift_of_void");
		t.name_taxonomic_class = "pucciniomycetes";
		t.addGenome(("health", 500f), ("stamina", 60f), ("lifespan", 450f), ("mutation", 1f), ("damage", 1f), ("armor", 4f), ("speed", 20f), ("offspring", 2f), ("diplomacy", 5f), ("warfare", 7f), ("stewardship", 5f), ("intelligence", 8f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("evil_staff");
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("phenotypes");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("skeleton_set");
		t.job = AssetLibrary<ActorAsset>.a<string>("skeleton_job");
		t.name_taxonomic_class = "calciata";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("bow_bronze", "bow_steel", "bow_iron", "sword_steel", "spear_steel", "sword_iron");
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.sound_hit = "event:/SFX/HIT/HitBone";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("jumpy_skull_set");
		t.name_taxonomic_class = "daemonica";
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_ice_one = false;
		t.sound_hit = "event:/SFX/HIT/HitBone";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fire_elemental_set");
		t.name_taxonomic_class = "daemonica";
		t.trait_group_filter_subspecies = AssetLibrary<ActorAsset>.l<string>("advanced_brain", "phenotypes");
		t.can_turn_into_mush = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.can_turn_into_tumor = false;
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("necromancer_set");
		t.can_turn_into_zombie = false;
		t.job = AssetLibrary<ActorAsset>.a<string>("skeleton_job");
		t.can_turn_into_mush = false;
		t.mush_id = string.Empty;
		t.can_turn_into_tumor = false;
		t.tumor_id = string.Empty;
		t.sound_hit = "event:/SFX/HIT/HitGeneric";
		t.prevent_unconscious_rotation = true;
		t.name_taxonomic_class = "ectoplasmica";
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fire_skull_set");
		t.name_taxonomic_class = "daemonica";
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("demon_set");
		t.name_taxonomic_class = "daemonica";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("flame_sword");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("angle_set");
		t.name_taxonomic_class = "geometrica";
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("ice_hammer");
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("fairy_set");
		t.addSubspeciesTrait("hyper_intelligence");
		t.name_taxonomic_class = "insecta";
		t.prevent_unconscious_rotation = true;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("bandit_set");
		t.addGenome(("health", 100f), ("stamina", 100f), ("lifespan", 60f), ("mutation", 2f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 5f), ("diplomacy", 4f), ("warfare", 6f), ("stewardship", 3f), ("intelligence", 4f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("spear_bronze", "spear_steel", "spear_iron", "sword_bronze", "sword_steel", "sword_iron", "bow_bronze", "bow_steel", "bow_iron");
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("snowman_set");
		t.name_taxonomic_class = "anthozoa";
		t.addGenome(("health", 100f), ("stamina", 50f), ("lifespan", 60f), ("mutation", 5f), ("damage", 10f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 2f), ("warfare", 2f), ("stewardship", 2f), ("intelligence", 2f));
		t.can_turn_into_mush = false;
		t.can_turn_into_tumor = false;
		t.can_turn_into_zombie = false;
		t.can_turn_into_ice_one = false;
		t.name_template_sets = AssetLibrary<ActorAsset>.a<string>("alien_set");
		t.addSubspeciesTrait("hyper_intelligence");
		t.name_taxonomic_class = "eutardigrada";
		t.addGenome(("health", 200f), ("stamina", 150f), ("lifespan", 60f), ("mutation", 2f), ("damage", 18f), ("speed", 10f), ("armor", 5f), ("offspring", 3f), ("diplomacy", 7f), ("warfare", 7f), ("stewardship", 7f), ("intelligence", 7f));
		t.default_weapons = AssetLibrary<ActorAsset>.a<string>("alien_blaster");
		t.can_turn_into_tumor = true;
		t.can_turn_into_mush = true;
	private void initTemplates()
		t.job = AssetLibrary<ActorAsset>.a<string>("decision");
		t.chromosomes_first = AssetLibrary<ActorAsset>.l<string>("chromosome_big", "chromosome_medium");
		t.can_turn_into_demon_in_age_of_chaos = true;
		t.can_turn_into_mush = true;
		t.can_turn_into_ice_one = true;
		t.can_turn_into_tumor = true;
		t.skin_citizen_male = AssetLibrary<ActorAsset>.a<string>("male_1", "male_2", "male_3", "male_4", "male_5", "male_6", "male_7", "male_8", "male_9", "male_10");
		t.skin_citizen_female = AssetLibrary<ActorAsset>.a<string>("female_1", "female_2", "female_3", "female_4", "female_5", "female_6", "female_7", "female_8", "female_9", "female_10");
		t.skin_warrior = AssetLibrary<ActorAsset>.a<string>("warrior_1", "warrior_2", "warrior_3", "warrior_4", "warrior_5", "warrior_6", "warrior_7", "warrior_8", "warrior_9", "warrior_10");
		t.kingdom_id_civilization = string.Empty;
		t.build_order_template_id = string.Empty;
		t.can_turn_into_mush = true;
		t.can_turn_into_ice_one = true;
		t.can_turn_into_tumor = true;
		t.can_turn_into_mush = true;
		t.can_turn_into_tumor = true;
		t.can_turn_into_mush = true;
		t.can_turn_into_tumor = true;
		t.can_turn_into_mush = true;
		t.chromosomes_first = AssetLibrary<ActorAsset>.l<string>("chromosome_tiny");
		t.addGenome(("diplomacy", 3f), ("warfare", 3f), ("stewardship", 3f), ("intelligence", 3f));
public class ActorAssetWindow : BaseDebugAssetWindow<ActorAsset, ActorDebugAssetElement>
	public void clickRandomKingdomColor()
	public void clickRandomSkinColor()
	public void clickChangeSex()
	protected override void initSprites()
		string pPath = asset.texture_asset.texture_path_base;
		if (new List<string> { "dragon", "zombie_dragon", "worm" }.Contains(asset.id))
public class ActorAvatar : MonoBehaviour
	public Dragon dragon;
	public Boat boat;
	public UFO ufo;
	public Crabzilla crabzilla;
	public GodFinger god_finger;
	public SpriteAnimation sprite_animation;
public class ActorAvatarData
	public ActorAsset asset;
	public SubspeciesTrait mutation_skin_asset;
	public ActorSex sex;
	public Sprite sprite_head;
	public int head_id;
	public long actor_id;
	public int phenotype_index;
	public int phenotype_skin_shade;
	public ColorAsset kingdom_color;
	public bool is_egg;
	public bool is_king;
	public bool is_warrior;
	public bool is_wise;
	public SubspeciesTrait egg_asset;
	public bool is_adult;
	public bool is_lying;
	public bool is_touching_liquid;
	public bool is_inside_boat;
	public bool is_hovering;
	public bool is_immovable;
	public bool is_unconscious;
	public bool is_stop_idle_animation;
	public IHandRenderer item_renderer;
	public int actor_hash;
	public IEnumerable<string> statuses;
	public IReadOnlyDictionary<string, Status> statuses_gameplay;
	public void setData(Actor pActor)
		setData(actorAsset, pActor.subspecies?.mutation_skin_asset, data.sex, data.id, data.head, pActor.cached_sprite_head, data.phenotype_index, data.phenotype_shade, pActor.kingdom.getColor(), pActor.isEgg(), pActor.isKing(), pActor.isWarrior() && !pActor.equipment.helmet.isEmpty(), pActor.hasTrait("wise"), pActor.subspecies?.egg_asset, pActor.isAdult(), !actorAsset.prevent_unconscious_rotation && pActor.isLying(), pActor.isTouchingLiquid(), pActor.is_inside_boat, pActor.isHovering(), pActor.isImmovable(), !actorAsset.prevent_unconscious_rotation && pActor.is_unconscious, pActor.hasStopIdleAnimation(), pActor.getHandRendererAsset(), pActor.GetHashCode(), pActor.getStatusesIds(), pActor.getStatusesDict());
	public void setData(ActorAsset pAsset, SubspeciesTrait pMutation, ActorSex pSex, long pActorId, int pHeadId, Sprite pSpriteHead, int pPhenotypeIndex, int pPhenotypeSkinShade, ColorAsset pKingdomColor, bool pIsEgg, bool pIsKing, bool pIsWarrior, bool pIsWise, SubspeciesTrait pEggAsset, bool pIsAdult, bool pIsLying, bool pIsTouchingLiquid, bool pIsInsideBoat, bool pIsHovering, bool pIsImmovable, bool pIsUnconscious, bool pIsStopIdleAnimation, IHandRenderer pItemPath, int pActorHash, IEnumerable<string> pStatuses, IReadOnlyDictionary<string, Status> pGameplayStatuses)
	public ActorTextureSubAsset getTextureAsset()
	public Sprite getColoredSprite(Sprite pSprite, AnimationContainerUnit pContainer)
	public bool hasRenderedSpriteHead()
public class ActorBag
	internal Dictionary<string, ResourceContainer> dict;
	internal string last_item_to_render;
public static class ActorBagExtensions
	public static ActorBag add(this ActorBag pBag, ResourceContainer pResourceContainer)
	public static ActorBag add(this ActorBag pBag, string pID, int pAmount)
	public static ActorBag remove(this ActorBag pBag, string pID, int pAmount)
	public static Dictionary<string, ResourceContainer> getResources(this ActorBag pBag)
	public static bool hasResources(this ActorBag pBag)
	public static bool isEmpty(this ActorBag pBag)
	public static string getRandomResourceID(this ActorBag pBag)
		int num = Randy.randomInt(0, pBag.dict.Count);
		int num2 = 0;
		foreach (string key in pBag.dict.Keys)
		return string.Empty;
	public static int getResource(this ActorBag pBag, string pID)
	public static void empty(this ActorBag pBag)
	public static string getItemIDToRender(this ActorBag pBag)
			using Dictionary<string, ResourceContainer>.ValueCollection.Enumerator enumerator = pBag.getResources().Values.GetEnumerator();
			if (enumerator.MoveNext())
				pBag.last_item_to_render = enumerator.Current.id;
		return string.Empty;
	public static int countResources(this ActorBag pBag)
public enum ActorColorEffect
public class ActorContainer : ObjectContainer<Actor>
public struct ActorDamageEffectData
	public Actor actor;
	public double timestamp;
public class ActorData : BaseObjectData
	public List<long> saved_items;
	public ActorBag inventory;
	public int x;
	public int y;
	public long transportID = -1L;
	public long homeBuildingID = -1L;
	public UnitProfession profession;
	public List<string> saved_traits;
	public long cityID { get; set; } = -1L;
	public long civ_kingdom_id { get; set; } = -1L;
	public long actorID
	public string firstName
	public string statsID
	public string favorite_food { get; set; } = "";
	public ActorSex sex { get; set; }
	public int head { get; set; } = -1;
	public long culture { get; set; } = -1L;
	public long clan { get; set; } = -1L;
	public long subspecies { get; set; } = -1L;
	public long language { get; set; } = -1L;
	public long plot { get; set; } = -1L;
	public long religion { get; set; } = -1L;
	public long family { get; set; } = -1L;
	public long army { get; set; } = -1L;
	public long lover { get; set; } = -1L;
	public long best_friend_id { get; set; } = -1L;
	public int renown { get; set; }
	public string asset_id { get; set; }
	public int kills { get; set; }
	public int food_consumed { get; set; }
	public int age_overgrowth { get; set; } = 1;
	public int births { get; set; }
	public long parent_id_1 { get; set; } = -1L;
	public long parent_id_2 { get; set; } = -1L;
	public long ancestor_family { get; set; } = -1L;
	public int generation { get; set; } = 1;
	public int pollen { get; set; }
	public int loot { get; set; }
	public int money { get; set; }
	public int nutrition { get; set; }
	public int happiness { get; set; }
	public int stamina { get; set; }
	public int mana { get; set; }
	public int level { get; set; } = 1;
	public int experience { get; set; }
	public int phenotype_shade { get; set; }
	public int phenotype_index { get; set; }
	public int hunger
	public List<string> traits
	public ActorGender gender
	public int getAge()
public class ActorDataObsolete
	public List<long> saved_items;
	public ActorBag inventory;
	public ActorData status;
	public long cityID = -1L;
	public int x;
	public int y;
public class ActorDebugAnimationElement : BaseDebugAnimationElement<ActorAsset>
	public SpriteAnimation adult;
	public SpriteAnimation baby;
	protected override void Start()
	public override void update()
	public override void setData(ActorAsset pAsset)
	protected override void clear()
	public override void stopAnimations()
	public override void startAnimations()
	protected override void clickNextFrame()
public class ActorDebugAssetElement : BaseDebugAssetElement<ActorAsset>
	public Image icon_left;
	public Image icon_right;
	public ActorDebugAnimationElement animation_idle;
	public ActorDebugAnimationElement animation_walk;
	public ActorDebugAnimationElement animation_swim;
	public Image egg;
	public Sprite no_animation_baby;
	private AnimationContainerUnit _animation_container_adult;
	private AnimationContainerUnit _animation_container_baby;
	private int _phenotype_index;
	private int _phenotype_shade_id;
	public override void setData(ActorAsset pAsset)
	protected override void initAnimations()
		string[] array = asset.animation_idle;
		bool pShouldHaveAnimation = array != null && array.Length != 0;
		string[] array2 = asset.animation_walk;
		bool pShouldHaveAnimation2 = array2 != null && array2.Length != 0;
		string[] array3 = asset.animation_swim;
		bool pShouldHaveAnimation3 = array3 != null && array3.Length != 0;
		List<string> default_subspecies_traits = asset.default_subspecies_traits;
	public override void update()
	public override void stopAnimations()
	public override void startAnimations()
	private void setAnimation(ActorAnimation pAnimation, ActorDebugAnimationElement pElement, float pAnimationSpeed, bool pIsAdult, bool pHasAnimation, bool pShouldHaveAnimation)
		for (int i = 0; i < pAnimation.frames.Length; i++)
	protected override void initStats()
	protected override void showAssetWindow()
public class ActorDebugAssetsComponent : BaseDebugAssetsComponent<ActorAsset, ActorDebugAssetElement, ActorAssetElementPlace>
	protected override List<ActorAsset> getAssetsList()
	protected override void init()
		sorting_tab.addButton("ui/Icons/iconHealth", "sort_by_health", base.setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/iconDamage", "sort_by_damage", base.setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/iconSpeed", "sort_by_speed", base.setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/iconAge", "sort_by_lifespan", base.setDataResorted, delegate
	private int sortByHealth(ActorAsset pObject1, ActorAsset pObject2)
	private int sortByDamage(ActorAsset pObject1, ActorAsset pObject2)
	private int sortBySpeed(ActorAsset pObject1, ActorAsset pObject2)
	private int sortByLifespan(ActorAsset pObject1, ActorAsset pObject2)
	protected override List<ActorAsset> getListCivsSort()
		bool flag = sorting_tab.getCurrentButton().getState() == SortButtonState.Up;
public enum ActorDirection
public class ActorEquipment : IEnumerable<ActorEquipmentSlot>, IEnumerable
	public const int SLOTS_AMOUNT = 6;
	public const string NONE = "none";
	public ActorEquipmentSlot helmet = new ActorEquipmentSlot(EquipmentType.Helmet);
	public ActorEquipmentSlot armor = new ActorEquipmentSlot();
	public ActorEquipmentSlot weapon = new ActorEquipmentSlot(EquipmentType.Weapon);
	public ActorEquipmentSlot boots = new ActorEquipmentSlot(EquipmentType.Boots);
	public ActorEquipmentSlot ring = new ActorEquipmentSlot(EquipmentType.Ring);
	public ActorEquipmentSlot amulet = new ActorEquipmentSlot(EquipmentType.Amulet);
	private Dictionary<EquipmentType, ActorEquipmentSlot> _dictionary;
	public ActorEquipment()
	public void destroyAllEquipment()
	private void initDictionary()
	public bool hasItems()
	public IEnumerable<Item> getItems()
	public List<long> getDataForSave()
		using (IEnumerator<ActorEquipmentSlot> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				ActorEquipmentSlot current = enumerator.Current;
	public void load(List<long> pList, Actor pActor)
	public void setItem(Item pItem, Actor pActor)
	public ActorEquipmentSlot getSlot(EquipmentType pType)
	public IEnumerator<ActorEquipmentSlot> GetEnumerator()
public class ActorEquipmentSlot
	private Item _item;
	public EquipmentType type;
	public bool is_empty => isEmpty();
	public ActorEquipmentSlot(EquipmentType pType = EquipmentType.Armor)
	public Item getItem()
	public bool isEmpty()
	public void takeAwayItem()
	public void setEmptyDebug()
	internal void setItem(Item pItem, Actor pActor)
	public bool canChangeSlot()
public enum ActorGender
public delegate Sprite ActorGetSprite(Actor pActor);
public delegate Sprite[] ActorGetSprites(Actor pActor);
public struct ActorHighlightEffectData
	public Actor actor;
	public double timestamp;
public class ActorIdleLoopSound
	internal EventInstance fmod_instance;
	private Actor _actor;
	public ActorIdleLoopSound(ActorAsset pAsset, Actor pActor)
	public void stop()
	internal void stopLoopCallback(Actor pActor)
public class ActorJob : JobAsset<BehaviourActorCondition, Actor>
public class ActorJobLibrary : AssetLibrary<ActorJob>
	public override void init()
	private void initJobsCivs()
	private void initJobsMobs()
		t.addTask("print_start");
		t.addTask("print_step");
public class ActorManager : SimSystemManager<Actor, ActorData>
	private JobManagerActors _job_manager;
	public readonly ActorRenderData render_data = new ActorRenderData(4096);
	public readonly ActorVisibleDataArray visible_units_avatars = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_alive = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_with_status = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_with_favorite = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_with_banner = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_just_ate = new ActorVisibleDataArray();
	public readonly ActorVisibleDataArray visible_units_socialize = new ActorVisibleDataArray();
	private double _timestamp_sleeping_units;
	public readonly List<Actor> cached_sleeping_units = new List<Actor>();
	private readonly List<ActorVisibleDataArray> _unit_visible_lists = new List<ActorVisibleDataArray>();
	public bool have_dying_units;
	public readonly List<Actor> units_only_wild = new List<Actor>();
	public readonly List<Actor> units_only_civ = new List<Actor>();
	public readonly List<Actor> units_only_alive = new List<Actor>();
	public readonly List<Actor> units_only_dying = new List<Actor>();
	public ActorManager()
	public void prepareForMetaChecks()
		for (int i = 0; i < simpleList.Count; i++)
	public void calculateVisibleActors()
	private void precalculateRenderDataParallel()
		int tDebugItemScale = ((!DebugConfig.isOn(DebugOption.RenderBigItems)) ? 1 : 10);
		bool tShouldRenderUnitShadows = World.world.quality_changer.shouldRenderUnitShadows();
		int tTotalVisibleObjects = visible_units.count;
		int tDynamicBatchSize = 256;
		int toExclusive = ParallelHelper.calcTotalBatches(tTotalVisibleObjects, tDynamicBatchSize);
		Parallel.For(0, toExclusive, World.world.parallel_options, delegate(int pBatchIndex)
	private void precalculateRenderDataNormal()
		int count = visible_units.count;
		for (int i = 0; i < count; i++)
	private void fillVisibleObjects()
		int count = Count;
		bool flag = MapBox.isRenderGameplay();
		int count2 = 0;
		int count3 = 0;
		for (int i = 0; i < count; i++)
	public override void update(float pElapsed)
	private void checkOverrideUnitShooting()
		using IEnumerator<Actor> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			Actor current = enumerator.Current;
	protected override void destroyObject(Actor pActor)
	internal override void scheduleDestroyOnPlay(Actor pObject)
	private void triggerActionsOnRemove(Actor pActor)
	public override void loadFromSave(List<ActorData> pList)
	public Actor evolutionEvent(Actor pTargetActor, bool pWithBiomeEffect, bool pAscension)
		bool flag = false;
		string pID = pTargetActor.asset.id;
	public bool cloneUnit(Actor pCloneFrom, WorldTile pTileTarget = null)
		string name = pCloneFrom.getName();
	public Actor createNewUnit(string pStatsID, WorldTile pTile, bool pMiracleSpawn = false, float pSpawnHeight = 0f, Subspecies pSubspecies = null, Subspecies pSubspeciesMutateFrom = null, bool pSpawnWithItems = true, bool pAdultAge = false, bool pGiveOwnerlessItems = false, bool pSapientSubspecies = false)
	private void finalizeActor(string pStats, Actor pActor, WorldTile pTile, float pZHeight = 0f)
	public Actor createBabyActorFromData(ActorData pData, WorldTile pTile, City pCity)
	public Actor spawnNewUnitByPlayer(string pStatsID, WorldTile pTile, bool pSpawnSound = false, bool pMiracleSpawn = false, float pSpawnHeight = 6f, Subspecies pSubspecies = null)
	public Actor spawnNewUnit(string pActorAssetID, WorldTile pTile, bool pSpawnSound = false, bool pMiracleSpawn = false, float pSpawnHeight = 6f, Subspecies pSubspecies = null, bool pGiveOwnerlessItems = false, bool pAdultAge = false)
		bool pGiveOwnerlessItems2 = pGiveOwnerlessItems;
	private void checkNewSpecies(ActorAsset pAsset, WorldTile pTile, Actor pActor, out Actor pClosestActor, bool pGlobalSearch = false, bool pLookForSapientSubspecies = false, Subspecies pSubspeciesMutateFrom = null)
		pActor.event_full_stats = true;
	public ActorTrait addRandomTraitFromBiomeToActor(Actor pActor, WorldTile pTile)
		List<string> spawn_trait_actor = biome_asset.spawn_trait_actor;
	public override Actor loadObject(ActorData pData)
		int health = pData.health;
		int nutrition = pData.nutrition;
		int stamina = pData.stamina;
		int mana = pData.mana;
	protected override void addObject(Actor pObject)
	private void clearLists()
		for (int i = 0; i < _unit_visible_lists.Count; i++)
	private void prepareLists()
		for (int i = 0; i < _unit_visible_lists.Count; i++)
	public override void clear()
	public void debugJobManager(DebugTool pTool)
	public JobManagerActors getJobManager()
	public void checkSleepingUnits()
public class ActorMove
	private const float CHUNK_MULTIPLIER = 4f;
	public static ExecuteEvent goTo(Actor pActor, WorldTile pTileTarget, bool pPathOnLiquid = false, bool pWalkOnBlocks = false, bool pPathOnLava = false, int pLimitPathfindingRegions = 0)
		bool is_boat = asset.is_boat;
		bool flag = current_tile.isSameIsland(pTileTarget);
		bool flag2 = pActor.isWaterCreature();
		bool flag3 = pActor.isInLiquid();
		bool flag4 = pActor.isImmuneToFire();
		bool flag5 = DebugConfig.isOn(DebugOption.UseGlobalPathLock);
	private static void lockRegionsForAStarSearch(Actor pActor, int pLimitPathfindingRegions)
		int num = 0;
		int limitedPathfindingRegions = getLimitedPathfindingRegions(current_path_global, pLimitPathfindingRegions);
		for (int i = 0; i < limitedPathfindingRegions; i++)
	private static int getLimitedPathfindingRegions(List<MapRegion> pPath, int pLimitPathfindingRegions)
	private static void cleanRegionSearch(Actor pActor)
	public unsafe static ExecuteEvent goToCurved(Actor pActor, params WorldTile[] pTargets)
		Span<Vector3> pPoints = span;
		for (int i = 0; i < pTargets.Length; i++)
		float num2 = 0f;
		for (int j = 1; j < pTargets.Length; j++)
		float num3 = (int)(num2 / 4f);
		for (int k = 0; (float)k < num3; k++)
public class ActorRenderData
	public Vector3[] positions;
	public Vector3[] scales;
	public Vector3[] rotations;
	public Color[] colors;
	public bool[] has_normal_render;
	public Sprite[] main_sprites;
	public Sprite[] main_sprite_colored;
	public Material[] materials;
	public bool[] flip_x_states;
	public bool[] shadows;
	public Vector3[] shadow_position;
	public Vector3[] shadow_scales;
	public Sprite[] shadow_sprites;
	public bool[] has_item;
	public Vector3[] item_scale;
	public Vector3[] item_pos;
	public Sprite[] item_sprites;
	public ActorRenderData(int pCapacity)
	public void checkSize(int pTargetSize)
public class ActorSelectedContainerEquipment : SelectedElementBase<EquipmentButton>
	private EquipmentButton _prefab_equipment;
	private void Awake()
	public void update(Actor pActor)
	protected override void refresh(NanoObject pNano)
	private void loadEquipmentButton(Item pItem)
public class ActorSelectedContainerStatus : SelectedElementBase<StatusEffectButton>
	private StatusEffectButton _prefab_status;
	private void Awake()
	public void update(NanoObject pNano)
	protected override void refresh(NanoObject pNano)
	private void loadStatusButton(Status pStatus)
public class ActorSelectedContainerTraits : SelectedContainerTraits<ActorTrait, ActorTraitButton, ActorTraitsContainer, ActorTraitsEditor>
	protected override MetaType meta_type => MetaType.Unit;
	protected override IReadOnlyCollection<ActorTrait> getTraits()
	protected override bool canEditTraits()
public class ActorSelectedMetaBanners : UnitMetaBanners, ISelectedTabBanners<Actor>
	public void update(Actor pActor)
	protected override void checkSetActor()
	protected override void OnEnable()
	protected override void checkSetWindow()
	public int countVisibleBanners()
public enum ActorSex
public abstract class ActorSimpleComponent : IDisposable
	internal Actor actor;
	internal virtual void create(Actor pActor)
	public virtual void update(float pElapsed)
	public virtual void Dispose()
public enum ActorSize
namespace ai.behaviours;
public class ActorTaskLibrary : BehaviourTaskActorLibrary
public class ActorTextureSubAsset : ICloneable
	public const string skin_civ_default_male = "male_1";
	public const string skin_civ_default_female = "female_1";
	public static List<Sprite> all_preloaded_sprites_units = new List<Sprite>();
	public readonly Dictionary<string, Sprite[]> dict_mains = new Dictionary<string, Sprite[]>();
	private static Dictionary<string, Sprite> _shadow_sprites = new Dictionary<string, Sprite>();
	public string texture_path_base;
	public string texture_path_base_male;
	public string texture_path_base_female;
	public string texture_path_main;
	public string texture_path_baby;
	public string texture_path_king;
	public string texture_path_leader;
	public string texture_path_warrior;
	public string texture_path_zombie;
	public bool has_advanced_textures;
	public bool has_old_heads;
	public string texture_heads = string.Empty;
	public string texture_head_king = string.Empty;
	public string texture_head_warrior = string.Empty;
	public string texture_heads_old_male = string.Empty;
	public string texture_heads_old_female = string.Empty;
	public string texture_heads_male = string.Empty;
	public string texture_heads_female = string.Empty;
	public bool render_heads_for_children;
	public bool prevent_unconscious_rotation;
	public bool shadow = true;
	public string shadow_texture = "unitShadow_5";
	internal Sprite shadow_sprite;
	internal Vector2 shadow_size;
	public string shadow_texture_egg = "unitShadow_2";
	internal Sprite shadow_sprite_egg;
	internal Vector2 shadow_size_egg;
	public string shadow_texture_baby = "unitShadow_4";
	internal Sprite shadow_sprite_baby;
	internal Vector2 shadow_size_baby;
	private string _base_path;
	private static int _total;
	private static readonly Regex _regex_heads_sorter = new Regex("(\\D*)(\\d+)");
	public ActorTextureSubAsset(string pBasePath, bool pHasAdvancedTextures)
		if (string.IsNullOrEmpty(texture_head_warrior))
		if (string.IsNullOrEmpty(texture_head_king))
		if (string.IsNullOrEmpty(texture_heads_old_female))
		if (string.IsNullOrEmpty(texture_heads_old_male))
		if (string.IsNullOrEmpty(texture_heads_male))
		if (string.IsNullOrEmpty(texture_heads_female))
		if (string.IsNullOrEmpty(texture_path_king))
		if (string.IsNullOrEmpty(texture_path_leader))
		if (string.IsNullOrEmpty(texture_path_warrior))
		if (string.IsNullOrEmpty(texture_path_zombie))
		if (string.IsNullOrEmpty(texture_heads))
	private void logAssetError(string pMessage, string pPath)
	public string getUnitTexturePath(Actor pActor)
		string result = texture_path_main;
	private string getTextureSkinBasedOnSex(Actor pActor)
	public string getUnitTexturePathForUI(ActorAsset pAsset)
		string result = texture_path_main;
	private bool hasSpriteInResources(string pPath)
	public object Clone()
	public void preloadSprites(bool pCivTextures, bool pHasBabyForm, IAnimationFrames pAnimationAsset)
	private bool preloadSpritePath(string pType, string pPath, IAnimationFrames pAnimationAsset, bool pLoadHeads = false, bool pThrowError = true, bool pSpecialHead = false)
		if (string.IsNullOrEmpty(pPath))
	internal void loadShadow()
	private Sprite getShadowSprite(string pTexturePath)
	private void checkHeads(Sprite[] pSprites, string pPath, IAnimationFrames pAnimationAsset)
		using ListPool<string> listPool = new ListPool<string>();
		for (int i = 0; i < pSprites.Length; i++)
		string text = "";
		int num = -1;
		foreach (ref string item in listPool)
	private int headSorter(string x, string y)
		if (match.Success && match2.Success && match.Groups[1].Value == match2.Groups[1].Value && int.TryParse(match.Groups[2].Value, out var result) && int.TryParse(match2.Groups[2].Value, out var result2))
	private void checkAnimations(Sprite[] pSprites, string pPath, Asset pAsset, IAnimationFrames pAnimationFrames)
		using ListPool<string> listPool = new ListPool<string>();
		using ListPool<string> listPool2 = new ListPool<string>();
		string[] walk = pAnimationFrames.getWalk();
		string[] walk2;
		string[] swim = pAnimationFrames.getSwim();
		string[] idle = pAnimationFrames.getIdle();
		bool flag3 = false;
		foreach (string item3 in walk2)
	public static int getTotal()
namespace ai;
public enum ActorTileTarget
namespace ai;
public static class ActorTool
	public static int countContagiousNearby(Actor pActor)
		int num = 0;
	public static Building findNewBuildingTarget(Actor pActor, string pType, bool pOnlyFreeTile = true)
				WorldTile constructionTile = buildingToBuild.getConstructionTile();
				if (constructionTile != null && constructionTile.isSameIsland(pActor.current_tile))
				if (item.isSameIslandAs(pActor) && !item.isUnderConstruction() && item.isUsable() && item.asset.hasHousingSlots())
	public static Building findNewTargetInZones(Actor pActor, string pType, ListPool<Building> pPossibleBuildings)
	public static WorldTile getTileNearby(ActorTileTarget pTarget, MapChunk pChunk)
	public static Docks getDockTradeTarget(Actor pActor)
	private static Docks getDockTradeTarget(WorldTile pTile, Actor pActor)
	private static Docks getDockTradeTarget(MapRegion pRegion, Actor pActor)
	private static Docks getDockTradeTarget(TileIsland pIsland, Actor pActor)
	private static Docks getDockTradeTarget(ListPool<Docks> pList, Actor pActor)
	public static WorldTile getRandomTileForBoat(Actor pActor)
	public static int attributeDice(Actor pActor, int pAmount = 2)
		int num = 0;
		int num2 = (int)(pActor.stats["diplomacy"] + pActor.stats["warfare"] + pActor.stats["stewardship"]);
		for (int i = 0; i < pAmount; i++)
	public static void checkHomeDocks(Actor pActor)
					if (docks2.building.isUsable() && !docks2.building.isAbandoned() && !docks2.building.isUnderConstruction() && docks2.building.hasCity() && docks2.building.city.kingdom == pActor.kingdom && !docks2.building.city.kingdom.isEnemy(pActor.kingdom) && !docks2.isFull(pActor.asset.boat_type))
	public static void copyImportantData(ActorData pFrom, ActorData pCloneTo, bool pCopyAge)
		pCloneTo["intelligence"] = pFrom["intelligence"];
	public static void copyUnitToOtherUnit(Actor pParent, Actor pCloneTarget, bool pCopyAge = true)
	public static bool canBeCuredFromTraitsOrStatus(Actor pActor)
	public static void applyForceToUnit(AttackData pData, BaseSimObject pTargetToCheck, float pMod = 1f, bool pCheckCancelJobOnLand = false)
		float num = pData.knockback * pMod;
	public static int countUnitsFrom(string pActorID)
	public static void checkFallInLove(Actor pActor, Actor pTarget)
	public static void checkBecomingBestFriends(Actor pActor, Actor pTarget)
	private static float calcLikeability(Actor pActor, Actor pTarget)
		float num = 0f;
public class ActorTrait : BaseTrait<ActorTrait>
	public int rate_birth;
	public int rate_acquire_grow_up;
	public bool acquire_grow_up_sapient_only;
	public int rate_inherit;
	public bool is_mutation_box_allowed = true;
	public int same_trait_mod;
	public int opposite_trait_mod;
	public bool only_active_on_era_flag;
	public bool era_active_moon;
	public bool era_active_night;
	public TraitType type = TraitType.Other;
	public bool remove_for_zombie_actor_asset;
	public bool can_be_cured;
	public bool affects_mind;
	public bool is_kingdom_affected;
	public string forced_kingdom = string.Empty;
	public bool can_be_removed_by_divine_light;
	public bool can_be_removed_by_accelerated_healing;
	public float likeability;
	public bool in_training_dummy_combat_pot;
	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_actor;
	public override string typed_id => "trait";
	public override BaseCategoryAsset getGroup()
	public int getRate(string pGroup)
	public Kingdom getForcedKingdom()
		if (forced_kingdom == string.Empty)
	protected override IEnumerable<ITraitsOwner<ActorTrait>> getRelatedMetaList()
	public override string getCountRows()
	protected override bool isSapient(ITraitsOwner<ActorTrait> pObject)
public class ActorTraitButton : TraitButton<ActorTrait>
	protected override string tooltip_type => "trait";
	internal override void load(string pTraitID)
	protected override TooltipData tooltipDataBuilder()
public class ActorTraitEditorButton : TraitEditorButton<ActorTraitButton, ActorTrait>
public class ActorTraitGroupAsset : BaseTraitGroupAsset
public class ActorTraitGroupElement : TraitGroupElement<ActorTrait, ActorTraitButton, ActorTraitEditorButton>
public class ActorTraitGroupLibrary : BaseCategoryLibrary<ActorTraitGroupAsset>
	public override void init()
public class ActorTraitLibrary : BaseTraitLibrary<ActorTrait>
	public const int COMBAT_SKILLS_AMOUNT = 5;
	public List<ActorTrait> pot_traits_mutation_box = new List<ActorTrait>();
	public List<ActorTrait> pot_traits_birth = new List<ActorTrait>();
	public List<ActorTrait> pot_traits_growup = new List<ActorTrait>();
	public List<ActorTrait> pot_traits_combat = new List<ActorTrait>();
	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	public override void init()
	private void addTraitsBody()
		t.special_effect_interval = 5f;
	private void addTraitsMind()
		t.base_stats["intelligence"] = -5f;
		t.base_stats["intelligence"] = 10f;
	private void addTraitsSpirit()
		t.base_stats["intelligence"] = 3f;
	private void addTraitsAcquired()
		t.base_stats["intelligence"] = 1f;
		t.special_effect_interval = 1.5f;
	private void addTraitsFun()
	private void addTraitsMisc()
		actorTrait.action_special_effect = (WorldAction)Delegate.Combine(actorTrait.action_special_effect, new WorldAction(ActionLibrary.flowerPrintsEffect));
	private void addTraitsSpecial()
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_golden_egg", "desire_harp" };
		t.traits_to_remove_ids = new string[4] { "desire_computer", "desire_golden_egg", "desire_harp", "madness" };
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_golden_egg", "desire_harp", "madness" };
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_harp", "madness" };
		t.traits_to_remove_ids = new string[4] { "desire_alien_mold", "desire_computer", "desire_golden_egg", "madness" };
	public override void post_init()
	public override ActorTrait add(ActorTrait pAsset)
	public override void linkAssets()
	private void checkDefault(ActorTrait pAsset)
	public int checkTraitsMod(Actor pMain, Actor pTarget)
		int num = 0;
public class ActorTraitsContainer : TraitsContainer<ActorTrait, ActorTraitButton>
public class ActorTraitsEditor : TraitsEditor<ActorTrait, ActorTraitButton, ActorTraitEditorButton, ActorTraitGroupAsset, ActorTraitGroupElement>
	protected override MetaType meta_type => MetaType.Unit;
	protected override List<ActorTraitGroupAsset> augmentation_groups_list => AssetManager.trait_groups.list;
	protected override ActorTrait edited_marker_augmentation => AssetManager.traits.get("scar_of_divinity");
	protected override List<ActorTrait> all_augmentations_list => AssetManager.traits.list;
	protected override void onEnableRain()
		rain_state_toggle_action = delegate
		for (int i = 0; i < powers_icons.childCount; i++)
	protected override bool addTrait(ActorTrait pTrait)
	protected override void onNanoWasModified()
	protected override void loadEditorSelectedButton(ActorTraitButton pButton, string pAugmentationId)
	protected override bool isAugmentationExists(string pId)
	public override void scrollToGroupStarter(GameObject pButton, bool pIgnoreTooltipCheck)
	protected void toggleRainState(TraitRainAsset pAsset)
public class ActorVisibleDataArray
	public Actor[] array = new Actor[0];
	public int count;
	public void prepare(int pTargetSize)
	public void addFromCollection(ICollection pList)
public class AdButtonTimer : MonoBehaviour
	internal static AdButtonTimer instance;
	public Text timer;
	public Button button;
	public Image icon;
	private double adTimer;
	private Color transparent = new Color(1f, 1f, 1f, 0.3f);
	private int tRecalc;
	private void Awake()
	internal static void setAdTimer()
	private void OnEnable()
	private void Update()
	private void updateButton()
public class AdLoadingButton : MonoBehaviour
	public Text button_text;
	public LocalizedText button_localized_text;
	public Button button;
	private Image button_image;
	public Sprite spriteOn;
	public Sprite spriteOff;
	private AdLoadingButtonState state;
	private void Awake()
	private void Update()
	private void toggleState()
internal enum AdLoadingButtonState
public delegate void AfterHatchFromEggAction(Actor pActor);
public struct AIHistoryElement
	public string id;
	public double timestamp;
public struct AIHistoryElementDecision
	public string id;
	public int amount;
	public double last_timestamp;
namespace ai.behaviours;
public class AILibrary : BehaviourTaskActorLibrary
public abstract class AiSystem<TSimObject, TJob, TTask, TAction, TCondition> where TJob : JobAsset<TCondition, TSimObject> where TTask : BehaviourTaskBase<TAction> where TAction : BehaviourActionBase<TSimObject> where TCondition : BehaviourBaseCondition<TSimObject>
	public AssetLibrary<TJob> jobs_library;
	public AssetLibrary<TTask> task_library;
	private List<SingleAction<TTask, TAction>> _single_actions;
	internal int action_index;
	internal int restarts;
	internal int task_index;
	private int[] _random_tasks = new int[0];
	public TJob job;
	internal TTask task;
	internal TAction action;
	private double _timestamp_task_start;
	protected readonly TSimObject ai_object;
	public GetNextJobID next_job_delegate;
	public JobAction clear_action_delegate;
	private TaskSwitchAction _task_switch_action;
	private string _scheduled_task_id;
	public AiSystem(TSimObject pObject)
		next_job_delegate = nextJobDefault;
	public void scheduleTask(string pTaskID)
	public void addSingleTask(string pID)
	private void updateNewBehJob()
	private TaskContainer<TCondition, TSimObject> getNextTask(TJob pJob)
	private bool checkConditionsForTask(TaskContainer<TCondition, TSimObject> pTaskContainer)
	public void subscribeToTaskSwitch(TaskSwitchAction pAction)
	public virtual void setTask(string pTaskId, bool pClean = true, bool pCleanJob = false, bool pForceAction = false)
	protected virtual void setAction(TAction pAction)
	private void clearAction()
	public void restartJob()
	internal void clearBeh()
		if (clear_action_delegate != null)
	public void clearJob()
	public virtual void setJob(string pJobID)
	public void updateSingleTasks(float pElapsed)
		for (int i = 0; i < _single_actions.Count; i++)
	internal void update()
	public void decisionRun()
	private void run()
	public bool hasTask()
	public void setTaskBehFinished()
	protected virtual void debugLogAction()
	protected virtual void debugLogActionResult(BehResult pResult)
	protected string getActionID(TAction pAction)
		string text = pAction?.GetType().ToString();
	public void debug(DebugTool pTool)
		string text = getActionID(action);
		string text2;
	public static string nextJobDefault()
	internal virtual void reset()
		next_job_delegate = null;
		clear_action_delegate = null;
	public string getTaskTime()
public class AiSystemActor : AiSystem<Actor, ActorJob, BehaviourTaskActor, BehaviourActionActor, BehaviourActorCondition>
	public AiSystemActor(Actor pObject)
public class AiSystemCity : AiSystem<City, JobCityAsset, BehaviourTaskCity, BehaviourActionCity, BehaviourCityCondition>
	public AiSystemCity(City pObject)
public static class AISystemDebug
	private static string dataName = "/ai_system.log";
	private static List<string> debug_list_actions = new List<string>();
	public static void clear()
	public static void debugLog(string pString)
	public static void log()
		string text = "";
		foreach (string debug_list_action in debug_list_actions)
	public static string getPath()
public class AiSystemKingdom : AiSystem<Kingdom, KingdomJob, BehaviourTaskKingdom, BehaviourActionKingdom, BehaviourKingdomCondition>
	public AiSystemKingdom(Kingdom pObject)
public class AiSystemTester : AiSystem<AutoTesterBot, JobTesterAsset, BehaviourTaskTester, BehaviourActionTester, BehaviourTesterCondition>
	public AiSystemTester(AutoTesterBot pObject)
namespace ai.behaviours;
public class AITask : BehaviourTaskActorLibrary
public class Alliance : MetaObject<AllianceData>
	public List<Kingdom> kingdoms_list = new List<Kingdom>();
	public HashSet<Kingdom> kingdoms_hashset = new HashSet<Kingdom>();
	public int power;
	protected override MetaType meta_type => MetaType.Alliance;
	public override BaseSystemManager manager => World.world.alliances;
	public void createNewAlliance()
		string pName = NameGenerator.getName("alliance_name");
	protected sealed override void setDefaultValues()
	public override int countTotalMoney()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countHappyUnits()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countSick()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countHungry()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countStarving()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countChildren()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countAdults()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countHomeless()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override IEnumerable<Family> getFamilies()
		for (int i = 0; i < tKingdoms.Count; i++)
	public override bool hasFamilies()
		for (int i = 0; i < list.Count; i++)
	public override int countMales()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countFemales()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countHoused()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public void setType(AllianceType pType)
	public bool isForcedType()
	public bool isNormalType()
	protected override ColorLibrary getColorLibrary()
	public override void generateBanner()
	public void addFounders(Kingdom pKingdom1, Kingdom pKingdom2)
	public void update()
		for (int i = 0; i < list.Count; i++)
	public bool checkActive()
		bool flag = false;
		for (int num = list.Count - 1; num >= 0; num--)
	public void dissolve()
	public void recalculate()
	public bool canJoin(Kingdom pKingdom)
	public bool join(Kingdom pKingdom, bool pRecalc = true, bool pForce = false)
	public void leave(Kingdom pKingdom, bool pRecalc = true)
	public override void save()
	public override void loadData(AllianceData pData)
	public int countBuildings()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public int countZones()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public override int countUnits()
	public int countPopulation()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public int countCities()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public int countKingdoms()
	public string getMotto()
		if (string.IsNullOrEmpty(data.motto))
	public int countWarriors()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public static bool isSame(Alliance pAlliance1, Alliance pAlliance2)
	public bool hasWarsWith(Kingdom pKingdom)
		for (int i = 0; i < list.Count; i++)
	public bool hasSupremeKingdom()
	public bool hasKingdom(Kingdom pKingdom)
	public bool hasSharedBordersWithKingdom(Kingdom pKingdom)
		for (int i = 0; i < list.Count; i++)
	public bool hasWars()
	public IEnumerable<War> getWars(bool pRandom = false)
	public void mergeWars()
		for (int i = 0; i < listPool.Count; i++)
	public IEnumerable<War> getAttackerWars()
	public IEnumerable<War> getDefenderWars()
	public override IEnumerable<Actor> getUnits()
		for (int i = 0; i < tKingdoms.Count; i++)
	public override bool isReadyForRemoval()
	public override Actor getRandomUnit()
	public Sprite getBackgroundSprite()
	public Sprite getIconSprite()
	public override void Dispose()
public class AllianceBanner : BannerGeneric<Alliance, AllianceData>
	public Sprite frame_normal;
	public Sprite frame_forced;
	protected override MetaType meta_type => MetaType.Alliance;
	protected override string tooltip_id => "alliance";
	protected override TooltipData getTooltipData()
	protected override void setupBanner()
public class AllianceBannersContainer<TBanner, TMetaObject, TData> : AllianceElement where TBanner : BannerGeneric<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
	protected ObjectPoolGenericMono<TBanner> pool_elements;
	private TBanner _prefab;
	private Transform _container;
	protected override void Awake()
	protected override void clear()
public class AllianceCustomizeWindow : GenericCustomizeWindow<Alliance, AllianceData, AllianceBanner>
	protected override MetaType meta_type => MetaType.Alliance;
	protected override Alliance meta_object => SelectedMetas.selected_alliance;
	protected override void onBannerChange()
public class AllianceData : MetaObjectData
	public List<long> kingdoms;
	public double timestamp_member_joined;
	public AllianceType alliance_type;
	public string motto { get; set; }
	public int banner_background_id { get; set; }
	public int banner_icon_id { get; set; }
	public string founder_actor_name { get; set; }
	public long founder_actor_id { get; set; } = -1L;
	public string founder_kingdom_name { get; set; }
	public long founder_kingdom_id { get; set; } = -1L;
public class AllianceElement : WindowMetaElement<Alliance, AllianceData>
	protected Alliance alliance => meta_object;
public class AllianceKingdomsContainer : AllianceBannersContainer<KingdomBanner, Kingdom, KingdomData>
	protected override IEnumerator showContent()
	protected void showBanner(Kingdom pKingdom)
public class AllianceListComponent : ComponentListBase<AllianceListElement, Alliance, AllianceData, AllianceListComponent>
	protected override MetaType meta_type => MetaType.Alliance;
	protected override void setupSortingTabs()
		sorting_tab.tryAddButton("ui/Icons/iconArmy", "sort_by_army", show, delegate
		sorting_tab.tryAddButton("ui/Icons/iconKingdomList", "sort_by_kingdoms", show, delegate
		sorting_tab.tryAddButton("ui/Icons/iconVillages", "sort_by_villages", show, delegate
	public static int sortByArmy(Alliance pAlliance1, Alliance pAlliance2)
	public static int sortByKingdoms(Alliance pAlliance1, Alliance pAlliance2)
	public static int sortByVillages(Alliance pAlliance1, Alliance pAlliance2)
public class AllianceListElement : WindowListElementBase<Alliance, AllianceData>
	public Text text_name;
	public CountUpOnClick age;
	public CountUpOnClick population;
	public CountUpOnClick warriors;
	public CountUpOnClick villages;
	public CountUpOnClick kingdoms;
	public Text level;
	public KingdomBanner prefabMiniKingdomBanner;
	public GameObject grid;
	private ObjectPoolGenericMono<KingdomBanner> pool_mini_banners;
	internal override void show(Alliance pAlliance)
	public void showKingdomBanners(List<Kingdom> pList)
	protected override void tooltipAction()
	protected override void OnDisable()
public class AllianceManager : MetaSystemManager<Alliance, AllianceData>
	public Sprite[] _cached_banner_backgrounds;
	public Sprite[] _cached_banner_icons;
	private List<Alliance> _to_dissolve = new List<Alliance>();
	public AllianceManager()
	public override void update(float pElapsed)
		using (IEnumerator<Alliance> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				Alliance current = enumerator.Current;
	public void dissolveAlliance(Alliance pAlliance)
	private void addTest()
	public bool forceAlliance(Kingdom pKingdom1, Kingdom pKingdom2)
		bool result = false;
	public void useDiscordPower(Alliance pAlliance, City pCity)
	public Alliance newAlliance(Kingdom pKingdom, Kingdom pKingdom2)
	public Sprite[] getBackgroundsList()
	public Sprite[] getIconsList()
	public bool anyAlliances()
	public override void clear()
	protected override void updateDirtyUnits()
public class AllianceSelectedKingdomsContainer : AllianceKingdomsContainer
	protected override void OnEnable()
	public void update(Alliance pAlliance)
public class AllianceStatsElement : AllianceElement, IStatsElement, IRefreshElement
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public enum AllianceType
public class AllianceWindow : WindowMetaGeneric<Alliance, AllianceData>
	public NameInput mottoInput;
	public StatBar bar_experience;
	public override MetaType meta_type => MetaType.Alliance;
	protected override Alliance meta_object => SelectedMetas.selected_alliance;
	protected override void initNameInput()
	private void applyInputMotto(string pInput)
	protected override void showTopPartInformation()
	internal override void showStatsRows()
	protected override void OnDisable()
public class Analytics
	private static Dictionary<string, string> _event_slugs = new Dictionary<string, string>();
	public static void trackWindow(string pName)
	public static void hideWindow()
	public static void worldLoaded()
	public static void worldLoading()
	private static void logScreen(string pClass, string pName)
	public static void LogEvent(string pName, bool pFirebase = true, bool pFacebook = true)
	public static void LogEvent(string pName, string parameterName, string parameterValue)
	public static string slugify(string pPhrase)
		if (!_event_slugs.TryGetValue(pPhrase, out var value))
public enum AnchorPresets
public enum AngleAnimationTarget
public class AnimationContainerUnit
	public bool child;
	internal readonly string id;
	internal readonly Dictionary<string, Sprite> sprites = new Dictionary<string, Sprite>();
	internal readonly Dictionary<string, AnimationFrameData> dict_frame_data = new Dictionary<string, AnimationFrameData>();
	internal ActorAnimation idle;
	internal ActorAnimation walking;
	internal ActorAnimation swimming;
	public bool has_swimming;
	public bool has_idle;
	public bool has_walking;
	public bool render_heads_for_children;
	internal Sprite[] heads;
	internal Sprite[] heads_male;
	internal Sprite[] heads_female;
	public AnimationContainerUnit(string pTexturePath)
public class AnimationDataBoat
	internal string id;
	internal Dictionary<int, ActorAnimation> dict = new Dictionary<int, ActorAnimation>();
	internal ActorAnimation broken;
	internal ActorAnimation normal;
public class AnimationFrameData
	internal string id;
	internal string sheet_path;
	internal Vector2 pos_head;
	internal Vector2 pos_head_new;
	internal Vector2 pos_item;
	internal Vector2 size_unit;
	public bool show_head;
	public bool show_item;
public static class AnimationHelper
	private static float animationTimeMax = 100f;
	private static float _time_simulation;
	private static float _time_session;
	public static float getTime()
	public static void updateTime(float pElapsedScaled, float pElapsedSession)
	private static void updateTimeSimulation(float pElapsed)
	private static void updateTimeSession(float pElapsed)
	public static float getAnimationGlobalTime(float pAnimationSpeed)
	public static Sprite getSpriteFromListSessionTime(int pHashCodeOffset, IList<Sprite> pFrames, float pAnimationSpeed)
	public static Sprite getSpriteFromList(int pHashCodeOffset, IList<Sprite> pFrames, float pAnimationSpeed)
	public static Sprite getSpriteFromList(float pTime, int pHashCodeOffset, IList<Sprite> pFrames)
		int spriteIndex = getSpriteIndex(pTime, pHashCodeOffset, pFrames.Count);
	public static int getSpriteIndex(float pTime, int pHashCodeOffset, int pFrameCount)
		return (int)(Mathf.Abs(pTime + (float)(pHashCodeOffset * 100)) % (float)pFrameCount);
	public static int getSpriteIndex(long pHashCodeOffset, int pFrameCount)
		return (int)(Mathf.Abs((float)(1 + pHashCodeOffset * 100)) % (float)pFrameCount);
public enum AnimPlayType
internal static class Ant
	private static List<WorldTile> _axis_neighbours = new List<WorldTile>(4);
	public static WorldTile getNextTile(WorldTile pTile, ActorDirection pDirection)
	public static WorldTile randomNeighbour(WorldTile pTile)
	internal static void antUseOnTile(WorldTile pTile, string pType)
		MusicBox.playSound("event:/SFX/UNIQUE/langton/ant_step", pTile);
public class AntimatterBombEffect : BaseEffect
	private bool used;
	private void Update()
	public bool tileAntimatter(WorldTile pTile, string pPowerID)
		bool pSkipTerraform = false;
	internal override void spawnOnTile(WorldTile pTile)
public class AotTypeEnforcer : MonoBehaviour
	public void Awake()
		AotHelper.EnsureType<CustomDataContainer<int>>();
		AotHelper.EnsureType<CustomDataContainer<float>>();
		AotHelper.EnsureType<CustomDataContainer<bool>>();
		AotHelper.EnsureType<CustomDataContainer<string>>();
		AotHelper.EnsureList<int>();
		AotHelper.EnsureList<float>();
		AotHelper.EnsureList<bool>();
		AotHelper.EnsureList<string>();
namespace UnityEngine.Purchasing.Security;
public class AppleTangle
	private static byte[] data = Convert.FromBase64String("K7kpflnrzFWnC4KQoki4nljwqXMioaCmqYom6CZXw8SloZAhUpCKpscvqBSAV2sMjIDP0BafoZAsF+Nv19eOwdDQzMWOw8/Nj8HQ0MzFw8GtpqmKJugmV62hoaWloKMioaGg/IyAw8XS1MnGycPB1MWA0M/MycPZhpCEpqP1pKuzveHQ0MzFgOPF0tTyxczJwc7DxYDPzoDUyMnTgMPF0oDBzsSAw8XS1MnGycPB1MnPzoDQrz2dU4vpiLpoXm4VGa55/rx2a50eVNM7TnLEr2vZ75R4Ap5Z2F/LaNDMxYDyz8/UgOPhkL63rZCWkJSSwszFgNPUwc7EwdLEgNTF0s3TgMFgw5PXV5qnjPZLeq+Brnoa07nvFaj+kCKhsaaj9b2ApCKhqJAioaSQljnsjdgXTSw7fFPXO1LWcteQ72HQzMWA48XS1MnGycPB1MnPzoDh1cnGycPB1MnPzoDh1dTIz9LJ1NmRgOPhkCKhgpCtpqmKJugmV62hoaGmkK+mo/W9s6GhX6SlkKOhoV+Qvaaj9b2upLaktItwyec01qleVMstnYbHgCqTyletIm9+SwOPWfPK+8STlvqQwpGrkKmmo/WkprOi9fORs9TJxsnDwdTFgMLZgMHO2YDQwdLUpKazovXzkbOQsaaj9aSqs6rh0NBpudJV/a513/87UoWjGvUv7f2tUdTIz9LJ1NmRtpC0pqP1pKOzreHQCHzegpVqhXV5r3bLdAKEg7FXAQy2kLSmo/Wko7Ot4dDQzMWA8s/P1HmW32En9XkHORmS4lt4ddE+3gHy0sHD1MnDxYDT1MHUxc3FztTTjpCKJugmV62hoaWloJDCkauQqaaj9fkHpanct+D2sb7Ucxcrg5vnA3XPvzF7vufwS6VN/tkkjUuWAvfs9UzakCKh1pCupqP1va+hoV+kpKOioczFgOnOw46RhpCEpqP1pKuzveHQp0zdmSMr84BzmGQRHzrvqstfi1zpeNY/k7TFAdc0aY2io6GgoQMioSC0i3DJ5zTWqV5Uyy2O4AZX5+3fF7sdM+KEsopnr70W7Tz+w2jrILeO4AZX5+3fqP6Qv6aj9b2DpLiQtt/hCDhZcWrGPITLsXADG0S7imO/xJWDteu1+b0TNFdWPD5v8Bph+PCloKMioa+gkCKhqqIioaGgRDEJqb8lIyW7OZ3nl1IJO+AujHQRMLJ4CwPRMufz9WEPj+ETWFtD0G1GA+wv0yHAZrv7qY8yEljk6FDAmD61VdmAwdPT1c3F04DBw8PF0NTBzsPFj5AhY6aoi6ahpaWnoqKQIRa6IROVkpGUkJOW+retk5WQkpCZkpGUkJCxpqP1pKqzquHQ0MzFgOnOw46RgM/GgNTIxYDUyMXOgMHQ0MzJw8EVmg1Ur66gMqsRgbaO1HWcrXvCtuXev+zL8DbhKWTUwquwI+EnkyohqIumoaWlp6Khtr7I1NTQ05qPj9fOxIDDz87EydTJz87TgM/GgNXTxRGQ+Ez6pJIsyBMvvX7F01/H/sUckCKkG5AiowMAo6KhoqKhopCtpqk1PtqsBOcr+3S2l5NrZK/tbrTJcYRCS3EX0H+v5UGHalHN2E1HFbe38AoqdXpEXHCpp5cQ1dWB");
	private static int[] order = new int[61]
	private static int key = 160;
	public static readonly bool IsPopulated = true;
	public static byte[] Data()
public enum ApplyAttackState
public class ArchitectMood : Asset, ILocalizedAsset
	public string color_main;
	public string color_text;
	public string path_icon;
	private Color _cached_color = Color.clear;
	private Color _cached_color_text = Color.clear;
	private Sprite _cached_sprite;
	public Sprite getSprite()
	public string getLocaleID()
	public Color getColor()
	public Color getColorText()
public delegate void ArchitectMoodAction(ArchitectMoodButton pElement);
public class ArchitectMoodButton : MonoBehaviour
	protected Button button;
	protected TipButton _tip_button;
	protected Image _icon;
	private Image _selected;
	private ArchitectMood _asset;
	private ArchitectMoodAction _click_callback;
	private void Awake()
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
	public ArchitectMood getAsset()
	public virtual void setAsset(ArchitectMood pAsset)
	public void toggleSelectedButton(bool pState)
	public void setIconActiveColor(bool pState)
		float num = ((!pState) ? 0.55f : 1f);
	public void addClickCallback(ArchitectMoodAction pAction)
public class ArchitectMoodLibrary : AssetLibrary<ArchitectMood>
	public const string DEFAULT_MOOD = "serene";
	public override void init()
	public override void editorDiagnosticLocales()
	public override void post_init()
	public override void editorDiagnostic()
public class ArchitectTab : MonoBehaviour
	private Dictionary<ArchitectMood, ArchitectMoodButton> _buttons = new Dictionary<ArchitectMood, ArchitectMoodButton>();
	private ArchitectMoodButton _mood_prefab;
	private Transform _grid_placement;
	private void Awake()
	private void initButtons()
		for (int i = 0; i < AssetManager.architect_mood_library.list.Count; i++)
	private ArchitectMoodButton initButton(ArchitectMood pAsset)
	private void buttonAction(ArchitectMoodButton pElement)
	private void updateElements()
	private void OnEnable()
public class ArchitectureAsset : Asset
	public bool generate_buildings;
	public string generation_target;
	public bool spread_biome;
	public string spread_biome_id;
	public string projectile_id = string.Empty;
	public bool burnable_buildings = true;
	public bool acid_affected_buildings = true;
	public bool has_shadows = true;
	public string material = "building";
	public Dictionary<string, string> building_ids_for_construction;
	public string[] styled_building_orders;
	public (string, string)[] shared_building_orders;
	public string actor_asset_id_boat_fishing = "boat_fishing";
	public string actor_asset_id_trading;
	public string actor_asset_id_transport;
	public void addBuildingOrderKey(string pKey, string pID)
		if (building_ids_for_construction == null)
			building_ids_for_construction = new Dictionary<string, string>();
		building_ids_for_construction[pKey] = pID;
	public void replaceSharedID(string pID, string pNewID)
		for (int i = 0; i < shared_building_orders.Length; i++)
	public BuildingAsset getBuilding(string pOrderID)
		string buildingID = getBuildingID(pOrderID);
	public string getBuildingID(string pOrderID)
		return building_ids_for_construction[pOrderID];
public class ArchitectureLibrary : AssetLibrary<ArchitectureAsset>
	private const string TEMPLATE_WITH_GENERATED_BUILDINGS = "$template_with_generated_buildings$";
	public override void init()
	private void addTemplates()
		t.styled_building_orders = new string[9] { "order_docks_0", "order_docks_1", "order_house_0", "order_hall_0", "order_windmill_0", "order_watch_tower", "order_temple", "order_library", "order_barracks" };
		t.shared_building_orders = new(string, string)[6]
	private void addClassic()
		t.styled_building_orders = new string[19]
		t.shared_building_orders = new(string, string)[6]
	private void addUnique()
	private void addAnimal()
	public override void post_init()
	private void initBuildingKeys()
	private void loadAutoBuildingsForAsset(ArchitectureAsset pAsset)
		string text = pAsset.id;
		string[] styled_building_orders = pAsset.styled_building_orders;
		foreach (string text2 in styled_building_orders)
public class ArmiesColorsLibrary : ColorLibrary
	public ArmiesColorsLibrary()
	public override void init()
	public override bool isColorUsedInWorld(ColorAsset pAsset)
public class Army : MetaObject<ArmyData>
	private Actor _captain;
	private WorldTile _prev_captain_position;
	private City _city;
	private Kingdom _kingdom;
	protected override MetaType meta_type => MetaType.Army;
	public override BaseSystemManager manager => World.world.armies;
	public override ActorAsset getActorAsset()
	public void createArmy(Actor pActor, City pCity)
	public void checkCity()
	public void onKingdomNameChange()
	protected override void generateColor()
	public override void trackName(bool pPostChange = false)
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
	private void generateName(Kingdom pKingdom = null)
		if (data.custom_name && !string.IsNullOrEmpty(data.name))
		string text = kingdom.name ?? "";
		string text2 = data.name;
		using ListPool<string> listPool = new ListPool<string>(World.world.armies.Count);
		int num = 1;
		string text4;
	public Actor getCaptain()
	public override void save()
	public override void loadData(ArmyData pData)
		if (string.IsNullOrEmpty(name))
	public void loadDataCaptains()
	public override void generateBanner()
	protected override ColorLibrary getColorLibrary()
	public override ColorAsset getColor()
	public void clearCity()
	public void disband()
		for (int i = 0; i < base.units.Count; i++)
	public void updateCaptains()
	public void addCaptain(Actor pActor)
	public void captainLeft()
	public void setCaptain(Actor pActor, bool pFromLoad = false)
	public void checkCaptainExistence()
	public void checkCaptainRemoval(Actor pActor)
	public int countMelee()
		int num = 0;
		for (int i = 0; i < base.units.Count; i++)
	public int countRange()
		int num = 0;
		for (int i = 0; i < base.units.Count; i++)
	public bool isGroupInCityAndHaveLeader()
	private void findCaptain()
	private Actor getRandomActorForCaptain()
	private Actor getNearbyUnitForCaptain(WorldTile pLastPosition)
		int num = int.MaxValue;
		for (int i = 0; i < list.Count; i++)
	public string getDebug()
		string text = base.units.Count.ToString() ?? "";
	public Kingdom getKingdom()
	public bool hasKingdom()
	public bool hasCaptain()
	public City getCity()
	public bool hasCity()
	public override bool isReadyForRemoval()
	public override void Dispose()
	public override string ToString()
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[Army:{base.id} ");
		stringBuilderPool.Append("\"" + name + "\" ");
		stringBuilderPool.Append($"Kingdom:{kingdom?.id ?? (-1)} ");
		stringBuilderPool.Append($"Units:{base.units.Count} ");
		return stringBuilderPool.ToString().Trim() + "]";
public class ArmyBanner : BannerGeneric<Army, ArmyData>
	private Image _species_icon;
	protected override MetaType meta_type => MetaType.Army;
	protected override string tooltip_id => "army";
	protected override void setupBanner()
	protected override TooltipData getTooltipData()
public class ArmyCaptainElement : ArmyElement
	private GameObject _title_element;
	private PrefabUnitElement _captain_element;
	protected override IEnumerator showContent()
	protected override void clear()
	public override bool checkRefreshWindow()
public class ArmyData : MetaObjectData
	public long id_city = -1L;
	public long id_captain = -1L;
	public long id_kingdom = -1L;
	public List<LeaderEntry> past_captains;
	public override void Dispose()
public class ArmyElement : WindowMetaElement<Army, ArmyData>
	protected Army army => meta_object;
public class ArmyListComponent : ComponentListBase<ArmyListElement, Army, ArmyData, ArmyListComponent>
	protected override MetaType meta_type => MetaType.Army;
	protected override void setupSortingTabs()
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
	private static int sortByKingdom(Army p1, Army p2)
public class ArmyListElement : WindowListElementBase<Army, ArmyData>
	private Text _text_name;
	private CountUpOnClick _amount;
	private CountUpOnClick _age;
	private CountUpOnClick _renown;
	private CountUpOnClick _kills;
	private CountUpOnClick _deaths;
	private UiUnitAvatarElement _captain;
	private ArmyBanner _army_banner;
	internal override void show(Army pArmy)
		bool flag = pArmy.hasCaptain();
		_kills.setValue((int)pArmy.getTotalKills());
		_deaths.setValue((int)pArmy.getTotalDeaths());
	protected override void initMonoFields()
	protected override void loadBanner()
	protected override void tooltipAction()
	protected override ActorAsset getActorAsset()
public class ArmyManager : MetaSystemManager<Army, ArmyData>
	public ArmyManager()
	public Army newArmy(Actor pActor, City pCity)
	public override void removeObject(Army pObject)
	public override void update(float pElapsed)
		using IEnumerator<Army> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.checkCaptainExistence();
	protected override void updateDirtyUnits()
		for (int i = 0; i < units_only_alive.Count; i++)
public class ArmyMemberIcons : ArmyElement
	private UnitAvatarLoader _top;
	private UnitAvatarLoader _top_left;
	private UnitAvatarLoader _top_right;
	private UnitAvatarLoader _left;
	private UnitAvatarLoader _right;
	private UnitAvatarLoader _bottom;
	private UnitAvatarLoader _bottom_left;
	private UnitAvatarLoader _bottom_right;
	private ArmyBanner _banner;
	private UnitAvatarLoader[] _list_warrior_avatars;
	protected override void Awake()
	protected override void clear()
		for (int i = 0; i < list_warrior_avatars.Length; i++)
	protected override IEnumerator showContent()
		for (int i = 0; i < _list_warrior_avatars.Length; i++)
public class ArmyMetaBanners : ArmyElement, IBaseMetaBanners
	private CityBanner _banner_city;
	private AllianceBanner _banner_alliance;
	private KingdomBanner _banner_kingdom;
	protected List<MetaBannerElement> banners = new List<MetaBannerElement>();
	private const float DELAY = 0.025f;
	private int _visible_banners;
	public int visible_banners => _visible_banners;
	protected override void Awake()
	protected override IEnumerator showContent()
	protected override void clear()
	public void metaBannerShow(MetaBannerElement pAsset)
	public void metaBannerHide(MetaBannerElement pAsset)
	public IReadOnlyCollection<MetaBannerElement> getBanners()
public class ArmySelectedMetaBanners : ArmyMetaBanners, ISelectedTabBanners<Army>
	public void update(Army pArmy)
	protected override void OnEnable()
	public int countVisibleBanners()
public class ArmyStatsElement : ArmyElement, IStatsElement, IRefreshElement
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public class ArmyWindow : WindowMetaGeneric<Army, ArmyData>
	private Image _race_top_left;
	private Image _race_top_right;
	public override MetaType meta_type => MetaType.Army;
	protected override Army meta_object => SelectedMetas.selected_army;
	protected override void showTopPartInformation()
	internal override void showStatsRows()
	private void tryShowPastCaptains()
	private TooltipData getTooltipPastCaptains()
public static class ArrayExtensions
	private static Random rnd => Randy.rnd;
	public static T First<T>(this T[] pArray)
	public static T Last<T>(this T[] pArray)
	public static int IndexOf<T>(this T[] pArray, T pValue)
	public static bool Contains<T>(this T[] pArray, T pValue)
	public static int FreeIndex<T>(this T[] pArray)
	public static T GetRandom<T>(this T[] pArray)
	public static T GetRandom<T>(this T[] pArray, int pLength)
	public static void Swap<T>(this T[] pArray, int pIndex1, int pIndex2)
	public static void Shuffle<T>(this T[] pArray)
	public static void Shuffle<T>(this T[] pArray, int pCount)
	public static void ShuffleOne<T>(this T[] pArray)
	public static void ShuffleOne<T>(this T[] pArray, int pItem)
	public static void ShuffleOne<T>(this T[] pArray, int pItem, int pCount)
	public static void Clear<T>(this T[] pArray)
	public static void Clear<T>(this T[] pArray, int pCount)
	public static bool AnyTrue(this bool[] pArray)
		for (int i = 0; i < pArray.Length; i++)
	public static bool AnyFalse(this bool[] pArray)
		for (int i = 0; i < pArray.Length; i++)
	public static string AsString<T>(this T[] pArray)
		using ListPool<string> listPool = new ListPool<string>(pArray.Length);
		for (int i = 0; i < pArray.Length; i++)
		return string.Join(", ", listPool.ToArray());
	public static void PrintToConsole<T>(this T[] pArray, string pMessage = null)
	public static bool AllTrue(this bool[] pArray)
	public static bool AllFalse(this bool[] pArray)
public class ArticleSettings : StructureSettings
	public override void create(LanguageStructure pStructure, int pSizeMin, int pSizeMax)
	public void generate(LanguageStructure pStructure, WordType pWord, int pSizeMin, int pSizeMax)
		bool flag = Randy.randomBool();
		enabled[(int)pWord] = flag;
	private string[] generateSets(LanguageStructure pStructure, int pAmount)
		string[] array = new string[pAmount];
		for (int i = 0; i < pAmount; i++)
public abstract class Asset : IEquatable<Asset>
	public const string DEFAULT_ASSET_ID = "ASSET_ID";
	public string id = "ASSET_ID";
	private int _hashcode;
	private int _index;
	public virtual void create()
	public void setHash(int pHash)
	public void setIndexID(int pValue)
	public int getIndexID()
	public bool Equals(Asset pAsset)
	public override int GetHashCode()
	public bool isTemplateAsset()
public abstract class AssetLibrary<T> : BaseAssetLibrary where T : Asset
	public List<T> list = new List<T>();
	public Dictionary<string, T> dict = new Dictionary<string, T>();
	protected T t;
	private T[] _array;
	public string file_path;
	private HashSet<string> _not_found = new HashSet<string>();
	public override int total_items => list.Count;
	public virtual T get(string pID)
	public T getSimple(string pID)
	public virtual bool has(string pID)
	public virtual T add(T pAsset)
		string text = pAsset.id;
	public virtual T clone(string pNew, string pFrom)
	public virtual void clone(out T pNew, T pFrom)
					IEnumerable enumerable = value as IEnumerable;
					fieldInfo.SetValue(pNew, Activator.CreateInstance(fieldInfo.FieldType, enumerable));
	internal void loadFromFile<TAssetLib>() where TAssetLib : AssetLibrary<T>
	public T[] getArray()
	public override void editorDiagnostic()
	public override void checkLocale(Asset pAsset, string pLocaleID)
		string text = pLocaleID?.Underscore();
		if (!string.IsNullOrEmpty(text) && !LocalizedTextManager.stringExists(text))
	public string getEditorPathForSave()
	public void saveToFile(string pPath = "units.json")
	protected bool checkSpriteExists(string pVariableID, string pPath, Asset pAsset)
		if (!string.IsNullOrEmpty(pPath) && !hasSpriteInResourcesDebug(pPath))
	protected static TA[] a<TA>(params TA[] pArgs)
	protected static List<TL> l<TL>(params TL[] pArgs)
	protected static HashSet<TH> h<TH>(params TH[] pArgs)
	public override IEnumerable<Asset> getList()
public class AssetManager
	public static TileEffectsLibrary tile_tile_effects;
	public static KingdomBannerLibrary kingdom_banners_library;
	public static CultureBannerLibrary culture_banners_library;
	public static ClanBannerLibrary clan_banners_library;
	public static ReligionBannerLibrary religion_banners_library;
	public static LanguageBannerLibrary language_banners_library;
	public static SubspeciesBannerLibrary subspecies_banners_library;
	public static FamilysBannerLibrary family_banners_library;
	public static WorldTimeScaleLibrary time_scales;
	public static OptionsLibrary options_library;
	public static WorldLawLibrary world_laws_library;
	public static WorldLawGroupLibrary world_law_groups;
	public static OnomasticsLibrary onomastics_library;
	public static OnomasticsEvolutionLibrary onomastics_evolution_library;
	public static LinguisticsLibrary linguistics_library;
	public static WordsLibrary words_library;
	public static SentencesLibrary sentences_library;
	public static StoryLibrary story_library;
	public static RarityLibrary rarity_library;
	public static GraphTimeLibrary graph_time_library;
	public static HistoryDataLibrary history_data_library;
	public static HistoryMetaDataLibrary history_meta_data_library;
	public static BaseStatsLibrary base_stats_library;
	public static ChromosomeTypeLibrary chromosome_type_library;
	public static GeneLibrary gene_library;
	public static NameplateLibrary nameplates_library;
	public static MetaTypeLibrary meta_type_library;
	public static MetaCustomizationLibrary meta_customization_library;
	public static MetaRepresentationLibrary meta_representation_library;
	public static DecisionsLibrary decisions_library;
	public static NeuralLayerLibrary neural_layers;
	public static LoyaltyLibrary loyalty_library;
	public static OpinionLibrary opinion_library;
	public static HappinessLibrary happiness_library;
	public static KingdomJobLibrary job_kingdom;
	public static BehaviourTaskKingdomLibrary tasks_kingdom;
	public static WorldLogLibrary world_log_library;
	public static HistoryGroupLibrary history_groups;
	public static CityJobLibrary job_city;
	public static BehaviourTaskCityLibrary tasks_city;
	public static ActorJobLibrary job_actor;
	public static BehaviourTaskActorLibrary tasks_actor;
	public static CitizenJobLibrary citizen_job_library;
	public static CultureTraitLibrary culture_traits;
	public static CultureTraitGroupLibrary culture_trait_groups;
	public static LanguageTraitLibrary language_traits;
	public static LanguageTraitGroupLibrary language_trait_groups;
	public static SubspeciesTraitLibrary subspecies_traits;
	public static SubspeciesTraitGroupLibrary subspecies_trait_groups;
	public static ClanTraitLibrary clan_traits;
	public static ClanTraitGroupLibrary clan_trait_groups;
	public static ReligionTraitLibrary religion_traits;
	public static ReligionTraitGroupLibrary religion_trait_groups;
	public static TraitRainLibrary trait_rains;
	public static CommunicationLibrary communication_library;
	public static CommunicationTopicLibrary communication_topic_library;
	public static BookTypeLibrary book_types;
	public static PersonalityLibrary personalities;
	public static ProfessionLibrary professions;
	public static DropsLibrary drops;
	public static BuildingLibrary buildings;
	public static ActorAssetLibrary actor_library;
	public static ActorTraitLibrary traits;
	public static ActorTraitGroupLibrary trait_groups;
	public static KingdomLibrary kingdoms;
	public static KingdomTraitLibrary kingdoms_traits;
	public static KingdomTraitGroupLibrary kingdoms_traits_groups;
	public static NameGeneratorLibrary name_generator;
	public static NameSetsLibrary name_sets;
	public static DisasterLibrary disasters;
	public static PhenotypeLibrary phenotype_library;
	public static BiomeLibrary biome_library;
	public static ResourceLibrary resources;
	public static ItemLibrary items;
	public static ItemModifierLibrary items_modifiers;
	public static ItemGroupLibrary item_groups;
	public static UnitHandToolLibrary unit_hand_tools;
	public static ProjectileLibrary projectiles;
	public static BuildOrderLibrary city_build_orders;
	public static ArchitectureLibrary architecture_library;
	public static CloudLibrary clouds;
	public static MonthLibrary months;
	public static TileLibrary tiles;
	public static TopTileLibrary top_tiles;
	public static TerraformLibrary terraform;
	public static PowerLibrary powers;
	public static SpellLibrary spells;
	public static StatusLibrary status;
	public static TesterJobLibrary tester_jobs;
	public static TesterBehTaskLibrary tester_tasks;
	public static MusicBoxLibrary music_box;
	public static AchievementLibrary achievements;
	public static AchievementGroupLibrary achievement_groups;
	public static SignalLibrary signals;
	public static MapGenSettingsLibrary map_gen_settings;
	public static MapGenTemplateLibrary map_gen_templates;
	public static QuantumSpriteLibrary quantum_sprites;
	public static WorldBehaviourLibrary world_behaviours;
	public static MapSizeLibrary map_sizes;
	public static WorldAgeLibrary era_library;
	public static EffectsLibrary effects_library;
	public static SimGlobals sim_globals_library;
	public static ColorStyleLibrary color_style_library;
	public static ClanColorsLibrary clan_colors_library;
	public static SubspeciesColorsLibrary subspecies_colors_library;
	public static FamiliesColorsLibrary families_colors_library;
	public static ArmiesColorsLibrary armies_colors_library;
	public static LanguagesColorsLibrary languages_colors_library;
	public static KingdomColorsLibrary kingdom_colors_library;
	public static CultureColorsLibrary culture_colors_library;
	public static ReligionColorsLibrary religion_colors_library;
	public static ArchitectMoodLibrary architect_mood_library;
	public static PlotsLibrary plots_library;
	public static PlotCategoryLibrary plot_category_library;
	public static TooltipLibrary tooltips;
	public static WarTypeLibrary war_types_library;
	public static HotkeyLibrary hotkey_library;
	public static StatisticsLibrary statistics_library;
	public static BrushLibrary brush_library;
	public static DebugToolLibrary debug_tool_library;
	public static CombatActionLibrary combat_action_library;
	public static DynamicSpritesLibrary dynamic_sprites_library;
	public static KnowledgeLibrary knowledge_library;
	public static WindowLibrary window_library;
	public static MetaTextReportLibrary meta_text_report_library;
	public static ListWindowLibrary list_window_library;
	public static PowerTabLibrary power_tab_library;
	public static LocaleGroupLibrary locale_groups_library;
	public static GameLanguageLibrary game_language_library;
	private static AssetManager _instance;
	private readonly List<BaseAssetLibrary> _list = new List<BaseAssetLibrary>();
	private readonly Dictionary<string, BaseAssetLibrary> _dict = new Dictionary<string, BaseAssetLibrary>();
	private string _assetgv;
	public static HashSet<string> missing_locale_keys = new HashSet<string>();
	public static void clear()
	public static void initMain()
	public static void init()
	public AssetManager()
	private void initLibs()
	public static void loadAutoTester()
	internal static void generateMissingLocalesFile()
	public void exportAssets()
	private void add(BaseAssetLibrary pLibrary, string pId)
	public static IEnumerable<BaseAssetLibrary> getList()
	public static bool has(string pLibraryID)
	public static BaseAssetLibrary get(string pLibraryID)
public static class AssetModLoader
	private static string path_log;
	public static void load()
		string text = Application.streamingAssetsPath + "/mods/";
		List<string> directories = getDirectories(text);
		for (int i = 0; i < directories.Count; i++)
	private static void loadMod(string pPath)
		string text = pPath.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)[^1];
		foreach (string directory in getDirectories(pPath))
	private static void checkModAssets(string pPath)
		List<string> directories = getDirectories(pPath);
		string[] array = pPath.Split(Path.DirectorySeparatorChar);
		string text = array[^1];
		foreach (string item in directories)
	private static void checkModFolder(string pPath, string pType)
		List<string> files = getFiles(pPath);
		string[] array = pPath.Split(Path.DirectorySeparatorChar);
		foreach (string item in files)
	private static void loadTexture(string pPath)
		string text = pPath.Split(Path.DirectorySeparatorChar)[^1];
		string text2 = "@wb_" + text;
	private static void loadFileJson(string pPath, string pType)
		string text = pPath.Split(Path.DirectorySeparatorChar)[^1];
		string pData = File.ReadAllText(pPath);
	private static void loadAssetActor(string pData)
	private static void loadAssetBuilding(string pData)
	private static void loadAssetKingdom(string pData)
	private static void loadAssetPowers(string pData)
	private static void loadAssetTraits(string pData)
	private static void log(string pLog)
	private static List<string> getDirectories(string pPath)
		List<string> list = new List<string>();
		string[] directories = Directory.GetDirectories(pPath);
		foreach (string text in directories)
	private static List<string> getFiles(string pPath)
		List<string> list = new List<string>();
		string[] files = Directory.GetFiles(pPath);
		foreach (string text in files)
public class AssetsDebugManager
	public static ActorSex actors_sex;
	public static void changeSex()
	public static void newKingdomColors()
	public static void setRandomKingdomColor(string pKingdomAssetId)
	public static void newSkinColors()
	public static void setRandomSkinColor(ActorAsset pAsset)
		string randomSkinColor = getRandomSkinColor(pAsset);
	private static string getRandomSkinColor(ActorAsset pAsset)
namespace EpPathFinding.cs;
public static class AStarFinder
	private static int _last_global_region_id;
	public static bool result_split_path;
	private static IntervalHeap<Node> _open_list = new IntervalHeap<Node>();
	public static void backTracePath(Node pNode, List<WorldTile> pSavePath, bool pEndToStartPath = false)
	public static void FindPath(AStarParam pParam, List<WorldTile> pSavePath)
		float weight = pParam.weight;
		bool boat = pParam.boat;
	private static bool isObstaclesAround(WorldTile pTile)
namespace EpPathFinding.cs;
public class AStarParam : ParamBase
	internal float weight;
	internal int max_open_list = -1;
	internal bool roads;
	internal bool use_global_path_lock;
	internal bool boat;
	internal bool limit;
	internal bool swamp;
	internal bool ocean;
	internal bool lava;
	internal bool fire;
	internal bool block;
	internal bool ground;
	internal bool end_to_start_path;
	public void resetParam()
	internal override void _reset(GridPos iStartPos, GridPos iEndPos, BaseGrid iSearchGrid = null)
public delegate bool AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null);
public readonly struct AttackData
	public readonly BaseSimObject initiator;
	public readonly Action kill_action;
	public readonly Kingdom kingdom;
	public readonly WorldTile hit_tile;
	public readonly Vector3 hit_position;
	public readonly Vector3 initiator_position;
	public readonly BaseSimObject target;
	public readonly AttackType attack_type;
	public readonly bool skip_shake;
	public readonly bool metallic_weapon;
	public readonly bool critical;
	public readonly int targets;
	public readonly int critical_damage_multiplier;
	public readonly float area_of_effect;
	public readonly int damage;
	public readonly float damage_range;
	public readonly bool is_projectile;
	public readonly string projectile_id;
	public readonly float knockback;
	public AttackData(BaseSimObject pInitiator, WorldTile pHitTile, Vector3 pHitPosition, Vector3 pInitiatorPosition, BaseSimObject pTarget, Kingdom pKingdom, AttackType pAttackType = AttackType.Other, bool pMetallicWeapon = false, bool pSkipShake = true, bool pProjectile = false, string pProjectileID = "", Action pKillAction = null, float pBonusAreOfEffect = 0f)
		bool flag = false;
		float num = 0f;
		int num2 = 1;
		float num3 = 0.1f;
		int num4 = 1;
		float num5 = 1f;
		float num6 = 1f;
		critical_damage_multiplier = (int)num6;
public struct AttackDataResult
	public long deflected_by_who_id;
	public ApplyAttackState state;
	public static AttackDataResult Continue => new AttackDataResult(ApplyAttackState.Continue, -1L);
	public static AttackDataResult Miss => new AttackDataResult(ApplyAttackState.Miss, -1L);
	public static AttackDataResult Hit => new AttackDataResult(ApplyAttackState.Hit, -1L);
	public static AttackDataResult Block => new AttackDataResult(ApplyAttackState.Block, -1L);
	public AttackDataResult(ApplyAttackState pState, long pDeflectedByWhoId = -1L)
public enum AttackType
public class AugmentationButton<TAugmentation> : MonoBehaviour where TAugmentation : BaseAugmentationAsset
	public TAugmentation augmentation_asset;
	internal Image image;
	internal Image locked_bg;
	private IconOutline _outline;
	private Shadow _shadow;
	private bool _tooltip_enabled = true;
	internal Button button;
	internal bool is_editor_button;
	private AugmentationUnlockedAction _on_augmentation_unlocked;
	private AugmentationButtonClickAction _on_button_clicked;
	protected bool created;
	private bool _selected;
	protected virtual string tooltip_type
	public bool isSelected()
	protected virtual void Awake()
	protected virtual void onStartDrag(DraggableLayoutElement pOriginalElement)
	protected virtual void create()
	public virtual void load(TAugmentation pElement)
	protected virtual void initTooltip()
	protected virtual void Update()
	protected void loadLegendaryOutline()
	private void showOutline(ContainerItemColor pContainer)
	public void showTooltip()
	public void addElementUnlockedAction(AugmentationUnlockedAction pAction)
	public void removeElementUnlockedAction(AugmentationUnlockedAction pAction)
	protected virtual void clearActions()
	public virtual void updateIconColor(bool pSelected)
	public TAugmentation getElementAsset()
	protected bool isElementUnlocked()
	protected virtual bool unlockElement()
	protected virtual void startSignal()
	protected virtual void fillTooltipData(TAugmentation pElement)
	protected virtual TooltipData tooltipDataBuilder()
	protected virtual string getElementType()
	public virtual string getElementId()
	protected virtual Rarity getRarity()
	protected virtual void disableTooltip()
	public void addClickAction(AugmentationButtonClickAction pAction)
	public void removeClickAction(AugmentationButtonClickAction pAction)
	private void clearClickActions()
	private void OnDestroy()
public delegate void AugmentationButtonClickAction(GameObject pTraitButton);
public class AugmentationCategory<TAugmentation, TAugmentationButton, TAugmentationEditorButton> : MonoBehaviour where TAugmentation : BaseAugmentationAsset where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentationEditorButton : AugmentationEditorButton<TAugmentationButton, TAugmentation>
	public Text title;
	public Text counter;
	public RectTransform height;
	public Transform augmentation_buttons_transform;
	public BaseCategoryAsset asset;
	public List<TAugmentationEditorButton> augmentation_buttons = new List<TAugmentationEditorButton>();
	public void clearDebug()
		for (int i = 0; i < augmentation_buttons_transform.childCount; i++)
	public void hideCounter()
	public void updateCounter()
		int num = 0;
		string arg = augmentation_buttons.Count.ToString();
	protected virtual bool isUnlocked(TAugmentationButton pButton)
	private void LateUpdate()
	private void updateValues()
	public int countActiveButtons()
		int num = 0;
	public bool hasAugmentation(TAugmentation pTrait)
public class AugmentationEditorButton<TAugmentationButton, TAugmentation> : MonoBehaviour where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentation : BaseAugmentationAsset
	public TAugmentationButton augmentation_button;
	public Image selected_icon;
public class AugmentationsEditor<TAugmentation, TAugmentationButton, TAugmentationEditorButton, TAugmentationGroupAsset, TAugmentationGroup, TAugmentationWindow, TEditorInterface> : BaseAugmentationsEditor where TAugmentation : BaseAugmentationAsset where TAugmentationButton : AugmentationButton<TAugmentation> where TAugmentationEditorButton : AugmentationEditorButton<TAugmentationButton, TAugmentation> where TAugmentationGroupAsset : BaseCategoryAsset where TAugmentationGroup : AugmentationCategory<TAugmentation, TAugmentationButton, TAugmentationEditorButton> where TAugmentationWindow : IAugmentationsWindow<TEditorInterface> where TEditorInterface : IAugmentationsEditor
	private const float FOCUS_SCROLL_OFFSET_TOP = -5f;
	private const float FOCUS_SCROLL_OFFSET_BOTTOM = 1f;
	public const float FOCUS_SCROLL_DURATION = 0.3f;
	protected Image art;
	public TAugmentationButton prefab_augmentation;
	public TAugmentationEditorButton prefab_editor_augmentation;
	public TAugmentationGroup prefab_augmentation_group;
	protected readonly Dictionary<string, TAugmentationGroup> dict_groups = new Dictionary<string, TAugmentationGroup>();
	protected readonly List<TAugmentationEditorButton> all_augmentation_buttons = new List<TAugmentationEditorButton>();
	protected TAugmentationWindow augmentation_window;
	protected ObjectPoolGenericMono<TAugmentationButton> selected_editor_buttons;
	private WindowMetaTab _editor_tab;
	protected virtual List<TAugmentationGroupAsset> augmentation_groups_list
	protected virtual List<TAugmentation> all_augmentations_list
	protected virtual TAugmentation edited_marker_augmentation => null;
	protected override void create()
	protected override void OnEnable()
	protected virtual ListPool<TAugmentation> getOrderedAugmentationsList()
		listPool.Sort(delegate(TAugmentation pT1, TAugmentation pT2)
	public override void reloadButtons()
		int num = 0;
		int num2 = 0;
		int num3 = 0;
	protected override void groupsBuilder()
	protected override void checkEnabledGroups()
	protected void editorButtonClick(TAugmentationEditorButton pButton)
	protected virtual void metaAugmentationClick(TAugmentationEditorButton pButton)
	protected virtual void rainAugmentationClick(TAugmentationEditorButton pButton)
	protected virtual void validateRainData()
		augmentations_list_link.RemoveAll(delegate(string tId)
	protected virtual void refreshAugmentationWindow()
	protected void saveRainValues()
		foreach (string item in augmentations_hashset)
	protected virtual void loadEditorSelectedAugmentations()
		foreach (string item in augmentations_hashset)
	public void scrollToGroupStarter(GameObject pButton)
	public virtual void scrollToGroupStarter(GameObject pButton, bool pIgnoreTooltipCheck)
		bool pWithDelay = false;
	private IEnumerator scrollToGroupStarterRoutine(GameObject pButton, bool pWithDelay)
	private void scrollToGroup(GameObject pButton, float pDuration = 0.3f)
		float height = ((Rect)(ref rect)).height;
		float height2 = ((Rect)(ref rect)).height;
		float height3 = ((Rect)(ref rect)).height;
		float height4 = ((Rect)(ref rect)).height;
		float height5 = ((Rect)(ref rect)).height;
		float num = Mathf.Abs(val2.anchoredPosition.y) - height4 * (1f - val2.pivot.y) - height2;
		float num2 = Mathf.Abs(component4.anchoredPosition.y) - height5 * (1f - component4.pivot.y) + num;
		float num3 = num2 + height5;
		bool flag = num2 < ((Transform)component2).localPosition.y;
		bool flag2 = num3 > ((Transform)component2).localPosition.y + height - height2;
	protected virtual bool isAugmentationExists(string pId)
	protected virtual void loadEditorSelectedButton(TAugmentationButton pButton, string pAugmentationId)
	protected virtual void createButton(TAugmentation pElement, TAugmentationGroup pGroup)
	protected virtual bool hasAugmentation(TAugmentationButton pButton)
	protected virtual bool addAugmentation(TAugmentationButton pButton)
	protected virtual bool removeAugmentation(TAugmentationButton pButton)
	public WindowMetaTab getEditorTab()
	protected bool isAugmentationAvailable(TAugmentationButton pButton)
public delegate void AugmentationUnlockedAction();
public static class Auth
	public static UserLoginWindow userLoginWindow;
	public static bool isLoggedIn = false;
	public static string userId;
	public static string userName;
	public static string displayName;
	public static string emailAddress;
	private static bool initialized = false;
	public static bool authLoaded = false;
	public static Promise authLoadedPromise = new Promise();
	public static void initializeAuth()
	public static void AuthStateChanged(object sender, EventArgs eventArgs)
	public static void signOut()
	public static bool isValidUsername(string username)
	public static bool isValidEmail(string email)
public class AuthButton : MonoBehaviour
	private static string windowId;
	private static List<string> worldnetNoSub = new List<string> { "worldnet_main" };
	private void Awake()
	public void showWorldNetOwnWorldsWindow()
	public void showWorldNetWorldsListWindow()
	public void showWorldNetMainWindow()
	public void showWorldNetUploadWindow()
	public void showBrowseByTagWindow()
	public void wbbConfirm()
	public void uploadWorldButton()
	public void checkAuthAndOpenWindow()
public class AuthorButton : MonoBehaviour
	public string authorId;
	private void Awake()
	public void showWorldNetAuthorListWindow()
public class AutoCivilization
	private const int KIDS_AGE = 5;
	private const float KIDS_PERCENT = 0.5f;
	private const int EGGS_AGE = 0;
	private const float EGGS_PERCENT_OF_KIDS = 0.5f;
	private const float WARRIORS_PERCENT_OF_ADULTS = 0.1f;
	private const float ITEMS_HOLDER_PERCENT = 0.6f;
	private const int TICKS_WITHOUT_BUILDING_TO_STOP = 100;
	private const int MAXIMUM_TICKS = 5000;
	private const int UNITS_AMOUNT = 100;
	private const float ELAPSED_PER_TICK = 1.5f;
	private const int ITEM_PRODUCTION_PER_UNIT = 5;
	private const int MAXIMUM_TASK_ACTIONS = 500;
	private const int FRAMES_PER_ROUTINE_UPDATE = 4;
	private List<BehaviourTaskActor> _tasks_building = new List<BehaviourTaskActor>();
	private List<BehaviourTaskActor> _tasks_gathering = new List<BehaviourTaskActor>();
	private List<BehaviourTaskActor> _tasks_farming = new List<BehaviourTaskActor>();
	private BehaviourTaskActor _task_take_items;
	private City _city;
	private Actor _unit;
	private List<Actor> _units_list = new List<Actor>(100);
	private BuildingBiomeFoodProducer _food_producer_bonfire;
	private BuildingBiomeFoodProducer _food_producer_hall;
	private Coroutine _routine;
	private int _action_index;
	public AutoCivilization()
	public void makeCivilization(Actor pUnit)
	private void makeBooks(Actor pActor)
	private Actor newUnit(Culture pCulture, Language pLanguage)
	private void spawnUnits(Culture pCulture, Language pLanguage)
		for (int i = 0; i < 99; i++)
	private IEnumerator civilizationMakingRoutine()
		int tNoBuiltTicks = 0;
		for (int i = 0; i < 5000; i++)
	private void claimZone(Actor pUnit)
	private void gatherResources(Actor pUnit)
	private bool buildBuilding(Actor pActor)
		bool result = CityBehBuild.buildTick(_city);
	private void doFarming(Actor pUnit)
	private void makeFood(Actor pUnit)
	private void refertilizeTiles(TileZone pTileZone)
	private void randomTeleport(Actor pUnit)
	private void craftAndTakeItems(Actor pUnit)
	private void doTask(BehaviourTaskActor pTask, Actor pActor)
		for (int i = 0; i < 500; i++)
	private bool updateTaskIndex(BehResult pResult)
	private void clear()
public class AutoSaveData
	public string name;
	public string path;
	public double timestamp;
public class AutoSaveElement : MonoBehaviour, IPointerMoveHandler, IEventSystemHandler
	private sealed class _003C_003Ec
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();
		public static UnityAction _003C_003E9__12_0;
		internal void _003CAwake_003Eb__12_0()
	private Image _preview;
	private Text _save_name;
	private Text _save_time_ago;
	private CountUpOnClick _kingdoms;
	private CountUpOnClick _cities;
	private CountUpOnClick _population;
	private CountUpOnClick _mobs;
	private CountUpOnClick _age;
	private Button _button;
	private GameObject _premium_icon;
	private string _world_path;
	private MapMetaData _meta_data;
	private void Awake()
	public void OnPointerMove(PointerEventData pData)
	private void tooltipAction()
	public void load(AutoSaveData pData)
		string text = SaveManager.generatePngSmallPreviewPath(pData.path);
		if (!string.IsNullOrEmpty(text) && File.Exists(text))
		string text2 = "";
		string text3 = "";
	public void clickLoadAutoSave()
	private void OnDisable()
public class AutoSaveHelper : MonoBehaviour
	public void openAutoSaveWindow()
public static class AutoSaveManager
	private static float _time = 300f;
	private static float _interval = 300f;
	private static bool lowMemory = false;
	private static int lastClear = 0;
	private static int low_mem_count = 0;
	public static void update()
	public static void autoSave(bool pSkipDelete = false, bool pForce = false)
		string text = SaveManager.generateAutosavesPath(Math.Truncate(Epoch.Current()).ToString());
	private static void checkClearSaves()
		Dictionary<string, ListPool<AutoSaveData>> autoSavesPerMap = getAutoSavesPerMap(listPool);
		UnsafeCollectionPool<Dictionary<string, ListPool<AutoSaveData>>, KeyValuePair<string, ListPool<AutoSaveData>>>.Release(autoSavesPerMap);
	public static void resetAutoSaveTimer()
		_time = _interval;
	public static ListPool<AutoSaveData> getAutoSaves()
		string text = SaveManager.generateAutosavesPath();
		using ListPool<string> listPool = Toolbox.getDirectories(text);
		foreach (ref string item in listPool)
	public static Dictionary<string, ListPool<AutoSaveData>> getAutoSavesPerMap(ListPool<AutoSaveData> pDatas)
		Dictionary<string, ListPool<AutoSaveData>> dictionary = UnsafeCollectionPool<Dictionary<string, ListPool<AutoSaveData>>, KeyValuePair<string, ListPool<AutoSaveData>>>.Get();
		for (int i = 0; i < pDatas.Count; i++)
	public static int sorter(AutoSaveData o1, AutoSaveData o2)
	internal static void OnLowMemory()
		int num = (int)Epoch.Current();
public class AutoSavesWindow : MonoBehaviour
	private AutoSaveElement _element_prefab;
	private List<AutoSaveElement> elements = new List<AutoSaveElement>();
	private Queue<AutoSaveData> _showQueue = new Queue<AutoSaveData>();
	private VerticalLayoutGroup _elements_parent;
	private float _timer;
	private void OnEnable()
	private void prepareSaves()
		for (int i = 0; i < listPool.Count; i++)
	private void Update()
	private void showNextItemFromQueue()
	private void prepareList()
	private void renderMapElement(AutoSaveData pData)
public class AutoTesterBot : BaseMapObject
	internal string debugString = "";
	internal bool active;
	internal AiSystemTester ai;
	internal float wait;
	internal int beh_year_target;
	internal WorldTile beh_tile_target;
	internal string beh_asset_target;
	internal string active_tester = "";
	private Image _icon;
	public Image icon
	internal void clearWorld()
	internal override void create()
		ai.next_job_delegate = AssetManager.tester_jobs.getNextJob;
	internal void create(string pJob)
		List<string> tJobs = new List<string> { pJob };
		ai.next_job_delegate = delegate
	public override void update(float pElapsed)
	private void updateButton()
	public void startAutoTester()
	public void stopAutoTester()
	public void toggleAutoTester()
public class AvatarCombineHandItem
	public readonly IHandRenderer hand_renderer;
	public AvatarCombineHandItem(IHandRenderer pHandRenderer)
public class AvatarEffect : MonoBehaviour
	public Image image;
	private RectTransform _rect_transform;
	private Vector3 _initial_position;
	private StatusAsset _asset;
	private Actor _actor;
	private UnitAvatarLoader _avatar;
	private bool _animated;
	private float _time_between_frames;
	private float _elapsed;
	private int _current_frame;
	public void load(StatusAsset pAsset, Actor pActor, UnitAvatarLoader pAvatar)
		int pIndex;
	public void update(float pElapsed)
	private Sprite getSprite(int pIndex)
	private Vector3 getSpritePosition(int pIndex)
	private Vector3 getSpriteRotation(int pIndex)
	public void setInitialPosition(Vector2 pPosition)
	public RectTransform getRectTransform()
	public UnitAvatarLoader getAvatar()
	public StatusAsset getAsset()
public class AvatarsCombineDataContainer
	private Dictionary<string, AvatarsCombineDataElement> _dict = new Dictionary<string, AvatarsCombineDataElement>();
	private List<AvatarsCombineDataElement> _list = new List<AvatarsCombineDataElement>();
	public void add(string pId, int pAmount)
	public int getListIndex(int pIndex, string pId)
		int num = avatarsCombineDataElement.order_index - 1;
		int num2 = 1;
		for (int i = num + 1; i < _list.Count; i++)
	public void clear()
	public int totalCombinations()
		int num = 1;
		for (int i = 0; i < _list.Count; i++)
public struct AvatarsCombineDataElement
	public readonly int order_index;
	public readonly int total_amount;
	public AvatarsCombineDataElement(int pOrderIndex, int pTotalAmount)
public readonly struct AvgStats
	public readonly double avg;
	public readonly int count;
	public readonly string name;
	public AvgStats(double pAvg, int pCount, string pName)
	public AvgStats add(double pValue)
		int pCount = count + 1;
public class AxonElement : MonoBehaviour
	public Image image;
	internal NeuronElement neuron_1;
	internal NeuronElement neuron_2;
	internal float mod_light = 1f;
	public bool axon_center;
	public void update()
	public void clear()
public static class BabyHelper
	public static Actor debugTryToMakeUnit(Actor pActor)
	public static void countBirth(Actor pBaby)
	public static void applyParentsMeta(Actor pParent1, Actor pParent2, Actor pBaby)
		using ListPool<int> listPool = new ListPool<int>(2);
	private static string getBestAtribute(Actor pParent1)
		string result = null;
		int num = 0;
		if (pParent1.data["intelligence"] > (float)num)
		if (pParent1.data["warfare"] > (float)num)
		if (pParent1.data["diplomacy"] > (float)num)
		if (pParent1.data["stewardship"] > (float)num)
	private static Clan checkGreatClan(Actor pParent1, Actor pParent2)
	private static Subspecies getBabySubspecies(Actor pParent1, Actor pParent2)
	public static bool canMakeBabies(Actor pActor)
	public static bool isMetaLimitsReached(Actor pActor)
	public static void countMakeChild(Actor pParent1, Actor pParent2)
	public static void babyMakingStart(Actor pActor)
	public static void traitsClone(Actor pActorTarget, Actor pParent1)
	public static void traitsInherit(Actor pActorTarget, Actor pParent1, Actor pParent2)
		int pCounter = 0;
		int pCounter2 = 0;
	private static void addTraitsFromParentToList(Actor pActor, ListPool<ActorTrait> pList, out int pCounter)
		int num = 0;
public class BabyMaker
	public static void startMiracleBirth(Actor pActor)
	public static void startSoulborneBirth(Actor pActor)
	public static void spawnSporesFor(Actor pActor)
		int num = Randy.randomInt(3, 10);
		for (int i = 0; i < num; i++)
	public static void spawnBabyFromSpore(Actor pActor, Vector3 pPosition)
		WorldTile tile = World.world.GetTile((int)pPosition.x, (int)pPosition.y);
	public static void makeBabyFromMiracle(Actor pActor, ActorSex pSex = ActorSex.None, bool pAddToFamily = false)
	public static Actor makeBabyViaFission(Actor pActor)
		int pValue = pActor.getHealth() / 2;
		int pValue2 = pActor.getHappiness() / 2;
		int pVal = pActor.getNutrition() / 2;
	public static Actor makeBabyViaBudding(Actor pActor)
	public static Actor makeBabyViaVegetative(Actor pActor)
	public static void makeBabyViaParthenogenesis(Actor pActor)
	public static void makeBabiesViaSexual(Actor pMotherTarget, Actor pParentA, Actor pParentB)
		int num = (int)pMotherTarget.stats["birth_rate"];
		float num2 = 0.5f;
		for (int i = 0; i < num; i++)
	public static void makeBabyFromPregnancy(Actor pActor)
		float num = 0.5f;
		int num2 = (int)pActor.stats["birth_rate"];
		for (int i = 0; i < num2; i++)
	private static void newImmediateBabySpawn(Actor pParent1, Actor pParent2)
	public static Actor makeBaby(Actor pParent1, Actor pParent2, ActorSex pForcedSexType = ActorSex.None, bool pCloneTraits = false, int pMutationRate = 0, WorldTile pTile = null, bool pAddToFamily = false, bool pJoinFamily = false)
		int generation = pParent1.data.generation;
		actor.event_full_stats = true;
internal class BackButtonHider : MonoBehaviour
	private void OnEnable()
public class BannerAsset : Asset
	public List<string> backgrounds;
	public List<string> icons;
	public List<string> frames;
public abstract class BannerBase : MonoBehaviour, IBanner, IBaseMono, IRefreshElement
	private Sequence _sequence;
	protected virtual MetaType meta_type
	public MetaCustomizationAsset meta_asset => AssetManager.meta_customization_library.getAsset(meta_type);
	public MetaTypeAsset meta_type_asset => AssetManager.meta_type_library.getAsset(meta_type);
	internal int option_1
	internal int option_2
	internal int color
	public virtual void load(NanoObject pObject)
	public virtual NanoObject GetNanoObject()
	public void jump(float pSpeed = 0.1f, bool pSilent = false)
		float y = ((Component)this).transform.localPosition.y;
		TweenSettingsExtensions.AppendCallback(_sequence, (TweenCallback)delegate
	private void OnDisable()
	public string getName()
	public virtual void showTooltip()
public abstract class BannerGeneric<TMetaObject, TData> : BannerBase where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
	protected TMetaObject meta_object;
	private bool _created;
	protected Image part_background;
	protected Image part_icon;
	protected Image part_frame;
	public bool enable_default_click = true;
	private bool _enable_customize_click;
	public bool enable_tab_show_click;
	protected TData data => meta_object.data;
	protected virtual string tooltip_id
	private void Start()
	private void create()
	protected virtual void setupClick()
	protected virtual void clickAction()
	private void switchOnDoubleTap()
	private void showMetaWindow()
		string window_name = base.meta_type_asset.window_name;
	protected virtual void clickCustomize()
		string customize_window_id = base.meta_asset.customize_window_id;
		if (customize_window_id == string.Empty)
	private void clickShowTab()
	protected virtual void setupParts()
	protected virtual void loadPartFrame()
	protected virtual void loadPartBackground()
	protected virtual void loadPartIcon()
	protected virtual void setupBanner()
	public override void load(NanoObject pObject)
	public override NanoObject GetNanoObject()
	protected virtual void setupTooltip()
		tipButton.setHoverAction(delegate
	protected virtual void tooltipAction()
	protected virtual TooltipData getTooltipData()
		CustomDataContainer<bool> customDataContainer = new CustomDataContainer<bool>();
	public override void showTooltip()
	protected void setMetaObject(NanoObject pObject)
	internal virtual void normalize()
	internal virtual void updateColor()
public class BannersMetaContainer<TMetaBanner, TMetaObject, TMetaData> : WindowMetaElementBase where TMetaBanner : BannerGeneric<TMetaObject, TMetaData> where TMetaObject : CoreSystemObject<TMetaData> where TMetaData : BaseSystemData
	private TMetaBanner _prefab;
	private Transform _container;
	private StatsWindow _window;
	private ObjectPoolGenericMono<TMetaBanner> _pool_elements;
	protected override void Awake()
	protected override void OnEnable()
	public void update(NanoObject pNano)
	private void showContent(NanoObject pNano)
		for (int i = 0; i < listPool.Count; i++)
	private void showElement(TMetaObject pMeta)
	protected virtual IEnumerable<TMetaObject> getMetaList(IMetaObject pMeta)
public delegate void BaseActionActor(Actor pActor);
public class BaseActorComponent : MonoBehaviour, IDisposable
	internal Actor actor;
	internal virtual void create(Actor pActor)
	public virtual void update(float pElapsed)
	public virtual void Dispose()
public class BaseAnimatedObject : BaseMapObject
	internal SpriteAnimation sprite_animation;
	private bool _has_sprite_animation;
	public virtual void Awake()
	internal override void create()
	public override void update(float pElapsed)
	internal void resetAnim()
	internal void updateSpriteAnimation(float pElapsed, bool pForce = false)
	public override void Dispose()
public class BaseAssetElementPlace<TAsset, TAssetElement> : MonoBehaviour where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset>
	public GameObject game_object_cache;
	public RectTransform rect_transform;
	public LayoutElement layout_element;
	public bool has_element;
	public TAssetElement element;
	public GameObject element_game_object_cache;
	public bool allowed_for_search = true;
	public void clear()
	public void setData(TAsset pAsset, TAssetElement pPrefab)
public abstract class BaseAssetLibrary
	private const string ERROR_COLOR_WHITE = "#FFFFFF";
	private const string ERROR_COLOR_RED = "#FF3232";
	private const string ERROR_COLOR_YELLOW = "#FFF832";
	private const string ERROR_COLOR_MAIN = "#D2B7FF";
	public string id = "ASSET_LIBRARY";
	protected static int _latest_hash = 1;
	private static JsonSerializer _json_serializer_internal = null;
	private static JsonSerializer _json_serializer
	public virtual int total_items => 0;
	public virtual void init()
	public void exportAssets()
		string text = "GenAssets/wbassets" + "/" + id + ".json";
	public void importAssets()
		string text = "GenAssets/wbassets" + "/" + id + ".json";
	public virtual void post_init()
	public virtual void linkAssets()
	public virtual void editorDiagnostic()
	public virtual void editorDiagnosticLocales()
	public virtual void checkLocale(Asset pAsset, string pLocaleID)
		if (!string.IsNullOrEmpty(pLocaleID) && !LocalizedTextManager.stringExists(pLocaleID))
	internal bool hasSpriteInResources(string pPath)
	internal bool hasSpriteInResourcesDebug(string pPath)
		string text = Path.Combine(Path.Combine("Assets/Resources", pPath).Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar));
	protected void logErrorOpposites(string pMainTraitID, string pOppositeTraitID)
	private static string formatLog(string pMessage, string pRightPart = null)
		string text = "<color=#D2B7FF>" + pMessage.Trim() + "</color>";
		if (!string.IsNullOrEmpty(pRightPart))
	public static void logAssetLog(string pMessage, string pRightPart = null)
	public static void logAssetError(string pMessage, string pRightPart = null)
	public virtual IEnumerable<Asset> getList()
public class BaseAugmentationAsset : BaseUnlockableAsset
	public bool can_be_given = true;
	public bool can_be_removed = true;
	public bool show_in_meta_editor = true;
	public WorldActionTrait action_on_object_remove;
	public WorldAction action_special_effect;
	public WorldActionTrait action_on_augmentation_add;
	public WorldActionTrait action_on_augmentation_remove;
	public WorldActionTrait action_on_augmentation_load;
	public float special_effect_interval = 1f;
	public AttackAction action_attack_target;
	public string group_id;
	public int priority;
	public string special_locale_id;
	public CombatActionHolder combat_actions;
	public List<SpellAsset> spells;
	public List<string> combat_actions_ids;
	public DecisionAsset[] decisions_assets;
	public List<string> decision_ids;
	public List<string> spells_ids { get; set; }
	public bool hasDecisions()
	public bool hasCombatActions()
	public bool hasSpells()
	public void addDecision(string pID)
	public void addSpell(string pSpell)
	public void addCombatAction(string pCombatActionID)
	public void linkCombatActions()
	public void linkSpells()
		foreach (string spells_id in spells_ids)
	public virtual BaseCategoryAsset getGroup()
public class BaseAugmentationsEditor : MonoBehaviour
	public Transform augmentation_groups_parent;
	public Text text_counter_augmentations;
	public LocalizedText window_title_text;
	public Image power_icon;
	public Transform powers_icons;
	public GridLayoutGroupExtended selected_editor_augmentations_grid;
	public RainSwitcherButton rain_state_switcher;
	protected List<string> augmentations_list_link;
	protected readonly HashSet<string> augmentations_hashset = new HashSet<string>();
	public bool rain_editor;
	public RainState rain_editor_state;
	private bool _groups_initialized;
	private bool _created;
	private StatsWindow _stats_window;
	protected ToggleRainStateAction rain_state_toggle_action;
	private void Awake()
	protected virtual void OnEnable()
	protected virtual void create()
	protected virtual void onEnableRain()
	public virtual void reloadButtons()
	protected virtual void showActiveButtons()
	private void loadAugmentationGroups()
	protected virtual void checkEnabledGroups()
	protected virtual void groupsBuilder()
	protected virtual void startSignal()
	protected virtual void onNanoWasModified()
	protected virtual void toggleRainState(ref RainState pState)
public class BaseBuildingComponent : IDisposable
	internal Building building;
	internal virtual void create(Building pBuilding)
	public virtual void update(float pElapsed)
	public virtual void Dispose()
public delegate void BaseCallback();
public class BaseCategoryAsset : Asset, ILocalizedAsset
	public string name;
	public string color;
	public bool show_counter = true;
	public Color? _color;
	public virtual string getLocaleID()
	public Color getColor()
public class BaseCategoryLibrary<T> : AssetLibrary<T> where T : BaseCategoryAsset
	public override void editorDiagnosticLocales()
public class BaseDebugAnimationElement<TAsset> : MonoBehaviour where TAsset : Asset
	protected TAsset asset;
	public Button play_pause_button;
	public Image play_pause_icon;
	public Sprite sprite_play;
	public Sprite sprite_pause;
	public Button frame_number_button;
	public Text frame_number_text;
	protected bool is_playing;
	protected virtual void Start()
	public virtual void update()
	public virtual void setData(TAsset pAsset)
	protected virtual void clear()
	public virtual void stopAnimations()
	public virtual void startAnimations()
	private void clickToggleState()
	private void checkButtons()
	protected virtual void clickNextFrame()
public class BaseDebugAssetElement<TAsset> : MonoBehaviour where TAsset : Asset
	public static TAsset selected_asset;
	internal TAsset asset;
	public Sprite no_animation;
	public Button asset_button;
	public Text title;
	public Text stats_description;
	public Text stats_values;
	internal RectTransform rect_transform;
	private void Awake()
		asset_button.OnHover((UnityAction)delegate
	public virtual void setData(TAsset pAsset)
	protected virtual void initAnimations()
	public virtual void update()
	public virtual void stopAnimations()
	public virtual void startAnimations()
	protected virtual void initStats()
	protected void showStat(string pID, object pValue)
	protected virtual void showAssetWindow()
public class BaseDebugAssetsComponent<TAsset, TAssetElement, TAssetElementPlace> : MonoBehaviour where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset> where TAssetElementPlace : BaseAssetElementPlace<TAsset, TAssetElement>
	public TAssetElementPlace place_prefab;
	public TAssetElement element_prefab;
	public ScrollRect scroll_rect;
	private RectTransform _scroll_rect_transform;
	private Rect _scroll_world_rect;
	public InputField search_input_field;
	public SortingTab sorting_tab;
	protected List<TAsset> list_assets_sorted;
	protected List<TAsset> list_assets_sorting;
	protected List<TAsset> list_assets_sorting_default;
	protected bool default_sort_reversed;
	protected List<TAssetElementPlace> list_places;
	private bool _initialized;
	protected virtual List<TAsset> getAssetsList()
	protected virtual List<TAsset> getListCivsSort()
	private void OnEnable()
	private void Start()
		((UnityEvent<string>)(object)search_input_field.onValueChanged).AddListener((UnityAction<string>)setDataSearched);
	protected virtual void init()
		sorting_tab.addButton("ui/Icons/iconHumans", "sort_by_civs", setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/actor_traits/iconClumsy", "default_sort", setDataResorted, delegate
	private void Update()
	private void checkVisible(TAssetElementPlace pPlace)
	public void refresh()
	public bool isElementVisible(TAssetElementPlace pPlace)
	protected void setDataResorted()
		int num = list_assets_sorted.Count - 1;
		for (int i = 0; i < list_places.Count; i++)
	protected void checkReverseSort()
	private void setDataSearched(string pValue)
		if (string.IsNullOrEmpty(pValue))
		for (int i = 0; i < list_assets_sorted.Count; i++)
public class BaseDebugAssetWindow<TAsset, TAssetElement> : TabbedWindow where TAsset : Asset where TAssetElement : BaseDebugAssetElement<TAsset>
	public static TAssetElement current_element;
	public SpriteElement sprite_element_prefab;
	public TAssetElement asset_debug_element;
	public Transform sprite_elements_parent;
	public SortingTab sorting_tab;
	public FieldInfoList field_infos;
	public PowerButton show_sprites_button;
	public GameObject hidden_sprites_placeholder;
	private List<FieldInfo> _sorted_fields;
	private List<FieldInfo> _sorting_fields;
	private List<FieldInfo> _default_sorting_fields;
	private bool _default_reversed;
	protected TAsset asset;
	private SortButton _default_sort_button;
	private bool _initialized;
	protected override void create()
		sorting_tab.addButton("ui/Icons/onomastics/onomastics_vowel_separator", "sort_by_alphabet", setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/onomastics/onomastics_consonant_separator", "sort_by_type", setDataResorted, delegate
		_default_sort_button = sorting_tab.addButton("ui/Icons/actor_traits/iconClumsy", "default_sort", setDataResorted, delegate
	private void OnEnable()
	private void Update()
	private void load()
	protected virtual void initSprites()
	public void clickShowAllSprites()
		bool flag = !gameObject.activeSelf;
	private void setDataResorted()
		Dictionary<string, FieldInfoListItem> fields_collection_data = field_infos.fields_collection_data;
		for (int i = 0; i < _sorted_fields.Count; i++)
	private void checkReverseSort()
	private int sortByName(FieldInfo pObject1, FieldInfo pObject2)
		return string.Compare(pObject1.Name, pObject2.Name, StringComparison.InvariantCulture);
	private int sortByType(FieldInfo pObject1, FieldInfo pObject2)
		return string.Compare(pObject1.FieldType.Name, pObject2.FieldType.Name, StringComparison.InvariantCulture);
public class BaseEffect : BaseAnimatedObject
	private const int MAP_MARGIN_TOP = 25;
	private const int MAP_OFFSET_BOTTOM_MIN = -50;
	private const int MAP_OFFSET_BOTTOM_MAX = 30;
	internal bool active;
	internal int effectIndex;
	public const int STATE_START = 1;
	public const int STATE_ON_DEATH = 2;
	public const int STATE_KILLED = 3;
	protected float scale;
	protected float alpha;
	public WorldTile tile;
	internal BaseEffectController controller;
	internal int state;
	private double _timestamp_spawned;
	internal SpriteRenderer sprite_renderer;
	internal BaseCallback callback;
	internal int callbackOnFrame = -1;
	internal EventInstance fmod_instance;
	internal Actor attachedToActor;
	public double timestamp_spawned => _timestamp_spawned;
	public override void Awake()
	public void activate()
	internal void attachTo(Actor pActor)
	internal void makeParentController()
	internal virtual void prepare(WorldTile pTile, float pScale = 0.5f)
		float num = (float)((Vector2Int)(ref pos)).x + 0.5f;
		current_position = Vector2.op_Implicit(new Vector3(num, (float)((Vector2Int)(ref pos)).y));
	public void setScale(float pScale)
	internal virtual void prepare(Vector2 pVector, float pScale = 1f)
	protected void setAlpha(float pVal)
	internal virtual void prepare()
		((Component)this).transform.position = new Vector3((float)Randy.randomInt(-50, 30), (float)Randy.randomInt(0, MapBox.height + 25));
	internal virtual void spawnOnTile(WorldTile pTile)
	internal void startToDie()
	public virtual void kill()
	public void deactivate()
	public void clear()
	public override void update(float pElapsed)
	private void updateAttached()
	public void setCallback(int pFrame, BaseCallback pCallback)
	public bool isKilled()
public class BaseEffectController : BaseMapObject
	public Transform prefab;
	private int _active_index;
	private readonly List<BaseEffect> _list = new List<BaseEffect>();
	private float _timer;
	private float _timer_interval = 1f;
	private bool _object_limit_used;
	private int _object_limit;
	private bool _limit_unload;
	public bool useInterval = true;
	public EffectAsset asset;
	internal override void create()
		_timer_interval = 0.9f;
	public void setLimits(int pLimitObjects, bool pLimitUnload)
	public BaseEffect GetObject()
	public int getActiveIndex()
	internal void addNewObject(BaseEffect pEffect)
	public void killObject(BaseEffect pObject)
	private void makeInactive(BaseEffect pObject)
	private void debugString()
		string text = "";
		for (int i = 0; i < list.Count; i++)
	public override void update(float pElapsed)
	private void updateSpawn(float pElapsed)
	private void updateChildren(float pElapsed)
		for (int num = _active_index - 1; num >= 0; num--)
	public virtual void spawn()
	public BaseEffect spawnNew()
	private void killOldest()
	internal bool isLimitReached()
	internal void clear()
		for (int i = 0; i < list.Count; i++)
	public bool isAnyActive()
	internal void debug(DebugTool pTool)
	internal List<BaseEffect> getList()
public class BaseEmptyListMono : MonoBehaviour
	internal NanoObject meta_object;
	internal MonoBehaviour element;
	private bool has_element;
	private bool has_object;
	public RectTransform rect_transform;
	internal string debug_original_name;
	public void Awake()
	public void assignObject(NanoObject pObject)
	public void assignElement(MonoBehaviour pElement)
	public bool hasElement()
	public void clearElement()
	public void clearObject()
	public bool hasObject()
	public void debugUpdateName(bool tVisible)
		if (string.IsNullOrEmpty(debug_original_name))
namespace EpPathFinding.cs;
public abstract class BaseGrid : IDisposable
	public readonly List<Node> closedList = new List<Node>();
	public int closed_list_count;
	public const int CLOSED_LIST_MINIMUM_ELEMENTS = 10;
	protected GridRect m_gridRect;
	public GridRect gridRect => m_gridRect;
	public abstract int width { get; protected set; }
	public abstract int height { get; protected set; }
	public BaseGrid()
	public BaseGrid(BaseGrid b)
	public abstract Node GetNodeAt(int iX, int iY);
	public abstract bool IsWalkableAt(int iX, int iY);
	public abstract bool SetWalkableAt(int iX, int iY, bool iWalkable, int pCost = 1);
	public abstract Node GetNodeAt(GridPos iPos);
	public abstract bool IsWalkableAt(GridPos iPos);
	public abstract bool SetWalkableAt(GridPos iPos, bool iWalkable);
	public List<Node> GetNeighbors(Node iNode, DiagonalMovement diagonalMovement)
		int x = iNode.x;
		int y = iNode.y;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		bool flag6 = false;
		bool flag7 = false;
		bool flag8 = false;
	public void addToClosed(Node pNode)
	public abstract void Reset();
	public abstract BaseGrid Clone();
	public virtual void Dispose()
public class BaseLibraryWithUnlockables<T> : AssetLibrary<T>, ILibraryWithUnlockables where T : BaseUnlockableAsset
	public IEnumerable<BaseUnlockableAsset> elements_list => list;
	public override void editorDiagnosticLocales()
public class BaseMapObject : BaseWorldObject
	public WorldTile current_tile;
	public float position_height;
	public Vector2 current_position;
	public override void Dispose()
public class BaseMapObjectSimple
	internal bool created;
	public virtual void update(float pElapsed)
	internal virtual void create()
public class BaseModule : BaseMapObject
	internal HashSet<WorldTile> hashset;
	protected float timer;
	internal virtual void clear()
public abstract class BaseObjectData : BaseSystemData
	public int health { get; set; } = 100;
public class BaseSimObject : NanoObject, IEquatable<BaseSimObject>
	public float position_height;
	public WorldTile current_tile;
	public Vector2 current_position;
	public Vector3 current_scale;
	internal Vector3 current_rotation;
	private HashSet<long> _targets_to_ignore;
	public Kingdom kingdom;
	private bool _stats_dirty;
	internal bool event_full_stats;
	internal readonly BaseStats stats = new BaseStats();
	internal Actor a;
	internal Building b;
	private MapObjectType _object_type;
	private readonly Dictionary<string, Status> _active_status_dict = new Dictionary<string, Status>();
	private bool _has_any_status_cached;
	private bool _has_any_status_to_render;
	internal Vector3 cur_transform_position;
	public TileIsland current_island => current_tile.region.island;
	public TileZone current_zone => current_tile.zone;
	public MapChunk current_chunk => current_tile.chunk;
	public MapRegion current_region => current_tile.region;
	public MapChunk chunk => current_tile.chunk;
	internal virtual void create()
	public int countStatusEffects()
	public Dictionary<string, Status>.ValueCollection getStatuses()
	public Dictionary<string, Status>.KeyCollection getStatusesIds()
	public IReadOnlyDictionary<string, Status> getStatusesDict()
	protected override void setDefaultValues()
		event_full_stats = false;
	public bool hasCity()
	public virtual City getCity()
	internal bool addStatusEffect(string pID, float pOverrideTimer = 0f, bool pColorEffect = true)
	internal virtual bool addStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer = 0f, bool pColorEffect = true)
		bool flag = isActor();
		bool flag2 = hasAnyStatusEffectRaw();
	private bool canAddStatus(StatusAsset pStatusAsset, bool pIsActor, bool pHasAnyStatus)
	private void addNewStatusEffect(StatusAsset pStatusAsset, float pOverrideTimer, bool pColorEffect, bool pIsActor, bool pHasAnyStatus)
	internal void finishAllStatusEffects()
	public void finishStatusEffect(string pID)
	public virtual void setStatsDirty()
	internal bool isActor()
	internal bool isBuilding()
	public void setObjectType(MapObjectType pType)
	internal bool hasStatus(string pID)
	internal bool hasAnyStatusEffect()
	internal bool hasAnyStatusEffectRaw()
	internal bool hasAnyStatusEffectToRender()
	public void removeFinishedStatusEffect(Status pStatusData)
	internal virtual void updateStats()
	public bool isStatsDirty()
	private void updateCachedStatusEffects()
	internal bool isInLiquid()
	internal bool isInWater()
	public bool isTouchingLiquid()
	internal virtual bool isInAir()
	internal virtual bool isFlying()
	internal virtual float getHeight()
	internal virtual void getHit(float pDamage, bool pFlash = true, AttackType pAttackType = AttackType.Other, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
	internal virtual void getHitFullHealth(AttackType pAttackType)
	internal BaseSimObject findEnemyObjectTarget(bool pAttackBuildings)
		bool flag = true;
	protected BaseSimObject checkObjectList(IEnumerable<BaseSimObject> pList, bool pAttackBuildings, bool pFindClosest, bool pIgnoreStunned, int pMaxDist = int.MaxValue)
		int num = int.MaxValue;
		long num2 = ((pMaxDist == int.MaxValue) ? pMaxDist : (pMaxDist * pMaxDist + 1));
		bool flag = isActor() && a.hasMeleeAttack();
	internal void ignoreTarget(BaseSimObject pTarget)
	internal bool shouldIgnoreTarget(BaseSimObject pTarget)
	internal void clearIgnoreTargets()
	internal int countTargetsToIgnore()
	internal bool canAttackTarget(BaseSimObject pTarget, bool pCheckForFactions = true, bool pAttackBuildings = true)
		bool flag = isActor();
		string species;
	public bool areFoes(BaseSimObject pTarget)
	public void setHealth(int pValue, bool pClamp = true)
	public void setMaxHealth()
	public void changeHealth(int pValue)
		int num = data.health + pValue;
	public int getHealth()
	public int getMaxHealthPercent(float pPercent)
		int num = (int)((float)getMaxHealth() * pPercent);
	public bool hasHealth()
	public bool Equals(BaseSimObject pObject)
	public int getMaxHealth()
		return (int)stats["health"];
	public override void Dispose()
	private void disposeStatusEffects()
	public bool isKingdomCiv()
	public bool isKingdomMob()
	public bool hasKingdom()
	public virtual BaseObjectData getData()
	public sealed override long getID()
	public override double getFoundedTimestamp()
	public virtual bool hasStatusTantrum()
	public bool isSameIsland(WorldTile pTile)
	public bool isSameIslandAs(BaseSimObject pTarget)
public class BaseStatAsset : Asset, ILocalizedAsset
	public bool hidden;
	public string icon;
	public bool normalize;
	public float normalize_min;
	public float normalize_max = 2.1474836E+09f;
	public bool used_only_for_civs;
	public bool actor_data_attribute;
	public bool show_as_percents;
	public float tooltip_multiply_for_visual_number = 1f;
	public bool multiplier;
	public string main_stat_to_multiply;
	public int sort_rank;
	public bool ignore;
	public string translation_key;
	public string getLocaleID()
public class BaseStats : ICloneable
	private List<BaseStatsContainer> _stats_list = new List<BaseStatsContainer>();
	private Dictionary<string, BaseStatsContainer> _stats_dict = new Dictionary<string, BaseStatsContainer>();
	private List<BaseStatsContainer> _multipliers_list;
	private HashSet<string> _tags;
	public float this[string pKey]
	private void set(string pID, float pAmount)
	public List<BaseStatsContainer> getList()
	public void checkStatName(string pID)
	public float get(string pID)
	public bool hasStat(string pID)
	public BaseStatsContainer getContainer(string pID)
	internal void mergeStats(BaseStats pStats, float pMultiplier = 1f)
		for (int i = 0; i < pStats._stats_list.Count; i++)
	public void checkMultipliers()
		for (int i = 0; i < _multipliers_list.Count; i++)
	public bool hasTag(string pTag)
	public bool hasTags(string[] pTags)
	public void normalize()
		for (int i = 0; i < _stats_list.Count; i++)
	internal void clear()
	public void reset()
	public void addTag(string pTag)
	public bool hasTags()
		HashSet<string> tags = _tags;
	public bool hasStats()
	public bool ShouldSerialize_tags()
	public bool ShouldSerialize_stats_list()
	public void addCombatAction(string pCombatAction)
	public object Clone()
public class BaseStatsContainer
	public string id;
	public float value;
	public BaseStatAsset asset => AssetManager.base_stats_library.get(id);
	public void normalize()
public static class BaseStatsExtension
	public static bool isEmpty(this BaseStats pBaseStats)
public static class BaseStatsHelper
	public delegate KeyValueField KeyValueFieldGetter(string pID);
	public static BaseStats _base_stats_tooltip_helper = new BaseStats();
	private static List<BaseStatsContainer> _stats_container_positive = new List<BaseStatsContainer>();
	private static List<BaseStatsContainer> _stats_container_negative = new List<BaseStatsContainer>();
	public static BaseStats getTotalStatsFrom(BaseStats pBaseStats, BaseStats pBaseStatsMeta)
	public static void showItemMods(Text pTextFieldDescription, Text pTextFieldValues, Item pItem)
	public static void showItemModsRows(KeyValueFieldGetter pFieldsFabric, Item pItem)
	private static ListPool<TooltipModContainerInfo> getItemModsBase(Item pItem)
		foreach (ref string modifier in pItem.data.modifiers)
	private static void addStatValues(Text pStatsField, Text pValuesField, string pStats, string pValues)
	private static void addLineBreak(Text pStatsField, Text pValuesField)
	private static int sortByPluses(TooltipModContainerInfo pContainer1, TooltipModContainerInfo pContainer2)
	public static void showBaseStats(Text pStatsField, Text pValuesField, BaseStats pBaseStats, bool pAddPlus = true)
	public static void showBaseStatsRows(KeyValueFieldGetter pFieldsFabric, BaseStats pBaseStats, bool pAddPlus = true)
	private static void calcBaseStatsBase(BaseStats pBaseStats)
	private static int sortByRank(BaseStatsContainer pContainerA, BaseStatsContainer pContainerB)
	private static void queueStatContainer(BaseStatsContainer pContainer)
	private static void showBaseStatLine(Text pStatsField, Text pValuesField, BaseStatsContainer pContainer, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
		string pText = tId;
		string text = tValue.ToText();
	private static void showBaseStatRow(KeyValueFieldGetter pFieldsFabric, BaseStatsContainer pContainer, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	private static void calcBaseStatLineBase(BaseStatsContainer pContainer, out string tId, out float tValue, out BaseStatAsset tAsset)
	private static void addItemText(Text pStatsField, Text pValuesField, string pID, float pValue, bool pPercent = false, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	private static void addItemTextRow(KeyValueField pField, string pID, float pValue, bool pPercent = false, bool pAddColor = true, bool pAddPlus = true, string pMainColor = "#43FF43", bool pForceZero = false)
	private static void addItemTextBase(float pValue, out string pValString, bool pPercent = false, bool pForceZero = false)
	private static void addLineIntText(Text pStatsField, Text pValuesField, string pID, int pValue, string pColor = null)
	private static void addLineText(Text pStatsField, Text pValuesField, string pID, string pValue, string pColor = null, bool pPercent = false)
		string text = LocalizedTextManager.getText(pID);
		if (!string.IsNullOrEmpty(pColor))
	private static void addRowText(KeyValueField pField, string pID, string pValue, string pColor = null, bool pPercent = false)
		string text;
		if (!string.IsNullOrEmpty(pColor))
public class BaseStatsLibrary : AssetLibrary<BaseStatAsset>
	public override void init()
			id = "construction_speed",
	public override void editorDiagnosticLocales()
public abstract class BaseSystemData : IDisposable
	public List<NameEntry> past_names;
	public CustomDataContainer<int> custom_data_int;
	public CustomDataContainer<long> custom_data_long;
	public CustomDataContainer<float> custom_data_float;
	public CustomDataContainer<bool> custom_data_bool;
	public CustomDataContainer<string> custom_data_string;
	public HashSet<string> custom_data_flags;
	public bool from_db;
	public long id { get; set; } = -1L;
	public string name { get; set; }
	public bool custom_name { get; set; }
	public long name_culture_id { get; set; } = -1L;
	public double created_time { get; set; }
	public double died_time { get; set; }
	public bool favorite { get; set; }
	public int age
	public float this[string pKey]
	public string obsidian_name_id => name + "(" + id + ")";
	public void cloneCustomDataFrom(BaseSystemData pTarget)
		if (pTarget.custom_data_int != null)
		if (pTarget.custom_data_float != null)
		if (pTarget.custom_data_bool != null)
		if (pTarget.custom_data_string != null)
		foreach (string custom_data_flag in pTarget.custom_data_flags)
	public Dictionary<string, string> debug()
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		if (custom_data_int != null)
		if (custom_data_float != null)
		if (custom_data_bool != null)
		if (custom_data_string != null)
	public void save()
	public void checkInt()
		CustomDataContainer<int> customDataContainer = custom_data_int;
	public void checkLong()
	public void checkFloat()
		CustomDataContainer<float> customDataContainer = custom_data_float;
	public void checkBool()
		CustomDataContainer<bool> customDataContainer = custom_data_bool;
	public void checkString()
		CustomDataContainer<string> customDataContainer = custom_data_string;
	public void checkFlags()
	public void load()
	public void get(string pKey, out int pResult, int pDefault = 0)
		if (custom_data_int == null || !custom_data_int.TryGetValue(pKey, out pResult))
	public void get(string pKey, out long pResult, long pDefault = 0L)
	public void get(string pKey, out float pResult, float pDefault = 0f)
		if (custom_data_float == null || !custom_data_float.TryGetValue(pKey, out pResult))
	public void get(string pKey, out string pResult, string pDefault = null)
		if (custom_data_string == null || !custom_data_string.TryGetValue(pKey, out pResult))
	public void get(string pKey, out bool pResult, bool pDefault = false)
		if (custom_data_bool == null || !custom_data_bool.TryGetValue(pKey, out pResult))
	public int set(string pKey, int pData)
		if (custom_data_int == null)
		custom_data_int[pKey] = pData;
	public long set(string pKey, long pData)
	public float set(string pKey, float pData)
		if (custom_data_float == null)
		custom_data_float[pKey] = pData;
	public string set(string pKey, string pData)
		if (custom_data_string == null)
		custom_data_string[pKey] = pData;
	public bool set(string pKey, bool pData)
		if (custom_data_bool == null)
		custom_data_bool[pKey] = pData;
	public void change(string pKey, int pValue, int pMin = 0, int pMax = 1000)
	public void removeInt(string pKey)
		if (custom_data_int != null)
	public void removeLong(string pKey)
	public void removeFloat(string pKey)
		if (custom_data_float != null)
	public void removeString(string pKey)
		if (custom_data_string != null)
	public void removeBool(string pKey)
		if (custom_data_bool != null)
	public bool addFlag(string pID)
	public bool hasFlag(string pID)
	public void removeFlag(string pID)
	public virtual void Dispose()
		custom_data_int?.Dispose();
		custom_data_float?.Dispose();
		custom_data_bool?.Dispose();
		custom_data_string?.Dispose();
		custom_data_int = null;
		custom_data_float = null;
		custom_data_bool = null;
		custom_data_string = null;
public abstract class BaseSystemManager
	protected static int _latest_hash = 1;
	internal static bool anything_changed = false;
	public virtual int Count
	public virtual void ClearAllDisposed()
	public virtual void parallelDirtyUnitsCheck()
	public virtual void checkLists()
	public virtual void clear()
	public virtual void checkDeadObjects()
	public virtual bool isUnitsDirty()
	public virtual bool isLocked()
	public virtual void startCollectHistoryData()
	public virtual void clearLastYearStats()
	public virtual void showDebugTool(DebugTool pTool)
	public virtual bool hasAny()
	public virtual string debugShort()
public class BaseTrait<TTrait> : BaseAugmentationAsset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset where TTrait : BaseTrait<TTrait>
	public float value;
	public WorldAction action_death;
	public WorldAction action_growth;
	public WorldAction action_birth;
	public GetHitAction action_get_hit;
	public bool spawn_random_trait_allowed = true;
	public int spawn_random_rate = 5;
	public bool special_icon_logic;
	public BaseStats base_stats_meta;
	public List<string> opposite_list;
	public HashSet<TTrait> opposite_traits;
	public string[] traits_to_remove_ids;
	public TTrait[] traits_to_remove;
	public string special_locale_description = string.Empty;
	public string special_locale_description_2 = string.Empty;
	public bool has_localized_id = true;
	public bool has_description_1 = true;
	public bool has_description_2 = true;
	public Rarity rarity = Rarity.R1_Rare;
	public bool can_be_in_book = true;
	public string plot_id = string.Empty;
	public List<ActorAsset> default_for_actor_assets;
	public virtual string typed_id
	public PlotAsset plot_asset => AssetManager.plots_library.get(plot_id);
	public bool hasPlotAsset()
		return !string.IsNullOrEmpty(plot_id);
	public string getId()
	public WorldAction getSpecialEffect()
	public float getSpecialEffectInterval()
		return special_effect_interval;
	public void addOpposite(string pID)
	public void addOpposites(IEnumerable<string> pListIDS)
	public void removeOpposite(string pID)
	public override string getLocaleID()
		if (!string.IsNullOrEmpty(special_locale_id))
	public string getDescriptionID()
		if (!string.IsNullOrEmpty(special_locale_description))
	public string getDescriptionID2()
		if (!string.IsNullOrEmpty(special_locale_description_2))
	public string getTranslatedName()
	public string getTranslatedDescription()
		string descriptionID = getDescriptionID();
		if (LocalizedTextManager.stringExists(descriptionID))
	public string getTranslatedDescription2()
		string descriptionID = getDescriptionID2();
		if (LocalizedTextManager.stringExists(descriptionID))
	protected override bool isDebugUnlockedAll()
	protected virtual IEnumerable<ITraitsOwner<TTrait>> getRelatedMetaList()
	private ListPool<ITraitsOwner<TTrait>> getOwnersList()
	private (int pTotal, int pCivs, int pMobs) countTraitOwnersByCategories()
		int num = 0;
		int num2 = 0;
		int num3 = 0;
	public virtual string getCountRows()
		int num = 0;
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append(LocalizedTextManager.getText(typed_id + "_amount_text").Replace("$amount$", getColoredNumber(listPool.Count.ToString())));
		stringBuilderPool.AppendLine();
		stringBuilderPool.Append(LocalizedTextManager.getText("population_amount").Replace("$amount$", getColoredNumber(num.ToString())));
		return stringBuilderPool.ToString();
	private string getColoredNumber(string pText)
	protected string getCountRowsByCategories()
		(int, int, int) tuple = countTraitOwnersByCategories();
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append(LocalizedTextManager.getText("trait_owners_civs").Replace("$amount$", getColoredNumber(tuple.Item2.ToString())));
		stringBuilderPool.AppendLine();
		stringBuilderPool.Append(LocalizedTextManager.getText("trait_owners_mobs").Replace("$amount$", getColoredNumber(tuple.Item3.ToString())));
		return stringBuilderPool.ToString();
	protected virtual bool isSapient(ITraitsOwner<TTrait> pObject)
	public bool ShouldSerializebase_stats_meta()
	public void setTraitInfoToGrinMark()
public class BaseTraitGroupAsset : BaseCategoryAsset
public class BaseTraitLibrary<T> : BaseLibraryWithUnlockables<T> where T : BaseTrait<T>
	protected List<T> _pot_allowed_to_be_given_randomly = new List<T>();
	protected virtual string icon_path
	public override void post_init()
	protected virtual void autoSetRarity()
	public override void linkAssets()
	private void linkCombatActions()
	private void linkSpells()
	private void linkDecisions()
	private void linkActorAssets()
	public override void editorDiagnostic()
	public override void editorDiagnosticLocales()
	private void checkOppositeErrors()
	private void fillOppositeHashsetsWithAssets()
	private void checkIcons()
	public override T add(T pAsset)
	public string addToGameplayReportShort(string pWhatFor)
		string empty = string.Empty;
	public string addToGameplayReport(string pWhatFor)
		string empty = string.Empty;
	public T getRandomSpawnTrait()
	protected virtual List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
public class BaseUnlockableAsset : Asset, ILocalizedAsset
	public string path_icon;
	public bool show_for_unlockables_ui = true;
	public BaseStats base_stats;
	public bool unlocked_with_achievement;
	public bool needs_to_be_explored = true;
	public string achievement_id;
	public bool show_in_knowledge_window = true;
	protected Sprite cached_sprite;
	public bool has_locales = true;
	protected GameProgressData _progress_data => GameProgress.instance?.data;
	protected virtual HashSet<string> progress_elements
	public void setUnlockedWithAchievement(string pAchievementID)
	public virtual bool unlock(bool pSaveData = true)
		bool flag = false;
	public bool isUnlocked()
	public bool isAvailable()
	public bool isUnlockedByPlayer()
	protected virtual bool isDebugUnlockedAll()
	public bool isCheatEnabled()
	public bool ShouldSerializebase_stats()
	public virtual string getLocaleID()
	public string getAchievementLocaleID()
	public Achievement getAchievement()
	public virtual Sprite getSprite()
public class BaseWorldAgeElement : MonoBehaviour
	protected Button button;
	protected TipButton _tip_button;
	protected Image _icon;
	protected WorldAgeAsset asset;
	protected WorldAgeElementAction click_callback;
	private void Awake()
	protected virtual void prepare()
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
	public WorldAgeAsset getAsset()
	public virtual void setAge(WorldAgeAsset pAsset)
	public void setIconActiveColor(bool pState)
		float num = ((!pState) ? 0.55f : 1f);
	public void addClickCallback(WorldAgeElementAction pAction)
	public void removeClickCallback(WorldAgeElementAction pAction)
	public WorldAgeElementAction getClickCallback()
	public void clearClickCallbacks()
	public Button getButton()
public class BaseWorldObject : MonoBehaviour, IDisposable
	internal bool created;
	internal Transform m_transform;
	private void Start()
	public virtual void update(float pElapsed)
	internal virtual void create()
	public virtual void Dispose()
public class Batch<T>
	internal ObjectContainer<T> main;
	internal bool free_slots;
	private List<ObjectContainer<T>> containers = new List<ObjectContainer<T>>();
	internal List<Job<T>> jobs_pre = new List<Job<T>>();
	internal List<Job<T>> jobs_post = new List<Job<T>>();
	internal List<Job<T>> jobs_parallel = new List<Job<T>>();
	protected List<T> _list;
	protected T[] _array;
	protected int _count;
	protected float _elapsed;
	protected ObjectContainer<T> _cur_container;
	internal JobUpdater clearParallelResults;
	internal JobUpdater applyParallelResults;
	public int batch_id;
	public Batch()
	public void updateJobsPre(float pElapsed)
		int count = list.Count;
		for (int i = 0; i < count; i++)
	public void updateJobsParallel(float pElapsed)
		int count = list.Count;
		for (int i = 0; i < count; i++)
	public void updateJobsPost(float pElapsed)
		int count = list.Count;
		for (int i = 0; i < count; i++)
	private void runUpdater(Job<T> pObj)
	internal virtual void prepare()
		for (int i = 0; i < containers.Count; i++)
	protected void createJob(out ObjectContainer<T> pContainer, JobUpdater pJobUpdater, JobType pType, string pID, int pRandomTickSkips = 0)
	protected void addJob(ObjectContainer<T> pContainer, JobUpdater pJobUpdater, JobType pType, string pID, int pRandomTickSkips = 0)
	private void putJob(ObjectContainer<T> pContainer, JobUpdater pJobUpdater, List<Job<T>> pListJobs, string pID, int pRandomTickSkips = 0)
	internal virtual void clear()
		for (int i = 0; i < containers.Count; i++)
	internal virtual void remove(T pObject)
		for (int i = 0; i < containers.Count; i++)
	internal virtual void add(T pObject)
	protected bool check(ObjectContainer<T> pContainer)
	protected virtual void createJobs()
	protected virtual void createHelpers()
	public virtual void clearHelperLists()
	public void debug(DebugTool pTool)
public class BatchActors : Batch<Actor>
	public ObjectContainer<Actor> c_main;
	public ObjectContainer<Actor> c_check_attack_target;
	public ObjectContainer<Actor> c_update_movement;
	public ObjectContainer<Actor> c_main_tile_action;
	public ObjectContainer<Actor> c_shake;
	public ObjectContainer<Actor> c_stats_dirty;
	public ObjectContainer<Actor> c_action_landed;
	public ObjectContainer<Actor> c_make_decision;
	public ObjectContainer<Actor> c_sprite_animations;
	public ObjectContainer<Actor> c_update_children;
	public ObjectContainer<Actor> c_check_enemy_target;
	public ObjectContainer<Actor> c_augmentation_effects;
	public ObjectContainer<Actor> c_events_become_adult;
	public ObjectContainer<Actor> c_events_hatched;
	public ObjectContainer<Actor> c_hovering;
	public ObjectContainer<Actor> c_pollinating;
	public ObjectContainer<Actor> c_check_deaths;
	internal List<Actor> l_parallel_update_sprites = new List<Actor>();
	public Random rnd = new Random(10u);
	protected override void createJobs()
		createJob(out c_events_become_adult, updateEventsBecomeAdult, JobType.Post, "update_events_become_adult");
		createJob(out c_events_hatched, updateEventsEggHatched, JobType.Post, "update_events_hatched");
	private void updateParallelChecks()
	private void updateVisibility()
		bool flag = MapBox.isRenderGameplay();
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateNutritionDecay()
		bool pDoStarvationDamage = false;
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateEventsBecomeAdult()
	private void updateEventsEggHatched()
	private void updateActionLanded()
	private void updateStats()
	private void u1_checkInside()
	private void u2_updateChildren()
	private void u3_spriteAnimation()
	private void u4_deadCheck()
	private void u5_curTileAction()
	private void u5_checkTileDeath()
	private void u6_checkFrozen()
	private void u7_checkAugmentationEffects()
	private void u8_checkUpdateTimers()
	private void b1_checkUnderForce()
	private void b2_checkCurrentEnemyTarget()
	private void b3_findEnemyTarget()
	private void b4_checkTaskVerifier()
	private void b5_checkPathMovement()
	private void b6_0_updateDecision()
	private void b55_updateNaturalDeaths()
	private void b6_updateAI()
	private void u10_checkSmoothMovement()
	private void updateShake()
	private void updateHovering()
	private void updatePollinating()
	private void updateDeathCheck()
	internal override void clear()
	private void clearParallelSprites()
	internal override void add(Actor pActor)
	internal override void remove(Actor pObject)
public class BatchBuildings : Batch<Building>
	public ObjectContainer<Building> c_main;
	public ObjectContainer<Building> c_scale;
	public ObjectContainer<Building> c_angle;
	public ObjectContainer<Building> c_components;
	public ObjectContainer<Building> c_spread_trees;
	public ObjectContainer<Building> c_spread_plants;
	public ObjectContainer<Building> c_spread_fungi;
	public ObjectContainer<Building> c_poop;
	public ObjectContainer<Building> c_resource_shaker;
	public ObjectContainer<Building> c_shake;
	public ObjectContainer<Building> c_position_dirty;
	public ObjectContainer<Building> c_tiles_dirty;
	public ObjectContainer<Building> c_stats_dirty;
	public ObjectContainer<Building> c_auto_remove;
	public Random rnd = new Random(10u);
	private float _timer_spread_trees;
	private float _timer_spread_plants;
	private float _timer_poop_flora;
	private float _timer_spread_fungi;
	public List<Action> actions_to_run = new List<Action>();
	protected override void createJobs()
		createJob(out c_poop, updatePoopTurningIntoFlora, JobType.Post, "update_poop_turning_into_flora");
	public void applyTweenActions()
	internal override void clear()
	private void updateScale()
	private void updateAngle()
	private void updateVisibility()
		bool flag = MapBox.isRenderGameplay();
		bool flag2 = World.world.quality_changer.shouldRenderBuildings();
		int count = _count;
	private void updateTilesDirty()
	private void updateAutoRemove()
	private void updateStatsDirty()
	private void updateComponents()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateSpreadTrees()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateSpreadPlants()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updatePoopTurningIntoFlora()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateSpreadFungi()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateResourceShaker()
		int count = _count;
		for (int i = 0; i < count; i++)
	private void updateShake()
	private void updatePositionsDirty()
	internal override void add(Building pBuilding)
	internal override void remove(Building pObject)
public class BattleContainer
	public float timer = 1f;
	public float timeout = 1f;
	public float timer_animation = 0.05f;
	public int frame;
	private int _deaths_civs;
	private int _deaths_mobs;
	public WorldTile tile;
	public int getDeathsTotal()
	public void increaseDeaths(Actor pActor)
	public bool isRendered()
public static class BattleKeeperManager
	private const int MAX_FRAMES = 8;
	private static HashSet<BattleContainer> _hashset;
	private static readonly List<BattleContainer> _to_remove = new List<BattleContainer>();
	public static void clear()
	public static HashSet<BattleContainer> get()
	public static void update(float pElapsed)
	public static void addUnitKilled(Actor pActor)
public class Beehive : BaseBuildingComponent
	public int honey;
	public void addHoney()
namespace ai.behaviours;
public class BehActive : BehaviourActionActor
namespace ai.behaviours;
public class BehActiveCrabDangerCheck : BehActive
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorAddExperience : BehaviourActionActor
	private int _min;
	private int _max;
	public BehActorAddExperience(int pMin, int pMax)
	public override BehResult execute(Actor pActor)
		int pValue = Randy.randomInt(_min, _max + 1);
namespace ai.behaviours;
public class BehActorAddStatus : BehaviourActionActor
	private string _status_id;
	private float _override_timer;
	private bool _effect_on;
	private bool _add_action_timer;
	public BehActorAddStatus(string pStatusID, float pOverrideTimer = -1f, bool pEffectOn = true, bool pAddActionTimer = false)
	public override BehResult execute(Actor pActor)
public class BehActorBuildingTarget : BehaviourActionActor
	protected override void setupErrorChecks()
public class BehActorChangeHappiness : BehaviourActionActor
	private string _happiness_id;
	public BehActorChangeHappiness(string pID)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorCheckBool : BehaviourActionActor
	private string actionIfBool;
	private string boolCheck;
	public BehActorCheckBool(string pBool, string pActionIfHit)
		boolCheck = pBool;
	public override BehResult execute(Actor pActor)
		pActor.data.get(boolCheck, out var pResult, pDefault: false);
public class BehActorCheckZoneTarget : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehActorGiveTax : BehCitizenActionCity
	public override BehResult execute(Actor pActor)
	private void payTributeToKing(Actor pActor, Actor pKing, float pTaxRate)
	private void payTaxToLeader(Actor pActor, Actor pTarget, float pTaxRate)
public class BehActorRandomJump : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		float num = Randy.randomFloat(1f, 5f);
		float pForceHeight = Randy.randomFloat(1f, 2f);
		float degrees = Randy.randomFloat(-180f, 180f);
namespace ai.behaviours;
public class BehActorRemoveStatus : BehaviourActionActor
	private string status;
	public BehActorRemoveStatus(string pStatus)
	public override BehResult execute(Actor pActor)
public class BehActorReverseFlip : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorSetBool : BehaviourActionActor
	private string boolName;
	private bool boolValue;
	public BehActorSetBool(string pBoolName, bool pBoolValue)
		boolName = pBoolName;
		boolValue = pBoolValue;
	public override BehResult execute(Actor pActor)
		pActor.data.set(boolName, boolValue);
namespace ai.behaviours;
public class BehActorSetFlip : BehaviourActionActor
	private bool flip;
	public BehActorSetFlip(bool pFlip)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorSetFlying : BehaviourActionActor
	private bool _flying;
	public BehActorSetFlying(bool pFlying)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorSetInt : BehaviourActionActor
	private string intName;
	private int intValue;
	public BehActorSetInt(string pIntName, int pIntValue)
		intName = pIntName;
		intValue = pIntValue;
	public override BehResult execute(Actor pActor)
		pActor.data.set(intName, intValue);
namespace ai.behaviours;
public class BehActorTryToAddRandomCombatSkill : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehActorTryToTakeItemFromCity : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehActorUsableBuildingTarget : BehActorBuildingTarget
	protected override void setupErrorChecks()
public class BehAddAggroForBehTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
public class BehAddHappiness : BehaviourActionActor
	private string _happiness_id;
	public BehAddHappiness(string pHappinessID)
	public override BehResult execute(Actor pActor)
public class BehAffectDreams : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private Actor getRandomDreamingActor(Actor pActor)
namespace ai.behaviours;
public class BehAngleAnimation : BehaviourActionActor
	private AngleAnimationTarget _target;
	private float _timer_action;
	private float _angle;
	private string _sound_event_id;
	private bool _check_flip;
	public BehAngleAnimation(AngleAnimationTarget pTarget, string pSound = null, float pTimerAction = 0f, float pAngle = 40f, bool pCheckFlip = true, bool pLandIfHovering = false)
		_sound_event_id = pSound;
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		if (!string.IsNullOrEmpty(_sound_event_id))
namespace ai.behaviours;
public class BehAnimalBreedingTime : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehAnimalCheckHungry : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehAnimalFindTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
			using IEnumerator<Actor> enumerator = Finder.findSpeciesAroundTileChunk(pActor.current_tile, "druid").GetEnumerator();
			if (enumerator.MoveNext())
				Actor current = enumerator.Current;
namespace ai.behaviours;
public class BehAntSetup : BehaviourActionActor
	private static string[] _ant_tile_types = new string[8] { "deep_ocean", "close_ocean", "shallow_waters", "sand", "soil_low", "soil_high", "hills", "mountains" };
	public override BehResult execute(Actor pActor)
		if (string.IsNullOrEmpty(pResult))
	public static string getRandomTileType(string pExclude = null)
		string random = _ant_tile_types.GetRandom();
namespace ai.behaviours;
public class BehAntSwitchGround : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehAttackActorHuntingTarget : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehaviourActionActor : BehaviourActionBase<Actor>
	public bool null_check_city;
	public bool null_check_kingdom;
	public bool null_check_tile_target;
	public bool null_check_building_target;
	public bool null_check_actor_target;
	public bool check_building_target_non_usable;
	public bool land_if_hovering;
	internal bool special_prevent_can_be_attacked;
	internal string force_animation_id = string.Empty;
	internal bool force_animation;
	internal bool socialize;
	protected static List<Actor> temp_actors = new List<Actor>();
	protected static List<WorldTile> possible_moves = new List<WorldTile>();
	public bool calibrate_target_position;
	public float check_actor_target_position_distance;
	public BehResult forceTask(Actor pActor, string pTask, bool pClean = true, bool pForceAction = false)
	public BehResult forceTaskImmediate(Actor pActor, string pTask, bool pClean = true, bool pForceAction = false)
	public override bool errorsFound(Actor pObject)
	public static void clear()
public class BehaviourActionBase<T> : BehaviourElementAI
	public bool uses_kingdoms;
	public bool uses_cities;
	public bool uses_books;
	public bool uses_religions;
	public bool uses_languages;
	public bool uses_cultures;
	public bool uses_clans;
	public bool uses_plots;
	public bool uses_families;
	protected bool _has_error_check;
	protected static MapBox world => MapBox.instance;
	public override void create()
	public virtual void prepare(T pObject)
	public virtual BehResult startExecute(T pObject)
	public virtual BehResult execute(T pObject)
	protected virtual void setupErrorChecks()
	private void setHasErrorCheck()
	public virtual bool errorsFound(T pObject)
	public virtual bool shouldRetry(T pObject)
public class BehaviourActionCity : BehaviourActionBase<City>
	public override bool errorsFound(City pCity)
	protected override void setupErrorChecks()
public class BehaviourActionKingdom : BehaviourActionBase<Kingdom>
	protected override void setupErrorChecks()
public class BehaviourActionTester : BehaviourActionBase<AutoTesterBot>
	public bool null_check_tile_target;
	public override bool errorsFound(AutoTesterBot pObject)
public class BehaviourActorCondition : BehaviourBaseCondition<Actor>
	public override bool check(Actor pActor)
public abstract class BehaviourBaseCondition<T>
	public virtual bool check(T pObject)
public class BehaviourCityCondition : BehaviourBaseCondition<City>
	public override bool check(City pCity)
public class BehaviourElementAI : Asset
	internal RateCounter rate_counter_calls;
	internal RateCounter rate_counter_performance;
	public override void create()
public class BehaviourKingdomCondition : BehaviourBaseCondition<Kingdom>
	public override bool check(Kingdom pKingdom)
namespace ai.behaviours;
public class BehaviourTaskActor : BehaviourTaskBase<BehaviourActionActor>
	public bool move_from_block;
	public bool ignore_fight_check;
	public bool in_combat;
	public string force_hand_tool = string.Empty;
	public bool flag_boat_related;
	public bool diet;
	public bool cancellable_by_reproduction;
	public bool cancellable_by_socialize;
	public bool is_fireman;
	public string path_icon = "ui/Icons/iconWarning";
	public bool show_icon;
	public float speed_multiplier = 1f;
	public UnitHandToolAsset cached_hand_tool_asset;
	private Sprite _cached_sprite;
	protected override string locale_key_prefix => "task_unit";
	public Sprite getSprite()
	public void setIcon(string pPath)
namespace ai.behaviours;
public class BehaviourTaskActorLibrary : AssetLibrary<BehaviourTaskActor>
	public override void init()
		for (int i = 0; i < 5; i++)
		for (int j = 0; j < 6; j++)
		t.setIcon("ui/Icons/iconPrinterStar");
		t.addBeh(new BehPrinterSetup());
		t.setIcon("ui/Icons/iconPrinterStar");
		t.addBeh(new BehPrinterStep());
		for (int k = 0; k < 3; k++)
		for (int l = 0; l < 3; l++)
		for (int m = 0; m < 7; m++)
		for (int num2 = 0; num2 < 3; num2++)
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Ruin, "event:/SFX/CIVILIZATIONS/CleanRuins", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
		for (int num3 = 0; num3 < 5; num3++)
		t.addBeh(new BehCheckStillUnderConstruction());
		t.addBeh(new BehFindConstructionTile());
		for (int num4 = 0; num4 < 5; num4++)
			t.addBeh(new BehCheckStillUnderConstruction());
			t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, "event:/SFX/BUILDINGS/onstructionBuildingGeneric", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
		for (int num5 = 0; num5 < 3; num5++)
		t.addBeh(new BehAngleAnimation(AngleAnimationTarget.Tile, "event:/SFX/CIVILIZATIONS/BuildRoad", 0f, 40f, pCheckFlip: true, pLandIfHovering: true));
		for (int num6 = 0; num6 < 4; num6++)
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/CollectFruits"));
		for (int num7 = 0; num7 < 4; num7++)
		for (int num8 = 0; num8 < 21; num8++)
		for (int num9 = 0; num9 < 4; num9++)
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/CollectHerbs"));
		for (int num10 = 0; num10 < 7; num10++)
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/ChopTree"));
		for (int num11 = 0; num11 < 6; num11++)
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/MiningMineral"));
		for (int num12 = 0; num12 < 6; num12++)
		for (int num13 = 0; num13 < 4; num13++)
		for (int num14 = 0; num14 < 3; num14++)
		t.addBeh(new BehResourceGatheringAnimation(0f, "event:/SFX/CIVILIZATIONS/HarvestCrops"));
		for (int num15 = 0; num15 < 5; num15++)
		for (int num16 = 0; num16 < 5; num16++)
		for (int num17 = 0; num17 < 5; num17++)
	private void initTasksThinkingReflectionHappiness()
		for (int i = 0; i < 2; i++)
		for (int j = 0; j < 4; j++)
		for (int l = 0; l < 5; l++)
		for (int n = 0; n < 4; n++)
		for (int num2 = 0; num2 < 4; num2++)
		for (int num4 = 0; num4 < 6; num4++)
		for (int num5 = 0; num5 < 2; num5++)
		for (int num6 = 0; num6 < 2; num6++)
	private void initTasksClanLeader()
	private void initTasksPoop()
		for (int i = 0; i < 1; i++)
		for (int k = 0; k < 4; k++)
	private void initTasksSleep()
	private void initTasksKings()
	private void initTasksWarriors()
		for (int i = 0; i < 10; i++)
	private void initTasksLeaders()
	private void initTasksStatusRelated()
		for (int i = 0; i < 6; i++)
		for (int j = 0; j < 6; j++)
		for (int k = 0; k < 12; k++)
	private void initTasksMobs()
		for (int i = 0; i < 10; i++)
		for (int j = 0; j < 4; j++)
		for (int k = 0; k < 4; k++)
		for (int l = 0; l < 4; l++)
		for (int m = 0; m < 4; m++)
		for (int n = 0; n < 4; n++)
		for (int num = 0; num < 4; num++)
		for (int num2 = 0; num2 < 4; num2++)
		for (int num3 = 0; num3 < 4; num3++)
		for (int num4 = 0; num4 < 4; num4++)
		for (int num5 = 0; num5 < 4; num5++)
		t.addBeh(new BehFindDesireWaypoint());
		for (int num6 = 0; num6 < 4; num6++)
	private void initTasksFingers()
		for (int i = 0; i < 6; i++)
	private void initTasksDragons()
	private void initTasksUFOs()
	private void initTasksBoats()
	private void initTasksReproductionAsexual()
		for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		for (int k = 0; k < 4; k++)
		for (int l = 0; l < 4; l++)
		for (int m = 0; m < 4; m++)
		for (int n = 0; n < 4; n++)
	private void initTasksReproductionSexual()
		for (int i = 0; i < 6; i++)
		for (int j = 0; j < 5; j++)
		for (int k = 0; k < 5; k++)
	private void initTasksChildren()
		for (int i = 0; i < 4; i++)
		for (int j = 0; j < 2; j++)
	private void initTasksSubspeciesTraits()
		for (int i = 0; i < 4; i++)
	private void initTasksSocializing()
	private void addActionsForDeliverResources(BehaviourTaskActor pTask, bool pWheatStorage = false)
		pTask.addBeh(new BehAngleAnimation(AngleAnimationTarget.Building, string.Empty, 0.1f, 20f));
	public override void linkAssets()
	public override void editorDiagnosticLocales()
public class BehaviourTaskBase<T> : BehaviourElementAI, ILocalizedAsset where T : BehaviourElementAI
	public float single_interval = 1f;
	public float single_interval_random;
	public List<T> list = new List<T>();
	public T task_verifier;
	public bool has_verifier;
	public string locale_key = string.Empty;
	public bool debug_flag;
	protected virtual bool has_locales => true;
	protected virtual string locale_key_prefix
	public BehaviourTaskBase()
	public T get(int pIndex)
	public string getLocaleID()
		if (string.IsNullOrEmpty(locale_key))
	public string getLocalizedText()
	public void addRepeatActions(int pIndexAmount, int pHowManyTimes)
		int count = this.list.Count;
		for (int i = 0; i < pHowManyTimes; i++)
	public void addBeh(T pAction)
	public void addTaskVerifier(T pAction)
public class BehaviourTaskCity : BehaviourTaskBase<BehaviourActionCity>
	protected override string locale_key_prefix => "task_city";
	protected override bool has_locales => false;
	public void executeAllActionsForCity(City pCity)
		for (int i = 0; i < list.Count; i++)
namespace ai.behaviours;
public class BehaviourTaskCityLibrary : AssetLibrary<BehaviourTaskCity>
	public override void init()
			id = "check_destruction",
		t.addBeh(new CityBehCheckDestruction());
	public override void editorDiagnosticLocales()
public class BehaviourTaskKingdom : BehaviourTaskBase<BehaviourActionKingdom>
	protected override string locale_key_prefix => "task_kingdom";
	protected override bool has_locales => false;
namespace ai.behaviours;
public class BehaviourTaskKingdomLibrary : AssetLibrary<BehaviourTaskKingdom>
	public override void init()
	public override void editorDiagnosticLocales()
public class BehaviourTaskTester : BehaviourTaskBase<BehaviourActionTester>
	protected override bool has_locales => false;
	protected override string locale_key_prefix => "task_tester";
public class BehaviourTesterCondition : BehaviourBaseCondition<AutoTesterBot>
namespace ai.behaviours;
public class BehBeeCheckHome : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBeeCheckNoHome : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBeeCheckReturnHome : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBeeCreateHive : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	public static bool isAnotherBeehiveNearby(Actor pActor)
namespace ai.behaviours;
public class BehBeeJoinHive : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBeeReturnHome : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBlackAntBuildIsland : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private static int getRandomDirection()
namespace ai.behaviours;
public class BehBlackAntBuildSand : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private static int getRandomDirection()
namespace ai.behaviours;
public class BehBlueAntSwitchGround : BehaviourActionActor
	private const string tileType1 = "sand";
	private const string tileType2 = "shallow_waters";
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoat : BehaviourActionActor
	internal Boat boat;
	internal void checkHomeDocks(Actor pActor)
	public override void prepare(Actor pActor)
	public override BehResult execute(Actor pActor)
public class BehBoatCheckExistence : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatCheckFishingRepeat : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatCheckHomeDocks : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatCheckLimit : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatCollectFish : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatDamageCheck : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatDangerCheck : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFindOceanNeutralTile : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFindRequest : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFindTargetForTrade : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFindTileInDock : BehBoat
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFindWaterTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatFishing : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	public void spawnFishnet(Actor pActor)
namespace ai.behaviours;
public class BehBoatMakeTrade : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatRemoveIfLimit : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatSetHomeDockTarget : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatTransportCheck : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatTransportDoLoading : BehBoat
	public override BehResult execute(Actor pActor)
		bool flag = true;
namespace ai.behaviours;
public class BehBoatTransportFindTilePickUp : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatTransportFindTileUnload : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBoatTransportUnloadUnits : BehBoat
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBuildingTargetHome : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehBuildingTargetLoverHome : BehCityActor
	public override BehResult execute(Actor pActor)
	private Building getLoverHomeBuilding(Actor pActor1, Actor pActor2)
namespace ai.behaviours;
public class BehBuildTarget : BehActorUsableBuildingTarget
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		if (!pActor.beh_building_target.isUnderConstruction())
		if (pActor.beh_building_target.updateBuild(pActor.getConstructionSpeed()))
namespace ai.behaviours;
public class BehBurnTumorTiles : BehaviourActionActor
	private static List<WorldTile> tiles = new List<WorldTile>();
	public override BehResult execute(Actor pActor)
	public void checkRegion(MapRegion pRegion, List<WorldTile> pTiles)
		for (int i = 0; i < list.Count; i++)
public class BehChangeCityActorCulture : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehChangeCityActorLanguage : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehChangeCityActorReligion : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehChangeKingdomCulture : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehChangeKingdomLanguage : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehChangeKingdomReligion : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckBuddingReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckBuildCity : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckCanRepairEquipment : BehCityActor
	public override BehResult execute(Actor pActor)
		bool flag = false;
namespace ai.behaviours;
public class BehCheckCityActorArmyGroup : BehCitizenActionCity
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckCityActorWarriorLimit : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckCityDestroyed : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckCure : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckCuriosityTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		float num = 0.6f;
public class BehCheckDivineReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckEndCityActorJob : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = pActor.city.jobs.countOccupied(citizen_job);
		int num2 = pActor.city.jobs.countCurrentJobs(citizen_job);
public class BehCheckEnemyNotNear : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckFissionReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckForBabiesFromSexualReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private void checkForBabies(Actor pParentA, Actor pParentB)
	private void checkFamily(Actor pActor, Actor pLover)
		bool flag = false;
namespace ai.behaviours;
public class BehCheckForLover : BehCitizenActionCity
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
public class BehCheckHasMoneyForCityFood : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehCheckHasResources : BehaviourActionActor
	public override BehResult execute(Actor pObject)
namespace ai.behaviours;
public class BehCheckIfInLiquid : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckIfOnGround : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckIfOnSmallLand : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckNearActorTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckNeeds : BehCityActor
	private int _max_restarts;
	public BehCheckNeeds(int pRestarts)
	public override BehResult execute(Actor pActor)
public class BehCheckParthenogenesisReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckPlot : BehCheckPlotBase
	public override BehResult execute(Actor pActor)
public class BehCheckPlotBase : BehaviourActionActor
	public override bool shouldRetry(Actor pActor)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	protected bool isBasePlotCheckOk(Actor pActor)
public class BehCheckPlotIsOk : BehCheckPlotBase
	public override BehResult execute(Actor pActor)
public class BehCheckPlotProgress : BehCheckPlotBase
	public override BehResult execute(Actor pActor)
		plot.updateProgressTarget(pActor, pActor.stats["intelligence"]);
public class BehCheckReproductionBasics : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckSameCityActorLover : BehCitizenActionCity
	public override bool errorsFound(Actor pObject)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckSexualReproductionCiv : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckSexualReproductionOutside : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	internal bool tryStartBreeding(Actor pActor, Actor pLover)
public class BehCheckSoulBorneReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckSporeReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehCheckStartCivilization : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCheckStillUnderConstruction : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		if (!pActor.beh_building_target.isUnderConstruction())
public class BehCheckVegetativeReproduction : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehChildFindRandomFamilyParent : BehaviourActionActor
	public override BehResult execute(Actor pBabyActor)
namespace ai.behaviours;
public class BehCitizenActionCity : BehCityActor
	protected override void setupErrorChecks()
namespace ai.behaviours;
public class BehCityActor : BehaviourActionActor
	protected override void setupErrorChecks()
namespace ai.behaviours;
public class BehCityActorCheckAttack : BehCityActor
	public override BehResult execute(Actor pActor)
	private bool isAttackingZoneAvailable(Actor pActor, TileZone pAttackZone, City pAttackCity)
namespace ai.behaviours;
public class BehCityActorCreateRoad : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFertilizeCrop : BehActorUsableBuildingTarget
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFindBuilding : BehCityActor
	private string _type;
	private string[] _types;
	private bool _only_free_tile;
	public BehCityActorFindBuilding(string pType, bool pFreeTile = true)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFindClosestFire : BehCityActor
	public override BehResult execute(Actor pActor)
	private static WorldTile getClosestTileOnFireFromZones(Actor pActor)
	private static WorldTile getClosestTileOnFire(WorldTile[] pArray, WorldTile pTarget)
		int num = pArray.Length;
		int num2 = int.MaxValue;
		for (int i = 0; i < num; i++)
	public static WorldTile raycastTileForUnitToFightFire(WorldTile pActorTile, WorldTile pTargetFire)
		float num = float.MaxValue;
		for (int i = 0; i < list.Count; i++)
namespace ai.behaviours;
public class BehCityActorFindFireZone : BehCityActor
	public override BehResult execute(Actor pActor)
	private static TileZone getCityZoneNearFire(Actor pActor)
		int num = int.MaxValue;
		for (int i = 0; i < listPool.Count; i++)
	public static WorldTile getClosestTileNotOnFire(WorldTile[] pArray, WorldTile pTarget)
		int num = pArray.Length;
		int num2 = int.MaxValue;
		for (int i = 0; i < num; i++)
namespace ai.behaviours;
public class BehCityActorFindNewJob : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFindStorage : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFindStorageWheat : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorFindUngrownCrop : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehCityActorGetRandomBorderTile : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorGetRandomDangerZone : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
namespace ai.behaviours;
public class BehCityActorGetRandomIdleTile : BehCityActor
	public override BehResult execute(Actor pActor)
	private WorldTile getRandomCityZoneTile(Actor pActor)
	private WorldTile tryToGetBonfireTile(Actor pActor)
namespace ai.behaviours;
public class BehCityActorGetRandomZoneTile : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorGetResourceFromStorage : BehCityActor
	private string _resource_id;
	private int _amount;
	public BehCityActorGetResourceFromStorage(string pResourceId, int pAmount)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehCityActorRemoveFire : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private void putOutFireForTile(WorldTile pTile, bool pForceEffect = false)
		bool flag = false;
namespace ai.behaviours;
public class BehCityActorWarriorTaxiCheck : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehClaimZoneForCityActorBorder : BehCityActor
	public override BehResult execute(Actor pActor)
	public static BehResult tryClaimZone(Actor pActor)
		bool flag = pActor.hasCultureTrait("expansionists") || DebugConfig.isOn(DebugOption.CityFastZonesGrowth);
		bool num = zone.city != null && zone.city != city;
public class BehClanChiefCheckMembersToBanish : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < clan.units.Count; i++)
public class BehClanChiefCheckMembersToKill : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < clan.units.Count; i++)
namespace ai.behaviours;
public class BehConsumeActorsBloodTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private void consume(Actor pMain, Actor pTarget)
namespace ai.behaviours;
public class BehConsumeActorTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private void consume(Actor pMain, Actor pTarget)
namespace ai.behaviours;
public class BehConsumeGrass : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehConsumeTargetBuilding : BehActorUsableBuildingTarget
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehConsumeTargetTile : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
public class BehCopyAggro : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private void copyEnemiesOf(Actor pCopyTo, Actor pTarget)
namespace ai.behaviours;
public class BehCrabBurrow : BehaviourActionActor
	protected override void setupErrorChecks()
		special_prevent_can_be_attacked = true;
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDealDamageToTargetBuilding : BehaviourActionActor
	private const float DAMAGE_MULTIPLIER = 0.1f;
	private float _min;
	private float _max;
	public BehDealDamageToTargetBuilding(float pMinMultiplier, float pMaxMultiplier)
	public override BehResult execute(Actor pActor)
		float num = Randy.randomFloat(_min, _max);
		int num2 = (int)Mathf.Max(pActor.stats["damage"] * num, 1f);
public class BehDecideWhereToPoop : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehDecideWhereToSleep : BehaviourActionActor
	public override BehResult execute(Actor pObject)
public class BehDoTalk : BehaviourActionActor
	public BehDoTalk()
	public override BehResult execute(Actor pActor)
		if ((!pActor.hasTelepathicLink() || !actor.hasTelepathicLink()) && (float)Toolbox.SquaredDistTile(actor.current_tile, pActor.current_tile) > 16f)
		int num = Randy.randomInt(5, 10);
	private bool stillCanTalk(Actor pTarget)
	private void continueTalk(Actor pActor, Actor pTarget)
		bool flag = false;
		float num = 10f;
namespace ai.behaviours;
public class BehDragon : BehaviourActionActor
	internal Dragon dragon;
	public override void prepare(Actor pActor)
namespace ai.behaviours;
public class BehDragonCantLand : BehaviourActionActor
	private string task_id;
	public BehDragonCantLand(string pNextAction)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonCheckAttackCity : BehDragon
	public override BehResult execute(Actor pActor)
		bool flag = true;
namespace ai.behaviours;
public class BehDragonCheckAttackTargetAlive : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonCheckAttackTile : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonCheckOverTargetActor : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonCheckOverTargetCity : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonFindRandomTile : BehaviourActionActor
	public unsafe override BehResult execute(Actor pActor)
		int num = 5;
namespace ai.behaviours;
public class BehDragonFinishAnimation : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonFlyUp : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonIdle : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonLandAttack : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonLanded : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonSetAnimation : BehDragon
	private DragonState state;
	private bool looped;
	private bool forceRestart;
	public BehDragonSetAnimation(DragonState pState, bool pLooped = true, bool pForceRestart = true)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonSleep : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonSleepy : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonSlide : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehDragonZombieFindGoldenBrain : BehDragon
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehEndJob : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehExitBuilding : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehExtractResourcesFromBuilding : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFamilyAlphaMove : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private Building getNearbyBuildings(WorldTile pTile)
		float num = float.MaxValue;
	private Actor getNearbyActor(Actor pActor, WorldTile pTile)
		float num = float.MaxValue;
	private WorldTile findTileForHerbivore(Actor pActor)
	private WorldTile findTileForCarnivore(Actor pActor)
public class BehFamilyCheckMembers : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFamilyFollowAlpha : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFamilyGroupJoin : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFamilyGroupLeave : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFamilyGroupNew : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	public Actor getNearbySameSpecies(Actor pActor, ActorAsset pUnitAsset, WorldTile pTile)
namespace ai.behaviours;
public class BehFightCheckEnemyIsOk : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		int x = pActor.chunk.x;
		int y = pActor.chunk.y;
		int x2 = pActor.attack_target.chunk.x;
		int y2 = pActor.attack_target.chunk.y;
		float num = 1f;
		if (Toolbox.Dist(x, y, x2, y2) >= (float)SimGlobals.m.unit_chunk_sight_range + num)
namespace ai.behaviours;
public class BehFindBuilding : BehaviourActionActor
	private readonly bool _only_non_targeted;
	private readonly bool _only_with_resources;
	private readonly string _type;
	public BehFindBuilding(string pType, bool pOnlyNonTargeted, bool pOnlyWithResources)
	public override BehResult execute(Actor pActor)
	private Building findBuildingType(Actor pActor, string pType)
namespace ai.behaviours;
public class BehFindBuildingWithFood : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindConstructionTile : BehActorBuildingTarget
	public override BehResult execute(Actor pActor)
		pActor.beh_tile_target = pActor.beh_building_target.getConstructionTile();
namespace ai.behaviours;
public class BehFindDesireWaypoint : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		string building_attractor_id = pActor.kingdom.asset.building_attractor_id;
		if (string.IsNullOrEmpty(building_attractor_id))
namespace ai.behaviours;
public class BehFindFarmField : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
namespace ai.behaviours;
public class BehFindGoldenBrain : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehFindHouse : BehCityActor
	public override BehResult execute(Actor pActor)
			if (!building2.isUnderConstruction() && building2.hasResidentSlots())
	private static Building tryToFindFamilyHouse(Actor pActor)
		int num = 0;
	private static Building checkBuilding(Building pGetHomeBuilding, Family pFamily)
public class BehFindLover : BehaviourActionActor
	public override bool shouldRetry(Actor pActor)
	public override BehResult execute(Actor pActor)
	private Actor findLoverAround(Actor pActor)
	private bool checkIfPossibleLover(Actor pActor, Actor pTarget)
	private Actor checkCityLovers(Actor pActor)
namespace ai.behaviours;
public class BehFindMeatInsectSource : BehFindMeatSource
	public BehFindMeatInsectSource(bool pCheckForFactions = true)
namespace ai.behaviours;
public class BehFindMeatSameSpeciesSource : BehFindMeatSource
	public BehFindMeatSameSpeciesSource(bool pCheckForFactions)
namespace ai.behaviours;
public class BehFindMeatSource : BehaviourActionActor
	private MeatTargetType _meat_target_type;
	private bool _check_for_factions;
	public BehFindMeatSource(MeatTargetType pMeatTargetType = MeatTargetType.Meat, bool pCheckForFactions = true)
	public override BehResult execute(Actor pActor)
	private Actor getClosestMeatActor(Actor pActor)
		bool flag = Randy.randomBool();
		float num = 2.1474836E+09f;
		int pChunkRadius = Randy.randomInt(1, 3);
	private bool isTargetOk(Actor pActor, Actor pTarget)
namespace ai.behaviours;
public class BehFindNearbyPotentialCivCityToJoin : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private static City getCityToJoin(Actor pActor)
	public static City getPotentialCityNearby(WorldTile pFromTile, Actor pActor)
namespace ai.behaviours;
public class BehFindRandomCivBuildingTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindRandomFarmTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehFindRandomFarTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < 5; i++)
public class BehFindRandomFrontTileNearHouse : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
namespace ai.behaviours;
public class BehFindRandomNeighbourTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindRandomTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindRandomTile4Directions : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindRandomTile8Directions : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehFindRandomTileAroundHouse : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehFindRandomTileNearBuildingTarget : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehFindRaycastTileForBuildingTarget : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		float resourceThrowDistance = pActor.getResourceThrowDistance();
		for (int i = 0; i < list.Count; i++)
public class BehFindTantrumTarget : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private Actor getClosestActor(Actor pActor)
		bool pRandom = Randy.randomBool();
		float num = 2.1474836E+09f;
namespace ai.behaviours;
public class BehFindTargetForHunter : BehCityActor
	public override BehResult execute(Actor pActor)
	private Actor getClosestMeatActor(Actor pActor, int pMinAge = 0, bool pCheckSame = false)
public class BehFindTargetToStealFrom : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private Actor getClosestActorWithMoneys(Actor pActor)
		bool pRandom = Randy.randomBool();
		int pChunkRadius = Randy.randomInt(1, 4);
		int num = Randy.randomInt(1, 4);
namespace ai.behaviours;
public class BehFindTile : BehaviourActionActor
	private TileFinderType _type;
	public BehFindTile(TileFinderType pType)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindTileBeach : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private void findEdgesInRegion(MapRegion pRegion)
		int count = edgeTiles.Count;
		int num = Randy.randomInt(0, count);
		for (int i = 0; i < count; i++)
namespace ai.behaviours;
public class BehFindTileForCity : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		float num = float.MaxValue;
		for (int i = 0; i < zones.Count; i++)
namespace ai.behaviours;
public class BehFindTileForEating : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private WorldTile findTileAround(IEnumerable<WorldTile> pList)
namespace ai.behaviours;
public class BehFindTileForFarm : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
namespace ai.behaviours;
public class BehFindTileNearbyGroupLeader : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFindTileWhenOnFire : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private WorldTile findWaterIn(MapChunk pChunk)
namespace ai.behaviours;
public class BehFindWheat : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
namespace ai.behaviours;
public class BehFinger : BehaviourActionActor
	protected GodFinger finger;
	public bool drawing_action;
	public override void prepare(Actor pActor)
namespace ai.behaviours;
public class BehFingerCheckCanDraw : BehFingerDrawAction
	protected override void setupErrorChecks()
namespace ai.behaviours;
public class BehFingerDrawAction : BehFinger
	public bool check_has_target_tiles = true;
	public bool check_current_tile_in_target_tiles = true;
	public bool check_target_tile_in_target_tiles = true;
	protected override void setupErrorChecks()
	public override bool errorsFound(Actor pActor)
namespace ai.behaviours;
public class BehFingerDrawToTileTarget : BehFingerDrawAction
	public BehFingerDrawToTileTarget()
	public override BehResult execute(Actor pActor)
	private static void pickBrush(GodFinger pFinger)
	private static bool brushFilter(BrushData pBrush)
	private static void pickPower(GodFinger pFinger)
		bool drawing_over_ground = pFinger.drawing_over_ground;
		bool drawing_over_water = pFinger.drawing_over_water;
		Dictionary<string, int> dictionary = UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Get();
		Dictionary<TileTypeBase, int> dictionary2 = UnsafeCollectionPool<Dictionary<TileTypeBase, int>, KeyValuePair<TileTypeBase, int>>.Get();
		int num = 0;
		UnsafeCollectionPool<Dictionary<string, int>, KeyValuePair<string, int>>.Release(dictionary);
		UnsafeCollectionPool<Dictionary<TileTypeBase, int>, KeyValuePair<TileTypeBase, int>>.Release(dictionary2);
namespace ai.behaviours;
public class BehFingerFindCloseTile : BehFinger
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFingerFindRandomTile : BehFinger
	private int _range;
	public BehFingerFindRandomTile(int pRange = 75)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFingerFindTarget : BehFinger
	private const float RANDOM_CHANCE_ADD_TILE = 0.65f;
	private const float RANDOM_CHANCE_FIND_PITS = 0.95f;
	private const float RANDOM_CHANCE_FIND_WATER = 0.95f;
	private const float RANDOM_CHANCE_FIND_GROUND = 0.95f;
	private const float RANDOM_CHANCE_USE_CURRENT_ISLAND = 0.6f;
	public override BehResult execute(Actor pActor)
	private FingerTarget fillRandomTiles(WorldTile pTile, HashSet<WorldTile> pTargetTiles)
		float num = BehaviourActionBase<Actor>.world.islands_calculator.groundIslandRatio() * 4f;
		int num2 = TileLibrary.pit_deep_ocean.hashset.Count + TileLibrary.pit_close_ocean.hashset.Count + TileLibrary.pit_shallow_waters.hashset.Count;
	private static FingerTarget getFingerTarget(WorldTile pTile)
	private static void clearTargets(GodFinger pFinger)
namespace ai.behaviours;
public class BehFingerGoToCircleTarget : BehFinger
	private int _min_range;
	private int _max_range;
	public BehFingerGoToCircleTarget(int pMinRange = 20, int pMaxRange = 25)
	public override BehResult execute(Actor pActor)
		int num = Randy.randomInt(_min_range, _max_range);
namespace ai.behaviours;
public class BehFingerGoTowardsTileTarget : BehFinger
	private int _tile_range;
	public BehFingerGoTowardsTileTarget(int pRadiusTileRange = 25)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFingerSetFlying : BehFinger
	private bool _flying;
	private float _height_target = -1f;
	public BehFingerSetFlying(bool pFlying, float pHeightTarget = -1f)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehFingerWaitForFlying : BehFinger
	public override BehResult execute(Actor pActor)
public class BehFinishReading : BehCitizenActionCity
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private void checkBookAttributes(Actor pActor, Book pBook)
	private void checkBookAssetAction(Actor pActor, Book pBook)
	private void checkSpecialBookRewards(Actor pActor, Book pBook)
	private void checkBookValueBonuses(Actor pActor, Book pBook)
		int num = pBook.getHappiness();
		int num2 = pBook.getExperience();
		int mana = pBook.getMana();
	private void checkBookTrait(Actor pActor, Book pBook)
	private void tryToConvertActorToMetaFromBook(Actor pActor, Book pBook)
	private void tryToGetMetaTraitsFromBook(Actor pActor, Book pBook)
	private void tryToGetMetaTraitFromBookCulture(Actor pActor, Book pBook)
	private void tryToGetMetaTraitFromBookLanguage(Actor pActor, Book pBook)
	private void tryToGetMetaTraitFromBookReligion(Actor pActor, Book pBook)
	private void tryToConvertActorToBookReligion(Actor pActor, Book pBook)
	private void tryToConvertActorToBookLanguage(Actor pActor, Book pBook)
	private void tryToConvertActorToBookCulture(Actor pActor, Book pBook)
	private bool hasStylishWritingActor(Actor pActor)
	private bool hasStylishWritingBook(Book pBook)
	private int getStylishWritingValue()
public class BehFinishSinging : BehaviourActionActor
	public override BehResult execute(Actor pObject)
public class BehFinishTalk : BehaviourActionActor
	public BehFinishTalk()
	public override BehResult execute(Actor pActor)
	private bool stillCanTalk(Actor pTarget)
	private void finishTalk(Actor pActor, Actor pTarget)
		bool num = Randy.randomChance(0.7f);
		int pValue = ((!num) ? (-15) : 10);
	private void checkAttribue(Actor pActor, Actor pTarget, string pAttributeID)
	private void checkPassLearningAttributes(Actor pActor, Actor pTarget)
		checkAttribue(pActor, pTarget, "intelligence");
	private void checkMetaSpread(Actor pActor, Actor pTarget)
	private void tryToSpreadCulture(Actor pActor, Actor pTarget)
	private void tryToSpreadLanguage(Actor pActor, Actor pTarget)
	private void tryToSpreadReligion(Actor pActor, Actor pTarget)
	private Religion decideReligion(Actor pActor1, Actor pActor2)
	private Language decideLanguage(Actor pActor1, Actor pActor2)
		int num = 3;
		int num2 = 3;
	private Culture decideCulture(Actor pActor1, Actor pActor2)
		int num = 3;
		int num2 = 3;
	private bool throwDiceForGift(Actor pActor, Actor pTarget)
		bool num = pActor.isRelatedTo(pTarget) || pActor.isImportantTo(pTarget);
		float num2 = 0.2f;
	private void makeGift(Actor pActor, Actor pTarget)
		bool flag = pTarget.tryToAcceptGift(pActor);
		int moneyForGift = pActor.getMoneyForGift();
public class BehGenerateLootFromHouse : BehCityActor
	public override BehResult execute(Actor pActor)
		int loot_generation = homeBuilding.asset.loot_generation;
		int num = 0;
		int num2 = loot_generation + num;
public class BehGetDamaged : BehaviourActionActor
	private int _damage;
	private AttackType _attackType;
	public BehGetDamaged(int pDamage, AttackType pAttackType)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehGetRandomZoneTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehGetResourcesFromMine : BehActorUsableBuildingTarget
	private const string ASSET_FOR_NO_BIOME = "mineral_stone";
	private static List<string> pool_mineral_assets_default = new List<string>();
	public override void create()
	private static void initPool()
	private static void addToPool(string pID, int pAmount, List<string> pPool)
		for (int i = 0; i < pAmount; i++)
	public override BehResult execute(Actor pActor)
	private static BuildingAsset getRandomAssetFromPool(Actor pActor)
		List<string> list = worldTile.Type.biome_asset?.pot_minerals_spawn;
		string random = list.GetRandom();
namespace ai.behaviours;
public class BehGetTargetBuildingMainTile : BehActorBuildingTarget
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehGoOrSwimToTileTarget : BehGoToTileTarget
	protected override void setupErrorChecks()
namespace ai.behaviours;
public class BehGoToActorTarget : BehaviourActionActor
	private GoToActorTargetType _type;
	private bool _path_on_water;
	private bool _check_can_attack_target;
	private bool _check_same_island;
	private bool _check_inside_something;
	public BehGoToActorTarget(GoToActorTargetType pType = GoToActorTargetType.SameTile, bool pPathOnWater = false, bool pCheckCanAttackTarget = false, bool pCalibrateTargetPosition = false, float pCheckDistance = 2f, bool pCheckSameIsland = true, bool pCheckInsideSomething = true)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private WorldTile raycastToTarget(Actor pSelf, BaseSimObject pTarget)
		float attackRangeSquared = pSelf.getAttackRangeSquared();
		for (int i = 0; i < list.Count; i++)
namespace ai.behaviours;
public class BehGoToBuildingTarget : BehActorBuildingTarget
	private bool _path_on_water;
	public BehGoToBuildingTarget(bool pPathOnWater = false)
	public override BehResult execute(Actor pActor)
	internal void goToBuilding(Actor pActor)
namespace ai.behaviours;
public class BehGoToStablePlace : BehaviourActionActor
	private static MapRegion best_region;
	private static int best_fast_dist = int.MaxValue;
	internal static List<KeyValuePair<int, MapRegion>> bestRegions = new List<KeyValuePair<int, MapRegion>>(4);
	internal static WorldTile best_tile = null;
	private const int MAX_DISTANCE = 15;
	public override BehResult execute(Actor pActor)
		best_fast_dist = int.MaxValue;
		for (int i = 0; i < BehaviourActionBase<Actor>.world.islands_calculator.islands.Count; i++)
		bestRegions.RemoveAll((KeyValuePair<int, MapRegion> x) => x.Key - 15 > bestRegions[0].Key);
	private static MapRegion findIslandNearby(Actor pActor)
		(MapChunk[], int) allChunksFromTile = Toolbox.getAllChunksFromTile(pActor.current_tile);
		int item2 = allChunksFromTile.Item2;
		for (int i = 0; i < item2; i++)
	private static bool checkIsland(TileIsland pCurrentIsland, TileIsland pIsland, Actor pActor)
	private static void selectBorderRegionsForComparison(TileIsland pIsland1, TileIsland pIsland2, out HashSet<MapRegion> pOut1, out HashSet<MapRegion> pOut2)
namespace ai.behaviours;
public class BehGoToTileTarget : BehaviourActionActor
	public bool walk_on_water;
	public bool walk_on_blocks;
	public int limit_pathfinding_regions;
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehGreenAntSwitchGround : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		string pType;
namespace ai.behaviours;
public class BehHeal : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehJoinCity : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehJumpingAnimation : BehaviourActionActor
	private float _timer_action;
	private float _timer_jumping;
	public BehJumpingAnimation(float pTimerAction, float pTimerJumpAnimation)
	public override BehResult execute(Actor pActor)
public class BehKingCheckNewCityFoundation : BehaviourActionActor
	private const int MAX_MOVED = 6;
	private List<TileZone> _next_wave = new List<TileZone>();
	private List<TileZone> _wave = new List<TileZone>();
	private HashSet<TileZone> _checked_zones = new HashSet<TileZone>();
	private static Color _color1 = new Color(1f, 0f, 0f, 0.3f);
	private static Color _color2 = new Color(0f, 0f, 1f, 0.3f);
	private static Color _color3 = new Color(1f, 0.92f, 0.016f, 0.3f);
	private static Color _color4 = new Color(0f, 1f, 0f, 0.3f);
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private bool hasCitiesWithoutPopulation(Kingdom pKingdom)
	private void moveSomeUnitsToNewCity(City pNewCity, City pFromCity)
		int num = Mathf.Min(pFromCity.units.Count, 6);
		int num2 = 0;
	private int checkUnitFamilyAndLovers(Actor pActor, City pCity, int pMovedAlready)
		int num = 0;
	private void moveToCity(Actor pActor, City pCity)
	private bool isPossibleToMoveUnitToCity(Actor pUnit, City pCity)
	private TileZone findZoneForExpansion(Actor pActor, ListPool<City> pPossibleCitiesToExpandFrom, out City pCityExpandFrom)
	private TileZone findZoneForCityOnFarIsland(Actor pActor, City pCity)
		int num = int.MaxValue;
	private TileZone findZoneForCityOnTheSameIsland2(Actor pActor, City pMainCity)
		bool flag = DebugConfig.isOn(DebugOption.CitySettleCalc);
		int num = 0;
	private void startWave(int pWave, WorldTile pCityTile, ListPool<TileZone> pGoodZones, Actor pActor)
	private ListPool<City> getCityListForExpansion(Kingdom pKingdom)
	private TileZone findCityForMigration(City pCity)
public class BehLaunchFireworks : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	internal void spawnFireworksByUnit(Actor pActor)
namespace ai.behaviours;
public class BehLookAtBuildingTarget : BehActorBuildingTarget
	private float _timer;
	public BehLookAtBuildingTarget(float pTimer = 0.3f)
	public override BehResult execute(Actor pActor)
public class BehMadnessRandomEmotion : BehaviourActionActor
	private const int STATUS_DURATION = 10;
	public override BehResult execute(Actor pActor)
		using ListPool<string> listPool2 = new ListPool<string>();
		string random2 = listPool2.GetRandom();
namespace ai.behaviours;
public class BehMagicMakeSkeleton : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		int num = 0;
public class BehMakeDecision : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehMakeFarm : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		MusicBox.playSound("event:/SFX/CIVILIZATIONS/MakeFarmField", pActor.beh_tile_target, pGameViewOnly: true, pVisibleOnly: true);
namespace ai.behaviours;
public class BehMakeItem : BehCityActor
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < 5; i++)
namespace ai.behaviours;
public class BehMoveAwayFromBlock : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
	private static WorldTile getBestTileToMove(MapRegion pRegion, Actor pActor)
		int num = int.MaxValue;
	private static bool isGoodTileRegion(MapRegion pRegion, Actor pActor)
namespace ai.behaviours;
public class BehNectarNectarFromFlower : BehActorUsableBuildingTarget
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehPlantCrops : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehPollinate : BehaviourActionActor
	public BehPollinate()
	public override BehResult execute(Actor pActor)
public class BehPoopInside : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		string text = ((!pActor.hasSubspecies()) ? "poop" : pActor.subspecies.getRandomBioProduct());
public class BehPoopOutside : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehPrinterSetup : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehPrinterStep : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		PrintTemplate template = PrintLibrary.getTemplate(pResult);
		for (int i = 0; i < template.steps_per_tick; i++)
	private static void printTile(Actor pActor)
		MusicBox.playSound("event:/SFX/UNIQUE/PrinterStep", pActor.current_tile);
public class BehRandomSocializeTopic : BehaviourActionActor
	private float _timer_min;
	private float _timer_max;
	private float _chance;
	public BehRandomSocializeTopic(float pMinTimer, float pMaxTimer, float pChance)
	public override BehResult execute(Actor pActor)
		float pValue = Randy.randomFloat(_timer_min, _timer_max);
namespace ai.behaviours;
public class BehRandomSwim : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehRandomTeleport : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		bool flag = false;
namespace ai.behaviours;
public class BehRandomWait : BehaviourActionActor
	private float min;
	private float max;
	public BehRandomWait(float pMin = 0f, float pMax = 1f, bool pLand = false)
	public override BehResult execute(Actor pActor)
public class BehReflection : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		int happiness = pActor.getHappiness();
		bool flag = happiness > 50;
		bool flag2 = happiness < -70;
		using ListPool<string> listPool = new ListPool<string>();
		string random = listPool.GetRandom();
	private void fillFromHappinessHistory(Actor pActor, ListPool<string> pPot)
	private void fillFromSuperPositivity(Actor pActor, ListPool<string> pPot)
namespace ai.behaviours;
public class BehRemoveRuins : BehActorBuildingTarget
	public override BehResult execute(Actor pActor)
public class BehRepairEquipment : BehCityActor
	public override BehResult execute(Actor pActor)
		bool flag = false;
namespace ai.behaviours;
public class BehRepairInDock : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		int num = pActor.getMaxHealth() - pActor.getHealth();
		float num2 = num / 25;
		pActor.timer_action = (float)Math.Ceiling(num2);
namespace ai.behaviours;
public class BehRepeatTaskChance : BehaviourActionActor
	private float chance;
	public BehRepeatTaskChance(float pChance = 0.5f)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehReplenishEnergy : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehReplenishNutrition : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehResourceGatheringAnimation : BehaviourActionActor
	private float _timer_action;
	private string _sound_event_id;
	public BehResourceGatheringAnimation(float pTimerAction, string pSound = "", bool pLandIfHovering = true)
		_sound_event_id = pSound;
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		if (!string.IsNullOrEmpty(_sound_event_id))
namespace ai.behaviours;
public class BehRestartTask : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehRestoreStats : BehaviourActionActor
	private readonly float _health;
	private readonly float _mana;
	public BehRestoreStats(float pHealth = 0f, float pMana = 0f)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public enum BehResult
namespace ai.behaviours;
public class BehSandspiderBuildSand : BehGoToTileTarget
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehSandspiderCheckDie : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehSandspiderCheckSand : BehaviourActionActor
	private static List<int> _list_directions = new List<int>(3);
	public override BehResult execute(Actor pActor)
	private static int getNewDirectionIndex(int pOldIndex)
		for (int i = 0; i < Toolbox.directions.Length; i++)
namespace ai.behaviours;
public class BehSetActorSpeed : BehaviourActionActor
	private float speed;
	public BehSetActorSpeed(float pSpeed = 0f)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehSetNextTask : BehaviourActionActor
	private bool _clean;
	private bool _force;
	private string _task_id;
	public BehSetNextTask(string taskID, bool pClean = true, bool pForce = false)
	public override BehResult execute(Actor pActor)
public class BehSexualReproductionTry : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		bool flag = (pActor.hasHouseCityInBordersAndSameIsland() ? true : false);
namespace ai.behaviours;
public class BehShakeBuilding : BehaviourActionActor
	private float _shake_time;
	private float _shake_intensity_x;
	private float _shake_intensity_y;
	public BehShakeBuilding(float pShakeParam = 0.7f, float pIntensityX = 0.04f, float pIntensityY = 0.04f)
		_shake_intensity_x = pIntensityX;
		_shake_intensity_y = pIntensityY;
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		pActor.beh_building_target.startShake(_shake_time, _shake_intensity_x, _shake_intensity_y);
namespace ai.behaviours;
public class BehShortRandomMove : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehSkeletonFindTile : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		using (IEnumerator<Actor> enumerator = Finder.findSpeciesAroundTileChunk(pActor.current_tile, "necromancer").GetEnumerator())
			if (enumerator.MoveNext())
				Actor current = enumerator.Current;
public class BehSocializeStartCheck : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class BehSocializeTalk : BehaviourActionActor
	public BehSocializeTalk()
public class BehSpawnCityBorderEffect : BehaviourActionActor
	private int _amount;
	public BehSpawnCityBorderEffect(int pAmount = 1)
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < _amount; i++)
namespace ai.behaviours;
public class BehSpawnHeartsFromBuilding : BehaviourActionActor
	private float _amount;
	public BehSpawnHeartsFromBuilding(float pAmount = 1f)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	private void spawnHearts(Actor pActor)
		for (int i = 0; (float)i < _amount; i++)
public class BehSpawnHmmEffect : BehaviourActionActor
	private int _amount;
	public BehSpawnHmmEffect(int pAmount = 1)
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < _amount; i++)
public class BehSpawnPlotProgressEffect : BehaviourActionActor
	private int _amount;
	public BehSpawnPlotProgressEffect(int pAmount = 1)
	public override BehResult execute(Actor pActor)
		for (int i = 0; i < _amount; i++)
public class BehSpawnSlashTalkTowardTileTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
public class BehSpawnSlashYellTowardTileTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehSpawnTreeFertilizer : BehaviourActionActor
	private static List<WorldTile> _tiles = new List<WorldTile>();
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehStartShake : BehaviourActionActor
	private float _timer_shake;
	private float _wait_action;
	public BehStartShake(float pTimerShake = 1f, float pTimeWaitAction = 0f)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehStayInBuildingTarget : BehCityActor
	private float min;
	private float max;
	public BehStayInBuildingTarget(float pMin = 0f, float pMax = 1f)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
public class BehStealFromTarget : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		bool flag = false;
		float pWaitTimerForThief = 0.5f;
		float pTargetStunnedTimer = 1f;
		bool pAddAggro = false;
namespace ai.behaviours;
public class BehTaxiCheck : BehCitizenActionCity
	public override BehResult execute(Actor pActor)
		bool flag = false;
namespace ai.behaviours;
public class BehTaxiEmbark : BehCityActor
	public override BehResult execute(Actor pActor)
		bool flag = requestForActor.isBoatNearDock();
		if ((float)Toolbox.SquaredDistTile(boat.actor.current_tile, pActor.current_tile) < 25f || flag)
namespace ai.behaviours;
public class BehTaxiFindShipTile : BehCityActor
	public override BehResult execute(Actor pActor)
				WorldTile constructionTile = homeBuilding.getConstructionTile();
				if (constructionTile != null)
					worldTile = constructionTile.region.tiles.GetRandom();
namespace ai.behaviours;
public class BehTaxiSitInside : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehTeleportHome : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehThrowResourceAnimation : BehCityActor
	private string _resource_id;
	public BehThrowResourceAnimation(string pResourceId)
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		float num = Toolbox.DistTile(pActor.current_tile, beh_building_target.current_tile);
namespace ai.behaviours;
public class BehThrowResources : BehCityActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
		float num = Toolbox.DistTile(pActor.current_tile, beh_building_target.current_tile);
		using (Dictionary<string, ResourceContainer>.Enumerator enumerator = pActor.inventory.getResources().GetEnumerator())
			if (enumerator.MoveNext())
				KeyValuePair<string, ResourceContainer> current = enumerator.Current;
public class BehTryFindTargetWithStatusNearby : BehaviourActionActor
	private string[] _status_ids;
	public BehTryFindTargetWithStatusNearby(params string[] pStatusIDs)
	public override BehResult execute(Actor pActor)
	private Actor getClosestActorWithStatus(Actor pSelf, string[] pStatusIDs)
		bool flag = Randy.randomBool();
		int num = int.MaxValue;
public class BehTryNewPlot : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private void fillRandomPlots(Actor pActor, ListPool<PlotAsset> pPotPlots)
	private void fillPlotsToTry(Actor pActor, List<PlotAsset> pPlotList, ListPool<PlotAsset> pPotPossiblePlots)
		for (int i = 0; i < pPlotList.Count; i++)
	private void startPlotFromTheList(Actor pActor, ListPool<PlotAsset> pPotList)
		for (int i = 0; i < pPotList.Count; i++)
public class BehTrySleep : BehaviourActionActor
	private bool _sleep_outside;
	public BehTrySleep(bool pSleepOutside = false)
	public override BehResult execute(Actor pActor)
		float waitTimer = getWaitTimer(pActor);
	private float getWaitTimer(Actor pActor)
		float num = 0f;
		bool flag = false;
		if (currentAge.flag_winter && subspecies.hasTrait("winter_slumberers"))
public class BehTryToEatCityFood : BehCityActor
	public override BehResult execute(Actor pActor)
		bool flag = !pActor.isFoodFreeForThisPerson();
	private void eatFood(Actor pActor, City pCity, ResourceAsset pFoodItem, bool pNeedToPay)
public class BehTryToRead : BehCityActor
	public override BehResult execute(Actor pActor)
public class BehTryToSocialize : BehaviourActionActor
	public override BehResult execute(Actor pActor)
	private Actor getRandomActorAround(Actor pActor)
		bool flag = pActor.subspecies.needOppositeSexTypeForReproduction();
		bool flag2 = pActor.hasCulture() && pActor.culture.hasTrait("animal_whisperers");
		bool num = pActor.hasTelepathicLink();
		int pChunkRadius = 1;
	private void fillUnitsViaTelepathicLink(Actor pActor, ListPool<Actor> pBestTargets, ListPool<Actor> pNormalTargets)
namespace ai.behaviours;
public class BehUFOBeam : BehaviourActionActor
	private bool enabled;
	public BehUFOBeam(bool pEnabled = false)
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUFOCheckAttackCity : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUFOCheckExplore : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUFOExplore : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUFOFindTarget : BehaviourActionActor
	public unsafe override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUFOSelectTarget : BehaviourActionActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehUnloadResources : BehCityActor
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehVerifierAttackZone : BehCitizenActionCity
	public override BehResult execute(Actor pActor)
namespace ai.behaviours;
public class BehWait : BehaviourActionActor
	private float _wait_interval;
	public BehWait(float pWaitInterval = 1f)
		_wait_interval = pWaitInterval;
	public override BehResult execute(Actor pActor)
		pActor.timer_action = _wait_interval;
namespace ai.behaviours;
public class BehWalkIntoWaterCorner : BehaviourActionActor
	public override BehResult execute(Actor pActor)
		int num = int.MaxValue;
public class BehWarriorCaptainWait : BehCityActor
	public override BehResult execute(Actor pActor)
		int num = 0;
		float num2 = 2f;
		float num3 = (float)num / (float)army.units.Count;
namespace ai.behaviours;
public class BehWormDig : BehaviourActionActor
	protected override void setupErrorChecks()
	public override BehResult execute(Actor pActor)
	public static bool tileFlashWorm(WorldTile pTile, string pPowerID)
	public static bool tileDrawWorm(WorldTile pTile, string pPowerID)
	public static void wormTile(WorldTile pTile)
namespace ai.behaviours;
public class BehWormDigEat : BehaviourActionActor
	private static List<BrushPixelData> myRange = new List<BrushPixelData>();
	public override BehResult execute(Actor pActor)
	public static void checkForWorms(WorldTile pCenterTile, int pBrushSize, Actor pActor)
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < brushData.pos.Length; i++)
	public void loopWithBrush(WorldTile pCenterTile, int pBrushSize, PowerActionWithID pAction, string pPowerID = null)
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < brushData.pos.Length; i++)
	public static void checkWorms(WorldTile pTile, Actor pActor)
		pTile.doUnits(delegate(Actor tActor)
	public static bool tileDrawWorm(WorldTile pTile, string pPowerID)
	private static void spawnBurst(WorldTile pTile, string pType, bool pCreateGround = true)
namespace ai.behaviours;
public class BehWormDive : BehaviourActionActor
	public override BehResult execute(Actor pActor)
public class Bench
	public static bool bench_enabled = false;
	public static bool bench_ai_enabled = false;
	private static Dictionary<string, BenchmarkGroup> dict = new Dictionary<string, BenchmarkGroup>();
	private static float _timer_flatten = 0f;
	public static void update()
	private static void flatten(string pID)
	private static void finishSplitBenchmarkGroupAI()
	private static void finishSplitBenchmarkGroup(string pID)
	public static void saveAverageCounter(string pID, string pGroup)
	public static BenchmarkGroup getGroup(string pID)
	private static ToolBenchmarkData get(string pID, string pGroupID = "main", bool pNew = true)
	public static void clearBenchmarkEntrySkipMultiple(string pGroupID = "main", params string[] pEntries)
		foreach (string pID in pEntries)
	public static void clearBenchmarkEntrySkip(string pID, string pGroupID = "main")
	public static double bench(string pID, string pGroupID = "main", bool pForce = false)
	public static double benchEnd(string pID, string pGroupID = "main", bool pSaveCounter = false, long pCounter = 0L, bool pForce = false)
	public static void benchSet(string pID, double pVal, int pCounter, string pGroupID = "main")
	public static void benchSetValue(string pID, int pValue, string pGroupID = "main")
	public static int getBenchValue(string pID, string pGroupID = "main")
		return (int)get(pID, pGroupID).debug_value;
	public static double benchSave(string pID, double pValue, int pCounter, string pGroupID = "main")
	public static double benchSaveSplit(string pID, double pValue, int pCounter, string pGroupID = "main")
	public static string getBenchResult(string pID, string pGroupID = "main", bool pAverage = true)
	public static double getBenchResultAsDouble(string pID, string pGroupID = "main", bool pAverage = true)
	public static string printableBenchResults(string pGroupID = "main", bool pAverage = false, params string[] pID)
		for (int i = 0; i < pID.Length; i++)
		using ListPool<string[]> listPool = new ListPool<string[]>();
		listPool.Add(new string[5] { "ID", "TIME", "PERCENT", "WINNER", "BAR" });
		listPool.Add(new string[0]);
		for (int j = 0; j < pID.Length; j++)
		return Toolbox.printRows(listPool);
	public static void printBenchResult(string pID, string pGroupID = "main", bool pAverage = false)
		string text = benchResultAsDouble.ToString("##,0.##########");
public static class Benchmark
	public static void benchHashsetStart()
		for (int i = 0; i < 1000; i++)
	public static void benchObjHashsetCreateVsAdd(int pAmount = 3000)
		for (int i = 0; i < pAmount; i++)
		int num = 10;
		for (int j = 0; j < num; j++)
		for (int k = 0; k < num; k++)
	public static void benchObjectsVsData(int pObjects)
		int num2 = pObjects;
		for (int i = 0; i < array.Length; i++)
		for (int j = 0; (double)j < num; j++)
		for (int l = 0; l < array.Length; l++)
		for (int m = 0; (double)m < num; m++)
		for (int num3 = 0; num3 < array.Length; num3++)
		for (int num4 = 0; (double)num4 < num; num4++)
		for (int num6 = 0; num6 < array.Length; num6++)
		for (int num7 = 0; (double)num7 < num; num7++)
		for (int num8 = 0; num8 < array.Length; num8++)
		for (int num9 = 0; (double)num9 < num; num9++)
		for (int num15 = 0; num15 < array.Length; num15++)
		for (int num16 = 0; (double)num16 < num; num16++)
	private static string getResult(Stopwatch p1, Stopwatch p2, double pTries)
	public static void benchNativeECSAndOOP()
		int num = 200000;
		NativeArray<int> val2 = default(NativeArray<int>);
		NativeArray<int> val3 = default(NativeArray<int>);
		NativeArray<int> val4 = default(NativeArray<int>);
		for (int i = 0; i < num; i++)
		for (int j = 0; j < num; j++)
		for (int k = 0; k < num; k++)
		for (int l = 0; l < num; l++)
		for (int m = 0; m < num; m++)
		for (int n = 0; n < num; n++)
		for (int num2 = 0; num2 < num; num2++)
		for (int num3 = 0; num3 < num; num3++)
		for (int num4 = 0; num4 < num; num4++)
	public static void benchReferenceVsDict()
	public static void testVirtual()
		int num = 1000;
		for (int i = 0; i < num; i++)
		for (int j = 0; j < num; j++)
	public static void testQueue()
		int num = 10000;
		for (int i = 0; i < num; i++)
		for (int j = 0; j < list.Count; j++)
		for (int k = 0; k < queue.Count; k++)
		for (int l = 0; l < linkedList.Count; l++)
		Bench.printBenchResult("list");
		Bench.printBenchResult("queue");
		Bench.printBenchResult("linked");
	public static void testRemoveStructs()
		int num = 100;
		int num2 = 500;
		for (int i = 0; i < num2; i++)
		for (int j = 0; j < num; j++)
		for (int k = 0; k < num; k++)
		for (int l = 0; l < num; l++)
		for (int m = 0; m < num; m++)
	public static void testCapacity()
		int num = 100;
		int num2 = 100000;
		List<List<int>> list = new List<List<int>>(num);
		for (int i = 0; i < num; i++)
		for (int k = 0; k < list.Count; k++)
		list = new List<List<int>>(num);
		for (int m = 0; m < num; m++)
		for (int num3 = 0; num3 < list.Count; num3++)
		Bench.printBenchResult("new_list");
		Bench.printBenchResult("new_list_set_capacity");
		Bench.printBenchResult("new_list_reused");
		Bench.printBenchResult("new_list_set_capacity_reused");
public static class BenchmarkBlacklist
	private static List<WorldTile> _test_world_tiles = new List<WorldTile>();
	private static HashSet<WorldTile> _test_hashset = new HashSet<WorldTile>();
	private static WorldTile[] _test_world_tiles_arr;
	private static List<string> _names = new List<string>();
	private static HashSet<string> _names_set = new HashSet<string>();
	private static int _runs = 0;
	private static int _max = 250;
	private static HashSet<string> _good_words = new HashSet<string>();
	private static HashSet<string> _bad_words = new HashSet<string>();
	private static HashSet<string> _result_good_words = new HashSet<string>();
	private static HashSet<string> _result_bad_words = new HashSet<string>();
	public static void start()
		int num = 0;
		for (int k = 0; k < _names.Count; k++)
		int num2 = 0;
		for (int l = 0; l < _names.Count; l++)
		int num3 = 0;
		for (int m = 0; m < _names.Count; m++)
		int num4 = 0;
		for (int n = 0; n < _names.Count; n++)
		int num5 = 0;
		for (int num6 = 0; num6 < _names.Count; num6++)
		int num7 = 0;
		for (int num8 = 0; num8 < _names.Count; num8++)
		int num9 = 0;
		for (int num10 = 0; num10 < _names.Count; num10++)
		int num11 = 0;
		for (int num12 = 0; num12 < _names.Count; num12++)
		int num13 = 0;
		for (int num14 = 0; num14 < _names.Count; num14++)
		int num15 = 0;
		for (int num16 = 0; num16 < _names.Count; num16++)
		int num17 = 0;
		for (int num18 = 0; num18 < _names.Count; num18++)
		int num19 = 0;
		for (int num20 = 0; num20 < _names.Count; num20++)
	public static void checkResult(string pBenchmarkName)
public class BenchmarkDist
	public long result;
	internal string benchmark_group_id;
	internal string benchmark_id;
	internal List<WorldTile> test_tiles;
	internal bool print_to_console;
	private static BenchmarkDist _instance;
	public BenchmarkDist()
	public static void update()
	public void setup()
	public void run()
		string pGroupID = benchmark_group_id;
		string text = benchmark_id;
		int num = 0;
		int num3 = -1;
		int num4 = int.MaxValue;
		float num5 = float.MaxValue;
		int2[] array = (int2[])(object)new int2[list.Count];
		for (int i = 0; i < list.Count; i++)
		float2[] array2 = (float2[])(object)new float2[list.Count];
		for (int j = 0; j < list.Count; j++)
		NativeArray<int2> val = default(NativeArray<int2>);
		NativeArray<float2> val2 = default(NativeArray<float2>);
		int2 val3 = default(int2);
		((int2)(ref val3))._002Ector(worldTile.x, worldTile.y);
		float2 val4 = default(float2);
		((float2)(ref val4))._002Ector((float)worldTile.x, (float)worldTile.y);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int k = 1; k < list.Count; k++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int l = 1; l < list.Count; l++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int m = 1; m < list.Count; m++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int n = 1; n < list.Count; n++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num10 = 1; num10 < list.Count; num10++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num12 = 1; num12 < list.Count; num12++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num14 = 1; num14 < list.Count; num14++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num16 = 1; num16 < list.Count; num16++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num18 = 1; num18 < list.Count; num18++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num20 = 1; num20 < list.Count; num20++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num22 = 1; num22 < list.Count; num22++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num24 = 1; num24 < list.Count; num24++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		for (int num26 = 1; num26 < list.Count; num26++)
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("float2", text);
		float2 val5 = default(float2);
		for (int num28 = 1; num28 < list.Count; num28++)
		Bench.benchEnd("float2", text, pSaveCounter: true, list[num3].tile_id);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("int2", text);
		int2 val6 = default(int2);
		for (int num30 = 1; num30 < list.Count; num30++)
		Bench.benchEnd("int2", text, pSaveCounter: true, list[num3].tile_id);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("int2array", text);
		for (int num32 = 1; num32 < array.Length; num32++)
		Bench.benchEnd("int2array", text, pSaveCounter: true, list[num3].tile_id);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("nint2array", text);
		for (int num34 = 1; num34 < val2.Length; num34++)
		Bench.benchEnd("nint2array", text, pSaveCounter: true, list[num3].tile_id);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("float2array", text);
		for (int num36 = 1; num36 < array2.Length; num36++)
		Bench.benchEnd("float2array", text, pSaveCounter: true, list[num3].tile_id);
		num4 = int.MaxValue;
		num5 = float.MaxValue;
		Bench.bench("nfloat2array", text);
		for (int num38 = 1; num38 < val.Length; num38++)
		Bench.benchEnd("nfloat2array", text, pSaveCounter: true, list[num3].tile_id);
		if (print_to_console)
	public static float DistFloat(float x1, float y1, float x2, float y2)
	public static float FastDistFloat(float x1, float y1, float x2, float y2)
public class BenchmarkFieldAccess
	public static void start()
public class BenchmarkGroup
	public string id;
	public Dictionary<string, ToolBenchmarkData> dict_data = new Dictionary<string, ToolBenchmarkData>();
	public void flatten()
public static class BenchmarkGroupID
	public const string main = "main";
	public const string quantum_sprites = "quantum_sprites";
	public const string world_beh = "world_beh";
	public const string zone_camera = "zone_camera";
	public const string zone_camera_total = "zone_camera_total";
	public const string world_cache_manager = "world_cache_manager";
	public const string sim_zones = "sim_zones";
	public const string chunks = "chunks";
	public const string chunks_total = "chunks_total";
	public const string sprites_test = "sprites_test";
	public const string sprites_test_total = "sprites_test_total";
	public const string field_acess_test = "field_acess_test";
	public const string field_acess_total = "field_acess_total";
	public const string borders_renderer = "borders_renderer";
	public const string borders_renderer_total = "borders_renderer_total";
	public const string fluid_zones_data = "fluid_zones_data";
	public const string fluid_zones_data_total = "fluid_zones_data_total";
	public const string game_total = "game_total";
	public const string music_box = "music_box";
	public const string music_box_total = "music_box_total";
	public const string nameplates = "nameplates";
	public const string nameplates_total = "nameplates_total";
	public const string loops_test_10 = "loops_test_10";
	public const string loops_test_100 = "loops_test_100";
	public const string loops_test_1000 = "loops_test_1000";
	public const string loops_test_10000 = "loops_test_10000";
	public const string loops_test_total_10 = "loops_test_total_10";
	public const string loops_test_total_100 = "loops_test_total_100";
	public const string loops_test_total_1000 = "loops_test_total_1000";
	public const string loops_test_total_10000 = "loops_test_total_10000";
	public const string dist_test = "dist_test";
	public const string dist_test_total = "dist_test_total";
	public const string shuffle_test_10 = "shuffle_test_10";
	public const string shuffle_test_100 = "shuffle_test_100";
	public const string shuffle_test_1000 = "shuffle_test_1000";
	public const string shuffle_test_10000 = "shuffle_test_10000";
	public const string shuffle_test_total_10 = "shuffle_test_total_10";
	public const string shuffle_test_total_100 = "shuffle_test_total_100";
	public const string shuffle_test_total_1000 = "shuffle_test_total_1000";
	public const string shuffle_test_total_10000 = "shuffle_test_total_10000";
	public const string loops_struct_test = "loops_struct_test";
	public const string loops_struct_test_total = "loops_struct_test_total";
	public const string decisions_test = "decisions_test";
	public const string decisions_test_total = "decisions_test_total";
	public const string ecs_test = "ecs_test";
	public const string ecs_test_total = "ecs_test_total";
	public const string blacklist_test = "blacklist_test";
	public const string blacklist_test_total = "blacklist_test_total";
	public const string actors = "actors";
	public const string buildings = "buildings";
	public const string effects_items = "effects_items";
	public const string effects_traits = "effects_traits";
	public const string loading = "loading";
	public const string ai_actions = "ai_actions";
	public const string ai_actions_total = "ai_actions_total";
	public const string ai_tasks = "ai_tasks";
	public const string ai_tasks_total = "ai_tasks_total";
public class BenchmarkLoops
	private List<WorldTile> _test_world_tiles = new List<WorldTile>();
	private ListPool<WorldTile> _test_world_tiles_pool;
	private HashSet<WorldTile> _test_hashset = new HashSet<WorldTile>();
	private WorldTile[] _test_world_tiles_arr;
	private List<WorldTile> _new_tiles = new List<WorldTile>();
	private int _runs;
	private bool _counter;
	private int _max_amount;
	private DebugToolAsset _asset;
	internal static Dictionary<string, BenchmarkLoops> _benchmarks = new Dictionary<string, BenchmarkLoops>();
	public BenchmarkLoops(DebugToolAsset pAsset, int pMaxAmount)
	public static void update(DebugToolAsset pAsset)
	public void run()
		string benchmark_group_id = _asset.benchmark_group_id;
		string benchmark_total_group = _asset.benchmark_total_group;
		int count = _test_world_tiles.Count;
		int num = 0;
		for (int j = 0; j < _test_world_tiles.Count; j++)
		for (int k = 0; k < _test_world_tiles_pool.Count; k++)
		for (int l = 0; l < span.Length; l++)
		for (int m = 0; m < test_world_tiles.Count; m++)
		for (int n = 0; n < test_world_tiles_pool.Count; n++)
		for (int num2 = 0; num2 < span2.Length; num2++)
		int count2 = test_world_tiles.Count;
		for (int num3 = 0; num3 < count2; num3++)
		for (int num4 = 0; num4 < count2; num4++)
		for (int num5 = 0; num5 < count2; num5++)
		for (int num6 = 0; num6 < span3.Length; num6++)
		for (int num7 = 0; num7 < span2.Length; num7++)
		for (int num8 = 0; num8 < span4.Length; num8++)
		for (int num6 = 0; num6 < span3.Length; num6++)
		for (int num6 = 0; num6 < span3.Length; num6++)
		for (int num9 = 0; num9 < readOnlySpan.Length; num9++)
		for (int num10 = 0; num10 < readOnlySpan2.Length; num10++)
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		for (int num11 = 0; num11 < _test_world_tiles_arr.Length; num11++)
		for (int num13 = 0; num13 < count2; num13++)
		for (int num6 = 0; num6 < readOnlySpan3.Length; num6++)
		for (int num14 = 0; num14 < readOnlySpan.Length; num14++)
		for (int num6 = 0; num6 < span3.Length; num6++)
		for (int num15 = 0; num15 < span2.Length; num15++)
public class BenchmarkObjects : MonoBehaviour
	public static BenchmarkObjects instance;
	public List<Sprite> some_sprites = new List<Sprite>();
	public TestActorGameObject prefab_unity_object;
	private List<TestActorGameObject> actors_unity = new List<TestActorGameObject>();
	internal List<TestActorSimpleObject> actors_simple = new List<TestActorSimpleObject>();
	internal List<TestActorSimpleObject> actors_simple_visible = new List<TestActorSimpleObject>();
	public int total_unity_objects;
	public int total_simple_objects;
	public int total_simple_objects_visible;
	public BenchmarkObjects()
	private void Update()
	public void addObjectsSimple(int pAmount = 2000)
		for (int i = 0; i < pAmount; i++)
	public void addObjectsUnity(int pAmount = 2000)
		for (int i = 0; i < pAmount; i++)
	public void killAll()
	public void randomRespawn()
	public void update(float pElapsed)
	private void updateKeys()
	private void updateUnityActors(float pElapsed)
		for (int i = 0; i < actors_unity.Count; i++)
	private void updateSimpleActors(float pElapsed)
		Parallel.ForEach(actors_simple, World.world.parallel_options, delegate(TestActorSimpleObject pActor)
	private void updateVisibility(float pElapsed)
		float num = 8f;
		for (int i = 0; i < actors_simple.Count; i++)
public class BenchmarkShuffle
	public int result;
	internal int max_tiles;
	internal int amount;
	internal string benchmark_total_group_id;
	internal string benchmark_group_id;
	internal List<WorldTile> test_tiles;
	internal bool print_to_console;
	internal static Dictionary<string, BenchmarkShuffle> _benchmarks = new Dictionary<string, BenchmarkShuffle>();
	public BenchmarkShuffle(DebugToolAsset pAsset, int pAmount, int pMaxTiles)
	public static void update(DebugToolAsset pAsset)
	public void setup()
		int num = max_tiles;
		int num2 = Mathf.CeilToInt(Mathf.Sqrt((float)num));
		for (int i = 0; i < num2; i++)
	public void run()
		int num = amount;
		string pGroupID = benchmark_total_group_id;
		string text = benchmark_group_id;
		int num2 = 0;
		int num3 = 0;
		for (int num4 = num - 1; num4 >= 0; num4--)
		for (int i = 0; i < num; i++)
		for (int j = 0; j < num; j++)
		for (int k = 0; k < num; k++)
		for (int l = 0; l < num; l++)
		int num5 = Randy.randomInt(0, num);
		int num6 = num + num5;
		for (int m = num5; m < num6; m++)
		for (int n = num5; n < num; n++)
		for (int num7 = 0; num7 < num5; num7++)
		if (print_to_console)
public class BenchmarkSprites
	public static void start()
public static class BenchmarkStructLoops
	private static List<WorldTileDataStruct> _test_world_tiles = new List<WorldTileDataStruct>();
	private static ListPool<WorldTileDataStruct> _test_world_tiles_pool;
	private static HashSet<WorldTileDataStruct> _test_hashset = new HashSet<WorldTileDataStruct>();
	private static WorldTileDataStruct[] _test_world_tiles_arr;
	private static int _runs = 0;
	public static void start()
		int count = _test_world_tiles.Count;
		Bench.bench("loops_struct_test", "loops_struct_test_total");
		Bench.bench("list_for", "loops_struct_test");
		int num3 = 0;
		for (int k = 0; k < _test_world_tiles.Count; k++)
		Bench.benchEnd("list_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for", "loops_struct_test");
		for (int l = 0; l < _test_world_tiles_pool.Count; l++)
		Bench.benchEnd("listpool_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for", "loops_struct_test");
		for (int m = 0; m < span.Length; m++)
		Bench.benchEnd("listpool_span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("hashset_foreach", "loops_struct_test");
		Bench.benchEnd("hashset_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_for_local", "loops_struct_test");
		for (int n = 0; n < test_world_tiles.Count; n++)
		Bench.benchEnd("list_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for_local", "loops_struct_test");
		for (int num4 = 0; num4 < test_world_tiles_pool.Count; num4++)
		Bench.benchEnd("listpool_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for_local", "loops_struct_test");
		for (int num5 = 0; num5 < span2.Length; num5++)
		Bench.benchEnd("listpool_span_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_for_local_len", "loops_struct_test");
		int count2 = test_world_tiles.Count;
		for (int num6 = 0; num6 < count2; num6++)
		Bench.benchEnd("list_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_for_local_len", "loops_struct_test");
		for (int num7 = 0; num7 < count2; num7++)
		Bench.benchEnd("listpool_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_for_local_len", "loops_struct_test");
		for (int num8 = 0; num8 < count2; num8++)
		Bench.benchEnd("listpool_span_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("list_foreach", "loops_struct_test");
		Bench.benchEnd("list_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_foreach", "loops_struct_test");
		Bench.benchEnd("listpool_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("listpool_span_foreach", "loops_struct_test");
		for (int num9 = 0; num9 < span3.Length; num9++)
		Bench.benchEnd("listpool_span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for", "loops_struct_test");
		for (int num10 = 0; num10 < _test_world_tiles_arr.Length; num10++)
		Bench.benchEnd("array_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for_local", "loops_struct_test");
		for (int num11 = 0; num11 < test_world_tiles_arr.Length; num11++)
		Bench.benchEnd("array_for_local", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_for_local_len", "loops_struct_test");
		for (int num12 = 0; num12 < count2; num12++)
		Bench.benchEnd("array_for_local_len", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("array_foreach", "loops_struct_test");
		for (int num9 = 0; num9 < test_world_tiles_arr2.Length; num9++)
		Bench.benchEnd("array_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("ro_span_foreach", "loops_struct_test");
		for (int num9 = 0; num9 < readOnlySpan2.Length; num9++)
		Bench.benchEnd("ro_span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("ro_span_for", "loops_struct_test");
		for (int num13 = 0; num13 < readOnlySpan.Length; num13++)
		Bench.benchEnd("ro_span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("span_foreach", "loops_struct_test");
		for (int num9 = 0; num9 < span3.Length; num9++)
		Bench.benchEnd("span_foreach", "loops_struct_test", pSaveCounter: true, count);
		Bench.bench("span_for", "loops_struct_test");
		for (int num14 = 0; num14 < span2.Length; num14++)
		Bench.benchEnd("span_for", "loops_struct_test", pSaveCounter: true, count);
		Bench.benchEnd("loops_struct_test", "loops_struct_test_total", pSaveCounter: false, 0L);
public class BenchObject
	public int derp;
	public void update(float pElapsed)
	public void updateMove(float pElapsed)
public class BenchTest1
	public bool test()
	public virtual bool testVirtual()
public class BenchTest2 : BenchTest1
	public override bool testVirtual()
public class BiomeAsset : Asset, IDescriptionAsset, ILocalizedAsset, IMultiLocalesAsset
	public GrowTypeSelector grow_type_selector_trees;
	public GrowTypeSelector grow_type_selector_plants;
	public GrowTypeSelector grow_type_selector_bushes;
	public GrowTypeSelector grow_type_selector_minerals;
	public List<string> pot_sapient_units_spawn;
	public List<string> pot_units_spawn;
	public List<string> pot_trees_spawn;
	public List<string> pot_plants_spawn;
	public List<string> pot_bushes_spawn;
	public List<string> pot_minerals_spawn;
	public bool grow_vegetation_auto;
	public bool grow_minerals_auto;
	public bool pot_spawn_units_auto;
	public bool cold_biome;
	public bool dark_biome;
	public bool spread_ignore_burned_stages;
	public bool spread_biome;
	public bool spread_by_drops_water;
	public bool spread_by_drops_fire;
	public bool spread_by_drops_curse;
	public bool spread_by_drops_blessing;
	public bool spread_by_drops_powerup;
	public bool spread_by_drops_acid;
	public bool spread_by_drops_coffee;
	public bool special_biome;
	public int grow_strength = 6;
	public string spread_only_in_era;
	public string tile_low;
	public string tile_high;
	private TopTileType _cached_tile_high;
	private TopTileType _cached_tile_low;
	public int generator_pot_amount;
	public int generator_max_size;
	public string localized_key;
	public int loot_generation;
	public string[] subspecies_name_suffix;
	public List<string> spawn_trait_actor;
	public List<string> spawn_trait_subspecies;
	public List<string> spawn_trait_subspecies_always;
	public List<string> spawn_trait_culture;
	public List<string> spawn_trait_clan;
	public List<string> spawn_trait_language;
	public List<string> spawn_trait_religion;
	public List<string> evolution_trait_subspecies;
	public TopTileType getTile(WorldTile pTile)
	public int getTileCount()
	public TopTileType getTileHigh()
	public TopTileType getTileLow()
	public void addTree(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	public void addPlant(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	public void addBush(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	public void addMineral(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	public void addUnit(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	public void addSapientUnit(string pID, int pRateAmount = 1)
		for (int i = 0; i < pRateAmount; i++)
	internal void addActorTrait(string pTrait)
	internal void addSubspeciesTrait(string pTrait)
	internal void addSubspeciesTraitAlways(string pTrait)
	internal void addSubspeciesTraitEvolution(string pTrait)
	internal void addCultureTrait(string pTrait)
	internal void addLanguageTrait(string pTrait)
	internal void addClanTrait(string pTrait)
	internal void addReligionTrait(string pTrait)
	public string getLocaleID()
	public string getDescriptionID()
	public IEnumerable<string> getLocaleIDs()
		if (LocalizedTextManager.stringExists(getLocaleID() + "_seeds"))
public class BiomeLibrary : AssetLibrary<BiomeAsset>
	public static List<BiomeAsset> pool_biomes = new List<BiomeAsset>();
	public override void init()
	public void addNormalBiomes()
		t.addLanguageTrait("nicely_structured_grammar");
		t.addSubspeciesTrait("hyper_intelligence");
		t.addSubspeciesTraitEvolution("mutation_skin_void");
	private void addSpecialBiomes()
	private void addCreepBiomes()
	public override void linkAssets()
	private void addBiomeToPool(BiomeAsset pAsset)
		for (int i = 0; i < pAsset.generator_pot_amount; i++)
	public override void editorDiagnosticLocales()
public enum BiomeTag
public class Blacklist
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();
	private const int INDEX_LENGTH = 3;
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(StringBuilderPool pName)
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
	internal static bool checkBlackList(string pName)
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
public class BlacklistTest
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	public static bool checkBlackList(string pName)
		string text = pName.ToLower();
		Dictionary<char, string[]> profanity = _profanity;
		bool flag = !(readOnlySpan2 == readOnlySpan);
public class BlacklistTest10
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	public static bool checkBlackList(string pName)
		string text = pName.ToLower();
		string text2 = BlacklistTools.cleanString(text);
		bool flag = !(text2 == text);
		Dictionary<char, string[]> profanity = _profanity;
public class BlacklistTest11
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();
	private const int INDEX_LENGTH = 3;
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		int length = readOnlySpan.Length;
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < length - 3 + 1; i++)
		int length2 = readOnlySpan2.Length;
		for (int k = 0; k < length2 - 3 + 1; k++)
public class BlacklistTest12
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();
	private const int INDEX_LENGTH = 3;
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < pText.Length - 3 + 1; i++)
		for (int k = 0; k < pText2.Length - 3 + 1; k++)
public class BlacklistTest13
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();
	private const int INDEX_LENGTH = 3;
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
public class BlacklistTest2
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		string text = pName.ToLower();
		Dictionary<char, string[]> profanity = _profanity;
		string text2 = BlacklistTools.cleanStringAsSpan(text);
		bool flag = !(text2 == text);
public class BlacklistTest3
	private static readonly Dictionary<char, string[]> _profanity = new Dictionary<char, string[]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		string text = pName.ToLower();
		Dictionary<char, string[]> profanity = _profanity;
		bool flag = !(readOnlySpan2 == readOnlySpan);
public class BlacklistTest4
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		string text = pName.ToLower();
		bool flag = !(readOnlySpan2 == readOnlySpan);
public class BlacklistTest5
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		string text = pName.ToLower();
		bool flag = !(readOnlySpan2 == readOnlySpan);
public class BlacklistTest6
	private static readonly Dictionary<char, char[][]> _profanity = new Dictionary<char, char[][]>();
	private static readonly HashSet<char> _unique = new HashSet<char>();
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		string text = pName.ToLower();
		string text2 = BlacklistTools.cleanStringAsSpan(text);
		bool flag = !(text2 == text);
public class BlacklistTest7
	private static readonly Dictionary<int, HashSet<int>> _profanity = new Dictionary<int, HashSet<int>>();
	private static int _min_length = int.MaxValue;
	private static int _max_length = int.MinValue;
	private static bool _initiated = false;
	public static void init()
	private static int getCharHashCode(char[] pChar)
	internal static bool checkBlackList(string pName)
		bool flag = !(readOnlySpan2 == readOnlySpan);
		for (int i = _min_length; i <= _max_length; i++)
public class BlacklistTest8
	private static readonly Dictionary<int, HashSet<int>> _profanity = new Dictionary<int, HashSet<int>>();
	private static int _min_length = int.MaxValue;
	private static int _max_length = int.MinValue;
	private static readonly Dictionary<int, char[]> _char_arrays = new Dictionary<int, char[]>();
	private static bool _initiated = false;
	public static void init()
	private static int getCharHashCode(char[] pChar)
	internal static bool checkBlackList(string pName)
		bool flag = !(readOnlySpan2 == readOnlySpan);
		for (int i = _min_length; i <= _max_length; i++)
public class BlacklistTest9
	private static readonly Dictionary<string, string[]> _profanity = new Dictionary<string, string[]>();
	private const int INDEX_LENGTH = 3;
	private static bool _initiated = false;
	public static void init()
	internal static bool checkBlackList(string pName)
		Dictionary<string, string[]> profanity = _profanity;
		for (int i = 0; i < readOnlySpan.Length - 3 + 1; i++)
		for (int k = 0; k < readOnlySpan2.Length - 3 + 1; k++)
public static class BlacklistTools
	private static string[] _profanities;
	public static string[] getProfanities()
		string text = ((TextAsset)obj2).text;
		string[] array = Regex.Split(text, "\r\n?|\n", RegexOptions.Singleline);
		using ListPool<string> listPool = new ListPool<string>(array.Length);
		for (int i = 0; i < array.Length; i++)
	public static void loadProfanityFilter(Dictionary<char, string[]> pProfanity, HashSet<char> pUnique)
	public static void loadProfanityFilter(Dictionary<char, char[][]> pProfanity, HashSet<char> pUnique)
	public static void loadProfanityFilter(Dictionary<int, HashSet<int>> pProfanity, ref int pMinLength, ref int pMaxLength)
	public static void loadProfanityFilter(Dictionary<string, string[]> pProfanity, int pIndexLength = 3)
	public static int getCharHashCode(char[] pChar)
	public static string cleanString(string pString)
		if (string.IsNullOrEmpty(pString))
		string text = pString[0].ToString();
		for (int i = 0; i < pString.Length - 1; i++)
	public static string cleanStringAsSpan(string pString)
		if (string.IsNullOrEmpty(pString))
		int length = 0;
		for (int i = 1; i < readOnlySpan.Length; i++)
		return new string(span.Slice(0, length));
	public static ReadOnlySpan<char> cleanSpan(ReadOnlySpan<char> pSpan)
		int length = 0;
		for (int i = 1; i < pSpan.Length; i++)
	public static bool contains(ReadOnlySpan<char> pText, ReadOnlySpan<char> pSearchPattern)
		for (int i = 0; i <= pText.Length - pSearchPattern.Length; i++)
	public static bool contains(ReadOnlySpan<char> pText, ReadOnlySpan<char> pSearchPattern, int pStartIndex)
		for (int i = pStartIndex; i <= pText.Length - pSearchPattern.Length; i++)
	public static bool contains(ref ReadOnlySpan<char> pText, ref ReadOnlySpan<char> pSearchPattern)
		for (int i = 0; i <= pText.Length - pSearchPattern.Length; i++)
	public static bool contains2(ref ReadOnlySpan<char> pText, ref ReadOnlySpan<char> pSearchPattern)
		int length = pSearchPattern.Length;
		int length2 = pText.Length;
		int i = 0;
		for (int num = length2 - length; i <= num; i++)
public class Boat : ActorSimpleComponent
	private readonly HashSet<Actor> _passengers = new HashSet<Actor>();
	internal TaxiRequest taxi_request;
	internal int passengerWaitCounter;
	public WorldTile taxi_target;
	public bool pickup_near_dock;
	internal int last_movement_angle;
	private Vector2 _last_step = Vector2.zero;
	private string _boat_texture_id => actor.asset.boat_texture_id;
	internal override void create(Actor pActor)
	public override void update(float pElapsed)
	public void calculateMovementAngle()
	public bool isNearDock()
	private void cancelPathfinderMovement(Actor pActor)
	internal void cancelWork(Actor pActor)
	public AnimationDataBoat getAnimationDataBoat()
	public void spawnBoatExplosion(Actor pActor)
	private void deathAction(Actor pActor)
	internal void unloadPassengers(WorldTile pTile, bool pRandomForce = false)
	internal bool hasPassengers()
	internal int countPassengers()
	internal bool hasPassenger(Actor pActor)
	public IReadOnlyCollection<Actor> getPassengers()
	internal void removePassenger(Actor pActor)
	internal void addPassenger(Actor pActor)
	public bool isHomeDockFull()
	public bool isHomeDockOverfilled()
	public void destroyBecauseOverfilled()
	public override void Dispose()
public enum BoatState
public class Book : CoreSystemObject<BookData>
	private BaseStats _base_stats_read_action = new BaseStats();
	public override BaseSystemManager manager => World.world.books;
	public void newBook(Actor pByActor, BookTypeAsset pBookType, ActorTrait pTraitActor, CultureTrait pTraitCulture, LanguageTrait pTraitLanguage, ReligionTrait pTraitReligion)
		string pName = NameGenerator.generateNameFromTemplate(pBookType.name_template, pByActor);
	public BaseStats getBaseStats()
	private void recalcBaseStats()
	public bool isReadyToBeRead()
	public override void loadData(BookData pData)
	public Religion getReligion()
	public Language getLanguage()
	public Culture getCulture()
	public ActorTrait getBookTraitActor()
		if (string.IsNullOrEmpty(data.trait_id_actor))
	public LanguageTrait getBookTraitLanguage()
		if (string.IsNullOrEmpty(data.trait_id_language))
	public CultureTrait getBookTraitCulture()
		if (string.IsNullOrEmpty(data.trait_id_culture))
	public ReligionTrait getBookTraitReligion()
		if (string.IsNullOrEmpty(data.trait_id_religion))
	public int getHappiness()
		int num = (int)_base_stats_read_action["happiness"];
	public int getExperience()
		int num = (int)_base_stats_read_action["experience"];
		else if (language.hasTrait("nicely_structured_grammar"))
			num = (int)((float)num * LanguageTraitLibrary.getValueFloat("nicely_structured_grammar"));
	public int getMana()
		return (int)_base_stats_read_action["mana"];
	protected sealed override void setDefaultValues()
	public BookTypeAsset getAsset()
	public void readIt()
	public void increaseReadTimes()
	public override void Dispose()
public class BookData : BaseSystemData
	public string book_type;
	public string path_cover;
	public string path_icon;
	public string author_name;
	public long author_id = -1L;
	public string author_clan_name;
	public long author_clan_id = -1L;
	public string author_kingdom_name;
	public long author_kingdom_id = -1L;
	public string author_city_name;
	public long author_city_id = -1L;
	public long language_id = -1L;
	public string language_name;
	public long culture_id = -1L;
	public string culture_name;
	public long religion_id = -1L;
	public string religion_name;
	public int times_read;
	public double timestamp_read_last_time;
	public string trait_id_actor = string.Empty;
	public string trait_id_language = string.Empty;
	public string trait_id_culture = string.Empty;
	public string trait_id_religion = string.Empty;
	public long building_id = -1L;
public class BookManager : CoreSystemManager<Book, BookData>
	public const string COVER_PATH = "books/book_covers/";
	public const string ICON_PATH = "books/book_icons/";
	private static Sprite[] _cached_covers;
	public BookManager()
	public Book generateNewBook(Actor pActor)
	public string getNewCoverPath()
	private BookTypeAsset getPossibleBookType(Actor pActor)
		for (int i = 0; i < AssetManager.book_types.list.Count; i++)
	public Book newBook(Actor pActor)
	private ActorTrait getBookTrait(Actor pActor)
	public void copyBook(Book pBook)
	public void burnBook(Book pBook)
	public override void removeObject(Book pObject)
public delegate int BookRateCalc(Actor pActor, BookTypeAsset pAsset);
public delegate void BookReadAction(Actor pActor, BookTypeAsset pBookAsset);
public delegate bool BookRequirementCheck(Actor pActor, BookTypeAsset pAsset);
public class BooksContainer : BooksElement
	private ObjectPoolGenericMono<CultureBookButton> _pool_books;
	private CultureBookButton _prefab_book;
	private Transform _title;
	private Transform _books_grid;
	protected override void Awake()
	protected override IEnumerator showContent()
	public void loadBookButton(long pBookID)
	protected override void clear()
	protected override void clearInitial()
		for (int i = 0; i < _books_grid.childCount; i++)
public class BooksElement : WindowMetaElementBase
	protected List<long> books;
	private IBooksWindow _books_window;
	protected override void Awake()
	protected override void OnEnable()
	protected override void OnDisable()
	public override bool checkRefreshWindow()
public class BooksHandler
	private readonly List<long> _books = new List<long>();
	private bool _books_dirty = true;
	private Culture _culture;
	private Language _language;
	private Religion _religion;
	public void setMeta(Culture pCulture = null, Language pLanguage = null, Religion pReligion = null)
	public List<long> getList()
	public int count()
	public bool hasBooks()
	public void setDirty()
	private void checkBooks()
	public void clear()
public class BooksNoItems : MonoBehaviour
	private GameObject _inner;
	private IBooksWindow _books_window;
	private void Awake()
	private void OnEnable()
public delegate void BookTraitAction(Actor pActor, LanguageTrait pTrait, Book pBook);
public class BookTypeAsset : Asset, IDescriptionAsset, ILocalizedAsset
	public int writing_rate = 1;
	public string name_template;
	public string path_icons;
	public string color_text;
	public BookReadAction read_action;
	public bool save_culture = true;
	public bool save_religion = true;
	public BookRateCalc rate_calc;
	public BookRequirementCheck requirement_check;
	private Sprite[] _cached_icons;
	public BaseStats base_stats = new BaseStats();
	public string getNewIconPath()
	public string getFullIconPath()
	public string getTypeID()
	public string getLocaleID()
	public string getDescriptionID()
	public string getDescriptionTranslated()
public class BookTypeLibrary : AssetLibrary<BookTypeAsset>
	public override void init()
		t.base_stats["intelligence"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["intelligence"] = 1f;
		t.base_stats["intelligence"] = 1f;
	public override void editorDiagnostic()
	public override void editorDiagnosticLocales()
public class Boulder : BaseEffect
	private const float SPEED = 2.5f;
	private const int BOUNCES_AMOUNT = 3;
	private const float SINGLE_BOUNCE_TIMER = 2f;
	private const float BASE_HEIGHT_MULTIPLIER = 10f;
	private const float BASE_LENGTH_MULTIPLIER = 40f;
	private const float INITIAL_ANGLE_RANGE = 200f;
	private const float CHARGE_VECTOR_MULTIPLIER = 0.777f;
	private const float Z_SORTING_FIX = 5f;
	private const int NO_TOUCH_ID = -2;
	private float angle;
	private float angleRotation;
	private float impactEffect;
	public GameObject mainSprite;
	public GameObject shadowSprite;
	private SpriteRenderer shadowRenderer;
	private Transform mainTransform;
	private Transform shadowTransform;
	private Vector2 _previous_bounce_position;
	private List<Vector2> _bounce_positions = new List<Vector2>();
	private int _bounces_left;
	private float _force_timer;
	private static bool _charge_started;
	private static Vector2 _initial_charge_position;
	private static Touch _latest_touch;
	private static int _latest_touch_id = -2;
	public override void Awake()
	public override void update(float pElapsed)
	private void updateForce(float pElapsed)
		float heightPosition = getHeightPosition();
	private void updateShadow()
		float num = (position_height / -5f + 10f) / 10f;
		float shadowAlpha = Mathf.Clamp(num, 0.15f, 1f) * 0.3f;
		float num2 = Mathf.Clamp(num, 0.25f, 0.9f) * 0.3f;
	private void setShadowAlpha(float pVal)
		float num = pVal;
	private void spawnEffect(string pEffectID)
	internal void actionLanded()
		current_tile = World.world.GetTile((int)((Component)this).transform.localPosition.x, (int)((Component)this).transform.localPosition.y);
		bool flag = true;
	private void sequencedBounce()
		EffectsLibrary.spawnExplosionWave(pVec, (float)_bounces_left * 0.14f, 6f);
	private void explosion()
	public static bool tileDrawBoulder(WorldTile pTile, string pPowerID)
		pTile.doUnits(delegate(Actor pActor)
	public void spawnOn(Vector2 pPosition)
		for (int i = 0; i < 3; i++)
	private void setCurrentPosition(float pX, float pY, float pHeight)
	private void updateCurrentPosition()
	private float getBounceProgress()
	private float getBounceProgressMirrored()
	private float getHeightProgress()
	private float getHeightPosition()
		return (float)_bounces_left * getHeightProgress() * 10f;
	private int getCurrentBounceIndex()
	private Vector2 getNextBouncePos()
	private Vector2 calcCurrentPos()
	public static void chargeBoulder(Vector2 pPosition, Touch pTouch = default(Touch))
	private static void startCharging(Vector2 pPosition)
	private static void endCharging()
	public static void checkRelease()
	private static void releaseManyBoulders(Vector2 pPosition)
	private static void releaseBoulder()
		Vector2 pointerPosition = getPointerPosition();
		EffectsLibrary.spawnAt("fx_boulder", pointerPosition, 1f);
	private static void spawnParticles()
		if (getPointerPositionPure(ref pPosition) && !isRandomLaunch(pPosition))
	private static bool isRandomLaunch(Vector2 pPosition)
	private static bool isBoulderPowerSelected()
	private static Vector2 chargeVector(Vector2 pPosition)
	public static Vector2 chargeVector()
		return chargeVector(getPointerPosition());
	private static bool isInteractionJustStarted()
	private static bool isInteractionJustEnded()
		else if (Input.touchCount == 0 || (int)((Touch)(ref _latest_touch)).phase == 3)
	private static Vector2 getPointerPosition()
		return Vector2.op_Implicit(World.world.camera.ScreenToWorldPoint(Vector2.op_Implicit(((Touch)(ref _latest_touch)).position)));
	private static bool getPointerPositionPure(ref Vector2 pPosition)
public class BoulderCharge : BaseEffect
	private const float BASE_ALPHA = 1f;
	private const float ALPHA_CHANGE = 0.001f;
	private const float RANDOM_OFFSET = 20f;
	private const float BASE_TIME_BETWEEN_FRAMES = 0.2f;
	private List<SpriteSet> _sprite_sets;
	private Vector2 _direction;
	internal override void prepare(Vector2 pVector, float pScale = 1f)
	public override void update(float pElapsed)
public class BoxPreview : MonoBehaviour
	private sealed class _003C_003Ec
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();
		public static UnityAction _003C_003E9__16_1;
		internal void _003CAwake_003Eb__16_1()
	private Sprite _preview_default;
	private Image _icon_gift;
	private Image _icon_premium;
	private Image _icon_broken;
	private Image _icon_modded;
	private Image _cursed_bg;
	private Image _cursed_overlay;
	private GameObject _favorited;
	private Image _preview_image;
	private Button _button;
	private Text _text_id;
	private bool _wantLoad_preview;
	private float _timer_preview;
	private string _world_path;
	private int _slot_id;
	private MapMetaData _metaData;
	private void Awake()
		_button.OnHover((UnityAction)delegate
	public void setSlot(int pID)
		_timer_preview = 0.02f * (float)pID;
		bool active = PlayerConfig.instance.data.favorite_world == pID;
	private void showHoverTooltip()
	private void Update()
	public void showDefaultImage()
	private void showPreview(Texture2D pTexture)
	private IEnumerator loadSaveSlotImage()
		string tPath = SaveManager.generatePngPreviewPath(_world_path);
		if (string.IsNullOrEmpty(tPath) || !File.Exists(tPath))
	public void click()
public enum BoxState
namespace ai.behaviours;
public class BrainsLibrary : BehaviourTaskActorLibrary
public class Brush
	public static string getRandom()
	public static string getRandom(int pMinSize, int pMaxSize = 50, Predicate<BrushData> pMatch = null)
	public static BrushData get(int pSize, string pID = "circ_")
		string text = pID + pSize;
	public static BrushData get(string pID)
public class BrushData : Asset, ILocalizedAsset
	public int size = 1;
	public int drops = 1;
	public BrushGroup group;
	public bool show_in_brush_window;
	public int width;
	public int height;
	public int sqr_size;
	public bool auto_size;
	public bool continuous;
	public bool fast_spawn;
	public string localized_key;
	public BrushPixelData[] pos;
	public BrushGenerateAction generate_action;
	public Vector2 ui_scale = new Vector2(1f, 1f);
	public Vector2 ui_size = new Vector2(28f, 28f);
	private Sprite _sprite;
	public void setupImage(Image pSprite)
	public Sprite getSprite()
		for (int i = 0; i < array.Length; i++)
		int num = 0;
		int num2 = 0;
		for (int j = 0; j < array2.Length; j++)
		for (int j = 0; j < array2.Length; j++)
		((Rect)(ref val2))._002Ector(0f, 0f, (float)((Texture)val).width, (float)((Texture)val).height);
	public string getLocaleID()
public delegate void BrushGenerateAction(BrushData pAsset);
public enum BrushGroup
public class BrushLibrary : AssetLibrary<BrushData>
	private static readonly List<string> _available_brushes = new List<string>();
	public override void init()
		t.generate_action = delegate(BrushData pAsset)
		t.generate_action = delegate(BrushData pAsset)
		t.generate_action = delegate(BrushData pAsset)
	public override void post_init()
	public override void linkAssets()
	public static void shuffleBrush(BrushData pAsset)
		int num = 0;
		for (int i = 0; i < pAsset.pos.Length; i++)
	public override void editorDiagnosticLocales()
	public override BrushData clone(string pNew, string pFrom)
	internal static void nextBrush()
	internal static void previousBrush()
	private static string getNext(string pBrushName)
		bool flag = false;
		for (int i = 0; i < _available_brushes.Count; i++)
	private static string getPrevious(string pBrushName)
		bool flag = false;
		for (int num = _available_brushes.Count - 1; num >= 0; num--)
public readonly struct BrushPixelData : IEquatable<BrushPixelData>
	public readonly int x;
	public readonly int y;
	public readonly int dist;
	public BrushPixelData(int pX, int pY, int pDist)
	public bool Equals(BrushPixelData pOther)
	public override int GetHashCode()
public class BrushPixelDataConverter : JsonConverter
	public override void WriteJson(JsonWriter pWriter, object pValue, JsonSerializer pSerializer)
		string text = brushPixelData.x + "," + brushPixelData.y + "," + brushPixelData.dist;
		pSerializer.Serialize(pWriter, (object)text, typeof(string));
	public override object ReadJson(JsonReader pReader, Type pObjectType, object pExistingValue, JsonSerializer pSerializer)
		string text = pSerializer.Deserialize<string>(pReader);
		if (string.IsNullOrEmpty(text))
		int[] array = Array.ConvertAll(text.Split(','), int.Parse);
	public override bool CanConvert(Type pObjectType)
public class BrushSelectButton : MonoBehaviour
	public Image icon;
	private BrushData _brush_asset;
	private void Start()
		((UnityEvent)((Component)this).GetComponent<Button>().onClick).AddListener((UnityAction)delegate
	public void setup(BrushData pBrushData)
public class BrushSizesButton : MonoBehaviour
	private PowerButton _power_button;
	private string _latest_used = string.Empty;
	private void Awake()
	private void Update()
public class BrushWindow : MonoBehaviour
	public Transform circles;
	public Transform squares;
	public Transform diamonds;
	public Transform special;
	public BrushSelectButton button_prefab;
	public void Awake()
	public void selectBrush(GameObject pObject)
public class Building : BaseSimObject, IEquatable<Building>, IComparable<Building>, ILoadable<BuildingData>
	public BatchBuildings batch;
	internal bool positionDirty;
	internal bool sprite_dirty;
	internal bool tiles_dirty;
	private Sprite _last_colored_sprite;
	private ColorAsset _last_color_asset;
	internal Sprite last_main_sprite;
	internal BuildingData data;
	internal BuildingAsset asset;
	public bool flip_x;
	internal readonly List<WorldTile> tiles = new List<WorldTile>();
	public BuildingAnimationData animData;
	public int animData_index;
	private float _shake_timer;
	private float _shake_intensity_x;
	private float _shake_intensity_y;
	internal float lastAngle;
	private Vector2 _shake_offset;
	internal readonly List<TileZone> zones = new List<TileZone>();
	internal BuildingAnimationState animation_state;
	internal BuildingOwnershipState state_ownership;
	internal ListPool<BaseBuildingComponent> components_list;
	internal Docks component_docks;
	internal Wheat component_wheat;
	internal BuildingFruitGrowth component_fruit_growth;
	internal UnitSpawner component_unit_spawner;
	internal BuildingSpreadBiome component_biome_spreader;
	internal BuildingMonolith component_monolith;
	internal BuildingWaypoint component_waypoint;
	internal BuildingBiomeFoodProducer component_food_producer;
	internal Beehive component_beehive;
	internal readonly BuildingTweenScaleHelper scale_helper = new BuildingTweenScaleHelper();
	internal bool chopped;
	internal bool is_visible;
	internal bool check_spawn_animation;
	private float _timer_shake_resource;
	private float _auto_remove_timer;
	public HashSet<long> residents = new HashSet<long>();
	private Vector3 _last_scale = Vector3.zero;
	public Material material;
	protected override MetaType meta_type => MetaType.Building;
	internal WorldTile door_tile
	public City city => current_tile.zone.city;
	public CityResources resources => data.resources;
	internal bool isBurnable()
	public float getExistenceTime()
	public float getExistenceMonths()
	public void setAnimData(int pIndex)
	internal void stopFire()
	internal override void create()
	protected sealed override void setDefaultValues()
	private T addComponent<T>() where T : BaseBuildingComponent, new()
	public bool hasBooks()
	public bool hasFreeBookSlot()
	public void addBook(Book pBook)
	public bool isState(BuildingState pState)
	internal void setBuilding(WorldTile pTile, BuildingAsset pAsset, BuildingData pData)
		if (!string.IsNullOrEmpty(asset.kingdom))
		if (!isUnderConstruction())
		if (pAsset.waypoint)
	private void debugCheckResourcesOnSpawn(BuildingAsset pAsset)
	public override void setStatsDirty()
	private void setPositionDirty()
	public override BaseObjectData getData()
	public void setData(BuildingData pData)
	public void loadData(BuildingData pData)
	public void loadBuilding(BuildingData pData)
		if (!isUnderConstruction())
	internal void setHaveResourcesToCollect(bool pValue)
	public bool hasResourcesToCollect()
	internal bool canBeUpgraded()
		if (isUnderConstruction())
	internal bool upgradeBuilding()
	private void setTemplate(BuildingAsset pTemplate)
	internal void setMaterial(string pMaterialID)
	internal void setKingdomCiv(Kingdom pKingdom)
	internal void makeRuins()
	public void makeAbandoned()
		if (isUnderConstruction())
	public void setKingdom(Kingdom pKingdom)
	private void checkKingdom()
	public bool hasHousingLogic()
	private void setState(BuildingState pState)
	public void checkMaterial()
	internal void updateKingdomColors()
	internal bool checkTilesForUpgrade(WorldTile pTile, BuildingAsset pTemplate)
		int num = ((Vector2Int)(ref pos)).x - pTemplate.fundament.left;
		int num2 = ((Vector2Int)(ref pos)).y - pTemplate.fundament.bottom;
		int num3 = pTemplate.fundament.right + pTemplate.fundament.left + 1;
		int num4 = pTemplate.fundament.top + pTemplate.fundament.bottom + 1;
		for (int i = 0; i < num3; i++)
	internal void debugConstructions()
		if (!((Object)(object)asset.building_sprites.construction == (Object)null))
			setUnderConstruction();
	private void initAnimationData()
		int num = Randy.randomInt(0, asset.building_sprites.animation_data.Count);
	private void fillTiles()
		int num = ((Vector2Int)(ref pos)).x - asset.fundament.left;
		int num2 = ((Vector2Int)(ref pos)).y - asset.fundament.bottom;
		int num3 = asset.fundament.right + asset.fundament.left + 1;
		int num4 = asset.fundament.top + asset.fundament.bottom + 1;
		int num5 = 0;
		for (int i = 0; i < num3; i++)
	internal void checkDirtyTiles()
	private void setTilesDirty()
	private void forceUpdateTilesDirty()
	private void setBuildingTile(WorldTile pTile, int pX, int pY)
	public void setOwnershipState(BuildingOwnershipState pState)
	internal bool isRuin()
	internal bool isRemoved()
	public bool isNormal()
	public bool isAbandoned()
	public bool isCiv()
	public void prepareForSave()
	public bool isUsable()
	internal void startDestroyBuilding()
			if (asset.has_ruins_graphics && !isUnderConstruction())
	private void clearZones()
	internal void kill()
	public override City getCity()
	internal override void updateStats()
	internal void chopTree()
	private void finishChop()
	private void startRemove()
			if (!isUnderConstruction() && asset.has_sound_destroyed)
	public bool isAnimationState(BuildingAnimationState pState)
	internal void startMakingRuins()
	internal void removeBuildingFinal()
	internal void clearTiles()
		for (int i = 0; i < tiles.Count; i++)
	private void clearComponents()
	public bool isOnRemove()
	internal void setAnimationState(BuildingAnimationState pState)
	internal void completeMakingRuin()
	private void checkAutoRemove()
	internal void updateAutoRemove(float pElapsed)
	internal void updateTimerShakeResources(float pElapsed)
	internal void updateComponents(float pElapsed)
		for (int i = 0; i < components_list.Count; i++)
	public void updatePosition()
	internal void spawnBurstSpecial(int pAmount = 1)
		int x = ((Vector2Int)(ref pos)).x;
		for (int i = 0; i < pAmount; i++)
	internal bool updateBuild(int pProgress = 1)
		data.change("construction_progress", pProgress);
		bool result = false;
		if (getConstructionProgress() > asset.construction_progress_needed)
			completeConstruction();
	private void makeZoneDirty()
	public bool hasResidentSlots()
	public int countResidents()
	public bool hasResidents()
	public void startShake(float pDuration, float pIntensityX = 0.1f, float pIntensityY = 0.1f)
		_shake_intensity_x = pIntensityX;
		_shake_intensity_y = pIntensityY;
	internal void resourceGathering(float pElapsed)
	public void updateShake(float pElapsed)
	internal override void getHitFullHealth(AttackType pAttackType)
	internal override void getHit(float pDamage, bool pFlash = true, AttackType pAttackType = AttackType.Other, BaseSimObject pAttacker = null, bool pSkipIfShake = true, bool pMetallicWeapon = false, bool pCheckDamageReduction = true)
		changeHealth((int)(0f - pDamage));
	internal void extractResources(Actor pBy)
	internal Color32 getColorForMinimap(WorldTile pTile)
	public WorldTile getConstructionTile()
				using IEnumerator<WorldTile> enumerator2 = checkZoneForDockConstruction(item).GetEnumerator();
				if (enumerator2.MoveNext())
					return enumerator2.Current;
	public int getConstructionProgress()
		data.get("construction_progress", out var pResult, 0);
	public void completeConstruction()
		data.removeInt("construction_progress");
		data.removeFlag("under_construction");
	public bool isUnderConstruction()
		if (!asset.has_sprite_construction)
		return data.hasFlag("under_construction");
	public void setUnderConstruction()
		if (asset.has_sprite_construction)
			data.addFlag("under_construction");
	public bool canRemoveForFarms()
	internal IEnumerable<WorldTile> checkZoneForDockConstruction(TileZone pZone)
	internal void checkStartSpawnAnimation()
	public Sprite calculateMainSprite()
		bool flag = true;
		bool flag2 = isRuin();
		if (isUnderConstruction())
			last_main_sprite = asset.building_sprites.construction;
	public bool isColoredSpriteNeedsCheck(Sprite pMainSprite)
	public Sprite calculateColoredSprite(Sprite pMainSprite)
	public Sprite getLastColoredSprite()
	public void clearSprites()
	public Sprite checkSpriteToRender()
	public Vector3 getCurrentScale()
		float tweenBuildingsValue = World.world.quality_changer.getTweenBuildingsValue();
		float num = current_scale.y * tweenBuildingsValue;
		float num2 = current_scale.x * tweenBuildingsValue;
	public bool isFullyGrown()
	private Sprite getSpawnFrameSprite()
		float worldTimeElapsedSince = World.world.getWorldTimeElapsedSince(data.created_time);
		float num = (float)spawn.Length * asset.animation_speed / 60f;
	public int takeResource(string pResourceID, int pAmount)
	public int getResourcesAmount(string pResourceID)
	public int addResources(string pResourceID, int pAmount)
	public bool hasSpaceForResource(ResourceAsset pResourceAsset)
	public bool hasResourcesForNewItems()
	public int countFood()
	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies, string pFavoriteFood = null)
	public override void Dispose()
		component_waypoint = null;
	public bool Equals(Building pObject)
	public int CompareTo(Building pTarget)
	public void checkVegetationSpread(float pElapsed)
	private bool tryToGrowOnTile(WorldTile pTile, BuildingAsset pAsset, bool pCheckLimit = true)
public static class BuildingActions
	public static void tryGrowVegetationRandom(WorldTile pTile, VegetationType pType, bool pOnStart = false, bool pCheckLimit = true, bool pCheckRandom = true)
	public static void tryGrowMineralRandom(WorldTile pTile, bool pOnStart = false, bool pCheckLimit = true)
	public static Building tryGrowVegetation(WorldTile pTile, string pTemplateID, bool pSfx = false, bool pCheckLimit = true)
	public static void spawnBeehives(int pAmount)
		for (int i = 0; i < pAmount; i++)
	public static void spawnResource(int pAmount, string pType, bool pRandomSize = true)
		for (int i = 0; i < pAmount; i++)
public class BuildingAnimationData
	public bool animated;
	public ListPool<Sprite> list_spawn;
	public ListPool<Sprite> list_main;
	public ListPool<Sprite> list_main_disabled;
	public ListPool<Sprite> list_ruins;
	public ListPool<Sprite> list_special;
	public Sprite[] main;
	public Sprite[] main_disabled;
	public Sprite[] spawn;
	public Sprite[] ruins;
	public Sprite[] special;
public enum BuildingAnimationState
public class BuildingAsset : Asset
	public bool sprites_are_initiated;
	public Vector3 scale_base = new Vector3(0.25f, 0.25f, 0.25f);
	public string kingdom = string.Empty;
	public string civ_kingdom = string.Empty;
	public BuildingFundament fundament;
	public string material = "building";
	public string atlas_id = "buildings";
	public string atlas_id_fallback_when_not_wobbly = "buildings";
	public DynamicSpritesAsset atlas_asset;
	public bool prevent_freeze;
	public float bonus_z;
	public bool removed_by_sponge;
	public string sprite_path = string.Empty;
	public string main_path = "buildings/";
	public bool grow_creep;
	public CreepWorkerMovementType grow_creep_movement_type;
	public string grow_creep_type = string.Empty;
	public bool draw_light_area;
	public float draw_light_area_offset_x;
	public float draw_light_area_offset_y;
	public float draw_light_size = 0.5f;
	public int grow_creep_steps_max;
	public float grow_creep_step_interval;
	public int grow_creep_workers = 1;
	public bool grow_creep_direction_random_position;
	public bool grow_creep_random_new_direction;
	public bool grow_creep_flash;
	public int construction_progress_needed;
	public bool grow_creep_redraw_tile;
	public int grow_creep_steps_before_new_direction = 7;
	public bool has_ruins_graphics = true;
	public bool has_special_animation_state;
	public float animation_speed = 6f;
	public BuildingType building_type;
	public bool sparkle_effect;
	public List<ResourceContainer> resources_given;
	public bool can_be_grown;
	public float vegetation_random_chance = 0.5f;
	public bool has_kingdom_color;
	public bool city_building;
	public bool can_be_abandoned;
	public bool mini_civ_auto_load;
	public bool destroy_on_liquid;
	public bool can_be_upgraded;
	public string upgrade_to = string.Empty;
	public string upgraded_from = string.Empty;
	public int upgrade_level;
	public string type = string.Empty;
	public bool gatherable;
	public bool wheat;
	public bool produce_biome_food;
	public float growth_time;
	public int loot_generation;
	public string[] boat_types;
	public string boat_type_fishing;
	public string boat_type_trading;
	public string boat_type_transport;
	public bool waypoint;
	public int priority;
	public BuildingStepAction step_action;
	public bool has_step_action;
	public bool shadow = true;
	public Vector2 shadow_bound = new Vector2(0.5f, 0.8f);
	public float shadow_distortion = 0.2f;
	public bool auto_remove_ruin;
	public bool ice_tower;
	public bool spawn_units;
	public bool beehive;
	public string spawn_units_asset = "-";
	public bool tower;
	public string tower_projectile = string.Empty;
	public float tower_projectile_offset;
	public bool tower_attack_buildings;
	public float tower_projectile_reload = 3f;
	public int tower_projectile_amount = 1;
	public bool ignore_other_buildings_for_upgrade;
	public bool random_flip;
	public ConstructionCost cost;
	public BaseStats base_stats;
	public bool ignored_by_cities;
	public bool remove_buildings_when_dropped;
	public bool remove_civ_buildings;
	public bool ignore_same_building_id;
	public bool build_road_to;
	public bool can_be_damaged_by_tornado;
	public bool can_be_placed_on_liquid;
	public bool can_be_placed_on_blocks;
	public bool damaged_by_rain;
	public bool only_build_tiles;
	public bool build_place_borders;
	public bool build_place_single;
	public bool build_place_center;
	public bool needs_farms_ground;
	public bool build_place_batch;
	public bool build_prefer_replace_house;
	public bool check_for_close_building;
	public bool ignore_buildings;
	public bool can_be_demolished;
	public bool burnable;
	public bool affected_by_lava;
	public bool affected_by_acid;
	public bool can_units_live_here;
	public int housing_slots;
	public int housing_happiness;
	public int max_houses;
	public bool storage;
	public bool storage_only_food;
	public bool can_be_living_house = true;
	public bool can_be_living_plant = true;
	public bool remove_ruins = true;
	public bool has_ruin_state = true;
	public bool has_resources_to_collect;
	public bool has_resources_grown_to_collect;
	public bool has_resources_grown_to_collect_on_spawn;
	public bool can_be_chopped_down;
	public int book_slots;
	public BuildingOverrideMainSprites get_override_sprites_main;
	public BuildingOverrideMainSprite get_override_sprite_main;
	public bool is_vegetation;
	public bool is_stockpile;
	public Vector2 stockpile_top_left_offset;
	public Vector2 stockpile_center_offset;
	public int limit_per_zone;
	public bool become_alive_when_chopped;
	public int limit_in_radius;
	public int limit_global;
	public bool docks;
	public bool has_biome_tags;
	public HashSet<BiomeTag> biome_tags_growth;
	public bool has_biome_tags_spread;
	public HashSet<BiomeTag> biome_tags_spread;
	public bool spread_biome;
	public string spread_biome_id;
	public string group = string.Empty;
	public bool affected_by_drought;
	public bool affected_by_cold_temperature;
	public bool smoke;
	public float smoke_interval = 0.5f;
	public Vector2Int smoke_offset;
	public bool spawn_drops;
	public string spawn_drop_id = "";
	public float spawn_drop_interval;
	public float spawn_drop_start_height;
	public float spawn_drop_min_height;
	public float spawn_drop_max_height;
	public float spawn_drop_min_radius;
	public float spawn_drop_max_radius;
	public string transform_tiles_to_tile_type;
	public string transform_tiles_to_top_tiles;
	public string sound_spawn;
	public string sound_idle;
	public string sound_hit;
	public string sound_built;
	public string sound_destroyed;
	public int nutrition_restore;
	public bool spawn_rats;
	public bool flora;
	public FloraSize flora_size;
	public bool spread;
	public float spread_chance;
	public float spread_steps;
	public FloraType flora_type;
	public string[] spread_ids;
	public bool has_sprites_spawn;
	public bool has_sprites_main;
	public bool has_sprites_main_disabled;
	public bool has_sprites_ruin;
	public bool has_sprites_special;
	public bool has_sprite_construction;
	public bool check_for_adaptation_tags;
	public GetColorForMapIcon get_map_icon_color;
	public bool has_get_map_icon_color;
	public BuildingSprites building_sprites;
	public HashSet<Building> buildings = new HashSet<Building>();
	public bool has_sound_spawn => sound_spawn != null;
	public bool has_sound_idle => sound_idle != null;
	public bool has_sound_hit => sound_hit != null;
	public bool has_sound_built => sound_built != null;
	public bool has_sound_destroyed => sound_destroyed != null;
	public bool setSpread(FloraType pType, int pSpreadSteps = 1, float pSpreadChance = 1f)
	public void setAtlasID(string pAtlasID, string pFallbackID = null)
	public void setShadow(float pBoundX, float pBoundY, float pDistortion)
	public bool isOverlaysBiomeTags(TileTypeBase pTileType)
	public bool isOverlaysBiomeSpreadTags(TileTypeBase pTileType)
	public void checkLimits(Building pBuildingToIgnore = null)
		int num = buildings.Count - limit_global;
	public bool canBeOccupied()
	public void addResource(string pID, int pAmount, bool pNewList = false)
	public bool hasResourceGiven(string pID)
	public ActorAsset getRandomBoatAssetToBuild(City pCity)
		string random = boat_types.GetRandom();
		string boatAssetIDFromType = getBoatAssetIDFromType(random, pCity);
		if (string.IsNullOrEmpty(boatAssetIDFromType))
	public void setHousingSlots(int pValue)
	public bool hasHousingSlots()
	private string getBoatAssetIDFromType(string pSpeciesBoat, City pCity)
	public void checkSpritesAreLoaded()
	public void loadBuildingSprites()
			case "construction":
				building_sprites.construction = val;
	public Sprite[] loadBuildingSpriteList()
		string text = sprite_path;
		if (string.IsNullOrEmpty(text))
public class BuildingAssetElementPlace : BaseAssetElementPlace<BuildingAsset, BuildingDebugAssetElement>
public class BuildingAssetWindow : BaseDebugAssetWindow<BuildingAsset, BuildingDebugAssetElement>
	public void clickRandomKingdomColor()
	protected override void initSprites()
		string text = asset.sprite_path;
		if (string.IsNullOrEmpty(text))
	public static void reloadSprites()
public class BuildingBiomeFoodProducer : BaseBuildingComponent
	private const float FOOD_INTERVAL = 90f;
	private float timer = 90f;
	public override void update(float pElapsed)
		string food_resource = random.Type.food_resource;
		if (string.IsNullOrEmpty(food_resource))
		if (!string.IsNullOrEmpty(food_resource) && building.city.getResourcesAmount(food_resource) < 10)
public readonly struct BuildingColorPixel
	public readonly Color32 color;
	public readonly Color32 color_abandoned;
	public readonly Color32 color_ruin;
	public BuildingColorPixel(Color32 pColor, Color32 pColorAbandoned, Color32 pColorRuin)
public class BuildingContainer : ObjectContainer<Building>
public class BuildingCreepHUB : BaseBuildingComponent
	private float _interval = 0.1f;
	private float _timer;
	private ListPool<BuildingCreepWorker> _workers;
	internal override void create(Building pBuilding)
		for (int i = 0; i < building.asset.grow_creep_workers; i++)
		_interval = building.asset.grow_creep_step_interval;
		_timer = _interval;
	public override void update(float pElapsed)
		_timer = _interval;
		for (int i = 0; i < workers.Count; i++)
	public override void Dispose()
		for (int i = 0; i < _workers.Count; i++)
public class BuildingCreepWorker : IDisposable
	private int steps_max;
	private WorldTile cur_tile;
	private ActorDirection cur_direction;
	private BuildingCreepHUB _parent;
	private int _total_step_counter;
	private BiomeAsset _this_creep_biome;
	private int _direction_step_amount;
	public BuildingCreepWorker(BuildingCreepHUB pParent)
	public void update()
	private void checkRandomDirectionChange()
	private void creepFlash(int pVal = 15)
	private void updateMovement(WorldTile pNextTile)
	private bool canPlaceWorkerOn(WorldTile pTile)
	private void makeCreep(WorldTile pTile)
	private WorldTile getNextRandomTile(WorldTile pTile)
	private WorldTile getDirectionTile(WorldTile pTile, bool pAddRandom = true)
		int num = ((Vector2Int)(ref pos)).x;
		int num2 = ((Vector2Int)(ref pos)).y;
	public void Dispose()
public class BuildingData : BaseObjectData
	public BuildingState state = BuildingState.Normal;
	public int mainX;
	public int mainY;
	public string asset_id;
	public long cityID = -1L;
	public float grow_time;
	public CityResources resources;
	public StorageBooks books;
	public int frameID = -1;
	public long objectID
	public string templateID
	public override void Dispose()
public class BuildingDebugAnimationElement : BaseDebugAnimationElement<BuildingAsset>
	public BuildingDebugAnimationVariation variation_prefab;
	public Sprite no_animation_sprite;
	public Transform variations_transform;
	private List<BuildingDebugAnimationVariation> _variations;
	private bool _has_baby;
	public override void update()
	public override void setData(BuildingAsset pAsset)
		for (int i = 0; i < pAsset.building_sprites.animation_data.Count; i++)
	private void setAnimationSettings(SpriteAnimation pAnimation, Image pImage)
	public void setFrames(List<DebugAnimatedVariation> pVariations, bool pShouldHaveSprites)
		bool flag = false;
		for (int i = 0; i < pVariations.Count; i++)
	protected override void clear()
	public override void stopAnimations()
	public override void startAnimations()
	protected override void clickNextFrame()
		int num = sprite_animation.frames.Length;
		int num2 = sprite_animation.currentFrameIndex++;
public class BuildingDebugAnimationVariation : DebugAnimationVariation
	public Image shadow;
	public SpriteAnimation shadow_animation;
	public void update(float pElapsed)
	public void toggleAnimation(bool pState)
	public void setFrame(int pIndex)
public class BuildingDebugAssetElement : BaseDebugAssetElement<BuildingAsset>
	public BuildingDebugAnimationElement spawn;
	public BuildingDebugAnimationElement main;
	public BuildingDebugAnimationElement disabled;
	public BuildingDebugAnimationElement ruin;
	public BuildingDebugAnimationElement special;
	public Image construction;
	public Image mini;
	public override void setData(BuildingAsset pAsset)
	protected override void initAnimations()
		if ((Object)(object)building_sprites.construction != (Object)null)
			construction.sprite = building_sprites.construction;
		else if (asset.has_sprite_construction)
			construction.sprite = no_animation;
			((Graphic)construction).color = Color.clear;
	private Sprite loadMini()
		string text = asset.sprite_path;
		if (string.IsNullOrEmpty(text))
		for (int i = 0; i < ((Texture)val).width; i++)
		return Sprite.Create(val, new Rect(Vector2.zero, new Vector2((float)((Texture)val).width, (float)((Texture)val).height)), new Vector2(0.5f, 0.5f), 1f);
	private Color32 getColor(Color pOrigColor, ColorAsset pKingdomColor)
	public override void update()
	public override void stopAnimations()
	public override void startAnimations()
	private Sprite[] getBuildingColoredSprites(Sprite[] pSprites)
		for (int i = 0; i < pSprites.Length; i++)
	private Sprite getBuildingColoredSprite(Sprite pMainSprite)
	protected override void initStats()
	protected override void showAssetWindow()
public class BuildingDebugAssetsComponent : BaseDebugAssetsComponent<BuildingAsset, BuildingDebugAssetElement, BuildingAssetElementPlace>
	protected override List<BuildingAsset> getAssetsList()
	protected override void init()
		sorting_tab.addButton("ui/Icons/iconHealth", "sort_by_health", base.setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/iconDamage", "sort_by_damage", base.setDataResorted, delegate
		sorting_tab.addButton("ui/Icons/iconPopulationAttackers", "sort_by_targets", base.setDataResorted, delegate
		sorting_tab.addButton("effects/circle132", "sort_by_area_of_effect", base.setDataResorted, delegate
	private int sortByHealth(BuildingAsset pObject1, BuildingAsset pObject2)
	private int sortByDamage(BuildingAsset pObject1, BuildingAsset pObject2)
	private int sortByTargets(BuildingAsset pObject1, BuildingAsset pObject2)
	private int sortByAreaOfEffect(BuildingAsset pObject1, BuildingAsset pObject2)
	protected override List<BuildingAsset> getListCivsSort()
		bool flag = sorting_tab.getCurrentButton().getState() == SortButtonState.Up;
public class BuildingEffectSpawnDrop : BaseBuildingComponent
	private float _timer;
	public override void update(float pElapsed)
		int num = Mathf.CeilToInt(0f - _timer / building.asset.spawn_drop_interval);
		_timer = building.asset.spawn_drop_interval;
public class BuildingFruitGrowth : BaseBuildingComponent
	private float _resource_reset_time;
	public override void update(float pElapsed)
	public void reset()
public class BuildingFundament
	public readonly int left;
	public readonly int right;
	public readonly int top;
	public readonly int bottom;
	public readonly int width;
	public readonly int height;
	public BuildingFundament(int pLeft, int pRight, int pTop, int pBottom)
public static class BuildingHelper
	private static List<WorldTile> _list_tiles = new List<WorldTile>();
	public static void tryToBuildNear(WorldTile pTile, string pAssetID)
	public static bool tryToBuildNear(WorldTile pTile, BuildingAsset pAsset)
		bool result = tryToPlaceBuilding(pAsset, list_tiles);
	private static void fillEmptyTilesAroundMine(WorldTile pTile, List<WorldTile> pList)
		int num = 4;
		int num2 = pTile.x - num;
		int num3 = pTile.y - num;
		for (int i = 0; i < num * 2; i++)
	private static bool tryToPlaceBuilding(BuildingAsset pAsset, List<WorldTile> pList)
using strings;
public class BuildingLibrary : AssetLibrary<BuildingAsset>
	public static readonly Vector2 shadow_under_construction_bound = new Vector2(0f, 0.61f);
	public static readonly float shadow_under_construction_distortion = 0.19f;
	private const string TEMPLATE_CREEP = "$building_creep$";
	private const string TEMPLATE_RESOURCE = "$resource$";
	private const string TEMPLATE_MINERAL = "$mineral$";
	private const string TEMPLATE_FLORA_SMALL = "$flora_small$";
	private const string TEMPLATE_BUILDING = "$building$";
	private const string TEMPLATE_WAYPOINT = "$waypoint$";
	private const string TEMPLATE_DROP_SPREADER = "$drop_spreader$";
	private const string TEMPLATE_CITY_BUILDING = "$city_building$";
	private const string TEMPLATE_CITY_COLORED_BUILDING = "$city_colored_building$";
	private const string TEMPLATE_WINDMILL_BASE = "$windmill_base$";
	private const string TEMPLATE_WINDMILL_0 = "$windmill_0$";
	private const string TEMPLATE_WINDMILL_1 = "$windmill_1$";
	private const string TEMPLATE_BUILDING_CIV_HUMAN = "$building_civ_human$";
	private const string TEMPLATE_BUILDING_CIV_ORC = "$building_civ_orc$";
	private const string TEMPLATE_BUILDING_CIV_DWARF = "$building_civ_dwarf$";
	private const string TEMPLATE_BUILDING_CIV_ELF = "$building_civ_elf$";
	public override void init()
	public override void post_init()
	public override void linkAssets()
	public void checkAtlasLink(bool pWobbleTreesSettingIsActive)
	private void initBuildingsFromArchitectures()
				string pNew = item.building_ids_for_construction[text2];
				buildingAsset.has_sprite_construction = true;
	private void addTrees()
		t.sound_spawn = "event:/SFX/NATURE/BaseFloraSpawn";
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_2");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("tree_green_3");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_tree", "corrupted_tree_big");
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCorruptedTree";
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_tree", "corrupted_tree_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("enchanted_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_1", "savanna_tree_big_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_2", "savanna_tree_big_2");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_1", "savanna_tree_big_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_tree_2", "savanna_tree_big_2");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("infernal_tree", "infernal_tree_small", "infernal_tree_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("cacti_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("palm_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("desert_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("crystal_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("wasteland_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("candy_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("lemon_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("pine_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("birch_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("maple_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("garlic_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_1");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_2");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_tree_3");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("rocklands_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_tree_small");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("singularity_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("clover_tree");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("paradox_tree");
	private void addVegetation()
		t.sound_spawn = "event:/SFX/NATURE/BaseFloraSpawn";
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("desert_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("crystal_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("candy_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("snow_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("green_herb");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("corrupted_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("savanna_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_red");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_green");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_teal");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_white");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("mushroom_yellow");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flame_flower");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("jungle_flower");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("wasteland_flower");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_plant", "swamp_plant_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("swamp_plant", "swamp_plant_big");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("birch_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("maple_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("flower_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("garlic_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("rocklands_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("celestial_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("singularity_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("clover_plant");
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("paradox_plant");
	private void addMinerals()
	private void addPoop()
	private void addGrownResources()
		t.spread_ids = AssetLibrary<BuildingAsset>.a<string>("fruit_bush");
		t.get_map_icon_color = delegate(Building pBuilding)
	private void addGeneralCityBuildings()
		t.has_sprite_construction = true;
		t.construction_progress_needed = 50;
		t.construction_progress_needed = 30;
		t.cost = new ConstructionCost();
		t.smoke_interval = 2.5f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBonfire";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		t.cost = new ConstructionCost(0, 20, 1, 5);
		t.construction_progress_needed = 200;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWell";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(5, 0, 0, 5);
		t.construction_progress_needed = 100;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBarracks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.has_sprite_construction = true;
		t.cost = new ConstructionCost();
		t.construction_progress_needed = 10;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 5, 0, 25);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleStatue";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 0, 0, 15);
		t.construction_progress_needed = 300;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleMine";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWindmill";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.cost = new ConstructionCost(5, 0, 0, 5);
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.cost = new ConstructionCost(0, 5, 5, 30);
		t.has_sprite_construction = false;
	private void addNatureBuildings()
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleGoldenBrain";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("$waypoint$", "$building$");
		t.waypoint = true;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		clone("waypoint_alien_mold", "$waypoint$");
		clone("waypoint_computer", "$waypoint$");
		clone("waypoint_golden_egg", "$waypoint$");
		clone("waypoint_harp", "$waypoint$");
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCorruptedBrain";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBeehive";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingGeneric";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		t.smoke_interval = 1.5f;
		t.spawn_drop_interval = 0.1f;
		t.step_action = delegate(Actor pActor, Building pBuilding)
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleVolcano";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.smoke_interval = 2.5f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleGeyser";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.smoke_interval = 3.5f;
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleAcidGeyser";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
	private void addMobBuildings()
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleFlameTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleIceTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
	private void addCreeps()
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleTumor";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBiomass";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleSuperPumpkin";
		t.sound_hit = "event:/SFX/HIT/HitFlesh";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingFlesh";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingFlesh";
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleCybercore";
		t.sound_hit = "event:/SFX/HIT/HitMetal";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingRobotic";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingRobotic";
	private void addHumans()
		t.cost = new ConstructionCost(10);
		t.boat_types = new string[1] { "boat_type_fishing" };
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleFishingDocks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.cost = new ConstructionCost(0, 20, 1, 5);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleWatchTower";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sprite_path = string.Empty;
		t.cost = new ConstructionCost(10, 6);
		t.boat_types = new string[3] { "boat_type_fishing", "boat_type_trading", "boat_type_transport" };
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleDocks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 5, 2, 15);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleBarracks";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 10, 2, 30);
		t.sound_idle = "event:/SFX/BUILDINGS_IDLE/IdleTemple";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 10, 2, 30);
		t.cost = new ConstructionCost(10, 5, 2, 100);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(1);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingGeneric";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingGeneric";
		t.cost = new ConstructionCost(5);
		t.has_sprite_construction = false;
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.cost = new ConstructionCost(4);
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.cost = new ConstructionCost(0, 5);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 10);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 15);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.cost = new ConstructionCost(0, 20, 2, 10);
		t.upgrade_to = string.Empty;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.sound_hit = "event:/SFX/HIT/HitWood";
		t.cost = new ConstructionCost(10, 5);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingWood";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingWood";
		t.has_sprite_construction = true;
		t.cost = new ConstructionCost(0, 10, 1, 20);
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
		t.has_sprite_construction = false;
		t.cost = new ConstructionCost(0, 15, 1, 100);
		t.upgrade_to = string.Empty;
		t.sound_built = "event:/SFX/BUILDINGS/SpawnBuildingStone";
		t.sound_destroyed = "event:/SFX/BUILDINGS/DestroyBuildingStone";
	private void addOrcs()
	private void addElves()
	private void addDwarves()
	public void setGrowBiomeAround(string pID, int pMaxSteps, int pWorkers, float pStepInterval, CreepWorkerMovementType pMovementType)
		t.grow_creep_step_interval = pStepInterval;
	public override void editorDiagnostic()
				BaseAssetLibrary.logAssetError("BuildingLibrary: SB class does not have property", item.id);
				BaseAssetLibrary.logAssetError("BuildingLibrary: SB class does not have type property", item.type);
	public void clear()
		for (int i = 0; i < list.Count; i++)
	public override BuildingAsset add(BuildingAsset pAsset)
	public string addToGameplayReport()
		string text = "##### Buildings: \n\n";
		int num = 35;
		int num2 = 35;
	private void addLine(ref string pLineInfo, string pText, int pSize)
public enum BuildingList
public class BuildingManager : SimSystemManager<Building, BuildingData>
	private List<WorldTile> _temp_list_tiles = new List<WorldTile>();
	private JobManagerBuildings _job_manager;
	private Building[] _array_visible_buildings = new Building[0];
	private int _visible_buildings_count;
	public BuildingRenderData render_data = new BuildingRenderData(4096);
	public HashSet<Building> occupied_buildings = new HashSet<Building>();
	public List<Building> visible_stockpiles = new List<Building>();
	public List<Building> sparkles = new List<Building>();
	public MultiStackPool<BaseBuildingComponent> component_pool = new MultiStackPool<BaseBuildingComponent>();
	private bool _need_normal_check;
	public BuildingManager()
	public override void clear()
	protected override void destroyObject(Building pBuilding)
	public override void update(float pElapsed)
	public override void loadFromSave(List<BuildingData> pList)
	internal Building addBuilding(string pID, WorldTile pTile, bool pCheckForBuild = false, bool pSfx = false, BuildPlacingType pType = BuildPlacingType.New)
	internal Building addBuilding(BuildingAsset pAsset, WorldTile pTile, bool pCheckForBuild = false, bool pSfx = false, BuildPlacingType pType = BuildPlacingType.New)
	protected override void addObject(Building pObject)
	public override Building loadObject(BuildingData pData)
	internal bool canBuildFrom(WorldTile pTile, BuildingAsset pNewBuildingAsset, City pCity, BuildPlacingType pType = BuildPlacingType.New, bool pFloraGrowth = false)
		bool flag = subspecies != null && pNewBuildingAsset.city_building && pNewBuildingAsset.check_for_adaptation_tags;
		int num = pTile.x - fundament.left;
		int num2 = pTile.y - fundament.bottom;
		int width = fundament.width;
		int height = fundament.height;
		bool flag2 = false;
		bool flag3 = false;
		bool docks = pNewBuildingAsset.docks;
		bool flag4 = !WorldLawLibrary.world_law_roots_without_borders.isEnabled();
		bool flag5 = pType == BuildPlacingType.New && Randy.randomChance(0.1f);
		for (int i = 0; i < width; i++)
	private bool isBuildingNearby(WorldTile pTile)
	public Building getNearbyBuildingToLive(Actor pActor, bool pOnlyBuilt)
				if (buildingFromZone.isUnderConstruction())
			else if (!buildingFromZone.isUnderConstruction())
	public IEnumerable<Building> getBuildingFromZones(WorldTile pTile, float pRadius)
		float num = pRadius / 8f;
		int tSize = (int)num + 1;
		int startX = pTile.zone.x - tSize;
		int startY = pTile.zone.y - tSize;
		for (int iX = 0; iX < tSize * 2; iX++)
	private IEnumerable<Building> checkZoneForBuilding(WorldTile pTile, TileZone pZone, float pRadius)
		float tRadius = pRadius * pRadius;
	public void debugJobManager(DebugTool pTool)
	private void prepareLists()
	internal void calculateVisibleBuildings()
	private void fillVisibleObjects()
		int count = visibleZones.Count;
		int num = 0;
		for (int i = 0; i < count; i++)
	private void precalculateRenderDataParallel()
		bool tNeedShadows = World.world.quality_changer.shouldRenderBuildingShadows();
		int tTotalVisibleObjects = _visible_buildings_count;
		bool[] tRenderFlipXStates = render_data.flip_x_states;
		bool[] tRenderShadows = render_data.shadows;
		int tDynamicBatchSize = 256;
		int toExclusive = ParallelHelper.calcTotalBatches(tTotalVisibleObjects, tDynamicBatchSize);
		bool tNeedNormalCheck = false;
		Parallel.For(0, toExclusive, World.world.parallel_options, delegate(int pBatchIndex)
	private void precalculateRenderDataNormal()
		int visible_buildings_count = _visible_buildings_count;
		for (int i = 0; i < visible_buildings_count; i++)
	public Building[] getVisibleBuildings()
	public int countVisibleBuildings()
	public void checkWobblySetting()
		bool flag = PlayerConfig.optionEnabled("tree_wind", OptionType.Bool);
		using IEnumerator<Building> enumerator2 = GetEnumerator();
		while (enumerator2.MoveNext())
			Building current3 = enumerator2.Current;
	public JobManagerBuildings getJobManager()
public class BuildingMapIcon
	private BuildingColorPixel[][] _tex;
	private BuildingColorPixel _clear_color_pixel = new BuildingColorPixel(Toolbox.clear, Toolbox.clear, Toolbox.clear);
	private int _width;
	private int _height;
	public BuildingMapIcon(Sprite sprite)
		for (int i = 0; i < _height; i++)
	internal Color32 getColor(int pX, int pY, Building pBuilding)
		bool flag = false;
public class BuildingMonolith : BaseBuildingComponent
	private const float ACTION_INTERVAL = 10f;
	private float _action_timer = 10f;
	public override void update(float pElapsed)
	internal void doMonolithAction(WorldTile pFromTile, bool pForce = false)
		if (!WorldLawLibrary.world_law_evolution_events.isEnabled())
		int num = 3;
		int num2 = 0;
	public void spawnMainEffect()
public delegate Sprite BuildingOverrideMainSprite(Building pBuilding);
public delegate Sprite[] BuildingOverrideMainSprites(Building pBuilding);
public enum BuildingOwnershipState
public class BuildingRenderData
	public Vector3[] positions;
	public Vector3[] scales;
	public Vector3[] rotations;
	public Sprite[] colored_sprites;
	public Sprite[] main_sprites;
	public Material[] materials;
	public bool[] flip_x_states;
	public Color[] colors;
	public bool[] shadows;
	public Sprite[] shadow_sprites;
	public BuildingRenderData(int pCapacity)
	public void checkSize(int pTargetSize)
public static class BuildingRendererSettings
	private const string material_building = "building";
	public static bool wobbly_material_enabled = true;
	public static string cur_default_material = "building";
public class BuildingSmokeEffect : BaseBuildingComponent
	private float smokeTimer;
	private Vector3 centerTopVec;
	internal override void create(Building pBuilding)
		float num = ((Vector2Int)(ref pos)).y;
	public override void update(float pElapsed)
		if (building.asset.smoke && !building.isUnderConstruction())
public class BuildingSpreadBiome : BaseBuildingComponent
	private const float SPREAD_INTERVAL_MIN = 8f;
	private const float SPREAD_INTERVAL_MAX = 16f;
	private const int SPREAD_RANGE = 2;
	private BiomeAsset _biome_asset;
	private float _spread_timer = 1f;
	internal override void create(Building pBuilding)
	public override void update(float pElapsed)
	private void spreadBiome()
	public override void Dispose()
public class BuildingSprites
	public Sprite construction;
	public BuildingMapIcon map_icon;
	public readonly List<BuildingAnimationData> animation_data = new List<BuildingAnimationData>();
public enum BuildingState
public delegate void BuildingStepAction(Actor pActor, Building pBuilding);
public class BuildingTower : BaseBuildingComponent
	protected float _check_targets_timeout = 1f;
	private bool _test_shooting;
	protected int _shooting_amount;
	private bool _shooting_active;
	protected BaseSimObject _shooting_target;
	public override void update(float pElapsed)
		if (!building.isUnderConstruction())
	protected void updateTestShooting()
	protected virtual void updateTower(float pElapsed)
	protected virtual void updateCheckTargets(float pElapsed)
	protected virtual void resetTimeout()
	protected virtual void shootAtTarget()
		float pTargetZ = 0f;
	protected virtual void projectileStarted()
	protected virtual void checkTargets()
	protected virtual BaseSimObject findTarget()
	public override void Dispose()
public static class BuildingTweenExtension
	internal static void checkTweens(this Building pBuilding)
	internal static void setScaleTween(this Building pBuilding, float pFrom = 0f, float pDuration = 0.2f, float pTarget = 1f, Action pActionOnComplete = null, EasingFunction pEase = null, int pPriority = 0)
		if (!scale_helper.active || scale_helper.scale_final_action == null || !(scale_helper.scale_last_priority >= (float)pPriority))
	public static void checkFinalAction(this Building pBuilding)
	internal static void finishScaleTween(this Building pBuilding)
	internal static void updateAngle(this Building pBuilding, float pElapsed)
	internal static void updateScale(this Building pBuilding)
public class BuildingTweenScaleHelper
	internal bool active;
	internal float scale_start;
	internal float scale_target = 1f;
	internal double scale_time;
	internal float scale_duration = 1f;
	internal float scale_last_priority;
	internal bool scale_use_x;
	internal Action scale_final_action;
	internal EasingFunction scale_ease;
	public float angle_target;
	public float angle_duration;
	public float angle_time;
	internal Action angle_final_action;
	public void doRotateTween(float pTargetAngle, float pDuration, Action pAction)
	public void reset()
public enum BuildingType
public abstract class BuildingWaypoint : BaseBuildingComponent
	private const int UNITS_AFFECTED_PER_ACTION = 5;
	private const float ACTION_INTERVAL = 20f;
	private float _action_timer = 20f;
	protected abstract string effect_id { get; }
	protected abstract string trait_id { get; }
	public override void update(float pElapsed)
	internal void doAction(WorldTile pFromTile)
		int num = 0;
	public void spawnMainEffect()
public class BuildingWaypointAlienMold : BuildingWaypoint
	protected override string effect_id => "fx_waypoint_alien_mold_launch_bottom";
	protected override string trait_id => "desire_alien_mold";
public class BuildingWaypointComputer : BuildingWaypoint
	protected override string effect_id => "fx_waypoint_computer_launch_bottom";
	protected override string trait_id => "desire_computer";
public class BuildingWaypointGoldenEgg : BuildingWaypoint
	protected override string effect_id => "fx_waypoint_golden_egg_launch_bottom";
	protected override string trait_id => "desire_golden_egg";
public class BuildingWaypointHarp : BuildingWaypoint
	protected override string effect_id => "fx_waypoint_harp_launch_bottom";
	protected override string trait_id => "desire_harp";
public class BuildingZonesSystem
	private static bool _dirty;
	public static void setDirty()
	public static void update()
		for (int i = 0; i < zones.Count; i++)
		for (int j = 0; j < listPool.Count; j++)
public class BuildOrder : Asset
	public int required_pop;
	public int required_buildings;
	public int limit_type;
	public bool check_full_village;
	public bool check_house_limit;
	public int min_zones;
	public bool upgrade;
	public string[] requirements_orders;
	public string[] requirements_types;
	public BuildingAsset getBuildingAsset(City pCity, string pOrderID = null)
		if (string.IsNullOrEmpty(pOrderID))
public class BuildOrderLibrary : AssetLibrary<CityBuildOrderAsset>
	public static BuildOrder b;
	public override void init()
	private void initCivsBasic()
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0", "order_statue");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
	private void initCivsBasic2()
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
	private void initCivsAdvanced()
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_tent");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_0", "order_house_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1", "order_house_1");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1", "order_house_2");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_2", "order_house_3");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_2", "order_house_4");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_house_1");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_statue", "order_mine", "order_barracks");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_docks_0");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_hall");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_barracks");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_0");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_bonfire", "order_hall_1", "order_statue");
		b.requirements_orders = AssetLibrary<CityBuildOrderAsset>.a<string>("order_hall_1");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
		b.requirements_types = AssetLibrary<CityBuildOrderAsset>.a<string>("type_bonfire", "type_hall");
	public override void linkAssets()
public enum BuildPlacingType
public class BurnedTilesLayer : MapLayer
	public Color color;
	private WorldBehaviour worldBehaviour;
	internal override void create()
	public void setTileDirty(WorldTile pTile)
	protected override void UpdateDirty(float pElapsed)
public class ButtonAnimation : MonoBehaviour
	public static float scaleTime = 0.1f;
	private IEnumerator newAnim()
	public void clickAnimation()
public class ButtonClickMaptemplate : MonoBehaviour
	private sealed class _003C_003Ec
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();
		public static UnityAction _003C_003E9__2_1;
		internal void _003CAwake_003Eb__2_1()
	private Button _button;
	private MapGenTemplate _template;
	private void Awake()
		string name = ((Object)((Component)this).transform).name;
	private void showTooltip()
	public void click()
public class ButtonDestroyer : MonoBehaviour
	private void Awake()
public class ButtonEmail : MonoBehaviour
	public void SendEmail()
		string text = "supworldbox@gmail.com";
		string text2 = convert("WorldBox Feedback ( " + Application.version + " )");
		string text3 = convert("Yo!\r\n");
	public void SendEmailLogs()
		string text = "supworldbox+errors@gmail.com";
		string text2 = convert("WorldBox Error Logs ( " + Application.version + " )");
		string text3 = convert("Please take a look at this error :\r\n" + LogHandler.log.Substring(Math.Max(0, LogHandler.log.Length - 4000)));
	private string convert(string url)
public class ButtonEvent : MonoBehaviour
	public static int premium_restore_opened;
	public static int premium_restore_action_pressed;
	public static int premium_more_help_pressed;
	public void clickGenerateMap(string pValue)
	public void clickPremiumButton()
	public void clickPossess()
	public void openUnitTabTraitsEditor()
	public void openUnitTabEquipmentEditor()
	public void openUnitTabMind()
	public void openUnitTabGenealogy()
	public void openUnitTabPlot()
	public void openUnitSpectate()
	public void openSettings()
	public void openSavesList()
	public void openPremiumHelp()
	public void openPremiumHelpFaq()
	public void openPatchNotes()
	public void clickRewardAds()
	public void showWindow(string pID)
	public void locateSelectedVillage()
	public void locateSelectedUnit()
	public void locateSelectedArmy()
	public void startLoadSaveSlot()
	public void clickSaveSlot()
	public void confirmDeleteWorld()
	public void startTutorialBear()
	public void showRewardedAd()
		PlayerConfig.instance.data.powerReward = string.Empty;
	public void showRewardedSaveSlotAd()
	public void hideRewardWindowAndHighlightPower()
		if (!(PlayerConfig.instance.data.lastReward != string.Empty))
		PlayerConfig.instance.data.lastReward = string.Empty;
	public void clickUnHideUI()
	public void closeActivePowerBar()
	public void clickOpenMain()
	public void clickBackTab()
	public void restorePurchases()
	public void debugUnlockAll()
	public void debugClearAllProgress()
	public void debugClearAchievements()
	public void debugUnlockAllAchievements()
	public void debugClearBannedSignals()
public static class ButtonExtensions
	public static void TriggerHover(this Button button)
	public static void OnHover(this Button button, UnityAction call)
	public static void OnHoverOut(this Button button, UnityAction call)
	public static void OnHover(this Slider slider, UnityAction call)
	public static void OnHoverOut(this Slider slider, UnityAction call)
public class ButtonGraphCategory : MonoBehaviour
	public Sprite sprite_on;
	public Sprite sprite_off;
	public Sprite sprite_on_light;
	private Image _button_graphics;
	private Image _icon;
	public bool is_on;
	private GraphCategoriesContainer _main_container;
	private Text _text;
	private Image _colored_circle;
	private Image _background_circle;
	private TipButton _tip_button;
	private HistoryDataAsset _asset;
	private bool _initialized;
	private void Awake()
	public void init()
		_tip_button.hoverAction = delegate
	public void setAsset(HistoryDataAsset pAsset)
	private void Update()
	private void checkSpriteStatus()
	private void switchCategory()
	private void showTooltip()
	public void turnOff()
	public void turnOn()
public class ButtonGraphListCompare : MonoBehaviour
	public void compareListItems()
public class ButtonGraphScale : MonoBehaviour
	public Sprite sprite_on;
	public Sprite sprite_off;
	public GraphTimeScale button_scale;
	private GraphTimeScaleContainer _main_container;
	private GraphController _graph_controller;
	private Image _image;
	private void Awake()
	private void Update()
	private void checkSpriteStatus()
	public void setScale()
public class ButtonGraphScalePlusMinus : MonoBehaviour
	public ButtonGraphScaleType button_scale_type;
	private GraphTimeScaleContainer _main_container;
	private GraphController _graph_controller;
	private void Awake()
	public void setScale()
public enum ButtonGraphScaleType
public class ButtonPremium : MonoBehaviour
	public void clickPremium()
		if ((int)Application.internetReachability == 0)
public class ButtonResource : MonoBehaviour
	public Text textAmount;
	public ResourceAsset asset;
	public static float scaleTime = 0.1f;
	private void Start()
	internal void load(ResourceAsset pAsset, int pAmount)
	private void showHoverTooltip()
	private void showTooltip()
		string tooltip = asset.tooltip;
	private void OnDestroy()
public class ButtonSfx : MonoBehaviour
	private Button _button;
	private void Start()
	private void playSound()
public class ButtonSocial : MonoBehaviour
	private SocialType _social_type;
	private Text _text;
	private void Awake()
	public void openFacebook()
	public void openTwitter()
	public void openDiscord()
	public void openLinkReddit()
	public void openLinkMoonBox()
	public void openLinkSteam()
		string text = string.Concat($"https://store.steampowered.com/app/{1206560u}/" + "?utm_source=game_bar", "&utm_campaign=get_wishlists");
public class ButtonsViewer : MonoBehaviour
	private List<PowerButton> buttons;
	private Transform content;
	private float lastX;
	private float lastY;
	private Canvas canvas;
	private void Start()
		for (int i = 0; i < ((Component)this).transform.childCount; i++)
	private void Update()
		int num = 0;
		int num2 = 0;
		bool flag = false;
		for (int i = 0; i < buttons.Count; i++)
public delegate void ButtonTipLoader(Transform pButton, BaseUnlockableAsset pAsset);
public delegate TooltipData ButtonTooltipLoader(Transform pButton, BaseUnlockableAsset pAsset);
public class ButtonTranslate : MonoBehaviour
	public void openLink()
public struct ButtonTrigger
	public Button button { get; }
	public Entry entry { get; }
	public int index { get; }
	public ButtonTrigger(Button pButton, Entry pEntry, int pIndex)
public class ButtonTwitter : MonoBehaviour
	public void openLink()
public class ButtonUtil : MonoBehaviour
	private Button _button;
	public void ResetState()
	private void playSound()
public class ButtonVersionUpdate : MonoBehaviour
	public void openLink()
public class ButtonVote : MonoBehaviour
	public void openLink()
public class ButtonWebsite : MonoBehaviour
	public void openLink()
	public void openLinkLSFLW2()
	public void openPatchLog()
public class ButtonWorldnet : MonoBehaviour
	public void clickWorldNet()
	public void clickCancel()
public class CameraRender : MonoBehaviour
	public Material PostProcessMaterial;
	public Camera BackgroundCamera;
	public Camera MainCamera;
	private RenderTexture mainRenderTexture;
	private void Start()
	private void Update()
	private void OnPostRender()
public class CancelButton : MonoBehaviour
	public Image powerIcon;
	public bool goUp;
	public bool goDown;
	private bool _going_down;
	private bool _going_up;
	private RectTransform _rect;
	private float _timer;
	private const float Y_TOP_TARGET = 90f;
	private void Awake()
	public void setIconFrom(PowerButton pButton)
	private void Update()
public class CanvasMain : MonoBehaviour
	public static CanvasMain instance;
	public static float tooltip_show_timeout;
	public Canvas canvas_ui;
	public Canvas canvas_windows;
	public Canvas canvas_map_names;
	public Canvas canvas_tooltip;
	public Image blocker;
	private ScreenOrientation screenOrientation;
	private CanvasScaler scaler_main_ui;
	private CanvasScaler scaler_windows_ui;
	private CanvasScaler scaler_tooltip;
	private CanvasScaler scaler_map_names;
	public Transform transformWindows;
	private float last_width = -1f;
	private float last_height = -1f;
	private const int REFERENCE_SIZE_X = 285;
	private const int REFERENCE_SIZE_Y = 420;
	private ResizeAction _on_resize;
	private ResizeUIAction _on_resize_ui;
	private void Awake()
	public bool setMainUiEnabled(bool pEnabled)
	public float getLastWidth()
	public float getLastHeight()
	public void addCallbackResize(ResizeAction pAction)
	public void removeCallbackResize(ResizeAction pAction)
	public void addCallbackResizeUI(ResizeUIAction pAction)
	public void removeCallbackResizeUI(ResizeUIAction pAction)
	private void checkResize(float pWidth, float pHeight)
	public void resizeWindowsUI()
		float pUISize = (float)PlayerConfig.getIntValue("ui_size_windows") / 100f;
	public void resizeTooltipUI()
	public void resizeMapNames()
	public void resizeMainUI()
	private void changeCanvasSize(CanvasScaler pScaler, string pSizeOption, float pReferenceWidth, float pReferenceHeight)
		float num = 1f;
		num = (float)PlayerConfig.getIntValue(pSizeOption) / 100f;
		float num2 = 2f - num;
	private void Start()
	private void Update()
		if ((float)Screen.width != last_width || (float)Screen.height != last_height)
	public static void addTooltipShowTimeout(float pTime)
	public static bool isBottomBarShowing()
	public static bool isNameplatesAllowed()
public class CanvasNotch : MonoBehaviour
	private bool screenChangeVarsInitialized;
	private bool ranFirstTime;
	private ScreenOrientation lastOrientation = (ScreenOrientation)5;
	private Vector2 lastResolution = Vector2.zero;
	private Rect lastSafeArea = Rect.zero;
	private Rect lastCanvasRect = Rect.zero;
	private RectTransform safeAreaTransform;
	private Canvas _canvas;
	private void Awake()
	private void Start()
	private void Update()
		if ((float)Screen.width != lastResolution.x || (float)Screen.height != lastResolution.y)
	private void ApplySafeArea()
	private void OrientationChanged()
	private void ResolutionChanged()
	private void SafeAreaChanged()
	private void CanvasChanged()
	private void debugConsole()
		Dictionary<string, Rect> dictionary = new Dictionary<string, Rect>();
		dictionary["screen"] = new Rect(0f, 0f, (float)Screen.width, (float)Screen.height);
		foreach (string key in dictionary.Keys)
		foreach (string key2 in dictionary.Keys)
public class CapturingZonesCalculator
	private static int _zoneTicks = 0;
	private static Queue<TileZone> _currentWave = new Queue<TileZone>();
	private static Queue<TileZone> _nextWave = new Queue<TileZone>();
	private static HashSet<TileZone> _waveChecked = new HashSet<TileZone>();
	public static void getListToDraw(City pCity, int pTicks, ListPool<TileZone> pResults)
	private static void check(TileZone pTargetZone, City pCity)
public enum CastEntity
public enum CastTarget
public class CategoryData : IDisposable
	private LinkedList<Dictionary<string, long>> _data = new LinkedList<Dictionary<string, long>>();
	internal ListPool<object> db_list;
	public LinkedListNode<Dictionary<string, long>> Last => _data.Last;
	public int Count => _data.Count;
	public LinkedListNode<Dictionary<string, long>> AddLast(Dictionary<string, long> pDict)
	public void Clear()
		foreach (Dictionary<string, long> datum in _data)
	public void Dispose()
public class CenterTipCaller : MonoBehaviour
	public string tip_title;
	public string tip_id;
	public void Show()
public class ChainElement : TraitButton<GeneAsset>
	public Image chain_left;
	public Image chain_right;
	public Image chain_up;
	public Image chain_down;
	internal int locus_index = -1;
	protected GeneAsset gene => augmentation_asset;
	public GeneAsset getGeneAsset()
	public override void load(GeneAsset pAsset)
	public void colorChains()
	protected void hideChains()
	protected void showChain(Image pChainImage, bool pShow, char pGeneticCode, Color? pColor = null)
	protected void hideChain(Image pChain)
	protected void colorChain(Image pChain, Color pColor)
public class ChangeTextInHindi : MonoBehaviour
	private void Start()
		string text = ((Component)this).gameObject.GetComponent<Text>().text;
public class Character : ScriptableObject
	public string name_first;
	public string name_last;
	public string name_nickname;
	public int age;
	public object religion;
	public object preferences;
	public object perks;
public delegate bool CheckActorHasMeta(Actor pActor);
public class Chromosome
	private const string IMAGE_PATH_NORMAL = "chromosomes/normal/";
	private const string IMAGE_PATH_GOLD = "chromosomes/golden/";
	private const string STRING_UNKOWN = "???????";
	private const string COLOR_BOUND = "#444444";
	private const string COLORED_UNKOWN_TEXT = "<color=#444444>???????</color>";
	public readonly List<GeneAsset> genes = new List<GeneAsset>();
	private readonly BaseStats _merged_base_stats_male = new BaseStats();
	private readonly BaseStats _merged_base_stats_female = new BaseStats();
	private readonly BaseStats _merged_base_stats = new BaseStats();
	private readonly BaseStats _merged_base_stats_meta = new BaseStats();
	private static readonly (int, int)[] DIRECTIONS = new(int, int)[4]
	private bool _dirty = true;
	private Sprite _cached_sprite;
	private int _cached_sprite_index = -1;
	public string chromosome_type;
	private readonly List<int> _loci_amplifiers = new List<int>();
	private readonly List<int> _loci_empty = new List<int>();
	private readonly BaseStats[] _base_stats_all = new BaseStats[4];
	private readonly int _columns;
	public Chromosome(string pType, bool pNew)
	public bool isLocusAmplifier(int pX, int pY)
		int indexFrom = getIndexFrom(pX, pY);
	public bool isLocusAmplifier(int pLocusIndex)
	public bool isVoidLocus(int pLocusIndex)
	public bool isSpecialLocusAt(int pX, int pY)
		int indexFrom = getIndexFrom(pX, pY);
	public bool isVoidLocusAt(int pX, int pY)
		int indexFrom = getIndexFrom(pX, pY);
	public bool isAllSidesVoidLocus(int pX, int pY)
		int num = countBounds(pX, pY);
		int num2 = 0;
	private bool isAmplifierLocusAt(int pX, int pY)
		int indexFrom = getIndexFrom(pX, pY);
	private bool isForcedSynergyAt(int pX, int pY)
	public bool isForcedSynergyLeft(int pX, int pY)
	public bool isForcedSynergyRight(int pX, int pY)
	public bool isForcedSynergyUp(int pX, int pY)
	public bool isForcedSynergyDown(int pX, int pY)
	public LocusType getLocusType(int pLocusIndex)
	public void fillStatsForTooltip(LocusElement pLocus, BaseStats pStatsContainer)
		int locus_index = pLocus.locus_index;
	private void generateAmplifiers(string pType)
		using ListPool<int> listPool = new ListPool<int>();
		for (int i = 0; i < chromosomeTypeAsset.amount_loci; i++)
		int num = Randy.randomInt(chromosomeTypeAsset.amount_loci_min_amplifier, chromosomeTypeAsset.amount_loci_max_amplifier);
		int num2 = Randy.randomInt(chromosomeTypeAsset.amount_loci_min_empty, chromosomeTypeAsset.amount_loci_max_empty);
		for (int j = 0; j < num; j++)
		for (int k = 0; k < num2; k++)
	public bool canAddGene(GeneAsset pAsset)
	public void setGene(GeneAsset pAsset, int pIndex)
	public GeneAsset getGene(int pIndex)
	public ChromosomeTypeAsset getAsset()
	public void load(ChromosomeData pData)
		foreach (string item in pData.loci)
		_loci_empty.AddRange(pData.void_loci);
	public ChromosomeData getDataForSave()
		chromosomeData.void_loci.AddRange(_loci_empty);
	public void addGene(GeneAsset pGeneAsset)
		for (int i = 0; i < genes.Count; i++)
	public bool isSpecialLocus(int pIndex)
	public bool canAddToLocus(int pIndex)
	public int countNonEmpty()
		int num = 0;
		for (int i = 0; i < genes.Count; i++)
	public int countEmpty()
		int num = 0;
		for (int i = 0; i < genes.Count; i++)
	public BaseStats getStats()
	public BaseStats getStatsMeta()
	public BaseStats getStatsMale()
	public BaseStats getStatsFemale()
	public void setDirty()
	public void recalculate()
		for (int i = 0; i < genes.Count; i++)
		for (int j = 0; j < genes.Count; j++)
	private void combineBonusesForSides(int pLocusIndex, BaseStats pBaseStatsMain)
		(int, int) xYFromIndex = getXYFromIndex(pLocusIndex);
		int item = xYFromIndex.Item1;
		int item2 = xYFromIndex.Item2;
		bool num = isNextToBad(pLocusIndex);
	private void getBonusesFromGene(int pX, int pY, BaseStats pBaseStatsMain, BaseStats pBaseStatsMeta = null, bool pCombineMeta = false)
	private void getBonusesFromGene(int pLocusIndex, BaseStats pBaseStatsMain, BaseStats pBaseStatsMeta = null, bool pCombineMeta = false)
		bool flag = hasFullSynergy(pLocusIndex);
		bool num = isNextToBad(pLocusIndex);
	private void clearAllBaseStats()
		for (int i = 0; i < base_stats_all.Length; i++)
	public bool hasFullSynergyAt(int pX, int pY)
		int num = 0;
		int num2 = 0;
	public bool hasFullSynergy(int pLocusIndex)
	public bool hasAnySynergy(int pLocusIndex)
	public string getSynergyTooltipText(int pLocusIndex)
		(int, int) xYFromIndex = getXYFromIndex(pLocusIndex);
		int item = xYFromIndex.Item1;
		int item2 = xYFromIndex.Item2;
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		bool flag = isBadAt(item, item2);
		stringBuilderPool.Append("\n");
		bool num = hasSynergyConnectionLeft(item, item2);
		bool flag2 = hasSynergyConnectionRight(item, item2);
		bool num2 = hasSynergyConnectionUp(item, item2);
		bool flag3 = hasSynergyConnectionDown(item, item2);
		bool flag4 = isForcedSynergyAt(item, item2);
		stringBuilderPool.Append("\n");
		stringBuilderPool.Append(" ... ");
		stringBuilderPool.Append("\n");
		stringBuilderPool.Append("\n");
		stringBuilderPool.Append("\n");
		return stringBuilderPool.ToString();
	private string getBadConnectionString()
	private string getNotConnectedText(char pChar, double pTime)
		string fullNucleobaseName = NucleobaseHelper.getFullNucleobaseName(pChar);
		string colorHex = NucleobaseHelper.getColorHex(pChar, pDark: true);
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		for (int i = 0; i < fullNucleobaseName.Length; i++)
		int num = pChar * 100;
		int index = (int)((pTime + (double)num) * 8.0 % (double)fullNucleobaseName.Length);
		stringBuilderPool[index] = '?';
		return Toolbox.coloredString(stringBuilderPool.ToString(), colorHex);
	private int getIndexFrom(int pX, int pY)
	public (int, int) getXYFromIndex(int pIndex)
		int item = pIndex % 6;
		int item2 = pIndex / 6;
	public Sprite getSpriteNormal()
	public Sprite getSpriteGolden()
	public void cloneFrom(Chromosome pParentChromosome)
	public void mutateRandomGene()
		using ListPool<int> listPool = new ListPool<int>();
		for (int i = 0; i < genes.Count; i++)
		int random = listPool.GetRandom();
	public bool hasGene(GeneAsset pAsset)
	public GeneAsset getGeneAtDirectionFrom(int pFromX, int pFromY, GeneDirection pDirection)
		(int, int) directionOffset = getDirectionOffset(pDirection);
		int item = directionOffset.Item1;
		int item2 = directionOffset.Item2;
		int pX = pFromX + item;
		int pY = pFromY + item2;
		int indexFrom = getIndexFrom(pFromX + item, pFromY + item2);
	public GeneAsset getGeneAt(int pFromX, int pFromY)
		int indexFrom = getIndexFrom(pFromX, pFromY);
	public GeneAsset getGeneLeft(int pFromX, int pFromY)
	public GeneAsset getGeneRight(int pFromX, int pFromY)
	public GeneAsset getGeneUp(int pFromX, int pFromY)
	public GeneAsset getGeneDown(int pFromX, int pFromY)
	private bool isIndexValid(int pIndex)
	private bool isCoordinatesValid(int pX, int pY)
	public (int, int) getDirectionOffset(GeneDirection pDirection)
	public bool canBeConnectedTo(int pFromX, int pFromY, int pToX, int pToY)
	public int countBounds(int pX, int pY)
		int num = 0;
	public bool hasSynergyConnectionLeft(int pFromX, int pFromY)
	public bool hasSynergyConnectionRight(int pFromX, int pFromY)
	public bool hasSynergyConnectionUp(int pFromX, int pFromY)
	public bool hasSynergyConnectionDown(int pFromX, int pFromY)
	public bool isAllLociSynergy()
		int num = -1;
	public bool hasAllSynergiesAt(int pFromX, int pFromY, bool pCheckBounds = true)
		bool num = (pCheckBounds ? hasSynergyConnectionLeft(pFromX, pFromY) : (hasBoundLeft(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Left)));
		bool flag = (pCheckBounds ? hasSynergyConnectionRight(pFromX, pFromY) : (hasBoundRight(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Right)));
		bool flag2 = (pCheckBounds ? hasSynergyConnectionUp(pFromX, pFromY) : (hasBoundUp(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Up)));
		bool flag3 = (pCheckBounds ? hasSynergyConnectionDown(pFromX, pFromY) : (hasBoundDown(pFromX, pFromY) || hasSynergyConnection(pFromX, pFromY, GeneDirection.Down)));
	public bool hasSynergyConnection(int pFromX, int pFromY, GeneDirection pDirection)
		bool flag = isAmplifierLocusAt(pFromX, pFromY);
		bool flag2 = false;
		(int, int) directionOffset = getDirectionOffset(pDirection);
		int item = directionOffset.Item1;
		int item2 = directionOffset.Item2;
		bool flag3 = isAmplifierLocusAt(pFromX + item, pFromY + item2);
	public bool isConnectionDeniedUp(int pFromX, int pFromY)
	public bool isConnectionDeniedDown(int pFromX, int pFromY)
	public bool isConnectionDeniedLeft(int pFromX, int pFromY)
	public bool isConnectionDeniedRight(int pFromX, int pFromY)
	public bool hasBoundAt(int pX, int pY)
	public bool hasBoundLeft(int pX, int pY)
	public bool hasBoundRight(int pX, int pY)
	public bool hasBoundUp(int pX, int pY)
	public bool hasBoundDown(int pX, int pY)
	public void fillEmptyLoci()
		for (int i = 0; i < genes.Count; i++)
	public bool isNextToBad(int pLocusIndex)
	public bool isNextToBad(int pX, int pY)
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
	public bool hasGenesAround(int pIndex)
	public bool hasGenesAround(int pX, int pY)
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
	public bool isNextToBadAmplifier(int pX, int pY)
		(int, int)[] dIRECTIONS = DIRECTIONS;
		for (int i = 0; i < dIRECTIONS.Length; i++)
	public bool isBadAt(int pX, int pY)
	public bool hasAmplifierBad(int pX, int pY)
	public void shuffleGenes()
		for (int i = 0; i < genes.Count; i++)
		for (int j = 0; j < genes.Count; j++)
public delegate void ChromosomeClickEvent(Chromosome pChromosome);
public class ChromosomeData
	public List<string> loci = new List<string>();
	public List<int> super_loci = new List<int>();
	public List<int> void_loci = new List<int>();
	public string chromosome_type = "chromosome_medium";
public class ChromosomeElement : MonoBehaviour
	private static readonly Color color_synergy_gold = Toolbox.makeColor("#FFF841");
	private static readonly Color color_normal_blue = Toolbox.makeColor("#00B0FF");
	internal Chromosome chromosome;
	private ChromosomeClickEvent _click_event;
	public Image image;
	private void Start()
	protected virtual void onStartDrag(DraggableLayoutElement pOriginalElement)
	private void clickChromosome()
		_click_event?.Invoke(chromosome);
	public void show(Chromosome pChromosome, ChromosomeClickEvent pClickEvent)
		_click_event = pClickEvent;
	protected virtual void setupTooltip()
	protected void tooltipAction()
public class ChromosomeTypeAsset : Asset, IDescriptionAsset, ILocalizedAsset
	public int amount_loci;
	public int amount_loci_min_amplifier;
	public int amount_loci_max_amplifier;
	public int amount_loci_min_empty;
	public int amount_loci_max_empty;
	public string name;
	public string description;
	public string getLocaleID()
	public string getDescriptionID()
public class ChromosomeTypeLibrary : AssetLibrary<ChromosomeTypeAsset>
	public const int LOCI_PER_ROW = 6;
	public override void init()
	public override void editorDiagnosticLocales()
public class ChunkObjectContainer : IDisposable
	public readonly List<long> kingdoms = new List<long>();
	public readonly List<Actor> units_all = new List<Actor>();
	public readonly List<Building> buildings_all = new List<Building>();
	private readonly HashSet<long> _hash_kingdoms = new HashSet<long>();
	private readonly Dictionary<long, List<Actor>> _dict_units = new Dictionary<long, List<Actor>>();
	private readonly Dictionary<long, List<Building>> _dict_buildings = new Dictionary<long, List<Building>>();
	private int _total_units;
	private int _total_buildings;
	public int total_units => _total_units;
	public int total_buildings => _total_buildings;
	public void reset(bool pClearBuildings)
	public List<Building> getBuildings(long pKingdom)
	public List<Actor> getUnits(long pKingdom)
	public bool isEmpty()
	public void addActor(Actor pActor)
	public void addBuilding(Building pBuilding)
	public void Dispose()
	public Dictionary<long, List<Building>>.ValueCollection getDebugBuildings()
	public Dictionary<long, List<Actor>>.ValueCollection getDebugUnits()
public class CircleIconShaderMod : MonoBehaviour
	public Material prefab_radial_fill;
	private Material _instance_material;
	public SpriteRenderer sprite_renderer_with_mat;
	private void Awake()
	public void setShaderVal(float pVal)
public class CitiesBannersContainer : BannersMetaContainer<CityBanner, City, CityData>
	protected override IEnumerable<City> getMetaList(IMetaObject pMeta)
public class CitiesKingdomsContainersController : MonoBehaviour
	private CitiesBannersContainer _banners_cities;
	private GameObject _line_cities;
	private KingdomsBannersContainer _banners_kingdoms;
	private GameObject _line_kingdoms;
	public void update(NanoObject pNano)
		bool active = obj.hasCities();
		bool active2 = obj.hasKingdoms();
public class CitiesMetaContainer : ListMetaContainer<CityListElement, City, CityData>
	protected override IEnumerable<City> getMetaList()
	protected override Comparison<City> getSorting()
public class CitiesNoItems : MetaListNoItems
	protected override bool hasMetas()
public class CitizenJobAsset : Asset
	public string path_icon;
	public int priority;
	public int priority_no_food;
	public bool common_job = true;
	public bool ok_for_king = true;
	public bool ok_for_leader = true;
	public bool only_leaders;
	public CitizenJobCondition should_be_assigned;
	public string unit_job_default;
	public DebugOption debug_option;
public delegate bool CitizenJobCondition(Actor pActor);
public class CitizenJobLibrary : AssetLibrary<CitizenJobAsset>
	public List<CitizenJobAsset> list_priority_normal;
	public List<CitizenJobAsset> list_priority_high;
	public List<CitizenJobAsset> list_priority_high_food;
	public static CitizenJobAsset builder;
	public static CitizenJobAsset gatherer_bushes;
	public static CitizenJobAsset gatherer_herbs;
	public static CitizenJobAsset gatherer_honey;
	public static CitizenJobAsset farmer;
	public static CitizenJobAsset hunter;
	public static CitizenJobAsset woodcutter;
	public static CitizenJobAsset miner;
	public static CitizenJobAsset miner_deposit;
	public static CitizenJobAsset road_builder;
	public static CitizenJobAsset cleaner;
	public static CitizenJobAsset manure_cleaner;
	public static CitizenJobAsset attacker;
	public override void init()
	public override void post_init()
	public override void linkAssets()
public class CitizenJobs
	public Dictionary<CitizenJobAsset, int> jobs = new Dictionary<CitizenJobAsset, int>();
	public Dictionary<CitizenJobAsset, int> occupied = new Dictionary<CitizenJobAsset, int>();
	private int _total_tasks;
	public void clear()
	public int getTotalTasks()
	public bool hasAnyTask()
	public void clearJobs()
	public void addToJob(CitizenJobAsset pJobAsset, int pValue)
	public bool continueJob(CitizenJobAsset pJobAsset)
	public int countOccupied(CitizenJobAsset pJobAsset)
	public int countCurrentJobs(CitizenJobAsset pJobAsset)
	public bool hasJob(CitizenJobAsset pJobAsset)
	public void takeJob(CitizenJobAsset pJobAsset)
	public void freeJob(CitizenJobAsset pJobAsset)
public class City : MetaObject<CityData>
	private static readonly HashSet<City> _connected_checked = new HashSet<City>();
	private static readonly HashSet<City> _connected_next_wave = new HashSet<City>();
	private static readonly HashSet<City> _connected_current_wave = new HashSet<City>();
	private readonly Dictionary<string, CityStorageSlot> _total_resource_slots = new Dictionary<string, CityStorageSlot>();
	private readonly Dictionary<UnitProfession, List<Actor>> _professions_dict = new Dictionary<UnitProfession, List<Actor>>();
	private readonly List<Actor> _boats = new List<Actor>();
	private readonly Dictionary<string, long> _species = new Dictionary<string, long>();
	public readonly List<Building> buildings = new List<Building>();
	public readonly Dictionary<string, List<Building>> buildings_dict_type = new Dictionary<string, List<Building>>();
	public readonly Dictionary<string, List<Building>> buildings_dict_id = new Dictionary<string, List<Building>>();
	public readonly CityTasksData tasks = new CityTasksData();
	public readonly CitizenJobs jobs = new CitizenJobs();
	public readonly CityStatus status = new CityStatus();
	public float mark_scale_effect;
	internal Kingdom kingdom;
	public Culture culture;
	public Language language;
	public Religion religion;
	public Actor leader;
	public Army army;
	internal readonly List<TileZone> zones = new List<TileZone>();
	internal readonly HashSet<TileZone> neighbour_zones = new HashSet<TileZone>();
	internal readonly HashSet<TileZone> border_zones = new HashSet<TileZone>();
	internal readonly HashSet<City> neighbours_cities = new HashSet<City>();
	internal readonly HashSet<City> neighbours_cities_kingdom = new HashSet<City>();
	internal readonly HashSet<Kingdom> neighbours_kingdoms = new HashSet<Kingdom>();
	internal Building under_construction_building;
	internal readonly List<Building> stockpiles = new List<Building>();
	internal readonly List<Building> storages = new List<Building>();
	internal float timer_build_boat;
	internal float timer_build;
	public float timer_action;
	private float _timer_capture;
	private float _timer_warrior;
	internal readonly List<WorldTile> road_tiles_to_build = new List<WorldTile>();
	private readonly List<WorldTile> tiles_to_remove = new List<WorldTile>();
	internal TileZone target_attack_zone;
	internal City target_attack_city;
	internal WorldTile _city_tile;
	internal string _debug_last_possible_build_orders;
	internal string _debug_last_possible_build_orders_no_resources;
	internal string _debug_last_build_order_try;
	internal Kingdom being_captured_by;
	private float _capture_ticks;
	public int last_visual_capture_ticks;
	private bool _dirty_citizens;
	private bool _dirty_city_status;
	private bool _dirty_abandoned_zones;
	internal Vector2 city_center;
	internal Vector2 last_city_center;
	public readonly WorldTileContainer calculated_place_for_farms = new WorldTileContainer();
	public readonly WorldTileContainer calculated_farm_fields = new WorldTileContainer();
	public readonly WorldTileContainer calculated_crops = new WorldTileContainer();
	public readonly WorldTileContainer calculated_grown_wheat = new WorldTileContainer();
	private readonly Dictionary<Kingdom, int> _capturing_units = new Dictionary<Kingdom, int>();
	internal readonly HashSet<TileZone> danger_zones = new HashSet<TileZone>();
	public AiSystemCity ai;
	private int _current_total_food;
	private int _last_checked_job_id;
	private double _loyalty_last_time;
	private int _loyalty_cached;
	private readonly List<long> _cached_book_ids = new List<long>();
	private readonly List<Building> _cached_buildings_with_book_slots = new List<Building>();
	public double timestamp_shrink;
	private int _storage_version;
	protected override MetaType meta_type => MetaType.City;
	public override BaseSystemManager manager => World.world.cities;
	protected override bool track_death_types => true;
	public int amount_wood => getResourcesAmount("wood");
	public int amount_gold => getResourcesAmount("gold");
	public int amount_stone => getResourcesAmount("stone");
	public int amount_common_metals => getResourcesAmount("common_metals");
	public int getStorageVersion()
	public override void increaseBirths()
	public void increaseLeft()
	public void increaseJoined()
	public void increaseMoved()
	public void increaseMigrants()
	public long getTotalLeft()
	public long getTotalJoined()
	public long getTotalMoved()
	public long getTotalMigrated()
	public bool isZoneToClaimStillGood(Actor pActor, TileZone pZone, WorldTile pCityTile)
	internal override void clearListUnits()
	public override ActorAsset getActorAsset()
	public ActorAsset getFounderSpecies()
	public CityLayoutTilePlacement getTilePlacementFromZone()
	public string getSpecies()
	public override bool isReadyForRemoval()
	public void clearBuildingList()
	public override void listUnit(Actor pActor)
	public Subspecies getSubspecies(string pSpeciesId)
	public long getSubspeciesId(string pSpeciesId)
	public bool hasFreeHouseSlots()
	public bool hasReachedWorldLawLimit()
	public void listBuilding(Building pBuilding)
	public WorldTile getTile(bool pForceRecalc = false)
	internal void recalculateCityTile()
		for (int i = 0; i < list.Count; i++)
	internal int countInHouses()
		int num = 0;
		for (int i = 0; i < list.Count; i++)
	public int countBookSlots()
		int num = 0;
		for (int i = 0; i < _cached_buildings_with_book_slots.Count; i++)
	public bool hasBookSlots()
		int num = countBookSlots();
	public Building getBuildingWithBookSlot()
	public int countBooks()
	private void setKingdomTimestamp()
	public override ColorAsset getColor()
	internal void setKingdom(Kingdom pKingdom, bool pFromLoad = false)
	internal void newForceKingdomEvent(List<Actor> pUnits, List<Actor> pBoats, Kingdom pKingdom, string pHappinessEvent)
	internal void forceBuildingsToKingdom(List<Building> pBuildings, Kingdom pKingdom)
		for (int i = 0; i < pBuildings.Count; i++)
	internal void forceUnitsIntoThisKingdom(List<Actor> pActors, Kingdom pKingdom, bool pBoats, string pHappinessEvent = null)
		for (int j = 0; j < pActors.Count; j++)
	internal Building getStorageNear(WorldTile pTile, bool pOnlyFood = false)
		int num = int.MaxValue;
		for (int i = 0; i < list.Count; i++)
	internal Building getStorageWithFoodNear(WorldTile pTile)
		int num = int.MaxValue;
		for (int i = 0; i < list.Count; i++)
	internal bool hasStorageBuilding()
		for (int i = 0; i < list.Count; i++)
			if (!list[i].isUnderConstruction())
	public WorldTile getRoadTileToBuild(Actor pBuilder)
		for (int i = 0; i < road_tiles_to_build.Count; i++)
		for (int j = 0; j < tiles_to_remove.Count; j++)
	internal void init()
	private void createAI()
			ai.addSingleTask("check_destruction");
	protected sealed override void setDefaultValues()
	private string getNextJob()
	public bool isValidTargetForWar()
	public bool hasZones()
	public bool needSettlers()
		int populationPeople = getPopulationPeople();
	internal void generateName(Actor pActor)
		string pName = pActor.generateName(MetaType.City, getID());
	public void loadLeader()
	public void newCityEvent(Actor pActor)
	private void loadCityZones(List<ZoneData> pZoneData)
		for (int i = 0; i < pZoneData.Count; i++)
	public void loadCity(CityData pData)
	public void forceDoChecks()
	public void executeAllActionsForCity()
	public void eventUnitAdded(Actor pActor)
	public void eventUnitRemoved(Actor pActor)
	public void setAbandonedZonesDirty()
	public void setCitizensDirty()
	public void setStatusDirty()
	private void sortZonesByDistanceToCenter()
	private void updateCityStatus()
		int num = countPopulationChildren();
		for (int i = 0; i < list2.Count; i++)
		for (int j = 0; j < list.Count; j++)
			if (!building.isUnderConstruction() && building.asset.hasHousingSlots())
	private void recalculateMaxHouses()
		float num = zones.Count;
		status.houses_max = (int)num;
	public bool hasBooksToRead(Actor pActor)
	public bool hasBooksOfLanguage(Language pLanguage)
		int i = 0;
		for (int num = countBooks(); i < num; i++)
	public Book getRandomBookOfLanguage(Language pLanguage)
		int i = 0;
		for (int num = countBooks(); i < num; i++)
	public Book getRandomBook()
		int i = 0;
		for (int num = countBooks(); i < num; i++)
	public List<long> getBooks()
	public int getHouseCurrent()
	public int getHouseLimit()
	public bool isConnectedToCapital()
		int num = 0;
	public void recalculateNeighbourCities()
	public void recalculateNeighbourZones()
		for (int i = 0; i < list.Count; i++)
	internal void setCulture(Culture pCulture)
	public Culture getCulture()
	public Language getLanguage()
	public Religion getReligion()
	public void checkAbandon()
	public void update(float pElapsed)
	private void turnCityToNeutral()
	private void makeBoatsAbandonCity()
	private void updateTotalFood()
	private void updateCapture(float pElapsed)
		if ((int)_capture_ticks != last_visual_capture_ticks)
		int num = countBuildingsType("type_watch_tower");
		bool flag = false;
		bool flag2 = false;
	public bool isGettingCaptured()
	public bool isGettingCapturedBy(Kingdom pKingdom)
	public Kingdom getCapturingKingdom()
	private void clearCapture()
	public float getCaptureTicks()
	private void prepareProfessionDicts()
			for (int i = 0; i < ProfessionLibrary.list_enum_profession_ids.Length; i++)
				UnitProfession key = ProfessionLibrary.list_enum_profession_ids[i];
	private void updateCitizens()
		for (int i = 0; i < list.Count; i++)
	public bool canGrowZones()
	internal int countProfession(UnitProfession pType)
	public void destroyCity()
	public override void Dispose()
		under_construction_building = null;
	public bool hasAttackZoneOrder()
	internal void spendResourcesForBuildingAsset(ConstructionCost pCost)
	internal bool hasEnoughResourcesFor(ConstructionCost pCost)
	internal Building getBuildingToBuild()
		if (under_construction_building != null && (!under_construction_building.isAlive() || !under_construction_building.isUnderConstruction()))
			under_construction_building = null;
		return under_construction_building;
	internal bool hasBuildingToBuild()
		if (under_construction_building != null)
			if (!under_construction_building.isAlive() || !under_construction_building.isUnderConstruction())
				under_construction_building = null;
	internal void setBuildingDictType(Building pBuilding)
	internal List<Building> getBuildingListOfID(string pBuildingID)
	public int countZones()
	public int countBuildings()
	public int countBuildingsOfID(string pBuildingID)
	internal void setBuildingDictID(Building pBuilding)
	public int countBuildingsType(string pBuildingTypeID, bool pCountOnlyFinished = true)
					if (!item.isUnderConstruction())
	internal bool hasBuildingType(string pBuildingTypeID, bool pCountOnlyFinished = true, TileIsland pLimitIsland = null)
		bool flag = pLimitIsland != null;
			if ((!pCountOnlyFinished || (!item.isUnderConstruction() && item.isUsable())) && (!flag || item.current_island == pLimitIsland))
	internal List<Building> getBuildingListOfType(string pType)
	internal Building getBuildingOfType(string pBuildingTypeID, bool pCountOnlyFinished = true, bool pRandom = false, bool pOnlyFreeTile = false, TileIsland pLimitIsland = null)
		bool flag = pLimitIsland != null;
		IEnumerable<Building> enumerable2;
			IEnumerable<Building> enumerable = buildingListOfType;
			enumerable2 = enumerable;
			enumerable2 = buildingListOfType.LoopRandom();
		foreach (Building item in enumerable2)
			if ((!pCountOnlyFinished || (!item.isUnderConstruction() && item.isUsable())) && (!pOnlyFreeTile || !item.current_tile.isTargeted()) && (!flag || item.current_island == pLimitIsland))
	public void addRoads(List<WorldTile> pTiles)
		for (int i = 0; i < pTiles.Count; i++)
	private bool isArmyFull()
	private bool isArmyOverLimit()
	private bool tryToMakeWarrior(Actor pActor)
	public bool checkCanMakeWarrior(Actor pActor)
	public void makeWarrior(Actor pActor)
	public bool checkIfWarriorStillOk(Actor pActor)
		bool flag = true;
	public void setCitizenJob(Actor pActor)
		for (int i = 0; i < list_priority_normal.Count; i++)
	private bool checkCitizenJobList(List<CitizenJobAsset> pList, Actor pActor)
		for (int i = 0; i < pList.Count; i++)
	private bool checkCitizenJob(CitizenJobAsset pJobAsset, City pCity, Actor pActor)
	public bool hasSuitableFood(Subspecies pSubspecies)
		HashSet<string> allowedFoodByDiet = pSubspecies.getAllowedFoodByDiet();
	internal ResourceAsset getFoodItem(Subspecies pSubspecies, string pFavoriteFood = null)
		if (!string.IsNullOrEmpty(pFavoriteFood) && getResourcesAmount(pFavoriteFood) > 0)
	internal void eatFoodItem(string pItem)
	internal void removeZone(TileZone pZone)
	internal void addZone(TileZone pZone)
	public int getLoyalty(bool pForceRecalc = false)
	public int getCachedLoyalty()
	public bool isCapitalCity()
	internal void updateAge()
	private void updateCityCenter()
		float num = 0f;
		float num2 = 0f;
		float num3 = float.MaxValue;
		for (int i = 0; i < zones.Count; i++)
		city_center.x = num / (float)zones.Count;
		city_center.y = num2 / (float)zones.Count;
		for (int j = 0; j < zones.Count; j++)
	internal void removeFromCurrentKingdom()
	internal void switchedKingdom()
		for (int i = 0; i < list.Count; i++)
	internal void useInspire(Actor pActor)
	internal void clearCurrentCaptureAmounts()
	internal void clearDangerZones()
	public bool isInDanger()
	internal void updateConquest(Actor pActor)
	public void addCapturePoints(BaseSimObject pObject, int pValue)
		addCapturePoints(pObject.kingdom, pValue);
	public void addCapturePoints(Kingdom pKingdom, int pValue)
	public void debugCaptureUnits(DebugTool pTool)
	internal void finishCapture(Kingdom pNewKingdom)
	private Kingdom findKingdomToJoinAfterCapture(Kingdom pKingdom, ListPool<War> pWars)
		for (int i = 0; i < pWars.Count; i++)
	private bool checkRebelWar(Kingdom pKingdomToJoin, ListPool<War> pWars)
	private void removeSoldiers()
	public void disbandArmy()
	public void checkArmyExistence()
	public bool hasArmy()
	public Army getArmy()
	public void setArmy(Army pArmy)
	public Actor getRandomWarrior()
	internal Kingdom makeOwnKingdom(Actor pActor, bool pRebellion = false, bool pFellApart = false)
		string pHappinessEvent = null;
	public override int getPopulationPeople()
	public int getPopulationMaximum()
	public int getUnitsTotal()
	public int countPopulationChildren()
		int num = 0;
	public int countBoats()
	public void joinAnotherKingdom(Kingdom pNewSetKingdom, bool pCaptured = false, bool pRebellion = false)
		string pHappinessEvent = null;
	public int countWeapons()
	public int countFoodTotal()
	public bool hasEnoughFoodForArmy()
	public int getTotalFood()
	public bool hasAnyFood()
	public int countWarriors()
	public bool hasAnyWarriors()
	public bool isHappy()
	public float getArmyMaxMultiplier()
		float num = 0f + getActorAsset().civ_base_army_multiplier;
		float armyMaxLeaderMultiplier = getArmyMaxLeaderMultiplier();
	public float getArmyMaxLeaderMultiplier()
		float num = 0f;
	public int getMaxWarriors()
	public void removeLeader()
	public void setLeader(Actor pActor, bool pNew)
	public void updateRulers()
	public void addRuler(Actor pActor)
	public void rulerLeft()
	public static bool nearbyBorders(City pA, City pB)
		for (int i = 0; i < city.zones.Count; i++)
	public static bool giveItem(Actor pActor, List<long> pItems, City pCity)
	public int getLimitOfBuildingsType(BuildOrder pElement)
		int num = pElement.limit_type;
	public Alliance getAlliance()
	public Clan getRoyalClan()
	public bool isOkToSendArmy()
		float num = getMaxWarriors();
		return (float)army.countUnits() / num >= 0.7f;
	public void tryToPutItem(Item pItem)
	public void tryToPutItems(IEnumerable<Item> pItems)
	private void tryToPutItemInStorage(Item pNewItem)
		float num = pNewItem.getValue();
		for (int i = 0; i < equipmentList.Count; i++)
	public int getZoneRange(bool pAllowCheat = true)
	public bool reachableFrom(City pCity)
	public bool hasLeader()
	public override void convertSameSpeciesAroundUnit(Actor pActorMain, bool pOverride = false)
	public override void forceConvertSameSpeciesAroundUnit(Actor pActorMain)
	public void setUnitMetas(Actor pActor)
	public override void save()
	public bool hasCulture()
	public bool hasLanguage()
	internal void setLanguage(Language pLanguage)
	internal void setReligion(Religion pReligion)
	public Subspecies getMainSubspecies()
	public bool hasReligion()
	public bool hasStockpiles()
	public bool hasStorages()
	public Building getRandomStockpile()
	public void takeResource(string pResourceID, int pAmount)
		int num = pAmount;
	public int getResourcesAmount(string pResourceID)
		int num = 0;
	public int addResourcesToRandomStockpile(string pResourceID, int pAmount = 1)
	public bool hasSpaceForResourceInStockpile(ResourceAsset pResourceAsset)
	public bool hasResourcesForNewItems()
	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies)
	public int countFood()
		int num = 0;
	public ListPool<CityStorageSlot> getTotalResourceSlots(ResType[] pResTypes)
	public bool hasKingdom()
	public float getTimerForNewWarrior()
	public List<long> getEquipmentList(EquipmentType pType)
	public bool planAllowsToPlaceBuildingInZone(TileZone pZone, TileZone pCenterZone)
	public bool hasSpecialTownPlans()
	public bool isNeutral()
	public bool isWelcomedToJoin(Actor pActor)
	public bool isSameSpeciesAsActor(Actor pActor)
	public string getCurrentSpecies()
	public Sprite getCurrentSpeciesIcon()
	public bool hasTransportBoats()
	public bool isCityUnderDangerFire()
	public bool isPossibleToJoin(Actor pActor)
	public override string ToString()
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append($"[City:{base.id} ");
		stringBuilderPool.Append("\"" + name + "\" ");
		stringBuilderPool.Append($"Kingdom:{kingdom?.id ?? (-1)} ");
		stringBuilderPool.Append($"Units:{base.units.Count} ");
		return stringBuilderPool.ToString().Trim() + "]";
public class CityBanner : BannerGeneric<City, CityData>
	private Sprite _city_sprite;
	private Sprite _capital_sprite;
	private Image _part_city_icon;
	protected override MetaType meta_type => MetaType.City;
	protected override string tooltip_id => "city";
	protected override void setupBanner()
	protected override void setupParts()
	protected override TooltipData getTooltipData()
public class CityBehBorderShrink : BehaviourActionCity
	public override bool errorsFound(City pCity)
	public override bool shouldRetry(City pCity)
	public override BehResult execute(City pCity)
	private TileZone getZoneToRemove(City pCity)
	private TileZone getRandomZoneFromList(IReadOnlyCollection<TileZone> pList)
namespace ai.behaviours;
public class CityBehBorderSteal : BehaviourActionCity
	private static List<TileZone> _zones = new List<TileZone>();
	public override BehResult execute(City pCity)
		for (int i = 0; i < 3; i++)
	private bool tryStealZone(City pCity)
	private void stealZone(TileZone pZone, City pCity)
namespace ai.behaviours;
public class CityBehBuild : BehaviourActionCity
	private static readonly List<BuildOrder> _possible_buildings = new List<BuildOrder>();
	private static readonly List<BuildOrder> _possible_buildings_no_resources = new List<BuildOrder>();
	private static readonly List<TileZone> _possible_zones = new List<TileZone>();
	public override bool shouldRetry(City pCity)
	public override BehResult execute(City pCity)
	public static bool buildTick(City pCity)
		if (pCity.under_construction_building == null)
				if (building2.isUnderConstruction())
					pCity.under_construction_building = building2;
		if (pCity.under_construction_building != null)
		if (DebugConfig.isOn(DebugOption.CityFastConstruction))
			pCity.under_construction_building = null;
	private void upgradeRandomBuilding(City pCity)
	public static bool upgradeBuilding(Building pBuilding, City pCity)
		string upgrade_to = pBuilding.asset.upgrade_to;
		bool num = pBuilding.upgradeBuilding();
	public static void calcPossibleBuildings(City pCity)
		bool flag = DebugConfig.isOn(DebugOption.OverlayCity);
	public static bool hasResourcesForBuildAsset(BuildOrder pBuildAsset, City pCity)
	public static bool canUseBuildAsset(BuildOrder pBuildAsset, City pCity)
		int num = pCity.countBuildingsType(buildingAsset.type, pCountOnlyFinished: false);
		int limitOfBuildingsType = pCity.getLimitOfBuildingsType(pBuildAsset);
	private static bool haveRequiredBuildings(BuildOrder pOrder, City pCity)
		for (int i = 0; i < pOrder.requirements_orders.Length; i++)
	private static bool haveRequiredBuildingTypes(string[] pRequiredBuildingTypes, City pCity)
		foreach (string pBuildingTypeID in pRequiredBuildingTypes)
	public static Building tryToBuild(City pCity, BuildingAsset pBuildingAsset)
		Building building = (pCity.under_construction_building = BehaviourActionBase<City>.world.buildings.addBuilding(pBuildingAsset, worldTile));
		building.setUnderConstruction();
	private static void fillPossibleZones(BuildingAsset pBuildingAsset, City pCity, List<TileZone> pPossibleZones)
		for (int i = 0; i < pCity.zones.Count; i++)
	public static WorldTile getOnHouseTile(City pCity, BuildingAsset pAsset)
	public static WorldTile tryToBuildInZones(List<TileZone> pList, BuildingAsset pBuildingAsset, City pCity, bool pForceCenterZone = false)
		bool num = pCity.hasCulture() && pCity.culture.hasTrait("buildings_spread");
		bool flag = pCity.hasSpecialTownPlans();
		int num2 = int.MaxValue;
		bool flag2 = !num && tile != null;
	private static WorldTile getTileBasedOnLayout(CityLayoutTilePlacement pCityLayoutTilePlacement, TileZone pTileZone, BuildingAsset pBuildingAsset, City pCity)
	private static WorldTile tryToBuildInZoneMoonsteps(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	private static WorldTile tryToBuildInZoneDrunk(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	private static WorldTile tryToBuildInZoneRandomly(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	private static WorldTile tryToBuildInZoneCenter(TileZone pZone, BuildingAsset pBuildingAsset, City pCity)
	internal static bool isZoneNearbyBorder(TileZone pParentZone, BuildingAsset pAsset, City pCity)
		for (int i = 0; i < neighbours_all.Length; i++)
	internal static bool isNearbySingleBuilding(TileZone pParentZone, BuildingAsset pAsset, City pCity)
		for (int i = 0; i < neighbours_all.Length; i++)
	internal static bool checkZoneNearbySignleBuilding(TileZone pZone, BuildingAsset pAsset, City pCity)
	internal static bool isZonesNearbyBuilding(TileZone pParentZone, BuildingAsset pAsset, City pCity)
		for (int i = 0; i < neighbours_all.Length; i++)
	internal static bool checkZoneNearbyBuilding(TileZone pZone, BuildingAsset pAsset, City pCity)
	internal static bool isZonesClear(TileZone pParentZone, BuildingAsset pAsset, City pCity)
		for (int i = 0; i < neighbours_all.Length; i++)
	internal static bool checkFarmGround(WorldTile pTile, BuildingAsset pAsset, City pCity)
		int num = 0;
		for (int i = 0; i < pTile.region.neighbours.Count; i++)
	internal static int countGoodForFarms(MapRegion pRegion, City pCity)
		int num = 0;
		for (int i = 0; i < tiles.Count; i++)
	internal static bool checkZoneClear(TileZone pZone, BuildingAsset pAsset, City pCity)
	public static bool isGoodTileForBuilding(WorldTile pTile, BuildingAsset pAsset, City pCity)
	public static void debugRoards(City pCity, Building pBuilding)
	public static void makeRoadsBuildings(City pCity, Building pBuilding)
			if (DebugConfig.isOn(DebugOption.CityFastConstruction))
	public static WorldTile getTileTrainingDummy(BuildingAsset pBuildingAsset, City pCity)
	public static WorldTile getDockTile(City pCity)
namespace ai.behaviours;
public class CityBehCheckArmy : BehaviourActionCity
	public override BehResult execute(City pCity)
namespace ai.behaviours;
public class CityBehCheckAttackZone : BehaviourActionCity
	public override BehResult execute(City pCity)
		bool flag = true;
	private City findTargetCity(City pOurCity)
		float num = float.MaxValue;
namespace ai.behaviours;
public class CityBehCheckCitizenTasks : BehaviourActionCity
	private int _citizens_left;
	public override BehResult execute(City pCity)
		int num = 0;
		bool flag = false;
		int pTaskAmountMax = 0;
		bool flag2 = pCity.hasStorageBuilding();
		int totalFood = pCity.getTotalFood();
		int num2 = 0;
		int num3 = 0;
		bool flag3 = pCity.hasBuildingType("type_windmill");
		bool flag4 = pCity.hasBuildingType("type_mine");
		bool flag5 = pCity.hasBuildingToBuild();
		int num4 = _citizens_left * 2;
	private void addToJob(CitizenJobAsset pJobAsset, CitizenJobs pJobsContainer, int pAdd, int pTaskAmountMax, int pJobMax = 0)
		int num = pJobsContainer.countCurrentJobs(pJobAsset);
	private int getPossibleWarriors(City pCity)
		float armyMaxMultiplier = pCity.getArmyMaxMultiplier();
		return (int)((float)pCity.status.population_adults * armyMaxMultiplier);
	private void countRoads(City pCity, CityTasksData pTasks)
	private void countResources(City pCity, CityTasksData pTasks)
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		for (int i = 0; i < pCity.zones.Count; i++)
	private void countFires(City pCity, CityTasksData pTasks)
		for (int i = 0; i < pCity.zones.Count; i++)
	private void checkOccupied(City pCity)
		Dictionary<CitizenJobAsset, int> occupied = pCity.jobs.occupied;
		for (int i = 0; i < pCity.units.Count; i++)
namespace ai.behaviours;
public class CityBehCheckDestruction : BehaviourActionCity
	public override BehResult execute(City pCity)
public class CityBehCheckFarms : BehaviourActionCity
	public override bool shouldRetry(City pCity)
	public override BehResult execute(City pCity)
	public static void check(City pCity)
	private static void behCheckWheat(City pCity)
	private static void behFindTileForFarm(City pCity)
	private static void checkRegion(MapRegion pRegion, Building pBuilding, City pCity)
		for (int i = 0; i < chunk.zones.Count; i++)
	private static void checkZone(TileZone pZone, Building pBuilding, City pCity)
		int num = tiles.Length;
		for (int i = 0; i < num; i++)
namespace ai.behaviours;
public class CityBehCheckLeader : BehaviourActionCity
	protected override void setupErrorChecks()
	public override BehResult execute(City pCity)
	private void checkLeaderClan(City pCity)
	private void checkFindLeader(City pCity)
		int num = 0;
	private Actor tryGetClanLeader(City pCity)
public class CityBehCheckLoyalty : BehaviourActionCity
	public override BehResult execute(City pCity)
	public static void check(City pCity)
namespace ai.behaviours;
public class CityBehProduceBoat : BehaviourActionCity
	public override BehResult execute(City pCity)
namespace ai.behaviours;
public class CityBehProduceResources : BehaviourActionCity
	public override bool shouldRetry(City pCity)
	public override BehResult execute(City pCity)
		foreach (string item in actorAsset.production.LoopRandom())
	private bool tryToProduce(ResourceAsset pAsset, City pCity, int pAmount = 1)
		for (int i = 0; i < pAmount; i++)
namespace ai.behaviours;
public class CityBehRandomWait : BehaviourActionCity
	private float min;
	private float max;
	public override bool shouldRetry(City pObject)
	public CityBehRandomWait(float pMin = 0f, float pMax = 1f)
	public override BehResult execute(City pCity)
namespace ai.behaviours;
public class CityBehSupplyKingdomCities : BehaviourActionCity
	public override BehResult execute(City pCity)
	private void updateSupplyTimer(City pCity)
		float num = 30f;
	private void shareResource(City pCity, City pTargetCity, CityStorageSlot pSlot)
public class CityBuildingIcons : CityElement
	public Image top;
	public Image topLeft;
	public Image topRight;
	public Image left;
	public Image right;
	public Image bottom;
	public Image bottomLeft;
	public Image bottomRight;
	public Image centerBonfire;
	private Image[] _list_house_images;
	private List<SpriteAnimation> _sprite_animations = new List<SpriteAnimation>();
	protected override void Awake()
	private void Update()
	protected override void clear()
		for (int i = 0; i < list_house_images.Length; i++)
	protected override IEnumerator showContent()
		using ListPool<string> pPossibleIDs = getCityBuildingTypes();
	private void showSprite(Image pImage, string pAssetID)
	private ListPool<string> getCityBuildingTypes()
		ListPool<string> listPool = new ListPool<string>(base.city.buildings.Count);
public enum CityBuildingPlacement
public class CityBuildOrderAsset : Asset
	public string[] list_for_generation;
	public List<BuildOrder> list = new List<BuildOrder>();
	public void addUpgrade(string pID, int pLimitType = 0, int pPop = 0, int pBuildings = 0, bool pCheckFullVillage = false, bool pZonesCheck = false, int pMinZones = 0)
	public BuildOrder addBuilding(string pID, int pLimitType = 0, int pPop = 0, int pBuildings = 0, bool pCheckFullVillage = false, bool pCheckHouseLimit = false, int pMinZones = 0)
	public void prepareForAssetGeneration()
		HashSet<string> hashSet = UnsafeCollectionPool<HashSet<string>, string>.Get();
		UnsafeCollectionPool<HashSet<string>, string>.Release(hashSet);
public class CityData : MetaObjectData
	public CityEquipment equipment;
	public List<ZoneData> zones = new List<ZoneData>();
	public int total_food_consumed;
	public float timer_supply;
	public float timer_trade;
	public List<LeaderEntry> past_rulers;
	public int total_leaders;
	public double timestamp_kingdom;
	public string original_actor_asset { get; set; }
	public long kingdomID { get; set; } = -1L;
	public long leaderID { get; set; } = -1L;
	public long founder_id { get; set; } = -1L;
	public string founder_name { get; set; }
	public long last_leader_id { get; set; } = -1L;
	public long last_kingdom_id { get; set; } = -1L;
	public long id_culture { get; set; } = -1L;
	public long id_language { get; set; } = -1L;
	public long id_religion { get; set; } = -1L;
	public long left { get; set; }
	public long joined { get; set; }
	public long moved { get; set; }
	public long migrated { get; set; }
	public string cityName
	public long cityID
	public string race
	public override void Dispose()
public class CityElement : WindowMetaElement<City, CityData>
	protected City city => meta_object;
public class CityElementNeutralHandler : CityElement
	private GameObject _layout_element_content_meta;
	private GameObject _layout_element_wants;
	private GameObject _layout_element_ruler;
	private void checkNeutralElements()
	protected override IEnumerator showContent()
public class CityEquipment : IDisposable
	internal Dictionary<EquipmentType, List<long>> items_dicts;
	public List<long> item_storage_weapons = new List<long>();
	public List<long> item_storage_helmets = new List<long>();
	public List<long> item_storage_armor = new List<long>();
	public List<long> item_storage_boots = new List<long>();
	public List<long> item_storage_rings = new List<long>();
	public List<long> item_storage_amulets = new List<long>();
	public CityEquipment()
	internal void init()
	public void clearItems()
	public int countItems()
		int num = 0;
	public bool hasAnyItem()
	public void addItem(City pCity, Item pItem, List<long> pList = null)
	public List<long> getEquipmentList(EquipmentType pType)
	public IEnumerable<List<long>> getAllEquipmentLists()
	public void loadFromSave(City pCity)
	public void Dispose()
	private void clearCollections()
public class CityJobLibrary : AssetLibrary<JobCityAsset>
	public override void init()
public enum CityLayoutTilePlacement
public class CityLeaderElement : CityElement
	private GameObject _title_element;
	private PrefabUnitElement _ruler_element;
	protected override IEnumerator showContent()
	protected override void clear()
	public override bool checkRefreshWindow()
public class CityListComponent : ComponentListBase<CityListElement, City, CityData, CityListComponent>
	protected override MetaType meta_type => MetaType.City;
	protected override void setupSortingTabs()
		sorting_tab.tryAddButton("ui/Icons/iconLoyalty", "sort_by_loyalty", show, delegate
		sorting_tab.tryAddButton("ui/Icons/iconZones", "sort_by_area", show, delegate
		sorting_tab.tryAddButton("ui/Icons/iconArmy", "sort_by_army", show, delegate
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
	private static int sortByKingdom(City p1, City p2)
	private static int sortByArmy(City p1, City p2)
	private static int sortByLoyalty(City p1, City p2)
	private static int sortByArea(City p1, City p2)
public class CityListElement : WindowListElementBase<City, CityData>
	public Text text_name;
	public CountUpOnClick population;
	public CountUpOnClick army;
	public CountUpOnClick zones;
	private CountUpOnClick _loyalty;
	public CountUpOnClick age;
	public UiUnitAvatarElement avatarLoader;
	public CityBanner city_banner;
	private GameObject _icon_capital;
	private CityLoyaltyElement _loyalty_element;
	internal override void show(City pCity)
		int loyalty = pCity.getLoyalty(pForceRecalc: true);
	protected override void initMonoFields()
	protected override void loadBanner()
	protected override void tooltipAction()
	private void toggleCapital(bool pState)
	protected override ActorAsset getActorAsset()
public class CityLoyaltyElement : MonoBehaviour
	private City _city;
	private TooltipData _tooltip_data;
	public void setCity(City pCity)
	private void Start()
	private void showHoverTooltip()
	private void showTooltip()
public class CityManager : MetaSystemManager<City, CityData>
	private bool _dirty_buildings;
	public CityManager()
	public City newCity(Kingdom pKingdom, TileZone pZone, Actor pOriginalActor)
	public City buildNewCity(Actor pActor, TileZone pZone)
	public bool tryToCreateCity(Actor pActor, ListPool<Building> pBuildingList)
	public bool canStartNewCityCivilizationHere(Actor pActor)
	public City buildFirstCivilizationCity(Actor pActor)
	protected override void updateDirtyUnits()
		for (int i = 0; i < units_only_alive.Count; i++)
	public void beginChecksBuildings()
	private void updateDirtyBuildings()
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			City current = enumerator.Current;
	public void setDirtyBuildings(City pCity)
	private void clearAllBuildingLists()
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearBuildingList();
	protected override void addObject(City pObject)
	public override City loadObject(CityData pData)
	public override void update(float pElapsed)
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			City current = enumerator.Current;
	public void updateAge()
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.updateAge();
	public override List<CityData> save(List<City> pList = null)
		using IEnumerator<City> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			City current = enumerator.Current;
	private void checkForCityErrors(SavedMap pSaveData)
		for (int i = 0; i < pSaveData.cities.Count; i++)
	public void loadCities(SavedMap pSaveData)
		for (int i = 0; i < pSaveData.cities.Count; i++)
	public override void removeObject(City pObject)
	private TileZone findZoneViaBuilding(long pID, List<BuildingData> pList)
		for (int i = 0; i < pList.Count; i++)
	public override bool isLocked()
public class CityMetaBanners : CityElement, IBaseMetaBanners
	private KingdomBanner _banner_kingdom;
	private ClanBanner _banner_clan;
	private AllianceBanner _banner_alliance;
	private LanguageBanner _banner_language;
	private CultureBanner _banner_culture;
	private ReligionBanner _banner_religion;
	private SubspeciesBanner _banner_subspecies;
	private ArmyBanner _banner_army;
	protected List<MetaBannerElement> banners = new List<MetaBannerElement>();
	private const float DELAY = 0.025f;
	protected int visible_banners;
	protected override void Awake()
	protected override IEnumerator showContent()
	protected override void clear()
	public void metaBannerShow(MetaBannerElement pAsset)
	public void metaBannerHide(MetaBannerElement pAsset)
	public IReadOnlyCollection<MetaBannerElement> getBanners()
public class CityPlaceFinder : CityZoneWorkerBase
	private bool _dirty;
	internal List<TileZone> zones = new List<TileZone>();
	internal bool isDirty()
	internal void recalc()
	internal override void clearAll()
		for (int i = 0; i < list.Count; i++)
	private void prepareBasicZones()
		for (int i = 0; i < list.Count; i++)
	private void prepareQueueFromCities()
	private void checkCity(City pCity, Queue<ZoneConnection> pWaveQ)
	private void startWave()
		int num = 3;
		int num2 = 0;
	private void createFinalList()
		for (int i = 0; i < World.world.zone_calculator.zones.Count; i++)
	public bool hasPossibleZones()
	internal void setDirty()
	private void clearCurrentZones()
public class CityResources : IDisposable
	private Dictionary<string, CityStorageSlot> _resources = new Dictionary<string, CityStorageSlot>();
	private List<CityStorageSlot> _list_food = new List<CityStorageSlot>();
	private List<CityStorageSlot> _list_other = new List<CityStorageSlot>();
	public List<CityStorageSlot> saved_resources;
	public void loadFromSave()
	public int get(string pRes)
	public int change(string pRes, int pAmount = 1)
		int num = 0;
	private int addNew(string pResID, int pAmount)
	public bool hasSpaceForResource(ResourceAsset pAsset)
	public bool hasResourcesForNewItems()
	public void set(string pRes, int pAmount)
	private void putToDict(CityStorageSlot pRes)
	public ResourceAsset getRandomSuitableFood(Subspecies pSubspecies, string pSpecificFood = null)
		if (!string.IsNullOrEmpty(pSpecificFood) && get(pSpecificFood) > 0)
		HashSet<string> allowedFoodByDiet = pSubspecies.getAllowedFoodByDiet();
	private ResourceAsset getAvailableFoodAsset(List<CityStorageSlot> pList, HashSet<string> pAllowedFood, bool pSort)
		for (int i = 0; i < pList.Count; i++)
	public int foodSorter(CityStorageSlot o1, CityStorageSlot o2)
	public int countFood()
		int num = 0;
	public ResourceAsset getRandomFoodAsset()
	public void save()
	public IEnumerable<string> getKeys()
	public IEnumerable<CityStorageSlot> getSlots()
	public void Dispose()
public class CitySelectedMetaBanners : CityMetaBanners, ISelectedTabBanners<City>
	public void update(City pCity)
	protected override void OnEnable()
	public int countVisibleBanners()
public class CitySelectedResources : UICityResources
	public void update(City pCity)
	protected override void OnEnable()
	protected override void onListChange()
public class CitySortableElement : CityElement, ILayoutController
	private RectTransform _rect;
	private List<RectTransform> _rect_children = new List<RectTransform>();
	protected override void Awake()
	protected virtual void onListChange()
	public void SetLayoutVertical()
	public void SetLayoutHorizontal()
public class CityStatsElement : CityElement, IStatsElement, IRefreshElement
	private CityLoyaltyElement _loyalty_element;
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public class CityStatus
	public int population_adults;
	public int population_children;
	public int population;
	public int housing_total;
	public int housing_free;
	public int housing_occupied;
	public int houses_max;
	public int warrior_slots;
	public int warriors_current;
	public int hungry;
	public int maximum_items;
	public int sick;
	public int homeless;
	public int housed;
	public int males;
	public int females;
	public int families;
	public void clear()
public class CityStorageSlot
	public string id;
	public int amount;
	public ResourceAsset asset => AssetManager.resources.get(id);
	public CityStorageSlot(string pID)
	public void create(string pID)
public class CityTasksData
	public int trees;
	public int minerals;
	public int bushes;
	public int plants;
	public int hives;
	public int farm_fields;
	public int farms_total;
	public int wheats;
	public int ruins;
	public int poops;
	public int roads;
	public int fire;
	public void clear()
public class CityWindow : WindowMetaGeneric<City, CityData>, IBooksWindow
	public Image raceTopIcon1;
	public Image raceTopIcon2;
	public LocalizedText village_title;
	public override MetaType meta_type => MetaType.City;
	protected override City meta_object => SelectedMetas.selected_city;
	public List<long> getBooks()
	protected override void showTopPartInformation()
	public override void startShowingWindow()
	private void tryShowPastRulers()
	private TooltipData getTooltipPastRulers()
	protected override bool onNameChange(string pInput)
	internal override void showStatsRows()
	public override void showMetaRows()
	public void clickTestItemProduction()
	public void clickTestClearItems()
	public void clickTestNewBook()
public class CityZoneAbandon : CityZoneWorkerBase
	private List<ListPool<TileZone>> _split_areas = new List<ListPool<TileZone>>();
	private HashSetTileZone _zones_to_check = new HashSetTileZone();
	public void checkCities()
	public void check(City pCity, bool pDebug = false, HashSet<TileZone> pSetToFill = null)
	private void startCheckingFromBuildings(City pCity)
		for (int i = 0; i < pCity.buildings.Count; i++)
	private void startWaveFromTile(WorldTile pTile, City pCity)
		int num = 0;
	private void abandonLeftoverZones(City pCity)
	private void abandonSmallAreas(City pCity)
		for (int i = 0; i < _split_areas.Count; i++)
	private void prepareCityZones(City pCity)
	internal override void clearAll()
	private static int sorter(ListPool<TileZone> pList1, ListPool<TileZone> pList2)
	protected override void queueConnection(ZoneConnection pConnection, Queue<ZoneConnection> pWave, bool pCheck = false)
public class CityZoneGrowth : CityZoneWorkerBase
	private const float MOD_RADIUS = 0.75f;
	public TileZone getZoneToClaim(Actor pActor, City pCity, bool pDebug = false, HashSet<TileZone> pSetToFill = null, int pBonusRange = 0)
		bool pStopWaveWhenEmptyZoneFound = !pDebug;
	private TileZone checkGrowBorder(City pCity)
		bool num = Randy.randomChance(0.7f);
	private TileZone getRandomZone(City pCity)
		float num = (float)pCity.getZoneRange() * 0.75f;
	private TileZone getBestZoneFromList(City pCity, List<TileZone> pList)
		int num = int.MaxValue;
		for (int i = 0; i < pList.Count; i++)
	private TileZone getRandomCheckedZone(City pCity)
	private void startWaveFromTile(Actor pActor, WorldTile pTile, City pCity, bool pStopWaveWhenEmptyZoneFound = true, int pBonusRange = 0)
		int num = pCity.getZoneRange() + pBonusRange;
		float num2 = (float)num * 0.75f;
		int num3 = 0;
		bool flag = false;
public class CityZoneHelper
	public CityZoneGrowth city_growth;
	public CityZoneAbandon city_abandon;
	public CityPlaceFinder city_place_finder;
	public CityZoneHelper()
	public void update(float pElapsed)
	public void clear()
public abstract class CityZoneWorkerBase
	protected bool debug;
	protected Queue<ZoneConnection> _wave = new Queue<ZoneConnection>();
	protected Queue<ZoneConnection> _next_wave = new Queue<ZoneConnection>();
	protected HashSet<ZoneConnection> _zones_checked = new HashSet<ZoneConnection>();
	protected void prepareWave()
	internal virtual void clearAll()
	protected virtual void queueConnection(ZoneConnection pConnection, Queue<ZoneConnection> pWave, bool pSetChecked = false)
	protected void checkZoneDebug()
public class Clan : MetaObjectWithTraits<ClanData, ClanTrait>
	public BaseStats base_stats_male = new BaseStats();
	public BaseStats base_stats_female = new BaseStats();
	protected override MetaType meta_type => MetaType.Clan;
	protected override bool track_death_types => true;
	public override BaseSystemManager manager => World.world.clans;
	protected override AssetLibrary<ClanTrait> trait_library => AssetManager.clan_traits;
	protected override List<string> default_traits => getActorAsset().default_clan_traits;
	protected override List<string> saved_traits => data.saved_traits;
	protected override string species_id => data.original_actor_asset;
	public void newClan(Actor pFounder, bool pAddDefaultTraits)
		string pName = pFounder.generateName(MetaType.Clan, getID());
	protected override void recalcBaseStats()
	public override void increaseBirths()
	protected sealed override void setDefaultValues()
	public override void listUnit(Actor pActor)
	protected override ColorLibrary getColorLibrary()
	public override void generateBanner()
	public string getMotto()
		if (string.IsNullOrEmpty(data.motto))
	public override void save()
	public void checkMembersForNewChief()
	public void setChief(Actor pActor)
	public void updateChiefs()
	public void addChief(Actor pActor)
	public void chiefLeft()
	public void tryForgetChief(Actor pActor)
	public Culture getClanCulture()
	private Culture getChiefCulture()
	public Actor getNextChief(Actor pIgnore = null)
	public int getMaxMembers()
		return (int)base_stats_meta["limit_clan_members"];
	public Actor getChief()
	public bool hasChief()
	public bool isFull()
		int maxMembers = getMaxMembers();
	public bool fitToRule(Actor pActor, Kingdom pKingdom)
	public Sprite getBackgroundSprite()
	public Sprite getIconSprite()
	public override void Dispose()
	public string getTextMaxMembers()
		int maxMembers = getMaxMembers();
	public override bool hasCities()
	public override IEnumerable<City> getCities()
	public override bool hasKingdoms()
	public override IEnumerable<Kingdom> getKingdoms()
public class ClanBanner : BannerGeneric<Clan, ClanData>
	protected override MetaType meta_type => MetaType.Clan;
	protected override string tooltip_id => "clan";
	protected override TooltipData getTooltipData()
	protected override void setupBanner()
public class ClanBannerLibrary : GenericBannerLibrary
	public override void init()
public class ClanChiefElement : ClanElement
	private GameObject _title_element;
	private PrefabUnitElement _chief_element;
	protected override IEnumerator showContent()
	protected override void clear()
	public override bool checkRefreshWindow()
public class ClanColorsLibrary : ColorLibrary
	public ClanColorsLibrary()
	public override void init()
	public override bool isColorUsedInWorld(ColorAsset pAsset)
public class ClanCustomizeWindow : GenericCustomizeWindow<Clan, ClanData, ClanBanner>
	protected override MetaType meta_type => MetaType.Clan;
	protected override Clan meta_object => SelectedMetas.selected_clan;
	protected override void onBannerChange()
public class ClanData : MetaObjectData
	public string motto;
	public long chief_id = -1L;
	public long culture_id = -1L;
	public List<LeaderEntry> past_chiefs;
	public List<string> saved_traits;
	public int books_written;
	public int banner_background_id;
	public int banner_icon_id;
	public string founder_actor_name;
	public long founder_actor_id = -1L;
	public string founder_kingdom_name;
	public long founder_kingdom_id = -1L;
	public string founder_city_name;
	public long founder_city_id = -1L;
	public string creator_species_id = string.Empty;
	public string creator_subspecies_name = string.Empty;
	public long creator_subspecies_id = -1L;
	public string original_actor_asset { get; set; }
	public string race_id
	public override void Dispose()
public class ClanElement : WindowMetaElement<Clan, ClanData>
	protected Clan clan => meta_object;
public class ClanListComponent : ComponentListBase<ClanListElement, Clan, ClanData, ClanListComponent>
	protected override MetaType meta_type => MetaType.Clan;
	protected override void setupSortingTabs()
		sorting_tab.tryAddButton("ui/Icons/iconKingdom", "sort_by_kingdom", show, delegate
	private static int sortByKingdom(Clan p1, Clan p2)
public class ClanListElement : WindowListElementBase<Clan, ClanData>
	public Text text_name;
	public CountUpOnClick members;
	public CountUpOnClick dead;
	public CountUpOnClick age;
	public CountUpOnClick renown;
	public UiUnitAvatarElement avatarLoader;
	internal override void show(Clan pClan)
		int pValue = pClan.getAge();
		dead.setValue((int)pClan.getTotalDeaths());
	protected override void tooltipAction()
	protected override ActorAsset getActorAsset()
public class ClanManager : MetaSystemManager<Clan, ClanData>
	public ClanManager()
	public Clan newClan(Actor pFounder, bool pAddDefaultTraits)
	private void convertFamilyToClan(Actor pFounder, Clan pNewClan)
	public override void removeObject(Clan pClan)
	public void addRandomTraitFromBiomeToClan(Clan pClan, WorldTile pTile)
	public override void update(float pElapsed)
	protected override void updateDirtyUnits()
		for (int i = 0; i < units_only_alive.Count; i++)
public class ClanMembersContainer : ClanElement
	private ObjectPoolGenericMono<PrefabUnitElement> _pool_members;
	private RectTransform _list_members;
	private LocalizedText _title_members;
	private PrefabUnitElement _prefab;
	private Text _members_counter;
	protected override void Awake()
	protected override IEnumerator showContent()
	private void showMember(Actor pActor)
	protected override void clear()
public class ClanSelectedContainerTraits : SelectedContainerTraits<ClanTrait, ClanTraitButton, ClanTraitsContainer, ClanTraitsEditor>
	protected override MetaType meta_type => MetaType.Clan;
	protected override IReadOnlyCollection<ClanTrait> getTraits()
	protected override bool canEditTraits()
public class ClanStatsElement : ClanElement, IStatsElement, IRefreshElement
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public class ClanTrait : BaseTrait<ClanTrait>
	public BaseStats base_stats_male = new BaseStats();
	public BaseStats base_stats_female = new BaseStats();
	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_clan;
	public override string typed_id => "clan_trait";
	protected override IEnumerable<ITraitsOwner<ClanTrait>> getRelatedMetaList()
	public override BaseCategoryAsset getGroup()
public class ClanTraitButton : TraitButton<ClanTrait>
	protected override string tooltip_type => "clan_trait";
	internal override void load(string pTraitID)
	protected override void startSignal()
	protected override TooltipData tooltipDataBuilder()
public class ClanTraitEditorButton : TraitEditorButton<ClanTraitButton, ClanTrait>
public class ClanTraitGroupAsset : BaseTraitGroupAsset
public class ClanTraitGroupElement : TraitGroupElement<ClanTrait, ClanTraitButton, ClanTraitEditorButton>
public class ClanTraitGroupLibrary : BaseCategoryLibrary<ClanTraitGroupAsset>
	public override void init()
public class ClanTraitLibrary : BaseTraitLibrary<ClanTrait>
	protected override string icon_path => "ui/Icons/clan_traits/";
	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	public override void init()
		t.base_stats["intelligence"] = 5f;
public class ClanTraitsContainer : TraitsContainer<ClanTrait, ClanTraitButton>
public class ClanTraitsEditor : TraitsEditor<ClanTrait, ClanTraitButton, ClanTraitEditorButton, ClanTraitGroupAsset, ClanTraitGroupElement>
	protected override MetaType meta_type => MetaType.Clan;
	protected override List<ClanTraitGroupAsset> augmentation_groups_list => AssetManager.clan_trait_groups.list;
	protected override List<ClanTrait> all_augmentations_list => AssetManager.clan_traits.list;
	protected override ClanTrait edited_marker_augmentation => AssetManager.clan_traits.get("geb");
	protected override void startSignal()
public class ClanWindow : WindowMetaGeneric<Clan, ClanData>, ITraitWindow<ClanTrait, ClanTraitButton>, IAugmentationsWindow<ITraitsEditor<ClanTrait>>
	public NameInput nameInput;
	public NameInput mottoInput;
	public override MetaType meta_type => MetaType.Clan;
	protected override Clan meta_object => SelectedMetas.selected_clan;
	protected override void initNameInput()
	protected override bool onNameChange(string pInput)
		string name = meta_object.data.name;
	private void applyInputMotto(string pInput)
	protected override void showTopPartInformation()
	internal override void showStatsRows()
	private void tryShowPastChiefs()
	private TooltipData getTooltipPastChiefs()
	protected override void OnDisable()
	public void debugClearExpLevel()
	T IAugmentationsWindow<ITraitsEditor<ClanTrait>>.GetComponentInChildren<T>(bool includeInactive)
public class ClickActionCallerAttribute : Attribute
public class ClickPowerActionCallerAttribute : Attribute
public class ClickQuitTheGame : MonoBehaviour
	public void clickQuit()
public class Cloud : BaseEffect
	public CloudAsset asset;
	private float speed = 1f;
	public SpriteShadow spriteShadow;
	private float _timer_action_1;
	private float _timer_action_2;
	internal float alive_time;
	private float _fade_multiplier = 0.2f;
	internal float effect_texture_width;
	internal float effect_texture_height;
	private float _lifespan;
	internal override void create()
	internal override void prepare()
		_timer_action_1 = asset.interval_action_1;
	public void setLifespan(float pLifespan)
	internal void setType(CloudAsset pAsset)
	internal void setType(string pType)
	public void spawn(WorldTile pTile, string pType)
	internal void prepare(Vector3 pVec, string pType)
	internal override void prepare(WorldTile pTile, float pScale = 0.5f)
	public override void update(float pElapsed)
		if (((Component)this).transform.localPosition.x > (float)MapBox.width || (_lifespan > 0f && alive_time > _lifespan))
		float num = asset.max_alpha;
public delegate void CloudAction(Cloud pCloud);
public class CloudAsset : Asset
	public bool normal_cloud;
	public Color color;
	public string color_hex = "#FFFFFF";
	public float max_alpha = 0.8f;
	public CloudAction cloud_action_1;
	public CloudAction cloud_action_2;
	public float interval_action_1 = 0.05f;
	public float interval_action_2 = 0.05f;
	public float speed_min = 1f;
	public float speed_max = 6f;
	public string drop_id = string.Empty;
	public string[] path_sprites;
	internal Sprite[] cached_sprites;
	public bool draw_light_area;
	public float draw_light_area_offset_x;
	public float draw_light_area_offset_y;
	public float draw_light_size = 4f;
	public bool considered_disaster;
public class CloudLibrary : AssetLibrary<CloudAsset>
	private static string[] _sprites_small = new string[2] { "effects/clouds/cloud_small_1", "effects/clouds/cloud_small_2" };
	private static string[] _sprites_big = new string[3] { "effects/clouds/cloud_big_1", "effects/clouds/cloud_big_2", "effects/clouds/cloud_big_3" };
	private static string[] _sprites_all = new string[5] { "effects/clouds/cloud_small_1", "effects/clouds/cloud_small_2", "effects/clouds/cloud_big_1", "effects/clouds/cloud_big_2", "effects/clouds/cloud_big_3" };
	public override void init()
	public override void linkAssets()
	public static void dropAction(Cloud pCloud)
	public static void spawnLightning(Cloud pCloud)
		int num = (int)((Component)pCloud).transform.localPosition.x;
		int num2 = (int)((Component)pCloud).transform.localPosition.y;
		float effect_texture_width = pCloud.effect_texture_width;
		float effect_texture_height = pCloud.effect_texture_height;
		num += (int)Randy.randomFloat(effect_texture_width * 0.5f, effect_texture_width);
		num2 += (int)Randy.randomFloat(0f - effect_texture_height + pCloud.spriteShadow.offset.y, effect_texture_height + pCloud.spriteShadow.offset.y);
public class ColorArray
	public List<Color32> colors;
	public ColorArray(float pR, float pG, float pB, float pA, float pAmount, float pMod = 1f)
		for (int i = 0; (float)i < pAmount; i++)
	public ColorArray(Color32 pColor, int pAmount)
		: this((int)pColor.r, (int)pColor.g, (int)pColor.b, (int)pColor.a, pAmount)
public class ColorAsset : Asset
	private static int _create_last_index_id = 1000;
	public int index_id;
	public string color_main;
	public string color_main_2;
	public string color_banner;
	public string color_text;
	public bool favorite;
	public Color32 k_color_0;
	public Color32 k_color_1;
	public Color32 k_color_2;
	public Color32 k_color_3;
	public Color32 k_color_4;
	public Color32 k2_color_0;
	public Color32 k2_color_1;
	public Color32 k2_color_2;
	public Color32 k2_color_3;
	public Color32 k2_color_4;
	private Color32 _color_main_32;
	private Color32 _color_main_second_32;
	private Color32 _color_unit_32;
	private Color32 _color_border_inside_alpha_32;
	private Color _color_main;
	private Color _color_main_second;
	private Color _color_text;
	private Color _color_minimap_element;
	private Color _color_border_out_capture;
	private Color _color_banner;
	private static readonly List<ColorAsset> _all_colors_list = new List<ColorAsset>();
	private static readonly Dictionary<string, ColorAsset> _all_colors_dict = new Dictionary<string, ColorAsset>();
	public const byte ALPHA_BORDER_INSIDE_BYTE = 170;
	private bool _initialized;
	private Material _material_line;
	private Material _material_gradient;
	public static List<ColorAsset> getAllColorsList()
	public ColorAsset()
	public static bool isColorAssetExists(string pColorMain)
	public static ColorAsset getExistingColorAsset(string pColorMain)
	public static ColorAsset tryMakeNewColorAsset(string pColorMain)
	private ColorAsset(string pColorMain)
	public static void saveToGlobalList(ColorAsset pAsset, bool pMustBeGlobal = false)
	private void setMainHexColors(string pColorMain, string pColorMain2, string pColorBanner)
	public void setEditorColors(Color pMain, Color pMain2, Color pBanner, Color pText)
	public void initColor()
	public Material getChartLineMaterial()
	public Material getChartInnerFillMaterial()
	private Material cloneMaterial(string pPath)
	private Color32 checkIfColorTooDark(Color32 pColor)
	private Color32 getDarkerColor(Color32 pColor, byte pValue)
	public Color32 getColorUnit32()
	public Color32 getColorMain32()
	public Color32 getColorBorderInsideAlpha32()
	public Color32 getColorMainSecond32()
	public Color getColorMainSecond()
	public Color getColorMain()
	public Color getColorText()
	public ref Color getColorTextRef()
	public Color getColorMinimapElements()
	public Color getColorBorderOut_capture()
	public Color getColorBanner()
public class ColorElement : MonoBehaviour
	public Button button;
	public Image selection;
	public Image outer;
	public Image inner;
	public int index;
	public MetaCustomizationAsset asset;
	public void setColor(Color pOuter, Color pInner)
	public void setSelected(bool pSelected)
	public void setAction(UnityAction pAction)
	public void showTooltip()
		CustomDataContainer<int> customDataContainer = new CustomDataContainer<int>();
public class ColorLibrary : AssetLibrary<ColorAsset>
	private readonly List<ColorAsset> _free_colors_main = new List<ColorAsset>();
	private readonly List<ColorAsset> _free_colors_bonus = new List<ColorAsset>();
	private readonly List<ColorAsset> _free_colors_preferred = new List<ColorAsset>();
	internal bool must_be_global;
	public override void post_init()
	public ColorAsset getColorByIndex(int pIndex)
	public ColorAsset getNextColor(ActorAsset pActorAsset)
		for (int i = 0; i < list.Count; i++)
	public int getNextColorIndex(ActorAsset pActorAsset)
	public virtual bool isColorUsedInWorld(ColorAsset pAsset)
	protected bool checkColor(ColorAsset pAsset, int pColorIndex)
	public override ColorAsset add(ColorAsset pAsset)
	public void useSameColorsFrom(ColorLibrary pSource)
public class ColorStyleAsset : Asset
	public string taxonomy_kingdom = "#76FFF8";
	public string taxonomy_phylum = "#74FFA3";
	public string taxonomy_subphylum = "#54FF8D";
	public string taxonomy_class = "#76FF4A";
	public string taxonomy_order = "#B9FF48";
	public string taxonomy_family = "#FEFD46";
	public string taxonomy_genus = "#F8AB4F";
	public string taxonomy_common_name = "#DC8D4E";
	public string color_text_grey = "#ADADAD";
	public string color_text_grey_dark = "#7D7D7D";
	public string color_text_selector = "#7FFF75AA";
	public string color_text_selector_remove = "#FF182AAA";
	public string color_text_pumpkin = "#FFA94C";
	public string color_text_pumpkin_light = "#FFBC66";
	public Color favorite_selected = Color.white;
	public Color favorite_not_selected = new Color(0.7f, 0.7f, 0.7f, 0.3f);
	public Color health_bar_main_green = Toolbox.makeColor("#00C21F");
	public Color health_bar_main_red = Toolbox.makeColor("#FF4300");
	public Color health_bar_background = Toolbox.makeColor("#303030");
	public string color_dead_text => color_text_grey_dark;
	public Color getSelectorColor()
	public Color getSelectorRemoveColor()
	public string getColorForTaxonomy(string pID)
			"taxonomy_class" => taxonomy_class,
public class ColorStyleLibrary : AssetLibrary<ColorStyleAsset>
	public static ColorStyleAsset m;
	public override void init()
public class ColorTool : MonoBehaviour
	public string colorString;
	public GameObject prefabKingdom;
	public GameObject prefabClan;
	public GameObject prefabCulture;
	public GameObject prefabAlliance;
	public Transform container;
	public string last_editor = "";
	private void resetCoords()
	public void InitKingdoms()
	public void InitCultures()
	public void InitClans()
	public void cleanup()
	private void createColorToolElement(ColorAsset pColor, GameObject pPrefab, string pWhat)
	public void saveEditor()
	private void convertToolIntoAsset(ColorToolElement pTool, ColorAsset pAsset)
	private void saveKingdoms()
	private void saveCultures()
	private void saveClans()
	private void saveLib(ColorLibrary pLibrary)
		for (int i = 0; i < container.childCount; i++)
		string contents = JsonUtility.ToJson((object)pLibrary, true);
public class ColorToolElement : MonoBehaviour
	public Color colorMain;
	public Color colorMain2;
	public Color colorBanner;
	public Color colorText;
	public string id;
	public bool favorite;
	public Image background;
	public Image icon;
	public Text text;
	public Image sprite_favorite;
	public Image borderInside;
	public Image borderOutside;
	public ColorAsset color_asset;
	public Image test_house;
	public Image test_face;
	public Sprite house_default_sprite;
	public Sprite face_default_sprite;
	public int debug_index;
	public void createKingdom(ColorAsset pColor)
	public void createCulture(ColorAsset pColor)
	public void createClans(ColorAsset pColor)
		string random = AssetManager.clan_banners_library.main.backgrounds.GetRandom();
		string random2 = AssetManager.clan_banners_library.main.icons.GetRandom();
	private void setColorsForObjects(ColorAsset pColorAsset)
	private void OnValidate()
	private void saveColors(ColorAsset pColor)
public enum ColorType
public delegate bool CombatAction(AttackData pData);
public delegate bool CombatActionActor(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f);
public delegate bool CombatActionActorTargetPosition(Actor pActor, Vector2 pTargetPosition, WorldTile pTile = null);
public class CombatActionAsset : Asset
	public bool play_unit_attack_sounds;
	public CombatActionPool[] pools;
	public string tag_required;
	public int rate = 1;
	public float chance = 0.2f;
	public float cooldown = 1f;
	public bool is_spell_use;
	public int cost_stamina;
	public int cost_mana;
	public bool basic;
	public CombatAction action;
	public CombatActionActor action_actor;
	public CombatActionActorTargetPosition action_actor_target_position;
	public CombatActionCheckStart can_do_action;
public delegate bool CombatActionCheckStart(Actor pActor, BaseSimObject pAttackTarget);
public class CombatActionHolder
	private readonly List<CombatActionAsset>[] _combat_action_pools = new List<CombatActionAsset>[Enum.GetValues(typeof(CombatActionPool)).Length];
	private bool _has_combat_actions;
	public void fillFromIDS(List<string> pIDs)
		foreach (string pID in pIDs)
	public List<CombatActionAsset> getPool(CombatActionPool pPool)
		return _combat_action_pools[(int)pPool];
	public void reset()
	public void mergeWith(CombatActionHolder pCombatActions)
		for (int i = 0; i < pCombatActions._combat_action_pools.Length; i++)
	public bool isEmpty()
	public bool hasAny()
public class CombatActionLibrary : AssetLibrary<CombatActionAsset>
	public static CombatActionAsset combat_attack_melee;
	public static CombatActionAsset combat_attack_range;
	public static CombatActionAsset combat_cast_spell;
	public static CombatActionAsset combat_action_deflect;
	public static CombatActionAsset combat_action_dash;
	public static CombatActionAsset combat_action_backstep;
	public override void init()
	private bool doThrowBombAction(Actor pSelf, Vector2 pTarget, WorldTile pTile = null)
	private bool doThrowTorchAction(Actor pSelf, Vector2 pTarget, WorldTile pTile = null)
	private bool doBackstepAction(Actor pActor, Vector2 pTarget, WorldTile pTile = null)
		float pForceAmountDirection = 5f;
		float pForceHeight = 1.2f;
	private bool doDashAction(Actor pActor, Vector2 pTarget, WorldTile pTile = null)
		float pForceAmountDirection = 5f;
		float pForceHeight = 1.2f;
	private bool doBlockAction(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
	private bool doDeflect(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
	private bool doDodgeAction(Actor pActor, AttackData pData, float pTargetX = 0f, float pTargetY = 0f)
		float num = 3f;
		float pForceHeight = 1.5f;
	public bool attackRangeAction(AttackData pData)
		string projectile_id = pData.projectile_id;
		float scaleMod = actor.getScaleMod();
		float num = actor.stats["size"];
		int num2 = (int)actor.stats["projectiles"];
		float num3 = actor.stats["accuracy"];
		float pMaxExclusive = Toolbox.DistVec2Float(actor.current_position, val) / num3 * 0.25f;
		float pStartPosZ = 0.6f * scaleMod;
		float pTargetZ = 0f;
		float value = 0f;
		for (int i = 0; i < num2; i++)
	public Vector2 getInnacuracyVector(float pAccuracyStat)
		float num = 1f * (10f - pAccuracyStat) / 10f;
		float num2 = (float)((double)(Randy.random() * 2f) * Math.PI);
		return new Vector2(num * (float)Math.Cos(num2), num * (float)Math.Sin(num2));
	public static bool tryToCastSpell(AttackData pData)
		if (randomSpell.min_distance > 0f && (float)Toolbox.SquaredDistTile(actor.current_tile, baseSimObject.current_tile) < randomSpell.min_distance * randomSpell.min_distance)
		bool flag = false;
	public bool attackMeleeAction(AttackData pData)
	public void showMeleeSlashAttack(AttackData pData)
	public Vector2 getAttackTargetPosition(AttackData pData)
		float num = target.stats["size"];
public enum CombatActionPool
public delegate bool CombatActionProjectile(Actor pActor, Projectile pProjectile);
public class CommunicationAsset : Asset
	public string icon_path;
	public bool show_topic;
	public float rate;
	public TopicCheck check;
	public TopicPotFill pot_fill;
	private Sprite _sprite_cache;
	public Sprite getSpriteBubble()
public class CommunicationLibrary : AssetLibrary<CommunicationAsset>
	public static CommunicationAsset normal;
	public override void init()
public class CommunicationTopicAsset : Asset
public class CommunicationTopicLibrary : AssetLibrary<CommunicationAsset>
	private List<Sprite> _cached_sprites_religion = new List<Sprite>();
	private List<Sprite> _cached_sprites_culture = new List<Sprite>();
	private List<Sprite> _cached_sprites_family = new List<Sprite>();
	private List<Sprite> _cached_sprites_kingdom = new List<Sprite>();
	private List<Sprite> _cached_sprites_city = new List<Sprite>();
	private List<Sprite> _cached_sprites_clan = new List<Sprite>();
	private List<Sprite> _cached_sprites_time_and_death = new List<Sprite>();
	private List<Sprite> _cached_sprites_general_topics = new List<Sprite>();
	private List<Sprite> _cached_sprites_boats_water = new List<Sprite>();
	private List<Sprite> _cached_sprites_housed = new List<Sprite>();
	private List<Sprite> _cached_sprites_homeless = new List<Sprite>();
	private const int MAX_TOPIC_SPRITES = 10;
	public override void init()
	public override void linkAssets()
	public Sprite getTopicSprite(Actor pActor)
	private void cacheSpritesGeneralTopics()
public class ComponentListBase<TListElement, TMetaObject, TData, TComponent> : MonoBehaviour, IComponentList, IShouldRefreshWindow where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData where TComponent : ComponentListBase<TListElement, TMetaObject, TData, TComponent>
	public GameObject no_items;
	public SortingTab sorting_tab;
	public TListElement element_prefab;
	public Transform list_transform;
	public ScrollRect scroll_rect;
	private Text _title_counter;
	private Text _favorites_counter;
	private Text _dead_counter;
	private ListItemsFilter _show_items;
	public GetListOfObjectsFunc<TListElement, TMetaObject, TData, TComponent> get_objects_delegate = getObjects;
	private ObjectPoolGenericMono<TListElement> _pool_elements;
	private ObjectPoolGenericMono<BaseEmptyListMono> _pool_empty_elements;
	protected Comparison<TMetaObject> current_sort;
	public readonly List<NanoObject> meta_list = new List<NanoObject>();
	private bool autolayout_done;
	private const int PADDING_ELEMENTS = 3;
	private static readonly bool _debug;
	private bool _created;
	protected int latest_counted;
	private float _element_height;
	protected virtual MetaType meta_type
	private MetaTypeAsset _meta_type_asset => AssetManager.meta_type_library.getAsset(meta_type);
	protected virtual bool change_asset_sort_order => true;
	protected virtual IEnumerable<TMetaObject> getObjectsList()
		return get_objects_delegate((TComponent)this);
	protected ObjectPoolGenericMono<BaseEmptyListMono> getPoolEmpty()
	private void checkCreate()
	protected virtual void create()
	protected virtual void setupSortingTabs()
	protected virtual void showSortingTabs()
	private void OnRenderObject()
	private void LateUpdate()
		int num = int.MaxValue;
		int num2 = int.MinValue;
		float y = ((Transform)scroll_rect.content).localPosition.y;
		float pScrollRectTop = y + ((Rect)(ref rect)).height;
		for (int i = 0; i < listTotal.Count; i++)
		if (num2 == int.MaxValue || num == int.MinValue)
		int num3 = Math.Max(0, num - 3);
		int num4 = Math.Min(listTotal.Count - 1, num2 + 3);
		for (int j = 0; j < listTotal.Count; j++)
		for (int k = num3; k <= num4; k++)
	private void makeElementVisible(BaseEmptyListMono pEmptyMono)
	private bool IsVisibleInScrollRect(RectTransform pRectTransform, ScrollRect pScrollRect, float pScrollRectTop, float pScrollRectBottom)
		float num = pRectTransform.sizeDelta.y * 0.6f;
	private void addEmptyPoolSystem()
	private void showElement(TMetaObject pObject)
	protected static IEnumerable<TMetaObject> getObjects(ComponentListBase<TListElement, TMetaObject, TData, TComponent> pComponentList)
	protected virtual IEnumerable<TMetaObject> getFiltered(IEnumerable<TMetaObject> pList)
	private void OnEnable()
	protected virtual void show()
	public ListPool<NanoObject> getElements()
	protected void showElements()
		for (int i = 0; i < listPool.Count; i++)
	public virtual bool isEmpty()
	public virtual void clear()
		for (int i = 0; i < listTotal.Count; i++)
	private void releaseElement(BaseEmptyListMono pEmptyMono)
	private void debugUpdateElementNames(IReadOnlyList<BaseEmptyListMono> pList, float pScrollRectTop, float pScrollRectBottom)
		for (int i = 0; i < pList.Count; i++)
	private void OnDisable()
	public void setShowFavoritesOnly()
	public void setShowAll()
	public void setShowDeadOnly()
	public void setShowAliveOnly()
	public virtual void setDefault()
	public ListItemsFilter getCurrentFilter()
	public void init(GameObject pNoItems, SortingTab pSortingTab, GameObject pListElementPrefab, Transform pListTransform, ScrollRect pScrollRect, Text pTitleCounter, Text pFavoritesCounter, Text pDeadCounter)
	public virtual bool checkRefreshWindow()
	protected void genericMetaSortByAge(Comparison<TMetaObject> pAction)
		sorting_tab.tryAddButton("ui/Icons/iconAge", "sort_by_age", show, delegate
	protected void genericMetaSortByRenown(Comparison<TMetaObject> pAction)
		sorting_tab.tryAddButton("ui/Icons/iconRenown", "sort_by_renown", show, delegate
	protected void genericMetaSortByPopulation(Comparison<TMetaObject> pAction)
		sorting_tab.tryAddButton("ui/Icons/iconPopulation", "sort_by_members", show, delegate
	protected void genericMetaSortByKills(Comparison<TMetaObject> pAction)
		sorting_tab.tryAddButton("ui/Icons/iconKills", "sort_by_kills", show, delegate
	protected void genericMetaSortByDeath(Comparison<TMetaObject> pAction)
		sorting_tab.tryAddButton("ui/Icons/iconDead", "sort_by_dead", show, delegate
	protected int sortByRenown(IMetaObject p1, IMetaObject p2)
	protected int sortByAge(IMetaObject p1, IMetaObject p2)
	public static int sortByPopulation(IMetaObject p1, IMetaObject p2)
	public static int sortByKills(IMetaObject p1, IMetaObject p2)
	public static int sortByDeaths(IMetaObject p1, IMetaObject p2)
public class ComponentListSapient<TListElement, TMetaObject, TData, TComponent> : ComponentListBase<TListElement, TMetaObject, TData, TComponent>, ISapientListComponent where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData where TComponent : ComponentListBase<TListElement, TMetaObject, TData, TComponent>
	private Text _sapient_counter;
	private Text _non_sapient_counter;
	private SapientListFilter _filter;
	protected override void show()
	protected override IEnumerable<TMetaObject> getFiltered(IEnumerable<TMetaObject> pList)
	public void setShowSapientOnly()
	public void setShowNonSapientOnly()
	public override void setDefault()
	public void setSapientCounter(Text pCounter)
	public void setNonSapientCounter(Text pCounter)
namespace ai.behaviours.conditions;
public class CondActorFlying : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondActorNotJustLanded : BehaviourActorCondition
	public override bool check(Actor pActor)
		bool result = pResult <= 0;
namespace ai.behaviours.conditions;
public class CondCurrentTileNoOtherUnits : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonCanLand : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonCanLandAttack : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonCanSlide : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonHasCityTarget : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonHasTargets : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonNotSleepy : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondDragonSleeping : BehaviourActorCondition
	public override bool check(Actor pActor)
		string text = pActor.ai.task?.id;
namespace ai.behaviours.conditions;
public class CondDragonSleepy : BehaviourActorCondition
	public override bool check(Actor pActor)
namespace ai.behaviours.conditions;
public class CondNoPeace : BehaviourActorCondition
	public override bool check(Actor pActor)
public class Config
	public static bool parallel_jobs_updater = true;
	public static bool parallel_chunk_manager = true;
	public static string versionCodeText = string.Empty;
	public static string gitCodeText = string.Empty;
	public static string versionCodeDate = string.Empty;
	public static string iname = string.Empty;
	internal static bool? gen = null;
	public static string testStreamingAssets = "test";
	public static bool ui_main_hidden = false;
	public static int WORLD_SAVE_VERSION = 17;
	public static string current_map_template = "continent";
	public static string customMapSize = "standard";
	public static int customZoneX = 0;
	public static int customZoneY = 0;
	public static int customPerlinScale = 10;
	public static int customRandomShapes = 10;
	public static int customWaterLevel = 10;
	public static int ZONE_AMOUNT_X = 4;
	public static int ZONE_AMOUNT_Y = 4;
	public static string customMapSizeDefault = "standard";
	public static string maxMapSize = "iceberg";
	public static int ZONE_AMOUNT_X_DEFAULT = 3;
	public static int ZONE_AMOUNT_Y_DEFAULT = 4;
	public const int MAP_BLOCK_SIZE = 64;
	public const int CHUNK_SIZE = 16;
	public const int TILES_IN_CHUNK = 256;
	public const int CITY_ZONE_SIZE = 8;
	public const int CITY_ZONE_TILES = 64;
	public const int TILES_IN_REGION = 256;
	public const int PREVIEW_MAP_SIZE = 512;
	public const float FOCUS_SCROLL_DELAY_PC = 0.4f;
	public const float FOCUS_SCROLL_DELAY_PHONE = 0.55f;
	public static WorldTimeScaleAsset time_scale_asset = null;
	public static bool fps_lock_30 = false;
	public static bool MODDED = false;
	public static bool EVERYTHING_MAGIC_COLOR = false;
	public static bool EVERYTHING_FIREWORKS = false;
	private static bool _paused = false;
	public static bool lockGameControls = false;
	internal static string steam_name;
	internal static string steam_id;
	internal static bool steam_language_allow_detect = true;
	internal static string discordId;
	internal static string discordName;
	internal static string discordDiscriminator;
	public static bool testAds = false;
	public static bool firebaseInitiating = false;
	public static bool firebaseChecked = false;
	public static bool firebaseEnabled = true;
	public static bool authEnabled = false;
	public const string firebaseDatabaseURL = "https://worldbox-g.firebaseio.com/";
	public const string baseURL = "https://versions.superworldbox.com";
	public const string currencyURL = "https://currency.superworldbox.com";
	public static bool adsInitialized = false;
	public static bool disable_dispose_logs = true;
	public static bool disable_loading_logs = false;
	public static bool disable_discord = false;
	public static bool disable_steam = false;
	public static bool disable_db = false;
	public static bool disable_startup_window = false;
	public static bool disable_tutorial = false;
	public static bool debug_log_meta_ranks = false;
	public static string debug_last_selected_power_button;
	public static string debug_last_window;
	public static int debug_worlds_loaded;
	public static WindowStats debug_window_stats;
	public static bool load_random_test_map = false;
	public static bool load_new_map = false;
	public static bool load_dragon = false;
	public static bool load_save_on_start = false;
	public static bool load_save_from_path = false;
	public static string load_test_save_path = "";
	public static bool load_test_map = false;
	public static int load_save_on_start_slot = 1;
	public static string auto_test_on_start = null;
	public static float LOAD_TIME_INIT = 0f;
	public static float LOAD_TIME_CREATE = 0f;
	public static float LOAD_TIME_GENERATE = 0f;
	public static float LAST_LOAD_TIME = 0f;
	public static bool editor_test_rewards_from_ads = false;
	private static bool _hpr = false;
	public static bool sprite_animations_on = true;
	public static bool shadows_active = false;
	public static bool tooltips_active = true;
	public static bool preload_windows = true;
	public static bool preload_quantum_sprites = true;
	public static bool preload_buildings = true;
	public static bool preload_units = true;
	public static bool autosaves = true;
	public static bool graphs = true;
	public static bool experimental_mode = false;
	public static bool wbb_confirmed = false;
	public static bool full_screen = true;
	public static bool firebase_available = false;
	public static bool upload_available = false;
	public static bool game_loaded = false;
	public static bool show_console_on_start = false;
	public static bool show_console_on_error = true;
	public static bool editor_maxim = false;
	public static bool editor_mastef = false;
	public static bool editor_nikon = false;
	public static bool editor_devs = false;
	public static bool fmod_test_build = false;
	public static bool isEditor = false;
	public static bool isMobile = false;
	public static bool isIos = false;
	public static bool isAndroid = false;
	public static bool isComputer = true;
	public static bool grey_goo_damaged = false;
	public static GodPower power_to_unlock;
	private static string _current_brush = "circ_5";
	public static string selected_trait_editor = string.Empty;
	public static readonly SelectedObjectsGraph selected_objects_graph = new SelectedObjectsGraph();
	private static bool _dragging_item = false;
	public static IDraggable dragging_item_object = null;
	public static Kingdom whisper_A;
	public static Kingdom whisper_B;
	public static Kingdom unity_A;
	public static Kingdom unity_B;
	private static float timer = 30f;
	private static bool skip = false;
	private static List<string> _loggedSelectedPowers = new List<string>();
	private static bool _scheduledGC = false;
	private static bool _scheduledGCUnload = false;
	public static string gv;
	public static bool worldLoading => SmoothLoader.isLoading();
	public static bool paused
	public static bool hasPremium
	public static string current_brush
	public static BrushData current_brush_data { get; private set; }
	public static bool joyControls => false;
	public static string gs { get; } = "";
	public static void setDraggingObject(IDraggable pGameObject)
	public static bool isDraggingObject(IDraggable pGameObject)
	public static IDraggable getDraggingObject()
	public static void clearDraggingObject()
	public static bool isDraggingItem()
	public static void setWorldSpeed(WorldTimeScaleAsset pAsset, bool pUpdateDebug = true)
	public static void setWorldSpeed(string pID, bool pUpdateDebug = true)
	public static void nextWorldSpeed(bool pCycle = false)
	public static void prevWorldSpeed()
	public static void setPortrait(bool pValue)
	public static void setAutorotation(bool pValue)
	public static void enableAutoRotation(bool pValue)
	public static bool skipCrashMetadata()
	public static void updateCrashMetadata()
	public static void logSelectedPower(GodPower pPower)
	public static void scheduleGC(string pWhere, bool pUnloadResources = false)
	public static void checkGC()
	public static void forceGC(string pWhere, bool pUnloadResources = false)
	public static float getScrollToGroupDelay()
	public static void fireworksCheck(bool pEnabled)
	public static void valCheck(bool pEnabled)
	public static void pCheck(bool value)
	public static void magicCheck(bool pEnabled)
	public static void givePremium()
	public static void removePremium()
namespace WorldBoxConsole;
public class Console : MonoBehaviour
	private const int MAX_ELEMENTS = 2500;
	private const int MAX_LINES = 25000;
	private const int MAX_CHARS_PER_LINE = 256;
	private static int _line_num = 0;
	private static int _warning_num = 0;
	private static int _error_num = 0;
	private Text _prefab;
	private static Queue<string> _texts = new Queue<string>(2500);
	private static StringBuilder _log = new StringBuilder();
	private static int _error_repeated = 0;
	private static int _warning_repeated = 0;
	private static Dictionary<string, int> _previous_errors = new Dictionary<string, int>();
	private static Dictionary<string, int> _previous_warnings = new Dictionary<string, int>();
	private static HashSet<string> _stacks = new HashSet<string>();
	private RectTransform _text_group;
	private List<Text> _text_obj = new List<Text>();
	private ObjectPoolGenericMono<Text> _pool_texts;
	private static ConcurrentQueue<LogItem> log_queue = new ConcurrentQueue<LogItem>();
	private void Awake()
	private void addText()
	private void truncateGameObjects()
	internal static bool hasErrors()
	private static void truncateTexts()
	private void OnEnable()
	private void OnDisable()
	public void Toggle()
	public void Hide()
	public void Show()
	public bool isActive()
	public static void HandleLog(string pLogString, string pStackTrace, LogType pLogType)
	public static void ProcessLog(string pLogString, string pStackTrace, LogType pLogType, DateTime pTime)
		switch ((int)pLogType)
	private static void clearRepeat()
	private void Update()
		string text = string.Join('\n', _texts).Trim('\n', ' ');
		string[] array = text.Split('\n');
		int num = -1;
		for (int i = 0; i < array.Length; i++)
	public static void PrependTime(StringBuilder pStringBuilder, DateTime pDateTime)
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("[").Append("<color=white>").Append((pDateTime.Hour < 10) ? "0" : "")
		pStringBuilder.Insert(0, stringBuilderPool.string_builder);
	public void openLogsFolder()
namespace WorldBoxConsole;
public class ConsoleFormatter
	private static string log;
	private static string start;
	private static string end;
	private static string build = "";
	private static Regex _regex = new Regex("[\\d\\.]+");
	public static string logWarning(int pWarningNum, string pLogString)
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.AppendLine().Append("<color=yellow>--- warning[").Append(pWarningNum)
		string[] array = pLogString.Trim().Split('\n');
		foreach (string value in array)
		return stringBuilderPool.ToString();
	public static string logError(int pErrorNum, string pLogString, string pStackTrace)
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		string text = "";
		string[] array = text.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries);
		foreach (string value in array)
		stringBuilderPool.Append("<color=red>--- error[").Append(pErrorNum).Append("]: ---")
		foreach (string value2 in array)
		if (!string.IsNullOrEmpty(pStackTrace.Trim('\n', ' ')))
		return stringBuilderPool.ToString();
	public static string addSystemInfo()
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("-----------").AppendLine().Append("Game Version: <color=white>")
		if (!string.IsNullOrEmpty(Config.versionCodeText))
		StringBuilderPool stringBuilderPool2 = stringBuilderPool.AppendLine().Append("Modded: <color=white>").Append(Config.MODDED)
		stringBuilderPool2.Append(((object)(GraphicsTier)(ref activeTier)).ToString()).Append("</color>").AppendLine()
		return stringBuilderPool.ToString();
	public static string logFormatter(string pLogString, string pColor = "white")
	private static bool HasDigit(string pString)
		for (int i = 0; i < pString.Length; i++)
	public static string formatStacktrace(string pStackTrace)
		string[] array = pStackTrace.Split('\n');
		for (int i = 0; i < array.Length; i++)
		pStackTrace = string.Join("\n", array);
	private static string getShortGameplayStateInfo()
		bool? flag = instance.quality_changer?.isLowRes();
		string text = PowerButtonSelector.instance?.selectedButton?.godPower?.id;
		string debug_last_selected_power_button = Config.debug_last_selected_power_button;
		bool flag2 = SelectedUnit.isSet();
		bool flag3 = ControllableUnit.isControllingUnit();
		string text2 = Config.time_scale_asset?.id ?? "null";
		int debug_worlds_loaded = Config.debug_worlds_loaded;
		using StringBuilderPool stringBuilderPool = new StringBuilderPool();
		stringBuilderPool.Append("spd: <H>" + text2 + "</H>");
		if (!string.IsNullOrEmpty(text) || !string.IsNullOrEmpty(debug_last_selected_power_button))
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append("zoom: <H>");
		stringBuilderPool.Append((!flag.HasValue) ? "null" : (flag.Value ? "map" : "full"));
		stringBuilderPool.Append("</H>");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append("win: <H>" + (debug_window_stats.current ?? "none") + "</H> (<H>" + (debug_window_stats.previous ?? "none") + "</H>)");
		stringBuilderPool.Append($" (o:{debug_window_stats.opens},c:{debug_window_stats.closes},s:{debug_window_stats.shows},h:{debug_window_stats.hides})");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"worlds: {debug_worlds_loaded}");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"modded: <H>{Config.MODDED}</H>");
		stringBuilderPool.Append(", ");
		stringBuilderPool.Append($"db pend: <H>{DBInserter.hasCommands()}</H>");
		stringBuilderPool.AppendLine();
		using StringBuilderPool stringBuilderPool2 = new StringBuilderPool();
		if (stringBuilderPool2.Length > 0)
		using StringBuilderPool stringBuilderPool3 = new StringBuilderPool();
		if (stringBuilderPool3.Length > 0)
		return logFormatter(stringBuilderPool.ToString(), "yellow").Replace("<H>", "<color=yellow>").Replace("</H>", "</color>");
	private static string getWindowInfo()
public static class ConsoleHelper
	public static void clearLogConsole()
public static class ConsonantSeparator
	private static HashSet<char> _consonants = new HashSet<char>
	public static void addRandomVowels(StringBuilderPool pString, string[] pPartsToInsert)
		int num = pString.LastIndexOfAny(' ', ',') + 2;
		using ListPool<int> listPool = new ListPool<int>(pString.Length);
		for (int i = num; i < pString.Length; i++)
	public static ListPool<int> findAllConsonants(StringBuilderPool pString, int pStart, int pLength)
		ListPool<int> listPool = new ListPool<int>(pLength);
		for (int i = pStart; i < pStart + pLength; i++)
	public static ListPool<int> findAllSingleConsonants(StringBuilderPool pString, int pStart, int pLength)
		ListPool<int> listPool = new ListPool<int>(pLength);
		for (int i = pStart; i < pStart + pLength; i++)
	public static bool isConsonant(char pChar)
public class ConstantineConventer
	private static bool enabled;
	public static void init()
	public static void init2()
		string[] array = Resources.Load<TextAsset>("texts/fmod_sheet").text.Split('\n');
		List<string> list = new List<string>();
		string text = "";
		string text2 = "";
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
public class ConstructionCost
	public int wood;
	public int stone;
	public int common_metals;
	public int gold;
	public ConstructionCost(int pWood = 0, int pStone = 0, int pCommonMetals = 0, int pGold = 0)
public enum ConstructionPlacement
public class ContainerItemColor
	public string color_id;
	public Color color;
	private Material material;
	private string path_material;
	public ContainerItemColor(string pID, string pMaterialPath)
	public Material getMaterial()
		if (string.IsNullOrEmpty(path_material))
public static class ControllableUnit
	private const float TOUCH_ATTACK_START_DELAY = 0.05f;
	private static Actor _unit_main = null;
	private static HashSet<Actor> _units = new HashSet<Actor>();
	private static Vector2 _movement_vector;
	private static Vector2 _click_vector;
	private static bool _action_pressed_jump = false;
	private static bool _action_pressed_dash = false;
	private static bool _action_pressed_backstep = false;
	private static bool _action_pressed_steal = false;
	private static bool _action_pressed_swear = false;
	private static bool _action_pressed_talk = false;
	private static bool _attack_pressed_button_left = false;
	private static bool _attack_pressed_button_right = false;
	private static bool _attack_just_pressed_button_left = false;
	private static bool _attack_just_pressed_button_right = false;
	private static float _touch_attack_started_at;
	private static bool _touch_attack_just_started;
	private static string[] _possessed_icons = new string[6] { "ui/Icons/iconBre", "ui/Icons/iconCrying", "ui/Icons/iconAngry", "ui/Icons/actor_traits/iconStupid", "ui/Icons/actor_traits/iconStrongMinded", "ui/Icons/iconDead" };
	public static bool isControllingUnit(Actor pUnit)
	public static HashSet<Actor> getCotrolledUnits()
	public static bool isControllingUnit()
	public static int count()
	public static bool isControllingCrabzilla()
	public static bool isControllingNormalUnits()
	public static Actor getControllableUnit()
	public static bool isAttackPressedLeft()
	public static bool isAttackPressedRight()
	public static bool isAttackJustPressedLeft()
	public static bool isAttackJustPressedRight()
	public static void setControllableCreatures(ListPool<Actor> pListActors)
	public static void setControllableCreatureAndSelected(Actor pActor)
	public static void setControllableCreatureCrabzilla(Actor pActor)
	public static void setControllableCreature(Actor pActor)
	private static void resetClickVector()
	public static Vector2 getMovementVector()
	public static Vector2 getClickVector()
	public static bool isActionPressedJump()
	public static bool isActionPressedTalk()
	public static bool isActionPressedDash()
	public static bool isActionPressedBackstep()
	public static bool isActionPressedSteal()
	public static bool isActionPressedSwear()
	public static void remove(Actor pActor)
	private static void trySelectNewMain()
	public static void clear(bool pCallKill = true)
	public static void updateControllableUnit()
	private static bool isAnyActionsPressed()
	private static void checkActions()
		bool attack_pressed_button_left = _attack_pressed_button_left;
	private static void updateMouseAttackPosition()
	private static bool getAttackTouch(out Touch pTouch)
		bool joystickState = ultimateJoystick.GetJoystickState();
		int touchId = ultimateJoystick.getTouchId();
		bool result = false;
		for (int i = 0; i < touches.Length; i++)
	private static Vector2 getTouchAttackPosition()
	private static void checkPossessionStatus()
	private static void fixNextStep(Actor pActor)
	private static void addStatus(Actor pActor)
		bool flag = false;
	private static void updateClick()
	public static bool isMovementActionActive()
	private static void updateMovementVector()
	private static void updateMovementVectorJoystick()
	private static void updateMovementVectorKeyboard()
	public static void updateCamera()
		float num = 1f / World.world.camera.orthographicSize;
	public static float getJoyAxisVerticalRight()
	public static float getJoyAxisHorizontalRight()
	private static float getJoyAxisVerticalLeft()
	private static float getJoyAxisHorizontalLeft()
public class ConwayLife : MapLayer
	public static Color32 colorEater = Color32.op_Implicit(new Color(1f, 0.2f, 1f));
	public static Color32 colorCreator;
	public bool makeFlash = true;
	private HashSetWorldTile newList;
	private float nextTickTimer;
	private float nextTickInterval = 0.05f;
	private int decreaseTick;
	private List<WorldTile> toRemove = new List<WorldTile>();
	internal override void create()
	protected override void UpdateDirty(float pElapsed)
		for (int i = 0; i < Config.time_scale_asset.conway_ticks; i++)
	private void UpdateVisual()
	public void remove(WorldTile pTile)
	public void add(WorldTile pTile, string pType)
	private void updateTick()
	private void makeAlive(WorldTile pCell)
	internal void makeFlashh(WorldTile pCell, int pAmount)
	internal override void clear()
	private void checkCell(WorldTile pCell)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
	internal void checkKillRange(Vector2Int pPos, int pRad)
public enum ConwayType
public abstract class CoreSystemManager<TObject, TData> : SystemManager<TObject, TData>, IEnumerable<TObject>, IEnumerable where TObject : CoreSystemObject<TData>, new() where TData : BaseSystemData, new()
	public readonly List<TObject> list = new List<TObject>(512);
	private readonly HashSet<TObject> _hashset = new HashSet<TObject>(512);
	private bool _dirty_list;
	public override int Count => _hashset.Count;
	private void setListDirty()
	public IEnumerator<TObject> GetEnumerator()
	public override void checkLists()
	public override void loadFromSave(List<TData> pList)
	protected override void addObject(TObject pObject)
	public virtual List<TData> save(List<TObject> pList = null)
	public override void removeObject(TObject pObject)
	public TObject getRandom()
	public override void clear()
public abstract class CoreSystemObject<TData> : NanoObject, ICoreObject, ILoadable<TData>, IFavoriteable where TData : BaseSystemData
	public TData data;
	public virtual BaseSystemManager manager
	public override string name
		protected set
	public string obsidian_name_id => data.obsidian_name_id;
	public bool isFavorite()
	public void switchFavorite()
	public virtual void setFavorite(bool pState)
	public virtual bool updateColor(ColorAsset pColor)
	public virtual void save()
	public virtual void loadData(TData pData)
	public virtual void setData(TData pData)
	public override void setAlive(bool pValue)
	public override bool hasDied()
	public virtual int getAge()
	public override double getFoundedTimestamp()
	public bool isJustCreated()
	public string getFoundedDate()
	public string getDiedDate()
	public string getFoundedYear()
	public string getDiedYear()
	public int getAgeMonths()
	public override void trackName(bool pPostChange = false)
		if (!string.IsNullOrEmpty(data.name) && (!pPostChange || (data.past_names != null && data.past_names.Count != 0)))
	public override void Dispose()
	public sealed override long getID()
	public string getBirthday()
public class CornerAye : MonoBehaviour
	public static CornerAye instance;
	public Transform sprite;
	private RectTransform _rect;
	private void Awake()
	private void reset()
	private void Start()
	public void startAye()
		float num = 0.3f;
	private void moveBack()
		float num = 0.3f;
public static class CoroutineHelper
	public static WaitForSecondsRealtime wait_for_0_5_s => new WaitForSecondsRealtime(0.5f);
	public static WaitForSecondsRealtime wait_for_0_01_s => new WaitForSecondsRealtime(0.01f);
	public static WaitForSecondsRealtime wait_for_0_05_s => new WaitForSecondsRealtime(0.05f);
	public static WaitForSecondsRealtime wait_for_0_025_s => new WaitForSecondsRealtime(0.025f);
	public static YieldInstruction wait_for_end_of_frame => (YieldInstruction)new WaitForEndOfFrame();
	public static YieldInstruction wait_for_next_frame => null;
public class CorruptedTreeObject : MonoBehaviour
	public bool used;
public class CorruptedTreesManager : MonoBehaviour
	private string currentString = "";
	private List<CorruptedTreeObject> _objects;
	public GameObject win_icon;
	public void Start()
		for (int i = 0; i < ((Component)this).transform.childCount; i++)
	public void click(CorruptedTreeObject pObject)
	private void win()
	private void lost()
public class CountUpOnClick : MonoBehaviour
	private const float TWEEN_DURATION = 0.45f;
	private Text _text;
	private Tweener _cur_tween;
	private int _value;
	private string _end = "";
	private bool _value_updated;
	private void Start()
	public void setValue(int pValue, string pEnd = "")
	private bool checkString()
		string text = _text.text;
		if (!int.TryParse(text, NumberStyles.Any, CultureInfo.CurrentCulture, out _value))
	private bool checkIfStringIsLegit(string pString)
		if (string.IsNullOrEmpty(pString))
	private void countAnimation()
	public Text getText()
	private void OnDisable()
	private void checkDestroyTween()
public class CrabArm : MonoBehaviour
	internal Crabzilla crabzilla;
	public SpriteRenderer laser;
	public Transform laserPoint;
	public GameObject joint;
	public List<Sprite> laserSprites;
	public bool mirrored;
	private const float LASER_INTERVAL = 0.07f;
	private float _laser_timer = 0.07f;
	private int _laser_frame_index;
	private void Start()
	internal void update(float pElapsed)
		Vector3 val = World.world.camera.WorldToScreenPoint(crabzilla.armTarget.transform.position);
		Vector3 val2 = World.world.camera.WorldToScreenPoint(joint.transform.position);
		float num = Mathf.Atan2(val.y, val.x) * 57.29578f + 90f;
		joint.transform.rotation = Quaternion.Euler(new Vector3(0f, 0f, num));
	private void damageWorld()
		float x = ((Component)laserPoint).transform.position.x;
		float y = ((Component)laserPoint).transform.position.y;
		WorldTile tile = World.world.GetTile((int)x, (int)y);
	private void updateLaser(float pTime)
public class CrabBody : MonoBehaviour
public class CrabLeg : MonoBehaviour
	public CrabLegLimbPoint limbPoint;
	internal Crabzilla crabzilla;
	private Vector3 _current_position;
	private Vector3 _target_position;
	private Vector3 _random_pos = Vector3.zero;
	public CrabLegJoint legJoint;
	private Vector3 _target_pos;
	internal void create()
		_target_position = ((Component)limbPoint).transform.position;
	internal void update(float pElapsed)
		float num = Toolbox.DistVec3(_current_position, _target_position);
		_target_pos = ((Component)limbPoint).transform.position + _random_pos;
		if (!legJoint.isAngleOk(-20f, 30f))
	public void moveLeg()
		_target_pos = ((Component)limbPoint).transform.position + _random_pos;
		WorldTile tile = World.world.GetTile((int)_target_pos.x, (int)_target_pos.y);
public class CrabLegJoint : MonoBehaviour
	[Header("Joints")]
	public Transform Joint0;
	public Transform Joint1;
	public Transform Hand;
	public Transform Target;
	private float length0;
	private float length1;
	public float targetDistance;
	public bool mirrored;
	internal Crabzilla crabzilla;
	public float angleMax;
	public float angleMin;
	public float defaultAngle;
	private float atan;
	private float jointAngle0;
	private float jointAngle1;
	public float angle0;
	public float angle1;
	public float groundAngleMin = 50f;
	public float groundAngleMax = 140f;
	internal Transform bodyPoint;
	public float actual_z_pos;
	internal void create()
		length0 = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Joint1.position));
		length1 = Vector2.Distance(Vector2.op_Implicit(Joint1.position), Vector2.op_Implicit(Hand.position));
		targetDistance = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Target.position));
		Vector2 val = Vector2.op_Implicit(Target.position - Joint0.position);
		float num = (targetDistance * targetDistance + length0 * length0 - length1 * length1) / (2f * targetDistance * length0);
		GameObject val2 = new GameObject("leg_point_" + ((Object)((Component)this).transform).name);
		bodyPoint = val2.transform;
	public bool isAngleOk(float pMinAngle, float pMaxAngle)
		bool num = Toolbox.inBounds(angle0, angleMin, angleMax);
		Vector2 val = Vector2.op_Implicit(((Component)Joint1).transform.position - ((Component)Hand).transform.position);
		bool flag = Toolbox.inBounds(Mathf.Atan2(val.y, val.x) * 57.29578f, groundAngleMin, groundAngleMax);
	internal void LateUpdate()
		Vector3 position = bodyPoint.position;
		targetDistance = Vector2.Distance(Vector2.op_Implicit(Joint0.position), Vector2.op_Implicit(Target.position));
		Vector2 val = Vector2.op_Implicit(Target.position - Joint0.position);
		if (!float.IsNaN(jointAngle0))
public class CrabLegLimbPoint : MonoBehaviour
	private void Start()
public enum CrabLimb
public class CrabLimbGroup
	public CrabLimb crabLimb;
	private CrabLimbItem[] _list;
	private CrabLimbState _dmg_state;
	private Actor actor;
	private float _flicker_timer;
	private const float _flicker_interval = 0.15f;
	public CrabLimbGroup(CrabLimb pCrabLimb, Actor pActor)
	internal void update(float pElapsed)
	internal void showDamage()
		int health = actor.getHealth();
		int maxHealth = actor.getMaxHealth();
		if ((float)health > (float)maxHealth * 0.7f)
		else if ((float)health > (float)maxHealth * 0.35f)
		for (int i = 0; i < list.Length; i++)
	internal bool IsFlickering()
public class CrabLimbItem : MonoBehaviour
	public CrabLimb crabLimb;
	public Sprite high_hp;
	public Sprite med_hp;
	public Sprite low_hp;
	internal SpriteRenderer _sprite_renderer;
	private Color _shade;
	private Color _dmg = new Color(1f, 0f, 0f, 1f);
	private void Awake()
	internal void stateChange(CrabLimbState pState)
	internal void flicker(float pProgress)
public enum CrabLimbState
public class Crabzilla : BaseActorComponent
	internal const float HIGH_HP_THRESHOLD = 0.7f;
	internal const float MED_HP_THRESHOLD = 0.35f;
	private CrabLeg[] list_legs;
	private CrabLegJoint[] list_joints;
	private CrabLimbGroup[] list_limbs;
	private int active_limb = -1;
	public CrabBody mainBody;
	internal const float angle0_min = -20f;
	internal const float angle0_max = 30f;
	public GameObject armTarget;
	public GameObject mouthSprite;
	private SpriteAnimation mouthSpriteAnim;
	private bool _beam_enabled;
	private Vector3 bodyRotationTarget;
	private Vector3 bodyRotation;
	private float moveRotationLimit = 5f;
	private Vector3 bodyPosTarget;
	private Vector3 bodyPos;
	private float bodyPosTimeout;
	public CrabArm arm1;
	public CrabArm arm2;
	public float z_pos = 10f;
	internal override void create(Actor pActor)
	public bool isBeamEnabled()
	internal void legMoved()
	public override void update(float pElapsed)
		for (int i = 0; i < array.Length; i++)
		bool beam_enabled = ControllableUnit.isAttackPressedLeft();
		float num = World.world.elapsed * 60f;
	private void updateArms()
	private void createLimbs()
		list_joints = ((Component)this).GetComponentsInChildren<CrabLegJoint>(false);
		CrabLegJoint[] array = list_joints;
		for (int i = 0; i < array.Length; i++)
		for (int i = 0; i < array2.Length; i++)
		for (int j = 0; j < list_limbs.Length; j++)
		array = list_joints;
		foreach (CrabLegJoint obj2 in array)
		for (int i = 0; i < array2.Length; i++)
	internal static bool getHit(BaseSimObject pSelf, BaseSimObject pAttackedBy = null, WorldTile pTile = null)
	public void ShowLimbDamage()
	private bool isAnyLimbFlickering()
public enum CreepWorkerMovementType
public static class CrowdinSettings
	public const string API_TOKEN = "-";
	public const string PROJECT_ID = "-";
public class CubeNode : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IInitializePotentialDragHandler
	private const float SCALE_HIGHLIGHTED = 1.6f;
	private const float SCALE_NORMAL = 1f;
	private const float TOOLTIP_SCALE_MIN = 0.4f;
	private const float TOOLTIP_SCALE_MAX = 1f;
	public Vector4 logical_pos;
	internal List<CubeNode> connected_nodes = new List<CubeNode>();
	private List<CubeNodeConnection> connections = new List<CubeNodeConnection>();
	private Image _image;
	private Text _text;
	private CubeOverview _cube_overview;
	internal float render_depth;
	internal float scale_mod_spawn = 1f;
	internal float bonus_scale = 1f;
	internal bool highlighted;
	private float _timer_change;
	private TooltipData _tooltip_data;
	private CubeNodeAssetData _data;
	public BaseUnlockableAsset current_asset => _data.asset;
	private void Start()
	public void update()
	public void setDebugText(string pText)
	public void clear()
	protected void initClick()
	protected void initTooltip()
	private void showTooltip()
	public void setupAsset(CubeNodeAssetData pData)
	public void updateTooltip()
	public void setHighlighted()
	public void setPressed()
	public void setColor(Color pColor)
	public void addConnection(CubeNode pNode, CubeNodeConnection pConnection)
	public void OnInitializePotentialDrag(PointerEventData pEventData)
	public void OnBeginDrag(PointerEventData pEventData)
	public void OnDrag(PointerEventData pEventData)
	public void OnEndDrag(PointerEventData pEventData)
public class CubeNodeAssetData
	public readonly BaseUnlockableAsset asset;
	public readonly string knowledge_type;
	public CubeNodeAssetData(BaseUnlockableAsset pAsset, string pKnowledgeType)
public class CubeNodeConnection : MonoBehaviour
	private Sprite _connection_inner;
	private Sprite _connection_outer;
	public Image image;
	internal CubeNode node_1;
	internal CubeNode node_2;
	internal bool inner_cube;
	internal float mod_light = 1f;
	public void update()
	public void setConnection(bool pInner)
	public void clear()
public class CubeOverview : MonoBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IDragHandler, IEndDragHandler
	private DragSnapElement _knob_perspective_strength_x;
	private DragSnapElement _knob_perspective_strength_y;
	private DragSnapElement _knob_perspective_strength_z;
	private DragSnapElement _knob_perspective_strength_main;
	private DragSnapElement _knob_warp;
	private DragSnapElement _knob_lense;
	private DragSnapElement _knob_spacing;
	private DragSnapElement _knob_speed_outer;
	private DragSnapElement _knob_speed_inner;
	private DragSnapElement _knob_speed_4d;
	private DragSnapElement _knob_icon_size;
	private DragSnapElement _knob_connection_size;
	private DragSnapElement _knob_reset;
	private CubeNode _active_node;
	private CubeNode _prefab_node;
	private CubeNodeConnection _prefab_connection;
	private RectTransform _parent_connections;
	private RectTransform _parent_nodes;
	private GameObject _object_main;
	private float _offset_target_x = -0.015f;
	private float _offset_target_y = 0.07f;
	private bool _is_dragging;
	private Vector2 _last_mouse_delta;
	private float _offset_x;
	private float _offset_y;
	internal bool highlighted;
	private List<CubeNode> _nodes_by_index = new List<CubeNode>();
	private List<CubeNode> _nodes = new List<CubeNode>();
	private ObjectPoolGenericMono<CubeNode> _pool_nodes;
	private ObjectPoolGenericMono<CubeNodeConnection> _pool_connections;
	private Quaternion _rotation_q = Quaternion.identity;
	private Quaternion _rotation_q_2 = Quaternion.identity;
	private List<CubeNodeAssetData> _all_available_assets = new List<CubeNodeAssetData>();
	private CubeNode _latest_touched_node;
	private KnowledgeAsset _filter_asset;
	private float _angle_4d;
	private const float DRAGGING_SMOOTHING_TIME = 0.1f;
	private const float ROTATION_BOUNDS = 0.7f;
	private const float ROTATION_BOUNDS_MARGIN = 1.05f;
	private const float DRAG_SPEED = 0.46f;
	private const float DRAG_ROTATE_SPEED = 0.005f;
	private const float MIN_NODE_CURSOR_DISTANCE = 40f;
	public float RADIUS_NODE_PLACEMENT = 30f;
	private const float NODE_SCALE_MIN = 0.4f;
	private const float NODE_SCALE_MAX = 1.2f;
	private Color _color_node_back = Toolbox.makeColor("#1D7A74");
	private Color _color_node_front = Toolbox.makeColor("#DDDDDD");
	private Color _node_highlighted = Toolbox.makeColor("#FFFFFF");
	private Color _color_connection_back = Toolbox.makeColor("#1D7A74", 0.5f);
	private Color _color_connection_default = Toolbox.makeColor("#3AFFF5", 1f);
	private const float PERSPECTIVE_STRENGTH_MAIN = 3f;
	private const float PERSPECTIVE_STRENGTH_MAIN_MOD = 1f;
	private const float PERSPECTIVE_STRENGTH_AXIS = 1f;
	private const float SPACING_MOD = 1f;
	private const float SPEED_MOD_OUTER = 0.2f;
	private const float SPEED_MOD_INNER = 0.2f;
	private const float SPEED_MOD_4D = 0.3f;
	private const float MOD_NODE_SIZE = 1f;
	private const float MOD_CONNECTION_SIZE = 1f;
	private const float WARP_MOD = 0f;
	private const float LENSE_MOD = 0f;
	private const float FOLD_MOD = 0f;
	private float _perspective_strength_main_mod = 1f;
	private float _perspective_strength_main = 3f;
	private float _perspective_strength_x = 1f;
	private float _perspective_strength_y = 1f;
	private float _perspective_strength_z = 1f;
	private float _mod_lense;
	private float _mod_warp;
	private float _spacing_mod = 1f;
	private float _speed_mod_inner = 0.2f;
	private float _speed_mod_outer = 0.2f;
	private float _speed_mod_4d = 0.3f;
	private float _mod_node_size = 1f;
	private float _mod_connection_size = 1f;
	public float spacing = 25f;
	private static readonly Vector4[] _hypercube_positions = (Vector4[])(object)new Vector4[16]
	private static readonly int[,] _hypercube_connections = new int[32, 2]
	protected void Awake()
	private void initStartPositions()
		for (int i = 0; i < _hypercube_positions.Length; i++)
	private void prepareConnections()
		for (int i = 0; i < _hypercube_connections.GetLength(0); i++)
	private Vector3 project4Dto3D(Vector4 p)
		float num = _perspective_strength_main * _perspective_strength_main_mod;
		float num2 = Mathf.Exp((0f - Mathf.Abs(p.w)) * _mod_lense);
		float num3 = p.w;
		float num4 = Mathf.Sin(num3 * _mod_warp);
		float num5 = num - num3;
		float num6 = ((num5 == 0f) ? 0f : (num / num5));
	private void updateRotationAndSpeeds()
		float num = 0f - _offset_x;
		float num2 = 0f - _offset_y;
		float num3 = _offset_y;
		float num4 = _offset_y;
	private void updateNodesVisual()
		float angle_4d = _angle_4d;
	private Vector4 rotate4D(Vector4 pPoint, float pAngle)
		float num = Mathf.Cos(pAngle);
		float num2 = Mathf.Sin(pAngle);
		float num3 = pPoint.x * num - pPoint.w * num2;
		float num4 = pPoint.x * num2 + pPoint.w * num;
		float num5 = pPoint.y * num - pPoint.z * num2;
		float num6 = pPoint.y * num2 + pPoint.z * num;
	protected void OnEnable()
	private CubeNodeConnection makeConnection(CubeNode pNode1, CubeNode pNode2)
	private void fillAssets()
	private void loadUnlockables(ILibraryWithUnlockables pLibrary, string pType)
	private void Update()
	private void updateKnobs()
		float num = 0.05f;
	private void updateConnectionPositions()
	public CubeNodeAssetData getRandom()
	public void setLatestTouched(CubeNode pNode)
	public void setFilterAsset(KnowledgeAsset pAsset)
	private void highlightAllConnectonsFromDrag(float pLight)
	private void highlightNode(CubeNode pHighlighted = null)
	private CubeNode getClosestNodeToCursor()
		float num = float.MaxValue;
	private void smoothOffsets()
	internal bool isDragging()
	private void calculateNodeDepth(CubeNode pElement, float pRadius)
		float z = ((Component)pElement).transform.localPosition.z;
		float render_depth = Mathf.InverseLerp(0f - pRadius, pRadius, z);
	private void sortNodesByDepth()
	private void clearContent()
	public void OnDrag(PointerEventData eventData)
		Vector2 delta = eventData.delta;
	public void OnEndDrag(PointerEventData eventData)
		Vector2 delta = eventData.delta;
	public void OnInitializePotentialDrag(PointerEventData eventData)
		eventData.useDragThreshold = false;
	public void OnBeginDrag(PointerEventData eventData)
	private void updateNodeColorAndScale(CubeNode pNode)
		float num = Mathf.Lerp(0.4f, 1.2f, pNode.render_depth);
	private CubeNode getHighlightedNode()
public class Culture : MetaObjectWithTraits<CultureData, CultureTrait>
	public const int MAX_LEVEL = 5;
	public readonly List<City> cities = new List<City>();
	public readonly List<Kingdom> kingdoms = new List<Kingdom>();
	public readonly BooksHandler books = new BooksHandler();
	private readonly List<string> _preferred_weapons_craft_subtypes = new List<string>();
	private readonly List<EquipmentAsset> _preferred_weapons_craft_assets = new List<EquipmentAsset>();
	private NameSetAsset _name_set_asset;
	private readonly List<CultureTrait> _traits_town_plan_zones = new List<CultureTrait>();
	private readonly Dictionary<MetaType, OnomasticsData> _onomastics_data = new Dictionary<MetaType, OnomasticsData>();
	protected override MetaType meta_type => MetaType.Culture;
	public override BaseSystemManager manager => World.world.cultures;
	protected override AssetLibrary<CultureTrait> trait_library => AssetManager.culture_traits;
	protected override List<string> default_traits => getActorAsset().default_culture_traits;
	protected override List<string> saved_traits => data.saved_traits;
	protected override string species_id => data.original_actor_asset;
	public void createCulture(Actor pActor, bool pAddDefaultTraits)
		string pName = pActor.generateName(MetaType.Culture, getID());
	public void cloneAndEvolveOnomastics(Culture pFrom)
	protected override void recalcBaseStats()
	private void recalcTownPlanTraits()
	public void countConversion()
	protected sealed override void setDefaultValues()
	public override void increaseBirths()
	public int countCities()
	public int countKingdoms()
	protected override ColorLibrary getColorLibrary()
	public bool canUseRoads()
	public void testDebugNewBook()
	private void recalcPreferredWeapons()
	public bool hasPreferredWeaponsToCraft()
	public List<EquipmentAsset> getPreferredWeaponAssets()
	public string getPreferredWeaponSubtypeIDs()
	public float chanceToGiveTraits()
	public void clearListCities()
	public void clearListKingdoms()
	public void listCity(City pCity)
	public void listKingdom(Kingdom pKingdom)
	public override void generateBanner()
	public override void save()
	public override void loadData(CultureData pData)
		if (!string.IsNullOrEmpty(data.name_template_set) && !AssetManager.name_sets.has(data.name_template_set))
		foreach (KeyValuePair<MetaType, string> onomastic in pData.onomastics)
	public override void updateDirty()
	public void debug(DebugTool pTool)
	internal void updateTitleCenter()
	public Sprite getElementSprite()
	public Sprite getDecorSprite()
	public List<long> getBooks()
	public override bool isReadyForRemoval()
	public override void convertSameSpeciesAroundUnit(Actor pActorMain, bool pOverrideExisting = false)
	public override void forceConvertSameSpeciesAroundUnit(Actor pActorMain)
	public override void Dispose()
	public string getNameTemplate(MetaType pType)
	public void loadAllOnomasticsData()
	public OnomasticsData getOnomasticData(MetaType pType, bool pReset = false)
	public bool planAllowsToPlaceBuildingInZone(TileZone pZone, TileZone pCenterZone)
	public bool hasSpecialTownPlans()
	public bool hasTrueRoots()
	public bool isPossibleToConvertToOtherMeta()
	public override bool hasCities()
	public override IEnumerable<City> getCities()
	public override bool hasKingdoms()
	public override IEnumerable<Kingdom> getKingdoms()
public class CultureBanner : BannerGeneric<Culture, CultureData>
	protected override MetaType meta_type => MetaType.Culture;
	protected override string tooltip_id => "culture";
	protected override void loadPartBackground()
	protected override TooltipData getTooltipData()
	protected override void setupBanner()
public class CultureBannerLibrary : GenericBannerLibrary
	public override void init()
public class CultureBookButton : MonoBehaviour
	private Book _book;
	public Image cover;
	public Image icon;
	private bool _created;
	private void Start()
	private void create()
	public void setupTooltip()
	internal void load(long pBookID)
	internal void load(Book pBook)
		string pPath = "books/book_icons/" + asset.path_icons + _book.data.path_icon;
		string pPath2 = "books/book_covers/" + _book.data.path_cover;
	private void showTooltip()
public class CultureColorsLibrary : ColorLibrary
	public CultureColorsLibrary()
	public override void init()
	public override bool isColorUsedInWorld(ColorAsset pAsset)
public class CultureCustomizeWindow : GenericCustomizeWindow<Culture, CultureData, CultureBanner>
	protected override MetaType meta_type => MetaType.Culture;
	protected override Culture meta_object => SelectedMetas.selected_culture;
	protected override void onBannerChange()
public class CultureData : MetaObjectData
	public int banner_decor_id;
	public int banner_element_id;
	public string creator_city_name = string.Empty;
	public long creator_city_id = -1L;
	public long creator_id = -1L;
	public string creator_name = string.Empty;
	public string creator_species_id = string.Empty;
	public string creator_subspecies_name = string.Empty;
	public long creator_subspecies_id = -1L;
	public long creator_kingdom_id = -1L;
	public string creator_kingdom_name = string.Empty;
	public long creator_clan_id = -1L;
	public string creator_clan_name = string.Empty;
	public List<string> saved_traits;
	public double timestamp_last_written_book;
	public Dictionary<MetaType, string> onomastics;
	public int year_obsolete;
	public string name_template_set = "";
	public long parent_culture_id = -1L;
	public string original_actor_asset { get; set; }
	public string race
	public override void Dispose()
public class CultureElement : WindowMetaElement<Culture, CultureData>
	protected Culture culture => meta_object;
public class CultureListComponent : ComponentListBase<CultureListElement, Culture, CultureData, CultureListComponent>
	protected override MetaType meta_type => MetaType.Culture;
	protected override void setupSortingTabs()
		sorting_tab.tryAddButton("ui/Icons/iconVillages", "sort_by_villages", show, delegate
	public static int sortByVillages(Culture pCulture1, Culture pCulture2)
public class CultureListElement : WindowListElementBase<Culture, CultureData>
	public Text name;
	public CountUpOnClick textFollowers;
	public CountUpOnClick textCities;
	public CountUpOnClick textRenown;
	public CountUpOnClick textAge;
	public CountUpOnClick textBooks;
	internal override void show(Culture pCulture)
	protected override void OnDisable()
	protected override void tooltipAction()
	protected override ActorAsset getActorAsset()
public class CultureManager : MetaSystemManager<Culture, CultureData>
	private bool _dirty_kingdoms = true;
	private bool _dirty_cities = true;
	public CultureManager()
	public Culture newCulture(Actor pFounder, bool pAddDefaultTraits)
	public void addRandomTraitFromBiomeToCulture(Culture pCulture, WorldTile pTile)
	public override void removeObject(Culture pObject)
	protected override void updateDirtyUnits()
		for (int i = 0; i < units_only_alive.Count; i++)
	public void beginChecksKingdoms()
	private void updateDirtyKingdoms()
	private void clearAllKingdomLists()
		using IEnumerator<Culture> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListKingdoms();
	public void beginChecksCities()
	private void updateDirtyCities()
	private void clearAllCitiesListst()
		using IEnumerator<Culture> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListCities();
	public void setDirtyCities()
	public void setDirtyKingdoms()
	public override bool isLocked()
	public Culture getMainCulture(List<Actor> pUnitList)
		for (int i = 0; i < pUnitList.Count; i++)
	public override void clear()
public class CultureSelectedContainerTraits : SelectedContainerTraits<CultureTrait, CultureTraitButton, CultureTraitsContainer, CultureTraitsEditor>
	protected override MetaType meta_type => MetaType.Culture;
	protected override IReadOnlyCollection<CultureTrait> getTraits()
	protected override bool canEditTraits()
public class CultureSelectedOnomasticsNames : OnomasticsNameGenerator
	private GameObject _main_container;
	private GameObject _separator;
	private Culture _culture;
	private string _last_template;
	private MetaType _meta_type => MetaType.Unit;
	public void load(Culture pCulture)
		string templateString = getTemplateString(pCulture);
	public void update()
		bool flag = _culture.isRekt();
	public void click()
	private string getTemplateString(Culture pCulture)
public class CultureStatsElement : CultureElement, IStatsElement, IRefreshElement
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public class CultureTrait : BaseTrait<CultureTrait>
	public bool is_weapon_trait;
	public List<string> related_weapon_subtype_ids;
	public List<string> related_weapons_ids;
	public bool town_layout_plan;
	public PassableZoneChecker passable_zone_checker;
	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_traits_culture;
	public override string typed_id => "culture_trait";
	protected override IEnumerable<ITraitsOwner<CultureTrait>> getRelatedMetaList()
	public override BaseCategoryAsset getGroup()
	public void addWeaponSpecial(string pID)
	public void addWeaponSubtype(string pSubtype)
	public void setTownLayoutPlan(PassableZoneChecker pZoneCheckerDelegate)
public class CultureTraitButton : TraitButton<CultureTrait>
	protected override string tooltip_type => "culture_trait";
	internal override void load(string pTraitID)
	protected override void startSignal()
	protected override TooltipData tooltipDataBuilder()
public class CultureTraitEditorButton : TraitEditorButton<CultureTraitButton, CultureTrait>
public class CultureTraitGroupAsset : BaseTraitGroupAsset
public class CultureTraitGroupElement : TraitGroupElement<CultureTrait, CultureTraitButton, CultureTraitEditorButton>
public class CultureTraitGroupLibrary : BaseCategoryLibrary<CultureTraitGroupAsset>
	public override void init()
public class CultureTraitLibrary : BaseTraitLibrary<CultureTrait>
	protected override string icon_path => "ui/Icons/culture_traits/";
	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	public override void init()
	private void addTownPlansZones()
		t.setTownLayoutPlan(TownPlans.isPassableMadmanLabyrinth);
	private void addTownPlansTilePlacements()
	private void addTownLayoutOpposites()
		using ListPool<string> listPool = new ListPool<string>();
	private void addWeaponRelatedTraits()
	public static float getValueFloat(string pID)
	public static int getValue(string pID)
		return (int)AssetManager.culture_traits.get(pID).value;
public class CultureTraitsContainer : TraitsContainer<CultureTrait, CultureTraitButton>
public class CultureTraitsEditor : TraitsEditor<CultureTrait, CultureTraitButton, CultureTraitEditorButton, CultureTraitGroupAsset, CultureTraitGroupElement>
	protected override MetaType meta_type => MetaType.Culture;
	protected override List<CultureTraitGroupAsset> augmentation_groups_list => AssetManager.culture_trait_groups.list;
	protected override List<CultureTrait> all_augmentations_list => AssetManager.culture_traits.list;
	protected override CultureTrait edited_marker_augmentation => AssetManager.culture_traits.get("ethno_sculpted");
	protected override void startSignal()
	protected override void metaAugmentationClick(CultureTraitEditorButton pButton)
public class CultureWindow : WindowMetaGeneric<Culture, CultureData>, ITraitWindow<CultureTrait, CultureTraitButton>, IAugmentationsWindow<ITraitsEditor<CultureTrait>>, IBooksWindow
	public StatBar experienceBar;
	public override MetaType meta_type => MetaType.Culture;
	protected override Culture meta_object => SelectedMetas.selected_culture;
	public void testDebugNewBook()
	public List<long> getBooks()
	protected override void showTopPartInformation()
	internal override void showStatsRows()
	protected override bool onNameChange(string pInput)
		string name = meta_object.data.name;
	T IAugmentationsWindow<ITraitsEditor<CultureTrait>>.GetComponentInChildren<T>(bool includeInactive)
public static class CursedSacrifice
	private const int SACRIFICE_COUNT = 314;
	private const int MAX_MESSAGES = 9;
	private static int _last_message_index = -1;
	private static int _current_sacrifice_count = 0;
	private static double _cursed_world_timestamp = 0.0;
	private static bool _latest_sacrificed_was_egg;
	public static void checkGoodForSacrifice(Actor pActor)
		bool flag = false;
	public static void spawnVoidElves()
		Subspecies voidElvesSubspecies = getVoidElvesSubspecies();
		if (voidElvesSubspecies != null)
	private static Subspecies getVoidElvesSubspecies()
	public static void countAllSacrificesDebug()
		for (int i = 0; i < 314; i++)
	private static void countSacrifice()
		int num = (int)(getCurseProgressRatio() * 9f);
	public static float getCurseProgressRatio()
		return (float)_current_sacrifice_count / 314f;
	public static float getCurseProgressRatioForBlackhole()
		return (float)_current_sacrifice_count / 314f;
	public static void reset()
	private static int getCurrentSacrificeCount()
	public static void loadAlreadyCursedState()
	public static bool isWorldReadyForCURSE()
	public static bool isAllSacrificesDone()
	public static void justCursedWorld()
	public static bool justGotCursedWorld()
	public static bool isLatestWasEgg()
public class CursorSpeed
	private Vector2 _lastFramePos;
	private Vector2 _curFramePos;
	private float difference;
	public float speed;
	public float fmod_speed;
	public void update()
		fmod_speed = (int)speed;
	public void debug(DebugTool pTool)
public static class CursorTooltipHelper
	private static float _timeout = 0f;
	private static float _timeout_interval = 0.2f;
	public static bool is_over_meta;
	public static void update()
		bool flag = false;
	private static bool updateGameplayTooltip()
		string text = "actor";
	private static bool showTooltipForSelectedMeta(Actor pActor)
		string text;
	private static bool updateMapTooltip()
		bool result = false;
	private static void cancel()
		Tooltip.hideTooltip(null, pOnlySimObjects: true, string.Empty);
	private static bool isInputHappening()
	private static void resetTimout()
		_timeout = _timeout_interval;
public class CustomButtonSwitch : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	public Action click_increase;
	public Action click_decrease;
	private Animator anim;
	private Vector3 defaultScale;
	private Vector3 clickedScale;
	private void Start()
	public void OnPointerClick(PointerEventData eventData)
		if ((int)eventData.button == 1)
	private void Awake()
	public void newClickAnimation()
	private void OnDestroy()
public class CustomDataContainer<TType> : IDisposable
	internal Dictionary<string, TType> dict = UnsafeCollectionPool<Dictionary<string, Dictionary<string, TType>>, KeyValuePair<string, Dictionary<string, TType>>>.Get();
	public TType this[string pKey]
	public IEnumerable<string> Keys => dict.Keys;
	public bool TryGetValue(string pKey, out TType pValue)
	public void Remove(string pKey)
	public void Dispose()
public class CustomDataContainerConverter : JsonConverter
	public override void WriteJson(JsonWriter pWriter, object pValue, JsonSerializer pSerializer)
	public override object ReadJson(JsonReader pReader, Type pObjectType, object pExistingValue, JsonSerializer pSerializer)
	public override bool CanConvert(Type pObjectType)
public class CustomizeWindow : MonoBehaviour
	public ColorElement color_element_prefab;
	public MetaType meta_type;
	private bool _created;
	private void OnEnable()
public class CustomJsonArrayWriter : JsonTextWriter
	public CustomJsonArrayWriter(TextWriter writer)
	protected override void WriteIndent()
		if ((int)((JsonWriter)this).WriteState != 3)
public class CustomTextureAtlas
	private static int width = 1202;
	private static int height = 2021;
	public static bool filesExists()
	public static void createUnityBin()
	private static void save(string pData)
	internal static void delete(string pTexture)
	public static string createTextureID(string pString)
		string pID = width.ToString() + height;
public static class Date
	public static string getAgoString(double pTimestamp)
	public static string formatSeconds(float pSeconds)
		string text = ((int)pSeconds / 60).ToText();
	public static float getMonthTime()
		int monthsSince = getMonthsSince(0.0);
		return (float)World.world.getCurWorldTime() - (float)monthsSince * 5f;
	public static string getYearDate(double pTime)
	public static int getYear(double pTime)
	public static int getYear0(double pTime)
		return (int)(pTime / 60.0);
	public static int[] getRawDate(double pTime)
		int num = (int)(pTime / 5.0 / 12.0);
		int num4 = (int)num2;
		int num5 = (int)num3;
		int num6 = (int)((pTime - (double)((float)num5 * 5f * 12f)) / 5.0);
		int num7 = (int)((pTime - (double)((float)num4 * 5f)) / 5.0 * 30.0);
		return new int[3] { num7, num6, num };
	public static string getDate(double pTime)
		int[] rawDate = getRawDate(pTime);
		int num = rawDate[0];
		int pMonth = rawDate[1];
		int num2 = rawDate[2];
	internal static string formatMonth(int pMonth)
	internal static string formatDate(int pDay, int pMonth, int pYear)
		string input = culture.DateTimeFormat.LongDatePattern;
		string text = Regex.Replace(input, "\\bdddd[,\\s]*", "").Trim();
		string text2 = LocalizedTextManager.getText("inflected_month_" + pMonth);
	public static int getCurrentMonth()
	public static int getMonth(double pTimestamp)
		float num = getYear0(pTimestamp);
		return (int)((pTimestamp - (double)(num * 12f * 5f)) / 5.0 + 1.0);
	public static int getCurrentYear()
	public static int getYearsSince(double pFrom)
	public static int getMonthsSince(double pFrom)
		return (int)((World.world.getCurWorldTime() - pFrom) / 5.0);
	private static string GetDaySuffix(int day)
	public static bool isMonolithMonth()
	public static string getUIStringYearMonthShort()
	public static string getUIStringYearMonth()
	public static string TimeNow()
		return new string(array);
	private static void Write2Chars(char[] chars, int offset, int value)
	private static char Digit(int value)
namespace db;
public static class DBGetter
	public static ListPool<GraphTimeScale> getTimeScales(NanoObject pObject)
	public static ListPool<GraphTimeScale> getTimeScales(long pID, string pMetaType)
	public static ListPool<WorldLogMessage> getWorldLogMessages()
	public static bool getData(CategoryData pData, NanoObject pObject, HistoryInterval pInterval, HistoryTable pExtraData)
	public static bool getData(CategoryData pData, long pID, string pMetaType, HistoryInterval pInterval, HistoryTable pExtraData)
	public static Dictionary<string, long?> parseValues(object pItem, TableMapping pTableMapping)
		Dictionary<string, long?> dictionary = UnsafeCollectionPool<Dictionary<string, long?>, KeyValuePair<string, long?>>.Get();
namespace db;
public static class DBInserter
	internal static int _insert_commands_count = 0;
	internal static readonly List<(long MetaID, Type MetaType)> _delete_commands = new List<(long, Type)>(4096);
	internal static readonly Dictionary<string, ListPool<HistoryTable>> _insert_commands = new Dictionary<string, ListPool<HistoryTable>>(64);
	internal static readonly Dictionary<string, ListPool<BaseSystemData>> _insert_metas = new Dictionary<string, ListPool<BaseSystemData>>(64);
	internal static readonly List<WorldLogMessage> _insert_logs = new List<WorldLogMessage>(64);
	private const float SQL_TIMEOUT_TIME = 10f;
	private static float _sql_timeout = 10f;
	private static Task _thread;
	private static bool _locked = false;
	public static void Lock()
	public static void Unlock()
	public static bool isLocked()
	public static void deleteData(long pID, string pMetaType)
	public static void insertLog(WorldLogMessage pObject)
	public static void insertData(BaseSystemData pObject, string tMetaType)
	public static void insertData(HistoryTable pObject, string tMetaType)
	public static bool hasCommands()
	public static void clearCommands()
	public static void executeCommands()
	public static void executeCommandsAsync()
		_thread = asyncConnection.RunInTransactionAsync((Action<SQLiteConnection>)delegate(SQLiteConnection pDBConn)
	private static void sendToDB(SQLiteConnection pDBConn, ListPool<ListPool<BaseSystemData>> tMetasList = null, ListPool<ListPool<HistoryTable>> tCommandsList = null, ListPool<(long MetaID, Type MetaType)> tDeleteCommandsList = null, ListPool<WorldLogMessage> tInsertLogsList = null)
	public static void quitting()
		_sql_timeout = float.MaxValue;
	public static void waitForAsync()
namespace db;
public class DBManager : MonoBehaviour
	private static SQLiteAsyncConnection _dbconn;
	private static string _dbpath;
	private static void resetDataPath()
	public static bool loadDBFrom(string pPath)
	public static void createDB()
	public static void openDB()
	public static SQLiteAsyncConnection getAsyncConnection()
	public static SQLiteConnectionWithLock getSyncConnection()
	public static void clearAndClose()
	public static void closeDB()
	private static void vacuum()
	private static void backupTo(string pPath)
	public static void saveToPath(string pPath)
		string text = "Stats DB";
		string text2 = pPath + ".bak";
		bool flag = false;
	private void Awake()
		ScrollWindow.addCallbackShowStarted(delegate
	private void OnApplicationQuit()
namespace db;
public static class DBTables
	public static void createOrMigrateTables()
	public static void createOrMigrateTable(Type pType)
	public static void checkTablesOK(bool pDropTable = false)
		int currentYear = Date.getCurrentYear();
		bool flag = true;
	public static bool checkTableExists(Type pType)
	public static bool checkTableOK(Type pType, int pTimestamp)
	public static bool checkTableExists<T>()
	public static void createTableIfNotExists<T>()
	public static void createTable<T>()
	public static void createOrMigrateTablesLoader(bool pCreating = true)
		string text = (pCreating ? "Creating" : "Migrating");
		SmoothLoader.add(delegate
		SmoothLoader.add(delegate
namespace db;
public static class DBTriggers
	public static void createTrigger(SQLiteConnectionWithLock pDBConn, HistoryMetaDataAsset tHistoryAsset)
		List<string> list = new List<string>();
	public static void dropTrigger(SQLiteConnectionWithLock pDBConn, HistoryMetaDataAsset tHistoryAsset)
	public static void dropTrimTableTrigger(SQLiteConnectionWithLock pDBConn, string pTableName)
		((SQLiteConnection)pDBConn).ExecuteScalar<string>("DROP TRIGGER IF EXISTS DELETE_OLD_" + pTableName, Array.Empty<object>());
	public static void createTrimTableTrigger(SQLiteConnectionWithLock pDBConn, string pTableName, List<string> pColumns, int pMaxYears)
		string text = string.Format("CREATE TRIGGER IF NOT EXISTS DELETE_OLD_{0}\n\t\t\tAFTER INSERT ON {1}\n\t\t\tWHEN\n\t\t\t\tNEW.timestamp % {2} = 0\n\t\t\tAND\n\t\t\t\tEXISTS (\n    \t\t\t\tSELECT 1 FROM {3}\n    \t\t\t\tWHERE\n\t\t\t\t\t\tid = NEW.id AND\n\t\t\t\t\t\ttimestamp < (NEW.timestamp - {4})\n\t\t\t\t\tLIMIT 1\n\t\t\t\t)\n\t\t\tBEGIN\n\t\t\t\tINSERT OR REPLACE INTO {5}\n\t\t\t\t(\n\t\t\t\t\tid,\n\t\t\t\t\ttimestamp,\n\t\t\t\t\t{6},\n\t\t\t\t\tauto\n\t\t\t\t) VALUES (\n\t\t\t\t\tNEW.id,\n\t\t\t\t\tNEW.timestamp - {7},\n\t\t\t\t\t{8},\n\t\t\t\t\t1\n\t\t\t\t);\n\n-- \t\t\t\tUPDATE {9}\n-- \t\t\t\tSET\n-- \t\t\t\t\t{10}\n-- \t\t\t\tWHERE\n-- \t\t\t\t\tid = NEW.id AND\n-- \t\t\t\t\ttimestamp = (NEW.timestamp - {11})\n-- \t\t\t\t;\n\n\t\t\t\tDELETE FROM {12}\n\t\t\t\tWHERE\n\t\t\t\t\tid = NEW.id AND\n\t\t\t\t\ttimestamp < (NEW.timestamp - {13})\n\t\t\t\t;\n\t\t\tEND;", pTableName, pTableName, pMaxYears, pTableName, pMaxYears, pTableName, string.Join(", ", pColumns), pMaxYears, string.Join(", ", pColumns.Select((string x) => $"(SELECT {x} FROM {pTableName} WHERE id = NEW.id AND timestamp <= (NEW.timestamp - {pMaxYears}) AND {x} IS NOT NULL ORDER BY timestamp DESC LIMIT 1)")), pTableName, string.Join(", ", pColumns.Select((string x) => $"{x} = CASE WHEN {x} IS NULL THEN (SELECT {x} FROM {pTableName} WHERE id = NEW.id AND timestamp <= (NEW.timestamp - {pMaxYears}) AND {x} IS NOT NULL ORDER BY timestamp DESC LIMIT 1) ELSE {x} END")), pMaxYears, pTableName, pMaxYears);
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
	public static void dropNullDuplicateValuesTrigger(SQLiteConnectionWithLock pDBConn, string pTableName)
		((SQLiteConnection)pDBConn).ExecuteScalar<string>("DROP TRIGGER IF EXISTS NULL_DUPLICATES_" + pTableName, Array.Empty<object>());
	public static void createNullDuplicateValuesTrigger(SQLiteConnectionWithLock pDBConn, string pTableName, List<string> pColumns)
		string text = "CREATE TRIGGER IF NOT EXISTS NULL_DUPLICATES_" + pTableName + "\n\t\t\tAFTER INSERT ON " + pTableName + "\n\t\t\t\tWHEN NOT EXISTS (\n\t\t\t\t\tSELECT 1 FROM " + pTableName + " WHERE id = NEW.id AND timestamp > NEW.timestamp LIMIT 1\n\t\t\t\t)\n\t\t\tBEGIN\n\t\t\t\tUPDATE " + pTableName + "\n\t\t\t\tSET " + string.Join(", ", pColumns.Select((string x) => x + " = CASE WHEN (SELECT " + x + " FROM " + pTableName + " WHERE id = NEW.id AND " + x + " IS NOT NULL ORDER BY timestamp DESC LIMIT 1,1) = NEW." + x + " THEN NULL ELSE NEW." + x + " END")) + "\n\t\t\t\tWHERE rowid = NEW.rowid;\n\n\t\t\t\tDELETE FROM " + pTableName + " WHERE rowid = NEW.rowid AND " + string.Join(" AND ", pColumns.Select((string x) => x + " IS NULL")) + ";\n\t\t\tEND;";
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
	public static void dropInsertionTrigger(SQLiteConnectionWithLock pDBConn, string pTargetTable, int pYearDiviver)
		((SQLiteConnection)pDBConn).ExecuteScalar<string>($"DROP TRIGGER IF EXISTS FILL_{pTargetTable}_{pYearDiviver}", Array.Empty<object>());
	public static void createInsertionTrigger(SQLiteConnectionWithLock pDBConn, string pTargetTable, List<HistoryDataAsset> pColumns, string pSourceTable, int pYearDiviver)
		string text = string.Format("CREATE TRIGGER IF NOT EXISTS FILL_{0}_{1}\n\t\t\tAFTER INSERT ON {2}\n\t\t\t\tWHEN NEW.timestamp % {3} = 0 AND NEW.auto IS NOT 1\n\t\t\tBEGIN\n\t\t\tINSERT INTO\n\t\t\t\t{4}(\n\t\t\t\t\t{5},\n\t\t\t\t\tid,\n\t\t\t\t\ttimestamp\n\t\t\t\t)\n\t\t\tSELECT\n\t\t\t\t{6},\n\t\t\t\tNEW.id,\n\t\t\t\tNEW.timestamp\n\t\t\tFROM\n\t\t\t\t(\n\t\t\t\t\tSELECT\n\t\t\t\t\t\t*\n\t\t\t\t\tFROM\n\t\t\t\t\t\t{7}\n\t\t\t\t\tWHERE\n\t\t\t\t\t\tid = NEW.id\n\t\t\t\t\tAND\n\t\t\t\t\t\ttimestamp >= NEW.timestamp - {8}\n\t\t\t\t\tAND\n\t\t\t\t\t\ttimestamp < NEW.timestamp\n\t\t\t\t\tORDER BY\n\t\t\t\t\t\ttimestamp DESC\n\t\t\t\t);\n\n\t\t\tEND;", pTargetTable, pYearDiviver, pSourceTable, pYearDiviver, pTargetTable, string.Join(", ", pColumns.Select((HistoryDataAsset x) => x.id)), string.Join(", ", pColumns.Select(delegate(HistoryDataAsset x)
		((SQLiteConnection)pDBConn).ExecuteScalar<string>(text, Array.Empty<object>());
public delegate bool DeadAnimation(BaseSimObject pTarget, WorldTile pTile, float pElapsed);
public class DeadKingdom : Kingdom
	public override void loadData(KingdomData pData)
	public override int getAge()
		int year = Date.getYear(data.created_time);
	public override string getMotto()
public class DebugActorsSpeed : MonoBehaviour
	public int speedup = 20;
	private void Update()
public class DebugAnimatedVariation
	public bool animated;
	public Sprite[] frames;
	public DebugAnimatedVariation(Sprite[] pFrames, bool pAnimated)
public class DebugAnimationVariation : MonoBehaviour
	public SpriteAnimation sprite_animation;
	public Image image;
public class DebugAvatarsWindow : MonoBehaviour
	private static readonly bool _test_mutations = false;
	private static readonly bool _test_eggs = true;
	private static readonly bool _test_hand_items = false;
	private static readonly bool _test_statuses = false;
	private Transform _avatars_parent;
	private UnitAvatarLoader _avatar_prefab;
	private Image _autotest_button_icon;
	private Sprite _sprite_play;
	private Sprite _sprite_pause;
	private ObjectPoolGenericMono<UnitAvatarLoader> _avatars;
	private List<SubspeciesTrait> _pool_mutations = new List<SubspeciesTrait>();
	private List<SubspeciesTrait> _pool_eggs = new List<SubspeciesTrait>();
	private List<PhenotypeAsset> _pool_phenotype = new List<PhenotypeAsset>();
	private List<AvatarCombineHandItem> _pool_hand_renderers = new List<AvatarCombineHandItem>();
	private List<StatusAsset> _pool_statuses = new List<StatusAsset>();
	private AvatarsCombineDataContainer _combine_data = new AvatarsCombineDataContainer();
	private HashSet<string> _statuses = new HashSet<string>();
	private HashSet<long> _check_collisions = new HashSet<long>();
	private bool _autotest_state;
	private Coroutine _autotest_routine;
	private void Awake()
	private void init()
	private void OnEnable()
	private void OnDisable()
	private void clear()
	private void showAvatars()
	private void preparePools()
	private SubspeciesTrait getRandomMutation()
	private SubspeciesTrait getRandomEgg()
	private PhenotypeAsset getRandomPhenotype()
	private ActorSex getRandomSex()
	private bool getRandomIsAdult()
	private bool getRandomIsLying()
	private bool getRandomIsTouchingLiquid()
	private bool getRandomIsHovering()
	private bool getRandomIsImmovable()
	private bool getRandomIsUnconscious()
	private AvatarCombineHandItem getRandomItemPath()
	private List<string> getRandomStatuses(out bool pStopIdleAnimation)
		List<string> list = new List<string>();
	public void toggleAutotest()
	private T getFromPool<T>(List<T> pPool, int pGlobalIndex, string pId) where T : class
		int listIndex = _combine_data.getListIndex(pGlobalIndex, pId);
	private bool getBool(int pGlobalIndex, string pId)
	private IEnumerator autotestRoutine()
		int tTotal = _combine_data.totalCombinations();
		for (int i = 0; i < tTotal; i++)
public class DebugButton : MonoBehaviour
	public GameObject premiumButton;
public class DebugConfig : MonoBehaviour
	public GameObject debugButton;
	public static DebugConfig instance;
	private static Dictionary<DebugOption, bool> _dictionary;
	private static int _pos_x = 20;
	public static List<string> default_debug_tools = new List<string>();
	public static bool debug_enabled => instance.debugButton.gameObject.activeSelf;
	private void Start()
	private static void enableDefaultOptions()
	public static void initDict()
		_dictionary = new Dictionary<DebugOption, bool>();
	public static void init()
	private static void editorNikonOptions()
	internal static void debugToolMastefDefaults(DebugTool pTool)
	private static void editorMastefOptions()
		MapBox.on_world_loaded = (Action)Delegate.Combine(MapBox.on_world_loaded, (Action)delegate
	private static void debugBoats()
	private static void debugReproduction()
	private static void debugMapChunks()
	private static void editorMaximOptions()
		for (int i = 0; i < 100; i++)
	public static bool isOn(DebugOption pOption)
	public static void switchOption(DebugOption pOption)
	public static void disablePremiumNotify()
	public static void testAdsNotify()
	public static void setOption(DebugOption pOption, bool pVal, bool pUpdateSpecialSettings = true)
	public static void checkSonicTimeScales()
	public static void checkGraphy()
	public static void createTool(string pID, int pX = 80, int pY = -10, int pWidth = -1)
		for (int i = 0; i < debugTool.dropdown.options.Count; i++)
		((Component)debugTool).transform.localPosition = new Vector3((float)pX, (float)pY);
	private static void addDebugTool(string pID)
public class DebugDropdown : MonoBehaviour
	private DebugTool _debug_tool;
	private void OnEnable()
public class DebugDropdownOption : MonoBehaviour
	public Text title;
public static class DebugHighlight
	public static HashSet<DebugHighlightContainer> hashset = new HashSet<DebugHighlightContainer>();
	private static List<DebugHighlightContainer> to_remove = new List<DebugHighlightContainer>();
	public static void updateDebugHighlights()
	public static void newHighlightList(Color pColor, List<TileZone> pZones, float pTime = 3f)
	public static void newHighlightList(Color pColor, List<MapChunk> pChunks, float pTime = 3f)
	public static void clear()
	public static void newHighlight(Color pColor, MapChunk pChunk, float pTime = 3f)
	public static void newHighlight(Color pColor, TileZone pZone, float pTime = 3f)
public class DebugHighlightContainer
	public Color color;
	public float timer = 0.2f;
	public float interval = 0.2f;
	public TileZone zone;
	public MapChunk chunk;
	public WorldTile tile;
	public void setTimer(float pVal)
		interval = pVal;
public delegate void DebugIconOptionAction(Image pButton);
public class DebugKingdomButton : MonoBehaviour
	private Button _button;
	private Image _image;
	internal KingdomAsset kingdom_asset;
	private Image _discrepancy_bad;
	private Image _discrepancy_have;
	private Image _discrepancy_normal;
	public Image image => _image;
	public void setAsset(KingdomAsset pAsset)
	public void checkSelected(KingdomAsset pAssetMain)
	public void setupTooltip()
	private void showTooltip()
	public static void getTooltipDescription(KingdomAsset pAsset, out string pDescription, out string pDescription2)
		pDescription = string.Empty;
		pDescription2 = string.Empty;
		int num = 0;
		foreach (string assets_discrepancy in pAsset.assets_discrepancies)
public class DebugKingdomFoes : MonoBehaviour
	private DebugKingdomButton _prefab_button;
	private Image _selector;
	private GridLayoutGroup _grid_main;
	private GridLayoutGroup _grid_civs;
	private GridLayoutGroup _grid_minicivs;
	private GridLayoutGroup _grid_minicivs_special;
	private GridLayoutGroup _grid_concepts;
	private GridLayoutGroup _grid_mobs;
	private GridLayoutGroup _grid_creeps;
	private GridLayoutGroup _grid_others;
	private List<DebugKingdomButton> _buttons = new List<DebugKingdomButton>();
	private KingdomAsset _current_selected;
	private bool _initialized;
	private void Awake()
	private void create()
	private void select(DebugKingdomButton pButton)
	private void updateButtons()
public class DebugLayer : MapLayer
	internal static List<TileZone> fmod_zones_to_draw = new List<TileZone>();
	private HashSet<WorldTile> _tiles = new HashSet<WorldTile>();
	public Color color1 = Color.gray;
	public Color color2 = Color.white;
	public Color color_red = Color.red;
	public Color color_active_path;
	private bool used;
	private List<MapRegion> _forced_global_path = new List<MapRegion>();
	protected override void UpdateDirty(float pElapsed)
		if (DebugConfig.isOn(DebugOption.ConstructionTiles))
			drawConstructionTiles();
	private void drawUnitKingdoms()
	private void drawUnitTiles()
	private void drawTargetedBy()
	private void drawProfession(UnitProfession pPro)
	private void drawCitizenJobs(string pID)
	private void drawUnitsInside()
	private void drawConstructionTiles()
				foreach (WorldTile item3 in worldTile.building.checkZoneForDockConstruction(pZone))
	private void drawFmodZones()
	private void drawBuildings()
	private void drawCityCenterZones()
	private void drawCityFarmZones()
	private void drawVisibleZones()
		for (int i = 0; i < visibleZones.Count; i++)
	private void drawCityDangerZones()
	private void drawCityPlaces()
	private void drawActivePaths()
	public void drawRegionPath(List<MapRegion> pRegions)
	public void forceDrawRegionPath(List<MapRegion> pRegions)
	private void drawPathRegions()
		for (int i = 0; i < chunks.Length; i++)
	private void fill(List<WorldTile> pTiles, Color pColor, bool pEdge = false)
		for (int i = 0; i < pTiles.Count; i++)
	private void fill(WorldTile[] pTiles, Color pColor, bool pEdge = false)
	private void drawZones()
	private void testCityLayout()
	private void drawChunks()
	internal override void clear()
public class DebugLayerCursor : MapLayer
	private Color color_highlight_white;
	private Color color_main;
	private Color color_neighbour;
	private Color color_neighbour_2;
	private Color color_region;
	private Color color_edges;
	private Color color_chunk_bounds;
	private Color color_edges_blink;
	private List<WorldTile> _tiles = new List<WorldTile>();
	private bool blink = true;
	private float timerBlink = 0.2f;
	private float timerRecalc = 0.1f;
	private MapChunk lastChunk;
	internal override void create()
	protected override void UpdateDirty(float pElapsed)
	private void renderPossibleCityReach()
	private void drawIsland(TileIsland pIsland)
	private void drawConnections(WorldTile pTile)
	private void fill(List<WorldTile> pTiles, Color pColor, bool pEdge = false)
		for (int i = 0; i < pTiles.Count; i++)
	private void fill(WorldTile[] pTiles, Color pColor, bool pEdge = false)
	internal override void clear()
public enum DebugLayerType
public class DebugLocales
	private const string TODO_TEXT = "TODO_TEXT";
	private const string NO_TEXT = "???";
	public static void init()
namespace tools.debug;
public class DebugMap
	public static void makeDebugMap()
		for (int i = 0; i < tiles_list.Length; i++)
		int num = 10;
		int num2 = 10;
		int num3 = 0;
		int count = AssetManager.buildings.list.Count;
	private static void debugConstructionZone()
			building.debugConstructions();
	private static void debugNextFrame()
	private static void debugRuins()
	public static void createDebugButtons()
		Button obj3 = makeNewButton("debug_construction", "iconBucket");
		((UnityEvent)obj3.onClick).AddListener(new UnityAction(debugConstructionZone));
	private static Button makeNewButton(string pName, string pIcon)
public static class DebugMemory
	public static void addMemorySnapshot(string pWhen)
public class DebugMessage : MonoBehaviour
	public GameObject prefab;
	public static bool log_enabled;
	public static DebugMessage instance;
	public List<DebugMessageFly> list;
	private List<DebugMessageFly> messagesToMove = new List<DebugMessageFly>();
	private void Start()
	public void moveAll(DebugMessageFly pMessage)
	public DebugMessageFly getOldMessage(Transform pTransform)
	public static void log(Transform pTransofrm, string pMessage)
public class DebugMessageFly : MonoBehaviour
	private List<string> listString = new List<string>();
	public Transform originTransform;
	private TextMesh textMesh;
	private void Awake()
	public void addString(string pText)
		string text = "";
		foreach (string item in listString)
	public void moveUp()
	private void Update()
public class DebugMusicBoxData
	public const float INTERVAL = 3f;
	public float timer = 3f;
	public string path;
	public float x;
	public float y;
	public EventInstance instance;
	public bool isPlaying()
		return (int)val == 0;
public enum DebugOption
	ConstructionTiles,
	CityFastConstruction,
public class DebugTextGroupSystem : SpriteGroupSystem<GroupSpriteObject>
	private Vector2 _pos;
	public override void create()
	protected override GroupSpriteObject createNew()
	public override void update(float pElapsed)
	private void checkSoundsPlaying()
	private void checkSounds()
	private void checkSoundsAttached()
		int count = World.world.units.visible_units.count;
		for (int j = 0; j < count; j++)
	private void checkBoats()
	private void checkActors()
		int count = World.world.units.visible_units.count;
		for (int i = 0; i < count; i++)
	private void checkBuildings()
		int num = World.world.buildings.countVisibleBuildings();
		for (int i = 0; i < num; i++)
	private void checkZones()
	private void checkArmies()
	private void checkCitiesOverlay()
	private void checkCitiesTasksOverlay()
	private void checkKingdoms()
public class DebugTool : MonoBehaviour
	private sealed class _003C_003Ec
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();
		public static UnityAction _003C_003E9__30_24;
		internal void _003CinitButtons_003Eb__30_24()
	public const int DT_WIDTH = 126;
	public const int DT_HEIGHT = 60;
	protected ObjectPoolGenericMono<DebugToolTextElement> pool_texts;
	public DebugToolTextElement element_prefab;
	internal int textCount;
	public Dropdown dropdown;
	internal bool sort_order_reversed;
	internal bool sort_by_names;
	internal bool sort_by_values = true;
	internal bool show_averages = true;
	internal bool percentage_slowest;
	internal bool hide_zeroes = true;
	internal bool show_counter = true;
	internal bool show_max = true;
	internal DebugToolState state = DebugToolState.FrameBudget;
	public DebugToolType type;
	internal bool paused;
	internal DebugToolAsset asset;
	public DebugDropdown active_dropdown;
	private double last_update_timestamp;
	private List<DebugIconOptionAction> list_actions = new List<DebugIconOptionAction>();
	private List<Image> list_icons = new List<Image>();
	private Transform transform_texts;
	private Transform benchmark_icons;
	private string _latest_text;
	private void Awake()
	private void initElements()
	private float calculateLineHeight(Text pText)
	internal void populateOptions()
		List<string> list = new List<string>();
		((UnityEvent<int>)(object)dropdown.onValueChanged).RemoveListener((UnityAction<int>)switchTool);
		((UnityEvent<int>)(object)dropdown.onValueChanged).AddListener((UnityAction<int>)switchTool);
	public void filterOptions(string pInput)
	private void initButtons()
		newButton("SortByName", new UnityAction(clickSortByName), delegate(Image pIcon)
		newButton("SortByValues", new UnityAction(clickSortByValues), delegate(Image pIcon)
		newButton("SortReversed", (UnityAction)delegate
		newButton("ShowAverages", (UnityAction)delegate
		newButton("PercentBasedOnSlowest", (UnityAction)delegate
		newButton("HideZeroes", (UnityAction)delegate
		newButton("ShowCounter", (UnityAction)delegate
		newButton("ShowMax", (UnityAction)delegate
		newButton("ShowSeconds", (UnityAction)delegate
		newButton("ShowPercentages", (UnityAction)delegate
		newButton("ShowTimeSpent", (UnityAction)delegate
		newButton("ShowFrameBudget", (UnityAction)delegate
		newButton("Paused", (UnityAction)delegate
		newButton("EnableBenchmarks", (UnityAction)obj, delegate(Image pIcon)
	private void newButton(string pID, UnityAction pAction, DebugIconOptionAction pCheckIcon)
	public bool isValueAverage()
	public bool isState(DebugToolState pState)
	private void updateIcons()
		for (int i = 0; i < list_actions.Count; i++)
	private void checkIcon(Image pImageIcon, bool pValue)
	private void switchTool(int pIndex)
		string text = dropdown.options[pIndex].text;
	public void setAsset(DebugToolAsset pAsset)
	private void Update()
	public IEnumerator updateSizeAfterFrame()
	private void updateSize()
		float num = LayoutUtility.GetPreferredWidth(((Component)transform_texts).GetComponent<RectTransform>()) * 1.2f;
		float num2 = LayoutUtility.GetPreferredHeight(((Component)transform_texts).GetComponent<RectTransform>()) + 40f;
	public void clickSortByName()
	public void clickSortByValues()
	public int kingdomSorter(Kingdom k1, Kingdom k2)
	public int citySorter(City c1, City c2)
	internal void setText(string pT1, object pT2, float pBarValue = 0f, bool pShowBar = false, long pCounter = 0L, bool pShowCounter = false, bool pShowMax = false, string pMaxValue = "")
		string text = ((pT2 == null) ? "-" : pT2.ToString());
	internal void setSeparator()
		next.text_left.text = string.Empty;
		next.text_right.text = string.Empty;
	private void clearTexts()
	public void clickClose()
	public void clickDuplicate()
		int pX = (int)((Component)this).transform.localPosition.x + 126 + 2;
		int pY = (int)((Component)this).transform.localPosition.y;
public class DebugToolAsset : Asset
	public string name;
	public string benchmark_group_id = string.Empty;
	public string benchmark_total = string.Empty;
	public string benchmark_total_group = string.Empty;
	public string path_icon;
	public int priority;
	public DebugToolType type;
	public DebugToolAssetAction action_1;
	public DebugToolAssetAction action_2;
	public DebugToolAssetAction action_start;
	public DebugToolUpdateDelegate action_update;
	public float update_timeout = 0.1f;
	public bool show_on_start;
	public bool show_benchmark_buttons;
	public bool split_benchmark;
	public bool show_last_count;
	public void showForMaxim()
	public void showForMastef()
	public void showForNikon()
public delegate void DebugToolAssetAction(DebugTool pTool);
public class DebugToolLibrary : AssetLibrary<DebugToolAsset>
	private UtilityBasedDecisionSystem _decision_system_debug;
	public override void init()
	private void initDebugConfigDefaults()
		foreach (string default_debug_tool in DebugConfig.default_debug_tools)
	private void initDiagnosticGameplay()
	private void showReproductionDebugInfo(DebugTool pTool, Subspecies pSubspecies)
	private void initCity()
	private void initSystems()
	private void initMap()
	private void initSubSystems()
	private void initGameplay()
						pTool.setText("under construction:", building3.isUnderConstruction(), 0f, pShowBar: false, 0L);
						pTool.setText("progress:", building3.getConstructionProgress(), 0f, pShowBar: false, 0L);
	private void initMain()
	private void initAI()
	private void initFmod()
	private void initUI()
	public override void post_init()
		list.Sort((DebugToolAsset a, DebugToolAsset b) => string.Compare(a.id, b.id, StringComparison.InvariantCultureIgnoreCase));
	public override DebugToolAsset get(string pId)
	private void initBenchmarks()
		debugToolAsset.action_1 = (DebugToolAssetAction)Delegate.Combine(debugToolAsset.action_1, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset2.action_1 = (DebugToolAssetAction)Delegate.Combine(debugToolAsset2.action_1, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset3.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset3.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset4.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset4.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset5.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset5.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset6.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset6.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		t.action_update = delegate(DebugTool pTool)
		debugToolAsset7.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset7.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset8.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset8.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset9.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset9.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
		debugToolAsset10.action_start = (DebugToolAssetAction)Delegate.Combine(debugToolAsset10.action_start, (DebugToolAssetAction)delegate(DebugTool pTool)
			benchmark_group_id = "loops_struct_test",
			benchmark_total = "loops_struct_test",
			benchmark_total_group = "loops_struct_test_total",
	private void setBenchmarksDefaultValue(DebugTool pTool)
	private void showGroupBenchmarkTop(DebugTool pTool)
		float deltaTime = Time.deltaTime;
		pTool.setText("total frame time spent:", trimPercent(num2), (float)num2, pShowBar: true, 0L);
		pTool.setText("total budget time spent:", trimPercent(num3), (float)num3, pShowBar: true, 0L);
	private void showGroupBenchmarkBottom(DebugTool pTool)
		float deltaTime = Time.deltaTime;
	private string trim(double pValue, bool pAddMS = false)
		string text = pValue.ToString("F5");
	private string trimPercent(double pValue, bool pAddPercent = true)
		string text = pValue.ToString("F1");
	private double getTotalFrameBudget()
public enum DebugToolState
public class DebugToolTextElement : MonoBehaviour
	public Text text_left;
	public Text text_right;
	public Image text_bar;
public enum DebugToolType
public delegate void DebugToolUpdateDelegate(DebugTool pTool);
public class DebugUiDrag : EventTrigger
	private bool dragging;
	private Transform mainTransform;
	private Transform canvasContainer;
	private DebugTool _tool;
	private Canvas _canvas;
	private void Start()
	public void Update()
	public override void OnPointerDown(PointerEventData eventData)
	public override void OnPointerUp(PointerEventData eventData)
public class DebugVariables : MonoBehaviour
	public static DebugVariables instance;
	public float multiplier = 1f;
	public float bonus = 1f;
	public float time;
	public float gravity = 9.8f;
	public float unit_force_multiplier = 1f;
	public float test_mass = 2f;
	public bool layout_city_test;
	public bool layout_lines_horizontal;
	public bool layout_lines_vertical;
	public bool layout_cross;
	public bool layout_diagonal;
	public bool layout_lattice_small;
	public bool layout_lattice_medium;
	public bool layout_lattice_big;
	public bool layout_clusters_small;
	public bool layout_clusters_medium;
	public bool layout_clusters_big;
	public bool layout_ring;
	public bool layout_diamond;
	public bool layout_diamond_cluster;
	public bool layout_honeycomb;
	public bool layout_brick_vertical;
	public bool layout_brick_horizontal;
	public bool layout_madman_labyrinth;
	public bool layout_map_ring;
public class DebugWorldText : MonoBehaviour
	public TextMesh text_mesh;
	public TextMesh text_mesh_bg_clone;
	private string _color_sounds_attached = "#FF1F44";
	private string _color_sounds = "#607BFF";
	private string _color_actors = "#FF8F44";
	private string _color_building = "#00FFFF";
	private string _color_city = "#A0FF93";
	private string _color_kingdom = "#FF4242";
	private string cur_string;
	private string cur_color;
	public void create()
	private void prepare(string pID, string pColor, float pSize = 0.25f)
		cur_string = pID;
	private void add(string pTitle, object pText)
		cur_string = cur_string + pTitle + ": " + cur_color + pText?.ToString() + "</color>\n";
	public void setTextFmodSound(DebugMusicBoxData pData)
	public void setTextFmodSound(DebugMusicBoxData pData, Color pColor)
		float a = pData.timer / 3f;
		cur_string = "mb:" + pData.path;
	public void setTextFmodSound(EventInstance pInstance)
		string pText = default(string);
	public void setTextZone(TileZone pZone)
		(string, int)[] debug_args = pZone.debug_args;
		for (int i = 0; i < debug_args.Length; i++)
	public void setTextBoat(Actor pActor)
	private void debugForce(Actor pActor)
	public void setTextActor(Actor pActor)
	public void setTextArmy(Army pArmy)
	public void setTextBuilding(Building pObj)
	public void setTextCity(City pObj)
		bool flag = false;
		string text = "";
		foreach (string key in pObj.buildings_dict_id.Keys)
		int num = 0;
	public void setTextCityTasks(City pCity)
		int num = 0;
		int num2 = 0;
		int num6 = 0;
		int num7 = 0;
	public void setTextKingdom(Kingdom pObj)
	private void fin()
		text_mesh.text = cur_string;
		text_mesh_bg_clone.text = cur_string;
public static class DebugZonesTool
	public static void actionGrowBorder()
	public static void actionAbandonZones()
public delegate bool DecisionAction(Actor pActor);
public delegate float DecisionActionWeight(Actor pActor);
public class DecisionAsset : Asset, ILocalizedAsset
	public DecisionAction action_check_launch;
	public float weight = 1f;
	public bool has_weight_custom;
	public DecisionActionWeight weight_calculate_custom;
	public string task_id;
	public int decision_index;
	public int cooldown;
	public string path_icon;
	public NeuroLayer priority;
	public int priority_int_cached;
	public bool cooldown_on_launch_failure;
	public bool only_special;
	public bool unique;
	public bool list_civ;
	public bool list_baby;
	public bool list_animal;
	public bool only_adult;
	public bool only_mob;
	public bool only_herd;
	public bool only_sapient;
	public bool only_safe;
	public bool only_hungry;
	public bool city_must_be_safe;
	public Sprite cached_sprite;
	public virtual Sprite getSprite()
	public bool isPossible(Actor pActor)
	public bool isPossible(ref DecisionChecks pChecks)
	public string getLocalizedText()
	public string getLocaleID()
		string pID = ((!string.IsNullOrEmpty(task_id)) ? task_id : id);
	public string getFiringRate()
		float num = 1f / (float)cooldown;
public readonly ref struct DecisionChecks
	public readonly bool is_hungry;
	public readonly bool is_fighting;
	public readonly bool is_herd;
	public readonly bool is_adult;
	public readonly bool is_civ;
	public readonly bool is_sapient;
	public readonly bool city_is_in_danger;
	public readonly bool can_capture_city;
	public DecisionChecks(bool pIsHungry, bool pIsFighting, bool pIsHerd, bool pIsAdult, bool pIsCiv, bool pIsSapient, bool pCityIsInDanger, bool pCanCaptureCity)
	public DecisionChecks(Actor pActor)
public class DecisionHelper
	internal static UtilityBasedDecisionSystem decision_system = new UtilityBasedDecisionSystem();
	public static bool makeDecisionFor(Actor pActor, out string pLastDecisionID)
		pLastDecisionID = string.Empty;
		string pTaskId = decisionAsset.id;
		if (!string.IsNullOrEmpty(decisionAsset.task_id))
	public static void runSimulation(Actor pActor)
	public static void runSimulationForMindTab(Actor pActor)
public class DecisionsLibrary : AssetLibrary<DecisionAsset>
	public DecisionAsset[] list_only_civ;
	public DecisionAsset[] list_only_children;
	public DecisionAsset[] list_only_city;
	public DecisionAsset[] list_only_animal;
	public DecisionAsset[] list_others;
	public override void init()
	private void initDecisionsWarriors()
	private void initDecisionsStatusRelated()
	private void initDecisionsNomads()
	private void initDecisionsHerd()
	private void initDecisionSleep()
	private void initDecisionDiets()
	private void initDecisionsAnimals()
	private void initDecisionsSocialize()
	private void initDecisionsReproduction()
	private void initDecisionsClans()
	private void initDecisionsKings()
	private void initDecisionsLeaders()
	private void initDecisionsCivs()
	private void initDecisionsBoats()
	private void initDecisionsBees()
	private void initDecisionsGeneral()
	private void initDecisionsTraits()
	private void initDecisionsUnique()
	private void initDecisionsOther()
	private void initDecisionsChildren()
	public override void editorDiagnosticLocales()
	public override void linkAssets()
		int num = 0;
	public override void editorDiagnostic()
public class DelayedAction
	public readonly Action action;
	private bool _game_speed_affected;
	private float _timer;
	public DelayedAction(Action pAction, float pDelay, bool pGameSpeedAffected)
	public bool update(float pElapsed, float pDeltaTime)
public class DelayedActionsManager
	private List<DelayedAction> _delayed_actions = new List<DelayedAction>();
	private List<DelayedAction> _to_remove = new List<DelayedAction>();
	public void update(float pElapsed, float pDeltaTime)
		for (int i = 0; i < _delayed_actions.Count; i++)
		for (int j = 0; j < _to_remove.Count; j++)
	public static void addAction(Action pAction, float pDelay, bool pGameSpeed = true)
	private void addActionInstance(Action pAction, float pDelay, bool pGameSpeed = true)
	public void clear()
public class DelegateConverter : JsonConverter
	public override void WriteJson(JsonWriter pWriter, object pValue, JsonSerializer pSerializer)
	public override object ReadJson(JsonReader pReader, Type pObjectType, object pExistingValue, JsonSerializer pSerializer)
	public override bool CanConvert(Type pObjectType)
				return pObjectType.IsSubclassOf(typeof(Delegate));
public static class DelegateExtensions
	public static string AsString<T>(this T pDelegate) where T : Delegate
		using ListPool<string> listPool = new ListPool<string>(pDelegate.GetInvocationList().Length);
		for (int i = 0; i < invocationList.Length; i++)
		return string.Join(", ", listPool.ToArray());
public class DeleteMapQueue : QueueItem
	public string username;
	public string userId;
	public string reason;
	public string error;
	public string status;
	public string mapId;
public class DeleteWorldButton : MonoBehaviour
	private void Start()
	private void deleteWorld()
public enum DepthGeneratorType
public class Derp : GenericType
namespace EpPathFinding.cs;
public enum DiagonalMovement
public static class DictionaryExtensions
	public static int RemoveByValue<TKey, TValue>(this IDictionary<TKey, TValue> pDict, Predicate<TValue> pPredicate)
	public static int RemoveByKey<TKey, TValue>(this IDictionary<TKey, TValue> pDict, Predicate<TKey> pPredicate)
public static class DiplomacyHelpers
	public static WarManager wars => World.world.wars;
	public static DiplomacyManager diplomacy => World.world.diplomacy;
	public static bool isWarNeeded(Kingdom pKingdom)
		float num = pKingdom.getPopulationPeople();
		float num2 = pKingdom.getPopulationTotalPossible();
	public static Kingdom getWarTarget(Kingdom pInitiatorKingdom)
		float num = float.MaxValue;
		int num2 = pInitiatorKingdom.countTotalWarriors();
	public static Kingdom getAllianceTarget(Kingdom pKingdomStarter)
	public static bool areKingdomsClose(Kingdom pMain, Kingdom pTarget)
	public static bool isThereActiveCityConquest(Kingdom pKingdom, Kingdom pTargetKingdom)
	public static bool isThereFightBetween(Kingdom pKingdom1, Kingdom pKingdom2)
	private static bool isThereActiveCityFight(Kingdom pDefenderKingdom, Kingdom pAttackerKingdom)
	public static bool areDefendersGettingCaptured(this War pWar)
	public static bool areAttackersGettingCaptured(this War pWar)
	public static bool areAttackersAttackingAnotherCity(this War pWar)
	public static bool areDefendersAttackingAnotherCity(this War pWar)
	public static bool isAttackingAnotherCity(this Kingdom pAttackerKingdom)
public static class DiplomacyHelpersRebellion
	public static void startRebellion(Actor pActor, Plot pPlot, bool pCheckForHappiness)
		int num = kingdom.countCities();
		int maxCities = kingdom2.getMaxCities();
		for (int i = 0; i < maxCities; i++)
	public static bool checkMoreAlignedCities(Kingdom pNewKingdom, Kingdom pOldKingdom, ListPool<City> pNewCities, bool pCheckForHappiness)
	private static void addNeighbourCities(ListPool<City> pTempCitiesToCheck, ListPool<City> pRebelledCities)
public class DiplomacyManager : CoreSystemManager<DiplomacyRelation, DiplomacyRelationData>
	public static Kingdom kingdom_supreme;
	public static Kingdom kingdom_second;
	public static List<Kingdom> superpowers = new List<Kingdom>();
	private float diplomacyTick;
	private static List<Kingdom> _kingdom_sorter = new List<Kingdom>();
	private static List<DiplomacyRelation> _relations_remover = new List<DiplomacyRelation>();
	protected readonly Dictionary<string, DiplomacyRelation> _dict = new Dictionary<string, DiplomacyRelation>();
	public DiplomacyManager()
	public override List<DiplomacyRelationData> save(List<DiplomacyRelation> pList = null)
		using IEnumerator<DiplomacyRelation> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			DiplomacyRelation current = enumerator.Current;
	public override void loadFromSave(List<DiplomacyRelationData> pList)
		for (int i = 0; i < pList.Count; i++)
	public override DiplomacyRelation loadObject(DiplomacyRelationData pData)
	public override void update(float pElapsed)
	public void newDiplomacyTick()
	private void checkAchievements()
	private void findSupremeKingdom()
	public int sortByPower(Kingdom o1, Kingdom o2)
	private War startTotalWar(Kingdom pAttacker, WarTypeAsset pType)
	internal War startWar(Kingdom pAttacker, Kingdom pDefender, WarTypeAsset pAsset, bool pLog = true)
	public void eventSpite(Kingdom pKingdom)
	public void eventFriendship(Kingdom pKingdom)
	public KingdomOpinion getOpinion(Kingdom k1, Kingdom k2)
	public int sortID(Kingdom o1, Kingdom o2)
	public DiplomacyRelation getRelation(Kingdom pK1, Kingdom pK2)
		string text = kingdom.id + "_" + kingdom2.id;
	public void removeRelationsFor(Kingdom pKingdom)
		using (IEnumerator<DiplomacyRelation> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				DiplomacyRelation current = enumerator.Current;
	public bool tryGet(string pID, out DiplomacyRelation pObject)
	public DiplomacyRelation get(string pID)
		if (string.IsNullOrEmpty(pID))
	public override void removeObject(DiplomacyRelation pObject)
	public override void clear()
public class DiplomacyRelation : CoreSystemObject<DiplomacyRelationData>
	public Kingdom kingdom1;
	public Kingdom kingdom2;
	internal KingdomOpinion opinion_k1;
	internal KingdomOpinion opinion_k2;
	public override BaseSystemManager manager => World.world.diplomacy;
	protected sealed override void setDefaultValues()
	public KingdomOpinion getOpinion(Kingdom pMain, Kingdom pTarget)
	private void recalculate(Kingdom k1 = null, Kingdom k2 = null)
	public override void Dispose()
public class DiplomacyRelationData : BaseSystemData
	public string rel_id;
	public long kingdom1_id;
	public long kingdom2_id;
	public double timestamp_last_war_ended;
public enum DiplomacyState
public delegate void DisasterAction(DisasterAsset pAsset);
public class DisasterAsset : Asset
	public DisasterAction action;
	public int rate = 1;
	public float chance = 1f;
	public string world_log;
	public int min_world_population;
	public int min_world_cities;
	public bool premium_only;
	public DisasterType type = DisasterType.Other;
	public string spawn_asset_unit = string.Empty;
	public string spawn_asset_building = string.Empty;
	public int max_existing_units = 20;
	public int units_min = 1;
	public int units_max = 10;
	public HashSet<string> ages_allow = new HashSet<string>();
	public HashSet<string> ages_forbid = new HashSet<string>();
public class DisasterLibrary : AssetLibrary<DisasterAsset>
	public override void init()
	public DisasterAsset getRandomAssetFromPool()
		for (int i = 0; i < list.Count; i++)
	public void spawnMadThought(DisasterAsset pAsset)
		for (int i = 0; i < listPool.Count; i++)
	public void spawnGreg(DisasterAsset pAsset)
	public void spawnNecromancer(DisasterAsset pAsset)
	public void spawnEvilMage(DisasterAsset pAsset)
	public void spawnHeatwave(DisasterAsset pAsset)
		int num = Randy.randomInt(1, 3);
		bool flag = false;
		for (int i = 0; i < num; i++)
	public void spawnSmallEarthquake(DisasterAsset pAsset)
	public void spawnDragon(DisasterAsset pAsset)
	public void startAlienInvasion(DisasterAsset pAsset)
	public void spawnBiomass(DisasterAsset pAsset)
	public void spawnTumor(DisasterAsset pAsset)
	public void gardenSurprise(DisasterAsset pAsset)
	public void spawnTornado(DisasterAsset pAsset)
	public void spawnMeteorite(DisasterAsset pAsset)
	public void simpleUnitAssetSpawnUsingIslands(DisasterAsset pAsset)
	private bool checkUnitSpawnLimits(DisasterAsset pAsset)
		if (string.IsNullOrEmpty(pAsset.spawn_asset_unit))
	private Actor spawnDisasterUnit(DisasterAsset pAsset, WorldTile pTile)
		int num = Randy.randomInt(pAsset.units_min, pAsset.units_max);
		for (int i = 0; i < num; i++)
	private Building spawnDisasterBuilding(DisasterAsset pAsset, WorldTile pTile)
		if (string.IsNullOrEmpty(pAsset.spawn_asset_building))
public enum DisasterType
public class DiscordTracker : MonoBehaviour, IRichTracker
	private sealed class _003C_003Ec
		public static readonly _003C_003Ec _003C_003E9 = new _003C_003Ec();
		public static UpdateActivityHandler _003C_003E9__10_0;
		public static UpdateActivityHandler _003C_003E9__23_0;
		public static UpdateActivityHandler _003C_003E9__24_0;
		internal void _003CStart_003Eb__10_0(Result pRes)
		internal void _003CtrackActivity_003Eb__23_0(Result _)
		internal void _003CupdateDetails_003Eb__24_0(Result _)
	private const long DISCORD_GAME_ID = 816251591299432468L;
	private const ulong DISCORD_FLAGS = 1uL;
	private static Discord _discord;
	private static ActivityManager _activity_manager;
	private bool _initiated;
	private static DiscordTracker _instance;
	private static Activity _activity;
	private static bool _have_user = false;
	private static int _user_tries = 10;
	private static float _timer = 10f;
	private void Start()
		bool flag = false;
	private static void tryGetUser()
	private void Update()
	private void OnDisable()
	private void OnDestroy()
	public void trackViewing(string pString)
		if (pString != "" && LocalizedTextManager.stringExists(pString))
	public void trackWatching()
	public void trackUsing(string pPower)
	public void updateUsing(int pAmount, string pPower = "")
	public void inspectKingdom(string pKingdom)
	public void inspectVillage(string pVillage)
	public void inspectUnit(string pUnit)
	public void spectatingUnit(string pUnit)
	public void trackActivity(string pState = "")
	public void updateDetails(StatisticsAsset pStat)
		string localeID = pStat.getLocaleID();
		if (!string.IsNullOrEmpty(localeID))
public struct DiscountData
	public string discount;
	public string price_current;
	public string price_old;
internal static class Discounts
	private static ProductMetadata localPriceData;
	private static string platform;
	internal static void checkDiscounts()
	private static void discountRequest(ProductMetadata pProductMeta)
		string text = "https://currency.superworldbox.com/discounts/" + platform + ".json?" + Toolbox.cacheBuster();
		string text2 = JsonConvert.SerializeObject((object)pProductMeta, new JsonSerializerSettings
		if (string.IsNullOrEmpty(text2) || text2 == "{}")
		RestClient.Post(text, text2).Then((Action<ResponseHelper>)delegate(ResponseHelper response)
	private static void checkPlatform()
internal enum DivineLightState
public class Docks : BaseBuildingComponent
	public ListPool<WorldTile> tiles_ocean;
	private Dictionary<string, int> _boat_types;
	internal override void create(Building pBuilding)
	public TileIsland getIsland()
	public WorldTile getOceanTileInSameOcean(WorldTile pTile)
	public bool hasOceanTiles()
	public void recalculateOceanTiles()
	public bool isDockGood()
	private bool ifStayingOnGround()
	public override void update(float pElapsed)
	public int countBoatTypes(string pType)
	public bool isFull(string pType)
	public bool isOverfilled(string pType)
	public Actor buildBoatFromHere(City pCity)
	public void clearBoatCounter()
	public void increaseBoatCounter(Actor pActor)
	public void addBoatToDock(Actor pBoat)
	public override void Dispose()
public class DownloadCounterMapQueue : QueueItem
	public string username;
	public string userId;
	public string reason;
	public string error;
	public string status;
	public string mapId;
public class DraggableLayoutElement : MonoBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IDragHandler, IBeginDragHandler, IEndDragHandler, ILayoutIgnorer, IDraggable
	public const float TOUCH_DELAY = 0.2f;
	private bool _spawn_particles_on_drag = true;
	private RectTransform _rect;
	private CanvasGroup _canvas_group;
	private LayoutGroupExtended _parent_layout;
	private RectTransform _parent;
	private Rect _cached_parent_rect;
	private Vector3 _cached_parent_position;
	private Transform _attach_parent;
	private bool _touch_drag_delay;
	private DraggableLayoutElement _drag_object;
	private int _target_index = -1;
	private List<MonoBehaviour> _toggle_elements = new List<MonoBehaviour>(3);
	private static bool _any_dragging;
	private bool? _dragging_cache;
	private bool _drag_only_over_parent = true;
	internal Action<DraggableLayoutElement> start_being_dragged;
	private float _drag_timer_started_at;
	public bool spawn_particles_on_drag => _spawn_particles_on_drag;
	public bool ignoreLayout { get; set; }
	private List<RectTransform> _siblings => _parent_layout.m_Children;
	private Vector2[] _sibling_positions => _parent_layout.m_Positions;
	private void Start()
	private void OnEnable()
	public void KillDrag()
	private void OnDisable()
	public void OnInitializePotentialDrag(PointerEventData pEventData)
	public void OnBeginDrag(PointerEventData pEventData)
	public void OnDrag(PointerEventData pEventData)
	public void OnEndDrag(PointerEventData pEventData)
	public void Update()
	internal void lockToParent(bool pLock = true)
	internal void setDragParent(Transform pParent)
	private void moveToTarget()
	private void recalcParent()
	private void findTarget()
	private bool isOverParent(Vector2 pPosition)
	private void swapSiblings(int pStartIndex, int pTargetIndex)
	private int findClosestNeighbour(int pIndex, ListPool<int> pNeighbours)
	private ListPool<int> getNeighbours(int pIndex)
	private void addToggleComponent<T>() where T : MonoBehaviour
	private bool isTouchDragDelayed()
public class Dragon : BaseActorComponent
	private DragonAsset dragonAsset;
	private DragonState state;
	internal float idle_time = -1f;
	internal float sleep_time = -1f;
	internal SpriteAnimation spriteAnimation;
	internal HashSet<Actor> aggroTargets = new HashSet<Actor>();
	internal WorldTile lastLanded;
	private HashSet<WorldTile> _landAttackTiles = new HashSet<WorldTile>();
	private WorldTile _landAttackPosCheck;
	internal int _landAttackCache;
	internal HashSet<WorldTile> _slideAttackTilesFlip = new HashSet<WorldTile>();
	internal HashSet<WorldTile> _slideAttackTilesNoFlip = new HashSet<WorldTile>();
	private WorldTile _slideAttackPosCheckFlip;
	private WorldTile _slideAttackPosCheckNoFlip;
	internal int _slideAttackTilesFlipCache;
	internal int _slideAttackTilesNoFlipCache;
	internal override void create(Actor pActor)
	private void playSound(DragonState pState)
	internal static bool shouldFly(Actor pActor, WorldTile pTile = null)
	internal static bool canLand(Actor pActor, WorldTile pTile = null)
	internal void attackTile(WorldTile pTile)
	internal bool hasTargetsForSlide()
	internal bool targetWithinSlide(WorldTile pTargetTile)
	internal static Kingdom getIgnoredKingdom(Actor pActor)
	internal bool targetsWithinLandAttackRange()
	internal bool landAttackRange(WorldTile pTargetTile)
	internal HashSet<WorldTile> landAttackTiles(WorldTile pTile)
	internal WorldTile randomTileWithinLandAttackRange(WorldTile pTile)
	internal HashSet<WorldTile> attackRange(bool flip)
	private static bool hasTarget(WorldTile tTile, Actor pActor)
	public void setFrames(DragonState pDragonState, bool pForce = false)
	internal static bool clickToWakeup(BaseSimObject pTarget, WorldTile pTile = null)
	internal static bool canFlip(BaseSimObject pTarget = null, WorldTile pTile = null)
	internal static bool getHit(BaseSimObject pSelf, BaseSimObject pAttackedBy = null, WorldTile pTile = null)
	internal static bool dragonFall(BaseSimObject pTarget, WorldTile pTile, float pElapsed)
	public override void update(float pElapsed)
	internal void checkLiquid()
	public HashSet<WorldTile> getLandAttackTiles()
public class DragonAsset : ScriptableObject
	private Dictionary<DragonState, DragonAssetContainer> _dict;
	public DragonAssetContainer[] list;
	public DragonAssetContainer getAsset(DragonState pState)
public class DragonAssetContainer
	public string name;
	public DragonState id;
	public Sprite[] frames;
	public DragonState[] states;
	public float speed = 0.1f;
public enum DragonState
public class DragOrderContainer : MonoBehaviour
	public enum SnapAxis
	internal static float drag_delay = 0.25f;
	public MonoBehaviour scroll_rect;
	public SnapAxis snapping_axis = SnapAxis.No;
	public bool limit_moving;
	public bool delay_before_drag = true;
	public bool debug;
	public Action on_order_changed;
	internal DragOrderElement dragging_element;
	internal bool is_anything_dragging;
	internal RectTransform rect_transform;
	internal LayoutGroup grid_layout;
	internal LayoutElement layout_element;
	private List<DragOrderElement> _elements = new List<DragOrderElement>();
	private Dictionary<int, DragOrderElement> _elements_dict = new Dictionary<int, DragOrderElement>();
	private Dictionary<int, Vector2> _children_positions = new Dictionary<int, Vector2>();
	private Dictionary<int, Rect> _children_rects = new Dictionary<int, Rect>();
	private Transform _to_ignore_in_intersection;
	private int _previous_elements_count;
	private bool _marked_for_update;
	private int _marked_for_update_on_frame;
	private bool _initialized;
	private void Awake()
	private void markForUpdate()
	private void OnApplicationFocus(bool pHasFocus)
	private void OnEnable()
	private void OnDisable()
	private void onWindowClose(string pId)
	private void disable()
	private void Update()
	private void OnDrawGizmos()
	private void checkIntersections()
	private DragOrderElement getIntersectedWith()
	private void updatePositions()
	public void updateChildrenData()
	private void switchElements(DragOrderElement pFirst, DragOrderElement pSecond)
	public Vector3 getChildPosition(int pIndex)
	private int sort(DragOrderElement pFirst, DragOrderElement pSecond, bool pIsAscending)
	private static void drawRect(Rect pRect, Color pColor)
public class DragOrderElement : MonoBehaviour, IDraggable, IEndDragHandler, IEventSystemHandler
	private bool _spawn_particles_on_drag = true;
	public RectTransform main_transform;
	public bool can_be_dragged = true;
	private DragOrderContainer _container;
	private int _parent_canvas_sorting_order;
	private Canvas _canvas;
	private GraphicRaycaster _raycaster;
	private Button _button;
	private Transform _current_parent;
	internal Vector2 current_destination;
	internal bool is_target_reached;
	internal int order_index;
	private bool _drag_initialized;
	private float _drag_started_at;
	private int _mouse_button = -1;
	private Vector3 _prev_mouse_position;
	public bool spawn_particles_on_drag => _spawn_particles_on_drag;
	private void Start()
	private void checkContainer()
	private void checkParent()
	private void Update()
	private void setOnTop()
	internal void unsetOnTop()
	public void updatePosition()
	private void moveDraggingTab()
	private void checkDrag()
	private void checkDragBegin()
	private void checkDragEnd()
	public void OnEndDrag(PointerEventData pData)
	private void startDrag()
	public void stopDrag()
	private void endDrag()
	private Vector3 getChildPositionInContainer()
	private bool isMouseOver()
	public Rect getRect()
	private void getGridValues(LayoutGroup pLayoutGroup, out Vector2 pCellSize, out Vector2 pSpacing)
	private static bool shouldStartDrag(Vector2 pPressPos, Vector2 pCurrentPos)
	private void OnDisable()
	public void KillDrag()
public class DragSnapElement : MonoBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IDragHandler, IBeginDragHandler, IEndDragHandler, IScrollHandler, IDraggable, IPointerEnterHandler, IPointerExitHandler
	private bool _spawn_particles_on_drag = true;
	private bool _touch_drag_delay;
	private float _drag_timer_started_at;
	private Tweener _tweener;
	private LayoutElement _layout_element;
	private Button _button;
	private Vector3 _start_local_position;
	private Transform _start_parent;
	public float limit_max_drag_distance = 77f;
	public float snapback_max_distance = 77f;
	public float snapback_speed_max_distance = 0.35f;
	public float snapback_min_distance = 22f;
	public float snapback_speed_min_distance = 0.9f;
	public Transform attach_parent;
	public Transform fly_back_parent;
	public Ease ease = (Ease)24;
	public float speed = 0.4f;
	private ScrollRect _scroll_rect;
	private ScrollRectExtended _scroll_rect_extended;
	private bool _initial_ignore_layout;
	private bool _hovered;
	private bool _is_dragging;
	public bool spawn_particles_on_drag => _spawn_particles_on_drag;
	private void Start()
	public void OnInitializePotentialDrag(PointerEventData pEventData)
	public void OnBeginDrag(PointerEventData pEventData)
	public void OnDrag(PointerEventData pEventData)
	public float getDragMod()
	private void updatePosition(Vector3 pTargetPosition)
	public void OnEndDrag(PointerEventData pEventData)
	public void resetElement()
	public float dragSpeed(float pDistance)
	public void onWindowClose(string pId)
	public void OnScroll(PointerEventData pEventData)
	public void OnPointerEnter(PointerEventData eventData)
	public void OnPointerExit(PointerEventData eventData)
	private void sendMessage(string pMethodName, PointerEventData pEventData)
	public void OnEnable()
	public void OnDisable()
	public void KillDrag()
	private bool isTouchDragDelayed()
public class Drop : BaseMapObject
	private readonly bool DEBUG_COLOR;
	public int drop_index;
	internal bool active;
	private SpriteRenderer _sprite_renderer;
	private SpriteAnimation _sprite_animation;
	private float _currentHeightZ;
	private bool _landed;
	private DropAsset _asset;
	internal bool soundOn;
	private bool _parabolic;
	private float _falling_speed;
	private float _scale = 1f;
	private bool _force_surprise;
	private long _caster_id = -1L;
	private Vector2 _targetPosition;
	private Vector2 _startPosition;
	private float _targetHeight;
	private float _timeToTarget;
	private float _timeInAir;
	private Color _gizmoColor = Color.op_Implicit(Vector4.zero);
	private Color _gizmoColor2 = Color.op_Implicit(Vector4.zero);
	private float _rotation_speed;
	private void Awake()
	public void setForceSurprise()
	internal void prepare()
	internal void launchStraight(WorldTile pTile, DropAsset pAsset, float zDropHeight = -1f)
	public void launchParabolic(float pStartHeight, float pMinHeight, float pMaxHeight, float pMinRadius, float pMaxRadius)
	private void updateStraightFall(float pElapsed)
	private void applyRandomXMove(float pChangeX)
	private void land()
	public override void update(float pElapsed)
	private void updateRotation(float pElapsed)
	private void updateParabolicFall(float pElapsed)
	private void updatePosition()
	public void setScale(Vector3 pVec)
	public void setCasterId(long pCasterId)
	public long getCasterId()
	public void makeInactive()
	public void reset()
	private void OnDrawGizmos()
public class DropAsset : Asset
	public DropType type = DropType.DropGeneric;
	public bool random_frame;
	public bool random_flip;
	public bool animated;
	public float animation_speed = 0.1f;
	public float animation_speed_random = 0.1f;
	public bool animation_rotation;
	public float animation_rotation_speed_min = 1f;
	public float animation_rotation_speed_max = 1f;
	public string sound_drop;
	public string sound_launch;
	public DropsAction action_launch;
	public DropsAction action_landed;
	public DropsLandedAction action_landed_drop;
	public string building_asset;
	public float falling_speed = 3.2f;
	public float falling_speed_random = 0.5f;
	public Vector3 falling_height = Vector2.op_Implicit(new Vector2(15f, 20f));
	public bool falling_random_x_move;
	public float particle_interval;
	public string material = "mat_world_object";
	public string path_texture = "drops/drop_pixel";
	public float default_scale = 1f;
	public bool surprises_units;
	public string drop_type_low;
	public string drop_type_high;
	public TopTileType cached_drop_type_low;
	public TopTileType cached_drop_type_high;
	public Sprite[] cached_sprites;
	private string[] _building_asset_split;
	public string getRandomBuildingAsset()
public class DropManager
	private List<Drop> _drops = new List<Drop>();
	private float _timeout_timer;
	private int _activeIndex;
	private GameObject _original_drop;
	private Transform _dropContainer;
	public DropManager(Transform pDropContainer)
	public Drop spawn(WorldTile pTile, string pDropID, float zHeight = -1f, float pScale = -1f, long pCasterId = -1L)
	public Drop spawn(WorldTile pTile, DropAsset pAsset, float zHeight = -1f, float pScale = -1f, bool pForceSurprise = false, long pCasterId = -1L)
	public void spawnParabolicDrop(WorldTile pTile, string pDropID, float pStartHeight = 0f, float pMinHeight = 0f, float pMaxHeight = 0f, float pMinRadius = 0f, float pMaxRadius = 0f, float pScale = -1f)
	public void clear()
	private void killObject(Drop pObject)
	public void landDrop(Drop pObject)
	public Drop getObject()
	public void update(float pElapsed)
	public void debug(DebugTool pTool)
	public int getActiveIndex()
	private void debugString()
public delegate void DropsAction(WorldTile pTile = null, string pDropID = null);
public delegate void DropsLandedAction(Drop pDrop, WorldTile pTile = null, string pDropID = null);
public class DropsLibrary : AssetLibrary<DropAsset>
	private const string TEMPLATE_BIOME_SEEDS = "$biome_seeds$";
	private const string TEMPLATE_SPAWN_BUILDING = "$spawn_building$";
	private const string TEMPLATE_SPAWN_MINERAL = "$spawn_mineral$";
	private const string TEMPLATE_SPAWN_CREEP = "$spawn_creep$";
	private static HashSet<TileZone> _paint_zones_hashset = new HashSet<TileZone>();
	public override void init()
	public override void linkAssets()
	private void addWaypointDrops()
	public static void action_drop_seeds(WorldTile pTile = null, string pDropID = null)
	public static void useDropSeedOn(WorldTile pTile, TopTileType pTypeLow, TopTileType pHigh)
	public static void tryToGrowWheat(WorldTile pTile = null, string pDropID = null)
	public static void useSeedOn(WorldTile pTile, TopTileType pTypeLow, TopTileType pHigh)
	public static void action_rain(WorldTile pTile = null, string pDropID = null)
	private static void useRainOn(WorldTile pTile)
	public static void action_gamma_rain(WorldTile pTile = null, string pDropID = null)
	public static void action_delta_rain(WorldTile pTile = null, string pDropID = null)
	public static void action_omega_rain(WorldTile pTile = null, string pDropID = null)
	private static void useTraitRain(WorldTile pTile, List<string> pList, RainState pRainState)
	public static void action_equipment_rain(WorldTile pTile = null, string pDropID = null)
	private static void useEquipmentRain(WorldTile pTile, List<string> pItems, RainState pRainState)
	public static void action_acid(WorldTile pTile = null, string pDropID = null)
	public static void action_fire(WorldTile pTile = null, string pDropID = null)
	public static void action_fireworks(WorldTile pTile = null, string pDropID = null)
	public static void action_tnt(WorldTile pTile = null, string pDropID = null)
	public static void action_tnt_timed(WorldTile pTile = null, string pDropID = null)
	public static void action_czar_bomba(WorldTile pTile = null, string pDropID = null)
	public static void action_atomic_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_antimatter_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_napalm_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_crab_bomb_impact(WorldTile pTile = null, string pDropID = null)
	public static void action_crab_bomb_shrapnel(WorldTile pTile = null, string pDropID = null)
	public static void action_grenade(WorldTile pTile = null, string pDropID = null)
	public static void action_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_santa_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_water_bomb(WorldTile pTile = null, string pDropID = null)
	public static void action_lava(WorldTile pTile = null, string pDropID = null)
	public static void action_rage(WorldTile pTile = null, string pDropID = null)
	public static void action_magic_rain(WorldTile pTile = null, string pDropID = null)
	public static void action_ash(WorldTile pTile = null, string pDropID = null)
	public static void action_life_seed(WorldTile pTile = null, string pDropID = null)
	private void action_jazz_rain(WorldTile pTile, string pDropID)
	private static void trySpawnUnit(WorldTile pTile)
	private static void trySpawnVegetation(WorldTile pTile)
	public static void action_snow(WorldTile pTile = null, string pDropID = null)
	public static void checkColdOneBabies(WorldTile pTile)
	private static void action_cure(WorldTile pTile = null, string pDropID = null)
	private static void action_clone_rain(WorldTile pTile, string pDropID = null)
	private void action_sleep_rain(WorldTile pTile, string pDropID)
	private void action_dispel_rain(WorldTile pTile, string pDropID)
	public static void action_blood_rain(Drop pDrop, WorldTile pTile = null, string pDropID = null)
	public static void action_plague(WorldTile pTile = null, string pDropID = null)
	public static void action_zombie_infection(WorldTile pTile = null, string pDropID = null)
	public static void action_mush_spore(WorldTile pTile = null, string pDropID = null)
	private static void action_curse(WorldTile pTile = null, string pDropID = null)
	private static void action_spell_silence(WorldTile pTile = null, string pDropID = null)
	private static void action_shield(WorldTile pTile = null, string pDropID = null)
	private static void action_powerup(WorldTile pTile = null, string pDropID = null)
	private static void action_paint(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_black(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_white(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_red(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_blue(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_gold(WorldTile pTile = null, string pDropID = null)
	public static void action_dust_purple(WorldTile pTile = null, string pDropID = null)
	public static void action_coffee(WorldTile pTile = null, string pDropID = null)
	public static void action_blessing(WorldTile pTile = null, string pDropID = null)
	public static void action_alien_mold(WorldTile pTile = null, string pDropID = null)
	public static void action_drop_computer(WorldTile pTile = null, string pDropID = null)
	public static void action_drop_golden_egg(WorldTile pTile = null, string pDropID = null)
	public static void action_drop_harp(WorldTile pTile = null, string pDropID = null)
	public static void action_madness(WorldTile pTile = null, string pDropID = null)
	public static void action_inspiration(WorldTile pTile, string pDropID = null)
	public static void action_discord(WorldTile pTile, string pDropID = null)
	public static void action_spite(WorldTile pTile, string pDropID = null)
	public static void action_friendship(WorldTile pTile, string pDropID = null)
	public static void action_spawn_building(WorldTile pTile = null, string pDropID = null)
	public static void flash(WorldTile pTile, string pDropID)
	public static void action_fertilizer_plants(WorldTile pTile = null, string pDropID = null)
	public static void action_fertilizer_trees(WorldTile pTile = null, string pDropID = null)
	public static void action_fruit_bush(WorldTile pTile = null, string pDropID = null)
	public static void action_landmine(WorldTile pTile = null, string pDropID = null)
	public static void action_living_house(WorldTile pTile = null, string pDropID = null)
	public static void action_living_plants(WorldTile pTile = null, string pDropID = null)
public enum DropType
public static class DynamicActorSpriteCreatorUI
	private static int[] _boat_angles = new int[8] { 0, -45, -90, -135, 180, 135, 90, 45 };
	public static AnimationContainerUnit getContainerForUI(ActorAsset pAsset, bool pAdult, ActorTextureSubAsset pTextureAsset, SubspeciesTrait pMutationAsset = null, bool pIsEgg = false, SubspeciesTrait pEggAsset = null, string pTexturePath = null)
	public static AnimationContainerUnit getContainerForUI(Actor pActor)
	public static Sprite getUnitSpriteForUI(ActorAsset pAsset, Sprite pMainSprite, AnimationContainerUnit pContainer, bool pAdult, ActorSex pSex, int pPhenotypeIndex, int pPhenotypeShade, ColorAsset pKingdomColor, long pActorId, int pHeadId, bool pEgg = false, bool pKing = false, bool pWarrior = false, bool pWise = false)
	public static Sprite getUnitSpriteForUI(Actor pActor, Sprite pSprite)
	public static Sprite getSpriteHeadForUI(ActorAsset pAsset, ActorSex pSex, AnimationContainerUnit pContainer, long pActorId, int pHeadId, bool pAdult = true, bool pEgg = false, bool pKing = false, bool pWarrior = false, bool pWise = false, bool pRandom = false)
	private static Sprite getSprite(int pIndex, Sprite[] pSprites)
	public static ActorAnimation getBoatAnimation(AnimationDataBoat pBoatAnimation)
public static class DynamicColorPixelTool
	private static bool _draw_phenotype;
	private static Color32 _phenotype_color;
	public static Color32 phenotype_shade_0;
	public static Color32 phenotype_shade_1;
	public static Color32 phenotype_shade_2;
	public static Color32 phenotype_shade_3;
	private static readonly Color32 _zombie_blood_color = Color32.op_Implicit(Toolbox.makeColor("#CE566E"));
	public static Color32 checkSpecialColors(Color32 pColor, ColorAsset pKingdomColor, bool pCheckForLightColors = false)
	public static Color32 checkZombieColors(ActorAsset pAsset, Color32 pColor, int pID, bool pHead = false)
	private static Color32 addNoiseAndBlood(Color32 pTargetColor, int pID)
	private static Color32 multiplyBlend(Color32 pBaseColor, Color32 pTargetBlendColor, float pIntensity = 1f)
	private static Color32 overlayBlend(Color32 pBaseColor, Color32 pTargetBlendColor)
	public static void loadPhenotype(int pPhenotypeIndex, int pPhenotypeShadeIndex)
	public static void loadPhenotype(PhenotypeAsset pPhenotypeAsset, int pPhenotypeShadeIndex)
	public static void loadSkinColorsPreview(PhenotypeAsset pPhenotype, int pSkinColor)
	public static void resetSkinColors()
	public static void setPlaceholderSkinColor(Color32 pColor)
namespace EpPathFinding.cs;
public class DynamicGrid : BaseGrid
	protected Dictionary<GridPos, Node> m_nodes;
	private bool m_notSet;
	public override int width
	public override int height
	public DynamicGrid(List<GridPos> iWalkableGridList = null)
	public DynamicGrid(DynamicGrid b)
	protected void buildNodes(List<GridPos> iWalkableGridList)
	public override Node GetNodeAt(int iX, int iY)
	public override bool IsWalkableAt(int iX, int iY)
	private void setBoundingBox()
	public override bool SetWalkableAt(int iX, int iY, bool iWalkable, int pCost = 1)
	public override Node GetNodeAt(GridPos iPos)
	public override bool IsWalkableAt(GridPos iPos)
	public override bool SetWalkableAt(GridPos iPos, bool iWalkable)
	public override void Reset()
	public void Reset(List<GridPos> iWalkableGridList)
	public override BaseGrid Clone()
namespace EpPathFinding.cs;
public class DynamicGridWPool : BaseGrid
	private bool m_notSet;
	private NodePool m_nodePool;
	public override int width
	public override int height
	public DynamicGridWPool(NodePool iNodePool)
	public DynamicGridWPool(DynamicGridWPool b)
	public override Node GetNodeAt(int iX, int iY)
	public override bool IsWalkableAt(int iX, int iY)
	private void setBoundingBox()
	public override bool SetWalkableAt(int iX, int iY, bool iWalkable, int pCost = 1)
	public override Node GetNodeAt(GridPos iPos)
	public override bool IsWalkableAt(GridPos iPos)
	public override bool SetWalkableAt(GridPos iPos, bool iWalkable)
	public override void Reset()
	public override BaseGrid Clone()
public static class DynamicSpriteCreator
	public static Actor debug_actor;
	private static Dictionary<Sprite, int> _int_ids_body = new Dictionary<Sprite, int>();
	private static readonly Color32 _placeholder_color_skin = Color32.op_Implicit(Toolbox.makeColor("#00FF00"));
	private static readonly List<Vector2Int> _light_colors = new List<Vector2Int>();
	public static Sprite createNewItemSprite(DynamicSpritesAsset pAsset, Sprite pSource, ColorAsset pKingdomColor)
		UnitSpriteConstructorAtlas atlas = pAsset.getAtlas();
	private static Sprite createFinalSprite(UnitSpriteConstructorAtlas pAtlasTexture, Sprite pMain, int pWidth, int pHeight, int pResizeX = 0, int pResizeY = 0)
	private static Sprite createNewSpriteBuildingShadow(DynamicSpritesAsset pDynamicSpritesAsset, BuildingAsset tAsset, Sprite pSource, bool pIsContructionSprite)
		UnitSpriteConstructorAtlas atlas = pDynamicSpritesAsset.getAtlas();
			val = BuildingLibrary.shadow_under_construction_bound;
			num6 = BuildingLibrary.shadow_under_construction_distortion;
	public static Sprite createNewUnitShadow(DynamicSpritesAsset pAsset, Sprite pSource)
		UnitSpriteConstructorAtlas atlas = pAsset.getAtlas();
	public static void createBuildingShadow(BuildingAsset pAsset, Sprite pSprite, bool pIsContructionSprite)
	public static Sprite createNewIcon(DynamicSpritesAsset pAsset, Sprite pSource, ColorAsset pKingdomColor, PhenotypeAsset pPhenotype = null)
		UnitSpriteConstructorAtlas atlas = pAsset.getAtlas();
	public static Sprite createNewSpriteBuilding(DynamicSpritesAsset pAssetAtlas, long pID, Sprite pSource, ColorAsset pKingdomColor)
		UnitSpriteConstructorAtlas atlas = pAssetAtlas.getAtlas();
	private static void checkBuildingLightSprite(DynamicSpritesAsset pQuantumAsset, long pHashcodeMainSprite, Sprite pSprite)
	public static Sprite createNewSpriteBuildingLight(DynamicSpritesAsset pAsset, Sprite pSource)
		UnitSpriteConstructorAtlas atlas = pAsset.getAtlas();
	private static void drawLightPixel(UnitSpriteConstructorAtlas pAtlas, int pColorCoordsX, int pColorCoordsY, int pWidth, int pHeight, int pBodyTextureWidth, Color32 pColor)
	public static Sprite createNewSpriteForDebug(Sprite pSpriteSource, ColorAsset pKingdomColor)
	public static Sprite createNewSpriteUnit(AnimationFrameData pFrameData, Sprite pSourceBody, Sprite pSourceHead, ColorAsset pKingdomColor, ActorAsset pAsset, int pPhenotypeIndex, int pPhenotypeShade, UnitTextureAtlasID pAtlasID)
		UnitSpriteConstructorAtlas unitSpriteConstructorAtlas = null;
			unitSpriteConstructorAtlas = DynamicSpritesLibrary.units.getAtlas();
			unitSpriteConstructorAtlas = DynamicSpritesLibrary.boats.getAtlas();
		unitSpriteConstructorAtlas.checkBounds(texture_rect_width, texture_rect_height);
		fillDebugColor(texture_rect_width, texture_rect_height, unitSpriteConstructorAtlas);
		int num7 = num5 + unitSpriteConstructorAtlas.last_x;
		int last_y = unitSpriteConstructorAtlas.last_y;
		drawPixelsAll(pixelBag, unitSpriteConstructorAtlas, pKingdomColor, num7, last_y, dynamic_sprite_zombie, pAsset);
			drawPixelsAll(pixelBag2, unitSpriteConstructorAtlas, pKingdomColor, num7, last_y, dynamic_sprite_zombie, pAsset, pHead: true);
		setAtlasDirty(unitSpriteConstructorAtlas);
		return createFinalSprite(unitSpriteConstructorAtlas, pSourceBody, texture_rect_width, texture_rect_height, num5);
	private static void fillDebugColor(int pWidth, int pHeight, UnitSpriteConstructorAtlas pAtlas)
	private static void drawPixelsAll(PixelBag pBag, UnitSpriteConstructorAtlas pAtlas, ColorAsset pKingdomColor, int pPartX, int pPartY, bool pDynamicZombie, ActorAsset pActorAsset, bool pHead = false)
	private static void drawPixels(Color32[] pPixels, int pAtlasWidth, Pixel[] pListSourcePixels, Color32 pNewColor, int pPartX, int pPartY, bool pDrawDynamicZombie, ActorAsset pActorAsset, bool pUseNormal = false, bool pHead = false)
	public static Sprite getSpriteUnit(AnimationFrameData pFrameData, Sprite pMainSprite, Actor pActor, ColorAsset pKingdomColor, int pPhenotypeIndex, int pPhenotypeShade, UnitTextureAtlasID pTextureAtlasID)
	public static void setAtlasDirty(UnitSpriteConstructorAtlas pAtlas)
	public static int getBodySpriteSmallID(Sprite pSprite)
public static class DynamicSprites
	public const int NO_COLOR_ID = -900000;
	public static Sprite getIconWithColors(Sprite pSprite, PhenotypeAsset pPhenotype, ColorAsset pKingdomColor)
	public static Sprite getRecoloredBuilding(Sprite pBuildingSprite, ColorAsset pColor, DynamicSpritesAsset pAtlasAsset)
	private static long getBuildingSpriteID(int pBaseSpriteID, ColorAsset pColor)
	public static Sprite getBuildingLight(Building pBuilding)
	public static Sprite getIcon(Sprite pSprite, ColorAsset pColorAsset)
	public static Sprite getShadowBuilding(BuildingAsset pAsset, Sprite pSprite)
	public static Sprite getShadowUnit(Sprite pSprite, int pHashCode)
	public static void preloadItemSprite(Sprite pSprite, ColorAsset pColorAsset = null)
	public static long getItemSpriteID(Sprite pSprite, ColorAsset pColor)
	public static long getItemSpriteID(Sprite pSprite, int pColorID = -900000)
	public static Sprite getCachedAtlasItemSprite(long pID, Sprite pSpriteSource)
	public static Sprite getCachedAtlasItemSprite(long pID, Sprite pSpriteSource, ColorAsset pColorAsset)
public class DynamicSpritesAsset : Asset
	public bool big_atlas = true;
	public bool check_wobbly_setting;
	public UnitTextureAtlasID atlas_id;
	public string export_folder_path;
	public bool buildings;
	private Dictionary<long, Sprite> _dictionary_sprites = new Dictionary<long, Sprite>();
	private UnitSpriteConstructorAtlas _atlas;
	public override void create()
			_atlas = new UnitSpriteConstructorAtlas(atlas_id, big_atlas);
	public void resetAtlas()
	public bool hasSprite(long pID)
	public void addSprite(long pHashCode, Sprite pSprite)
	public Sprite getSprite(long pID)
	public UnitSpriteConstructorAtlas getAtlas()
	public void checkAtlasDirty()
	public void clear()
	public int countSprites()
	public int countTextures()
public static class DynamicSpritesConfig
	public const int EDGE_PIXEL = 1;
	public const int TEXTURE_SIZE_512 = 512;
	public const int TEXTURE_SIZE_1024 = 1024;
	public const int TEXTURE_SIZE_2048 = 2048;
	private static int _cached_texture_size;
	public static int texture_size
	private static int calculateTargetTextureSize()
public class DynamicSpritesLibrary : AssetLibrary<DynamicSpritesAsset>
	public static DynamicSpritesAsset units;
	public static DynamicSpritesAsset boats;
	public static DynamicSpritesAsset units_shadows;
	public static DynamicSpritesAsset building_lights;
	public static DynamicSpritesAsset building_shadows;
	public static DynamicSpritesAsset icons;
	public static DynamicSpritesAsset items;
	public static DynamicSpritesAsset zombies;
	private bool _dirty;
	public static long _debug_id;
	private static long _debug_kingdom_color_id;
	private static long _debug_head_id;
	private static long _debug_main_body_sprite;
	private static long _debug_phenotype_index;
	private static long _debug_shade_id;
	public override void init()
	public override DynamicSpritesAsset add(DynamicSpritesAsset pAsset)
	public override void linkAssets()
	public void clear()
	public void debug(DebugTool pTool, Actor pActor)
	public void setDirty()
	public void checkDirty()
	public void setDebugActor(long pID, long pKingdomColorID, long pHeadID, long pMainBodySpriteID, long pPhenotypeIndex, long pShadeID)
	public void export()
public class Earthquake : BaseMapObject
	private PrintTemplate _current_print;
	private int _print_tick;
	private WorldTile _print_tile_origin;
	private float _timer;
	private const float INTERVAL = 0.05f;
	private bool _quake_active;
	private EarthquakeType _type;
	private int _current_print_index;
	private static Earthquake _instance;
	public void Awake()
	public static void startQuake(WorldTile pTile, EarthquakeType pType = EarthquakeType.RandomPower)
	private void spawnQuake(WorldTile pTile, EarthquakeType pType)
	private void Update()
	private void tileAction(WorldTile pTile)
	private void unitAction(Actor pActor)
	public static bool isQuakeActive()
	private void endQuake()
public enum EarthquakeType
public class EasterEggBanner : MonoBehaviour
	private GameObject _container_with_elements;
	private float _cur_random_accumulation;
	private const float BASE_CHANCE = 0.1f;
	private const float ACCUMULATION_STEP = 0.01f;
	private bool? _dragging_item;
	public Image main_image;
	private void OnEnable()
	private void nextChance()
	private void clearChance()
	private void Update()
public static class EditorHelper
	public static bool HasArgument(string pName)
	public static string GetArgument(string pName)
public delegate BaseEffect EffectAction(BaseEffect pEffect, WorldTile pTile = null, string pParam1 = null, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null);
public delegate BaseEffect EffectActionVector(BaseEffect pEffect, Vector3 pVecPosition);
public class EffectAsset : Asset
	public string prefab_id;
	public bool use_basic_prefab;
	public bool load_texture;
	public string sprite_path;
	public string sorting_layer_id;
	public float time_between_frames = 0.1f;
	public int limit;
	public bool limit_unload;
	public string sound_launch;
	public string sound_loop_idle;
	public bool show_on_mini_map;
	public EffectAction spawn_action;
	public double cooldown_interval;
	private double _cooldown;
	public bool draw_light_area;
	public float draw_light_area_offset_x;
	public float draw_light_area_offset_y;
	public float draw_light_size = 0.5f;
	public bool has_sound_launch => sound_launch != null;
	public bool has_sound_loop_idle => sound_loop_idle != null;
	public bool checkIsUnderCooldown()
public struct EffectDataRain
public class EffectDivineLight : BaseAnimatedObject
	public SpriteAnimation raySpawn;
	public SpriteAnimation rayIdle;
	public SpriteAnimation baseSpawn;
	public SpriteAnimation baseIdle;
	public bool isOn;
	private DivineLightState state;
	public override void Awake()
	private void setState(DivineLightState pState)
	private void stopEffet()
	private void useEffect()
	private void Update()
	public void playOn(WorldTile pTile)
public class EffectDragParticlesManager : MonoBehaviour
	public static EffectDragParticlesManager instance;
	private ObjectPoolGenericMono<EffectParticlesCursor> _pool;
	private EffectParticlesCursor _prefab;
	private List<SpriteSet> _sprite_sets;
	public float _spawn_interval = 10f;
	private void Awake()
	private void Update()
	private void updateAnimation()
	private void updateSpawn()
	public void spawnNew(Vector3 pPos)
	private void finishingEffectAction(MonoBehaviour pEffectObject)
public class EffectFlyingY : BaseEffect
	public override void update(float pElapsed)
public class EffectHearts : BaseEffect
	internal override void spawnOnTile(WorldTile pTile)
	public override void update(float pElapsed)
public class EffectInfinityCoin : BaseEffect
	private static List<Actor> _temp_list = new List<Actor>();
	private bool used;
	internal override void create()
	internal override void spawnOnTile(WorldTile pTile)
	internal override void prepare(Vector2 pVector, float pScale = 1f)
	private void Update()
	private void doAction()
public class EffectParticlesCursor : MonoBehaviour
	private SpriteAnimationSimple _sprite_animation;
	private float _speed = 50f;
	private void Awake()
	public void launch()
	public void update()
	public SpriteAnimationSimple getAnimation()
	public void setFrames(Sprite[] pFrames)
public delegate void EffectParticlesCursorDelegate(MonoBehaviour pEffectObject);
public class EffectsCamera : MonoBehaviour
	private Camera _mainCamera;
	private Camera _effectsCamera;
	internal RenderTexture renderTexture;
	private void Awake()
	private void Start()
	private void LateUpdate()
public class EffectsLibrary : AssetLibrary<EffectAsset>
	public override void init()
	public override void editorDiagnostic()
	private static BaseEffect check(string pID)
	public static BaseEffect spawnAtTileRandomScale(string pID, WorldTile pTile, float pScaleMin, float pScaleMax)
	public static void spawnDebugTile(WorldTile pTile, Color pColor)
	public static BaseEffect spawnAtTile(string pID, WorldTile pTile, float pScale)
	public static BaseEffect spawnAt(string pID, Vector2 pPos, float pScale)
	public static BaseEffect spawnAt(string pID, Vector3 pPos, float pScale)
	public static BaseEffect spawn(string pID, WorldTile pTile = null, string pParam1 = null, string pParam2 = null, float pFloatParam1 = 0f, float pX = -1f, float pY = -1f, Actor pActor = null)
	public static void spawnExplosionWave(Vector3 pVec, float pRadius, float pSpeed = 1f)
	public static bool canShowSlashEffect()
	public static void spawnSlash(Vector2 pVec, string pPathSprites, float pAngle, float pScaleMod = 0.1f)
	public BaseEffect spawnMeteorite(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnSanta(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnBoulder(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnNapalmFlash(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnNukeFlash(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnThunderFlash(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnSimpleTile(BaseEffect pEffect, WorldTile pTile, string pParam1 = null, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnZoneFlash(BaseEffect pEffect, WorldTile pTile, string pParam1 = null, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnCloud(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnFireworks(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect showSpawnEffect(BaseEffect pEffect, WorldTile pTile, string pParam1, string pParam2 = null, float pFloatParam1 = 0f, Actor pActor = null)
	public BaseEffect spawnStatusParticle(BaseEffect pEffect, Vector3 pPos)
	public static void highlightKingdomZones(Kingdom pKingdom, Color pColor, float pAlpha = 0.3f)
	public static void showMoneyEffect(string pID, Vector2 pPosition, TileZone pZone, float pScale)
	public static void showMetaEventEffectConversion(string pID, Actor pActor)
	public static void showMetaEventEffect(string pID, Actor pActor)
	public static void showMetaEventEffect(string pID, Vector2 pPosition, TileZone pZone, float pScale)
public class EmptyLogElement : MonoBehaviour
	private WorldLogElement _log_element;
	public RectTransform rect_transform;
	private WorldLogElement _element;
	private WorldLogMessage _message;
	public void load(WorldLogMessage pMessage)
	public void setElement(WorldLogElement pElement)
	public WorldLogElement getElement()
public class Encryption
	private const string INIT_VECTOR = "sayHiIfUReadThis";
	private const int KEY_SIZE = 256;
	public static string EncryptString(string pPlainText, string pPassPhrase)
	public static string DecryptString(string pCipherText, string pPassPhrase)
public static class EnemiesFinder
	private static Dictionary<Kingdom, EnemyFinderContainer> _cache_data = new Dictionary<Kingdom, EnemyFinderContainer>();
	public static int counter_reused = 0;
	private static EnemyFinderContainer getCacheContainer(Kingdom pKingdom)
	internal static EnemyFinderData findEnemiesFrom(WorldTile pTile, Kingdom pKingdom, int pChunkRange = -1)
	public static void clear()
	public static void disposeAll()
public class EnemyFinderContainer
	public Dictionary<int, EnemyFinderData> dict_data = new Dictionary<int, EnemyFinderData>((int)Math.Pow(9.0, SimGlobals.m.unit_chunk_sight_range));
	private Kingdom _kingdom;
	public void setKingdom(Kingdom pKingdom)
	public EnemyFinderData getData(MapChunk pChunk, int pRange)
	private void checkRange(EnemyFinderData pData, MapChunk pChunk, int pRange, int pSkipLessThan = -1)
	private static void findEnemiesOfKingdomInChunk(EnemyFinderData pData, MapChunk pChunk, Kingdom pMainKingdom)
	public void clear()
	public void disposeAll()
public class EnemyFinderData
	public readonly List<BaseSimObject> list = new List<BaseSimObject>();
	public bool isEmpty()
	public void addEnemyList(List<Actor> pList)
	public void addEnemyList(List<Building> pList)
	public void reset()
public static class EnumerableExtensions
	public static T GetRandom<T>(this IEnumerable<T> pEnumerable)
public static class EnumExtensions
	public static int Count<TEnum>(this TEnum pEnum) where TEnum : Enum
public delegate bool EnvironmentAction(BuildingAsset pAsset);
public static class Epoch
	private static DateTime epochStart = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
	public static double Current()
	public static double SecondsElapsed(double t1)
	public static int SecondsElapsed(int t1, int t2)
	internal static DateTime toDateTime(double epoch)
public class EquipmentAsset : ItemAsset, IHandRenderer
	public bool is_colored => colored;
	public bool is_animated => animated;
	public Sprite[] getSprites()
public class EquipmentBanner : BannerGeneric<Item, ItemData>
	private IconOutline _outline;
	private Sprite _frame_sprite_legendary;
	private Sprite _frame_sprite_epic;
	protected override MetaType meta_type => MetaType.Item;
	protected override string tooltip_id => "equipment";
	protected override TooltipData getTooltipData()
	protected override void setupBanner()
	private void showOutline()
public class EquipmentButton : AugmentationButton<EquipmentAsset>, IBanner, IBaseMono, IRefreshElement
	private Image _favorited_icon;
	private Item _item;
	private bool _object_button;
	public MetaCustomizationAsset meta_asset => AssetManager.meta_customization_library.getAsset(MetaType.Item);
	public MetaTypeAsset meta_type_asset => AssetManager.meta_type_library.getAsset(MetaType.Item);
	protected override string tooltip_type => "equipment";
	protected override void Update()
	protected override void onStartDrag(DraggableLayoutElement pOriginalElement)
	public void load(NanoObject pObject)
	internal void load(Item pItem)
	public override void load(EquipmentAsset pItem)
	protected override void initTooltip()
	private void openItemWindow()
	protected override void fillTooltipData(EquipmentAsset pElement)
	protected override bool unlockElement()
	protected override TooltipData tooltipDataBuilder()
	protected override string getElementType()
	protected override void startSignal()
	public override string getElementId()
	private bool hasDivineRune()
	protected override Rarity getRarity()
	public string getName()
	public NanoObject GetNanoObject()
public class EquipmentEditor : AugmentationsEditor<EquipmentAsset, EquipmentButton, EquipmentEditorButton, ItemGroupAsset, EquipmentGroupElement, IEquipmentWindow, IEquipmentEditor>, IEquipmentEditor, IAugmentationsEditor
	protected Sprite sprite_art;
	protected Sprite sprite_art_void;
	protected override List<ItemGroupAsset> augmentation_groups_list => AssetManager.item_groups.list;
	protected override EquipmentAsset edited_marker_augmentation => null;
	protected override List<EquipmentAsset> all_augmentations_list => AssetManager.items.list;
	protected override void onEnableRain()
	protected override void OnEnable()
	protected override void metaAugmentationClick(EquipmentEditorButton pButton)
	protected override void rainAugmentationClick(EquipmentEditorButton pButton)
	protected override void showActiveButtons()
	protected override ListPool<EquipmentAsset> getOrderedAugmentationsList()
	protected override void createButton(EquipmentAsset pElement, EquipmentGroupElement pGroup)
	protected override void startSignal()
	private bool canChangeSlot(EquipmentAsset pAsset)
	private bool isSlotEmpty(EquipmentButton pButton)
	protected override bool hasAugmentation(EquipmentButton pButton)
	protected override bool addAugmentation(EquipmentButton pButton)
	protected override bool removeAugmentation(EquipmentButton pButton)
	private ActorEquipmentSlot getSlotFromCurrentActor(EquipmentType pType)
	private Actor getCurrentActor()
	protected override void loadEditorSelectedButton(EquipmentButton pButton, string pAugmentationId)
	protected override bool isAugmentationExists(string pId)
	protected override void toggleRainState(ref RainState pState)
public class EquipmentEditorButton : AugmentationEditorButton<EquipmentButton, EquipmentAsset>
public class EquipmentGrid : MonoBehaviour
public class EquipmentGroupElement : AugmentationCategory<EquipmentAsset, EquipmentButton, EquipmentEditorButton>
	protected override bool isUnlocked(EquipmentButton pButton)
public enum EquipmentType
public class ErrorWindow : MonoBehaviour
	public Text errorText;
	public static string errorMessage;
	private void OnEnable()
internal static class ExceptionHelpers
	public static Exception PrepareForRethrow(Exception exception)
namespace ai;
public enum ExecuteEvent
public class ExitAction : MonoBehaviour
	public void clickExit()
public class ExplosionChecker
	private const float TIMER = 1f;
	private Dictionary<int, ExplosionMemoryData> data = new Dictionary<int, ExplosionMemoryData>();
	private List<int> _to_remove = new List<int>(16);
	public bool checkNearby(WorldTile pTile, int pRange)
	private void updateNearbyTimers(WorldTile pTile, float pRange)
	private bool isNearbyOthers(WorldTile pTile, float pRange)
	private void add(int pID, WorldTile pTile, int pRange)
	public void update(float pElapsed)
	public void clear()
	public static void debug(DebugTool pTool)
public class ExplosionFlash : BaseEffect
	private float speed;
	public void start(Vector3 pVector, float pRadius, float pSpeed = 1f)
	public override void update(float pElapsed)
public class ExplosionMemoryData
	public int x;
	public int y;
	public int range;
	public float timer;
public class ExplosionsEffects : MapLayer
	private Dictionary<WorldTile, TileTypeBase> explosionDict;
	private Dictionary<WorldTile, TileTypeBase> explosionDictCurrent;
	public List<WorldTile> explosionQueue;
	private List<WorldTile> explosionQueueCurrent;
	private float timerExplosionQueue;
	public float interval = 0.01f;
	internal Queue<WorldTile> nextWave = new Queue<WorldTile>();
	internal HashSetWorldTile hashset_bombs = new HashSetWorldTile();
	internal List<WorldTile> delayedBombs = new List<WorldTile>();
	internal List<WorldTile> timedBombs = new List<WorldTile>();
	internal override void create()
	internal override void clear()
	internal void activateDelayedBomb(WorldTile pBomb)
	internal void addTimedTnt(WorldTile pTile)
	internal void explodeBomb(WorldTile pBombTile, bool pForce = false)
	public void prepareNewExplosion(WorldTile pTile)
	private void updateExplosionQueue()
	public override void update(float pElapsed)
	public override void draw(float pElapsed)
	protected override void UpdateDirty(float pElapsed)
	internal void setDirty(WorldTile pTile, float pDist, float pRadius)
public class FadeInOutAnimation : MonoBehaviour
	private const float FADE_OUT_BOUND = 0.1f;
	private const float FADE_SPEED = 0.015f;
	private const float INTERVAL = 0.025f;
	public float alpha_max = 1f;
	private float _current_alpha;
	private float _timer = 0.025f;
	private bool _fade_out = true;
	private Image _image;
	public void Awake()
	public void checkInit()
	private void updateAlpha()
	public void resetToFadeOut()
	public void resetToFadeIn()
	public void reset()
	private void OnEnable()
	private void Update()
public class FadeOutDelayed : MonoBehaviour
	private CanvasGroup _group;
	private float _duration;
	private float _delay;
	private float _max_alpha = 1f;
	private float _min_alpha;
	private float _time_left;
	private float _delay_time_left;
	private void OnEnable()
	private void Update()
	private void reset()
public class FamiliesColorsLibrary : ColorLibrary
	public FamiliesColorsLibrary()
	public override void init()
	public override bool isColorUsedInWorld(ColorAsset pAsset)
public class FamiliesNoItems : MonoBehaviour
	private GameObject _inner;
	private IMetaWithFamiliesWindow _families_window;
	private void Awake()
	private void OnEnable()
public class Family : MetaObject<FamilyData>, ISapient
	private Actor _cached_alpha;
	private ActorAsset _cached_species;
	private Actor _founder_1;
	private Actor _founder_2;
	private bool _founders_dirty;
	private double _timestamp_hungry_check;
	private bool _cached_hungry_check_result;
	protected override MetaType meta_type => MetaType.Family;
	public override BaseSystemManager manager => World.world.families;
	public void newFamily(Actor pActor1, Actor pActor2, WorldTile pTile)
	public bool areMostUnitsHungry()
	public bool isFull()
	public bool isAlpha(Actor pActor)
	private void removeAlpha()
	public void checkAlpha()
	public Actor getAlpha()
	public Actor findAlpha()
	private void setAlpha(Actor pActor, bool pNew)
	public void saveOriginFamily1(long pFamilyID)
	public void saveOriginFamily2(long pFamilyID)
	public IEnumerable<Family> getOriginFamilies()
	public override void generateBanner()
	public Sprite getSpriteBackground()
	public Sprite getSpriteFrame()
	public override ActorAsset getActorAsset()
	public bool isSapient()
	public bool isMainFounder(Actor pActor)
	public bool hasFounders()
	public Actor getRandomFounder()
	public Actor getFounderFirst()
	public Actor getFounderSecond()
	private void checkFounders()
	private void clearFounders()
	protected override ColorLibrary getColorLibrary()
	public bool isSameSpecies(string pAssetID)
	private void generateName(Actor pActor)
	public override void loadData(FamilyData pData)
	public override void updateDirty()
	public override void Dispose()
public class FamilyBanner : BannerGeneric<Family, FamilyData>
	protected override MetaType meta_type => MetaType.Family;
	protected override string tooltip_id => "family";
	protected override TooltipData getTooltipData()
	protected override void setupBanner()
public class FamilyCustomizeWindow : GenericCustomizeWindow<Family, FamilyData, FamilyBanner>
	protected override MetaType meta_type => MetaType.Family;
	protected override Family meta_object => SelectedMetas.selected_family;
	protected override void onBannerChange()
public class FamilyData : MetaObjectData
	public int banner_background_id;
	public int banner_frame_id;
	public long alpha_id = -1L;
	public string founder_actor_name_1;
	public string founder_actor_name_2;
	public long main_founder_id_1 = -1L;
	public long main_founder_id_2 = -1L;
	public long subspecies_id = -1L;
	public string subspecies_name = string.Empty;
	public string species_id = string.Empty;
	public long founder_city_id = -1L;
	public string founder_city_name = string.Empty;
	public long founder_kingdom_id = -1L;
	public string founder_kingdom_name = string.Empty;
	public long original_family_1 = -1L;
	public long original_family_2 = -1L;
public class FamilyElement : WindowMetaElement<Family, FamilyData>
	protected Family family => meta_object;
public class FamilyListComponent : ComponentListSapient<FamilyListElement, Family, FamilyData, FamilyListComponent>
	private IMetaWithFamiliesWindow _families_window;
	protected override MetaType meta_type => MetaType.Family;
	protected override bool change_asset_sort_order => _families_window == null;
	protected override void create()
	protected override void setupSortingTabs()
	public override bool isEmpty()
	public static int sortByAdults(Family pObject1, Family pObject2)
	public static int sortByChildren(Family pObject1, Family pObject2)
	public static int sortBySpecies(Family pObject1, Family pObject2)
public class FamilyListElement : WindowListElementBase<Family, FamilyData>
	public Text text_name;
	public CountUpOnClick text_age;
	public CountUpOnClick text_population;
	public CountUpOnClick text_adults;
	public CountUpOnClick text_children;
	public CountUpOnClick text_dead;
	private Text _collective_term;
	internal override void show(Family pFamily)
	protected override void tooltipAction()
	protected override ActorAsset getActorAsset()
public class FamilyManager : MetaSystemManager<Family, FamilyData>
	public FamilyManager()
	public Family newFamily(Actor pActor, WorldTile pTile, Actor pActor2)
	public override void removeObject(Family pObject)
	public Family getNearbyFamily(ActorAsset pUnitAsset, WorldTile pTile)
	protected override void updateDirtyUnits()
public class FamilyMembersContainer : FamilyElement
	private ObjectPoolGenericMono<PrefabUnitElement> _pool_parents;
	private ObjectPoolGenericMono<PrefabUnitElement> _pool_children;
	private RectTransform _list_parents;
	private RectTransform _list_children;
	private LocalizedText _title_parents;
	private LocalizedText _title_children;
	private PrefabUnitElement _prefab;
	protected override void Awake()
	protected override IEnumerator showContent()
	private void showParents()
	private void showChildren()
	private int sortByMainParent(Actor pActor1, Actor pActor2)
	private void showMember(Actor pActor, ObjectPoolGenericMono<PrefabUnitElement> pPool)
	protected override void clear()
public class FamilyOriginElement : FamilyElement
	private GameObject _family_origin_title;
	private FamilyListElement _prefab;
	private ObjectPoolGenericMono<FamilyListElement> _pool_elements;
	private Transform _container;
	protected override void Awake()
	protected override IEnumerator showContent()
	protected override void clear()
	protected override void clearInitial()
public enum FamilyParentsMode
public class FamilysBannerLibrary : GenericBannerLibrary
	public override void init()
public class FamilyStatsElement : FamilyElement, IStatsElement, IRefreshElement
	private StatsIconContainer _stats_icons;
	public void setIconValue(string pName, float pMainVal, float? pMax = null, string pColor = "", bool pFloat = false, string pEnding = "", char pSeparator = '/')
	protected override void Awake()
	protected override IEnumerator showContent()
public class FamilyWindow : WindowMetaGeneric<Family, FamilyData>
	public Text title_family;
	public override MetaType meta_type => MetaType.Family;
	protected override Family meta_object => SelectedMetas.selected_family;
	protected override void showTopPartInformation()
	internal override void showStatsRows()
public class FaveWorldButton : MonoBehaviour
	public Image icon;
	private void Start()
	private void OnEnable()
	private void faveWorld()
	private void updateFavoriteIconFor(int pId)
public class FavoriteItemListComponent : ComponentListBase<FavoriteItemListElement, Item, ItemData, FavoriteItemListComponent>
	private List<NanoObject> _meta_objects = new List<NanoObject>();
	protected override MetaType meta_type => MetaType.Item;
	protected override void setupSortingTabs()
	protected override IEnumerable<Item> getObjectsList()
	public static int sortByAge(Item pItem1, Item pItem2)
	public static int sortByKills(Item pItem1, Item pItem2)
	public static int sortByType(Item pItem1, Item pItem2)
	public static int sortByQuality(Item pItem1, Item pItem2)
	public static int sortByCity(Item pItem1, Item pItem2)
	public static int sortByOwner(Item pItem1, Item pItem2)
	public static int sortByDamage(Item pItem1, Item pItem2)
	public static int sortByArmor(Item pItem1, Item pItem2)
	public override void clear()
	public override bool checkRefreshWindow()
public class FavoriteItemListElement : WindowListElementBase<Item, ItemData>
	public Text name_text;
	public CountUpOnClick kills_text;
	public CountUpOnClick age_text;
	public CountUpOnClick owners_text;
	public CountUpOnClick damage_text;
	public CountUpOnClick armor_text;
	public CountUpOnClick durability_text;
	private UiUnitAvatarElement _unit_avatar_element;
	private CityBanner _banner_city;
	private GameObject _ownerless;
	private IconOutline _outline;
	internal override void show(Item pItem)
	protected override void tooltipAction()
	private void clear()
public class FavoriteItemSpriteSwitcher : SpriteSwitcher
	protected override bool hasAny()
public class Favorites
	public static Dictionary<string, bool> favorites = new Dictionary<string, bool>();
	public static Promise promise;
public class FavoriteUnitSpriteSwitcher : SpriteSwitcher
	protected override bool hasAny()
public static class FavoriteWorld
	private const int NO_WORLD_SET = -1;
	private static int _cache_favorite_world_id = -1;
	public static void checkFavoriteWorld()
	public static void clearFavoriteWorld()
	public static bool hasFavoriteWorldSet(bool pCheck = true)
	public static void restoreCachedFavoriteWorldOnSuccess()
	public static void cacheSaveSlotID(int pID)
public static class FieldInfoExtensions
	public static bool isString(this FieldInfo pField)
	public static bool isCollection(this FieldInfo pField)
	public static bool isEnumerable(this FieldInfo pField)
	public static bool isCloneable(this FieldInfo pField)
public class FieldInfoList : MonoBehaviour
	public static string color_null = "#9F9F9F";
	public static string color_white = Toolbox.colorToHex(Color32.op_Implicit(Toolbox.color_white));
	public static string color_string = "#F3961F";
	public static string color_enum = Toolbox.colorToHex(Color32.op_Implicit(Toolbox.color_plague));
	public static string color_type = Toolbox.colorToHex(Color32.op_Implicit(Toolbox.color_yellow));
	public static string color_collection = color_null;
	public static Dictionary<string, string> selected_field_data;
	public KeyValueField field_prefab;
	public InputField search_input_field;
	public Transform fields_transform;
	private ObjectPoolGenericMono<KeyValueField> _pool_fields;
	internal List<FieldInfo> field_infos = new List<FieldInfo>();
	internal Dictionary<string, FieldInfoListItem> fields_collection_data = new Dictionary<string, FieldInfoListItem>();
	public void init<T>() where T : class
	public void init<T>(ListPool<string> pFieldsToLoad) where T : class
	public void checkInitPool()
	public void setData(object pReference)
	public FieldInfoListItem getFieldData(FieldInfo pField, object pReference)
													pCollectionData = enumerableToRows(value as IEnumerable);
												pCollectionData = enumerableToRowsCompacted(list);
											pCollectionData = enumerableToRowsCompacted(array);
										text = Toolbox.coloredText($"{fieldType.Name}.{arg}", color_enum);
	public KeyValueField addRow(string pName, string pValue)
	internal void setDataSearched(string pValue)
	private void setOddEvenColor(KeyValueField pComponent, int pIndex)
	private Dictionary<string, string> enumerableToRowsCompacted(IEnumerable pEnumerable)
	private Dictionary<string, string> enumerableToRows(IEnumerable pEnumerable)
	private Dictionary<string, string> dictionaryToRows(IDictionary pDictionary)
	public void clear()
public class FieldInfoListItem
	public string field_name;
	public string field_value;
	public Dictionary<string, string> collection_data;
	public FieldInfoListItem(string pName, string pValue, Dictionary<string, string> pCollectionData = null)
public static class Finder
	private static readonly List<BaseSimObject> _list_objects = new List<BaseSimObject>(4096);
	private static MapChunk[] _chunks;
	public static IEnumerable<Building> getBuildingsFromChunk(WorldTile pTile, int pChunkRadius, int pTileRadius = 0, bool pRandom = false)
	public static bool isEnemyNearOnSameIsland(Actor pActor, int pChunkRadius = 1)
	public static bool isEnemyNearOnSameIslandAndCarnivore(Actor pActor, int pChunkRadius = 1)
	public static IEnumerable<Actor> getUnitsFromChunk(WorldTile pTile, int pChunkRadius, float pTileRadius = 0f, bool pRandom = false)
	public static List<BaseSimObject> getAllObjectsInChunks(WorldTile pTile, int pTileRadius = 3)
	private static void fillAllObjectsFromChunk(MapChunk pChunk, WorldTile pTile, int pTileRadius, List<BaseSimObject> pListObjects)
	internal static IEnumerable<Actor> findSpeciesAroundTileChunk(WorldTile pTile, string pUnitID)
	public static Building getClosestBuildingFrom(Actor pActor, IReadOnlyCollection<Building> pBuildingList)
	public static Building getClosestBuildingFrom(WorldTile pTile, IReadOnlyCollection<Building> pBuildingList)
	public static void clear()
	public static WorldTile findTileInChunk(WorldTile pTile, TileFinderType pTileType)
internal enum FingerTarget
public class FireLayer : MapLayer
	internal override void create()
	public void setTileDirty(WorldTile pTile)
	protected override void checkAutoDisable()
	protected override void UpdateDirty(float pElapsed)
public class Fireworks : BaseEffect
	internal override void spawnOnTile(WorldTile pTile)
	private void loadSprites(string pPath)
public class FlexibleOneRowGrid : MonoBehaviour, ILayoutController
	public bool debug;
	public int bonus_spacing_x;
	private RectTransform _grid_rect;
	private GridLayoutGroup _grid;
	private GridLayoutGroupExtended _grid_extended;
	private bool _is_extended;
	private bool _initialized;
	private void Awake()
	private void init()
	public void SetLayoutHorizontal()
	public float calculateChildren()
	public void SetLayoutVertical()
public enum FloraSize
public enum FloraType
public delegate void FmodAction();
public delegate Font FontGetter();
public class ForcedFontStyle
	public FontStyle style;
	public bool shadow;
	public ForcedFontStyle(FontStyle pStyle, bool pShadow = false)
public class ForgotPasswordButton : MonoBehaviour
	public GameObject emailBG;
	public InputField emailInput;
	public Text statusMessage;
	public Button continueButton;
	private Button forgotPasswordButton;
	private bool checking;
	private void OnEnable()
	public void resetPassword()
	private void Update()
	private void newStatus(string pMessage)
	private void clearStatus()
public static class FPS
	private static float _delta_time;
	private static float _frame_count;
	private static float _update_rate = 3f;
	private static int _fps;
	private const int DEBUG_FPS_THRESHOLD = 25;
	private static List<int> _last_fps = new List<int>(5);
	public static int fps => _fps;
	public static string getFPS()
	public static void update()
	public static void debug_update()
internal class FSoundTimer
	public float timer;
public class GameLanguageAsset : Asset
	public string name;
	public bool main;
	public bool export = true;
	public bool is_rtl;
	public bool is_hanzi;
	public bool is_hindi;
	public bool debug_only;
	public string path_icon;
	public bool show_translators = true;
	public FontGetter font = () => LocalizedTextManager.instance.default_font;
	public ForcedFontStyle force_style;
	private Dictionary<string, Dictionary<string, string>> _translations;
	private static Dictionary<string, GameLanguageData> _language_data;
	public Dictionary<string, Dictionary<string, string>> translations
	public IEnumerable<string> getGroups()
	public GameLanguageData getLanguageData()
	public bool isRTL()
	public bool isHanzi()
	public bool isHindi()
	public bool hasForcedStyle()
public class GameLanguageData
	public string language;
	public string[] active;
	public string[] inactive;
public class GameLanguageLibrary : AssetLibrary<GameLanguageAsset>
	public override void init()
	public GameLanguageAsset add(string pID, string pName)
public class GameLoadedEvent : BaseMapObject
	private void Awake()
	private void setVersionData()
	internal override void create()
public static class GameObjectExtensions
	public static T AddOrGetComponent<T>(this GameObject pGameObject) where T : Component
	public static bool HasComponent<T>(this GameObject pGameObject)
	public static bool HasComponent<T>(this Component pComponent)
	public static T AddComponent<T>(this Component pComponent) where T : Component
public class GameObjectZSorter : MonoBehaviour
	public GameObject zParent;
	public float z_order_offset;
	private void Start()
internal class GameplayReportData
	public int usages_actors;
	public int usages_biomes;
	public int usages_food;
	public List<string> owners = new List<string>();
	public List<string> biomes = new List<string>();
	public List<string> food = new List<string>();
public static class GameplayReportGenerator
public class GameProgress
	public static GameProgress instance;
	private string dataPath;
	internal GameProgressData data;
	public static void init()
	public void create()
	private void setNewDataPath()
	private void initNewSave()
	public static bool unlockAchievement(string pName)
	public static bool isAchievementUnlocked(string pName)
	public static void saveData()
	private void loadData()
	public void debugClearAllAchievements()
	public void unlockAllAchievements()
	public void debugClearAll()
	public void debugUnlockAll()
public class GameProgressData
	internal List<HashSet<string>> all_hashsets = new List<HashSet<string>>();
	public HashSet<string> achievements;
	public HashSet<string> unlocked_traits_actor;
	public HashSet<string> unlocked_traits_culture;
	public HashSet<string> unlocked_traits_language;
	public HashSet<string> unlocked_traits_subspecies;
	public HashSet<string> unlocked_traits_clan;
	public HashSet<string> unlocked_traits_kingdom;
	public HashSet<string> unlocked_traits_religion;
	public HashSet<string> unlocked_equipment;
	public HashSet<string> unlocked_genes;
	public HashSet<string> unlocked_actors;
	public HashSet<string> unlocked_plots;
	public int saveVersion = 2;
	public List<string> unlocked_traits
	public GameProgressData()
	public void setDefaultValues()
	public void prepare()
public class GameStats : MonoBehaviour
	internal GameStatsData data;
	private string dataPath;
	private WorldTimer saveTimer;
	private void Start()
	internal bool goodForAds()
	private void saveData()
	private void checkDataForErrors()
	private void loadData()
	public void updateStats(float pTime)
public class GameStatsData
	public double gameTime;
	public long treesGrown;
	public long floraGrown;
	public long meteoritesLaunched;
	public long pixelsExploded;
	public long creaturesBorn;
	public long creaturesCreated;
	public long creaturesDied;
	public long subspeciesCreated;
	public long subspeciesExtinct;
	public long languagesCreated;
	public long languagesForgotten;
	public long booksWritten;
	public long booksRead;
	public long booksBurnt;
	public long culturesCreated;
	public long culturesForgotten;
	public long religionsCreated;
	public long religionsForgotten;
	public long kingdomsCreated;
	public long kingdomsDestroyed;
	public long citiesCreated;
	public long citiesConquered;
	public long citiesRebelled;
	public long citiesDestroyed;
	public long alliancesMade;
	public long alliancesDissolved;
	public long warsStarted;
	public long peacesMade;
	public long plotsStarted;
	public long plotsSucceeded;
	public long plotsForgotten;
	public long familiesCreated;
	public long familiesDestroyed;
	public long clansCreated;
	public long clansDestroyed;
	public long armiesCreated;
	public long armiesDestroyed;
	public long creaturesSacrificed;
	public long elvesSacrificed;
	public long boatsDestroyedByMagnet;
	public long gameLaunches;
	public long bombsDropped;
	public long wallsPlaced;
	public long workshopUploads;
	public long mapsCreated;
public class GenderCount
	public int males;
	public int females;
public class GeneAsset : BaseTrait<GeneAsset>
	private const string CHARS_FOR_CODONS = "ACGT";
	public bool is_stat_gene = true;
	public bool can_drop_and_grab = true;
	public bool is_empty;
	public bool for_generation;
	public bool is_bad;
	public bool is_simple;
	public bool is_bonus_male;
	public bool is_bonus_female;
	public bool show_genepool_nucleobases = true;
	public bool synergy_sides_always;
	private string _genetic_code;
	public char genetic_code_right;
	public char genetic_code_left;
	public char genetic_code_up;
	public char genetic_code_down;
	private string _cached_sequence;
	private string _cached_sequence_locked;
	private BaseStats _cached_half_stats;
	private BaseStats _cached_half_stats_meta;
	protected override HashSet<string> progress_elements => base._progress_data?.unlocked_genes;
	public override string typed_id => "gene";
	public GeneAsset()
	public override BaseCategoryAsset getGroup()
	public string getSequence()
	private string getHarmfulSequence()
	public string getColoredSequence()
	public string getLockedSequence()
	public BaseStats getHalfStats()
	public BaseStats getHalfStatsMeta()
	public void generateDNA(long pSeed)
	private string generateRandomCodonString(long pSeed, int pLength)
	protected override bool isDebugUnlockedAll()
public delegate void GeneAssetClickEvent(GeneAsset pGeneAsset);
public class GeneButton : ChainElement
	private GameObject _petri_bg;
	private GeneAssetClickEvent _gene_asset_click_event;
	protected override void create()
	private void click()
	protected override void onStartDrag(DraggableLayoutElement pOriginalElement)
	internal void locusChild(UnityAction pAction, int pLocusIndex)
	protected override void fillTooltipData(GeneAsset pElement)
	protected override TooltipData tooltipDataBuilder()
	public void addGeneClickCallback(GeneAssetClickEvent pAction)
	public void removeGeneClickCallback(GeneAssetClickEvent pAction)
public enum GeneDirection
public class GeneEditor : MonoBehaviour
	private Text _text_unlocked_genes;
	private Transform _transform_chromosomes;
	private Transform _transform_loci;
	private Transform _transform_gene_selector;
	private ChromosomeElement _prefab_chromosome_element;
	private LocusElement _prefab_locus_element;
	private GeneButton _prefab_gene_button;
	private bool _initialized;
	private Dictionary<GeneAsset, GeneButton> _dictionary_gene_buttons = new Dictionary<GeneAsset, GeneButton>();
	private ObjectPoolGenericMono<ChromosomeElement> _pool_elements_chromosomes;
	private ObjectPoolGenericMono<LocusElement> _pool_elements_loci;
	private LocusElement _selected_locus;
	private Chromosome _selected_chromosome;
	public Image selection_locus;
	public Image selection_gene_asset;
	public Text genome_counter_text;
	private SubspeciesWindow _window_subspecies;
	private Subspecies _meta_object => SelectedMetas.selected_subspecies;
	internal void load()
	private void init()
	private void clear()
	private void OnEnable()
	private void OnDisable()
	public void debugRandomizeGenes()
	public void debugShuffleGenes()
	private void loadChromosomes(bool pSelectFirstChromosome = true)
	private void recolorGenePoolButtons()
	private void loadGeneButtons()
	public void clickChromosome(Chromosome pChromosome)
	private void selectFirstNormalLocus()
	internal void selectLocus(LocusElement pElement)
	private void clickGeneAssetAction(GeneAsset pGeneAsset)
	private void chromosomeUpdatedEvent()
	public void showGenes(Chromosome pChromosome)
	private void updateTextGenome()
	private void Update()
	private GeneButton getCurrentGeneAssetButton()
	private void reloadButtons()
	protected virtual bool hasGene(GeneAsset pTrait)
public class GeneLibrary : BaseTraitLibrary<GeneAsset>
	private Dictionary<string, List<GeneAsset>> _cached_stat_genes_dictionary = new Dictionary<string, List<GeneAsset>>();
	private List<GeneAsset> _gene_assets_simple = new List<GeneAsset>();
	private List<GeneAsset> _gene_assets_mutations = new List<GeneAsset>();
	public static GeneAsset gene_for_generation;
	protected override string icon_path => "ui/Icons/genes/";
	protected override List<string> getDefaultTraitsForMeta(ActorAsset pAsset)
	public override void init()
	public string getRandomNormalGene()
	private void addBonusStats()
	private void addFightStats()
	private void addBaseStats()
	private void addAttributes()
	private void addSpecial()
	public override GeneAsset add(GeneAsset pAsset)
	public GeneAsset getRandomSimpleGene()
	public GeneAsset getRandomGeneForMutation()
	public void regenerateBasicDNACodesWithLifeSeed(long pLifeSeed)
	public override void linkAssets()
	public List<GeneAsset> getGenesWithStat(string pStatID)
	private List<GeneAsset> filterGenes(string pStatID)
public class GeneratedRoom
	public int id_debug;
	public List<WorldTile> edges_left;
	public List<WorldTile> edges_right;
	public List<WorldTile> edges_up;
	public List<WorldTile> edges_down;
public static class GenerateLLMPrompt
	public static string getText(Actor pActor)
		stringBuilderPool.AppendLine("Make it as though it were from a classic fantasy tale like Lord of the Rings or a D&D campaign.");
public enum GeneratorTarget
public class GeneratorTool : ScriptableObject
	private static WorldTile[,] _tiles_map;
	private static Texture2D[] _textures;
	private static List<WorldTile> _neighbours = new List<WorldTile>(4);
	private static List<WorldTile> _neighbours_all = new List<WorldTile>(8);
	internal static void Setup(WorldTile[,] pTilesMap)
	public static void Init()
	internal static void applyTemplate(string pID, float pMod = 1f)
	internal static void ApplyRandomShape(string pWhat = "height", float tDistMax = 2f, float pMod = 0.7f, bool pSubtract = false)
	private static void LoadGenShapeTextures()
	public static void ApplyWaterLevel(WorldTile[,] tilesMap, int width, int height, int pVal)
	public static void ApplyPerlinNoise(WorldTile[,] tilesMap, int width, int height, float pPosX, float pPosY, float pAlphaMod, float pScaleMod, bool pSubtract = false, GeneratorTarget pTarget = GeneratorTarget.Height)
	public static void ApplyPerlinReplace(PerlinReplaceContainer pContainer)
	public static void UpdateTileTypes(bool pGeneratorStage = false, int pStartIndex = 0, int pAmount = 0)
	public static void GenerateTileNeighbours(WorldTile[] pTilesList)
	public static void generateTileNeighbours(WorldTile pTile)
	public static void ApplyRingEffect()
	private static WorldTile getTile(int pX, int pY)
public abstract class GenericBannerLibrary : AssetLibrary<BannerAsset>
	public BannerAsset main;
	public int getNewIndexBackground()
	public int getNewIndexIcon()
	public int getNewIndexFrame()
	public Sprite getSpriteBackground(int pIndex)
	public Sprite getSpriteBackground(int pIndex, string pAssetID)
	public Sprite getSpriteIcon(int pIndex)
	public Sprite getSpriteIcon(int pIndex, string pAssetID)
	public Sprite getSpriteFrame(int pID)
	private Sprite loadSpriteFromAsset(List<string> pSpriteList, int pIndex)
	public BannerAsset getCurrentAsset()
public class GenericCustomizeWindow<TMetaObject, TData, TBanner> : MonoBehaviour where TMetaObject : MetaObject<TData> where TData : MetaObjectData where TBanner : BannerGeneric<TMetaObject, TData>
	private bool _created;
	protected Text counter_option_1;
	protected Text counter_option_2;
	protected Text counter_color;
	protected Image image_banner_option_1;
	protected Image image_banner_option_2;
	protected LocalizedText title;
	protected LocalizedText title_option_1;
	protected LocalizedText title_option_2;
	protected LocalizedText title_color;
	protected Transform banner_area;
	protected Image icon_banner;
	protected Image icon_top;
	protected Transform option_1;
	protected Transform option_2;
	protected Transform colors;
	protected Transform colors_parent;
	public TBanner banner;
	private List<ColorElement> _color_elements = new List<ColorElement>();
	protected virtual TMetaObject meta_object
	protected TData data => meta_object.data;
	private MetaCustomizationAsset meta_asset => AssetManager.meta_customization_library.getAsset(meta_type);
	protected virtual MetaType meta_type
	private void OnEnable()
	public int getChangeValue()
	protected virtual void apply()
	protected virtual void loadBanner()
	protected virtual void updateColors()
	protected virtual void updateColorsBanner()
	private void Awake()
	private void create()
	protected virtual void setupParts()
	protected virtual void setupButtons()
	protected virtual void setupBanner()
	protected virtual void setupTexts()
	protected virtual void setupImages()
	protected virtual void updateCounters()
	protected virtual void updateBanner()
	protected virtual void updateSelection()
	protected virtual void onBannerChange()
	public void randomize()
	public void option1Left()
	public void option1Right()
	public void option2Left()
	public void option2Right()
	private void colorSet(int pIndex)
	private void reselectAllColors()
	private void clickColorElement(ColorElement pElement, int pIndex)
public class GenericTest
	private List<object> list = new List<object>();
	public T get<T>(int pI) where T : class
	public void Add(object pObject)
public class GenericType
public readonly struct GenomePart : IEquatable<GenomePart>
	public readonly string id;
	public readonly float value;
	public GenomePart(string id, float pValue)
	public override bool Equals(object pObject)
	public bool Equals(GenomePart pOther)
	public override int GetHashCode()
	public override string ToString()
public delegate Color32 GetColorForMapIcon(Building pBuilding);
public delegate OnomasticsData GetCurrentOnomasticsData();
public delegate Sprite GetEffectSprite(BaseSimObject pObject, int pIndex);
public delegate int GetEffectSpriteCount(BaseSimObject pObject, StatusAsset pAsset);
public delegate Vector3 GetEffectSpritePosition(BaseSimObject pObject, int pIndex);
public delegate Vector3 GetEffectSpritePositionUI(AvatarEffect pEffect, int pIndex);
public delegate float GetEffectSpriteRotationZ(BaseSimObject pObject, int pIndex);
public delegate float GetEffectSpriteRotationZUI(AvatarEffect pEffect, int pIndex);
public delegate Sprite GetEffectSpriteUI(AvatarEffect pEffect, int pIndex);
public delegate bool GetHitAction(BaseSimObject pSelf, BaseSimObject pAttackedBy = null, WorldTile pTile = null);
public delegate IEnumerable<TMetaObject> GetListOfObjectsFunc<TListElement, TMetaObject, TData, TComponent>(TComponent pComponent) where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData where TComponent : ComponentListBase<TListElement, TMetaObject, TData, TComponent>;
public delegate IMetaObject GetMetaFromActor(Actor pActor);
public delegate ListPool<IMetaObject> GetMetaTotalFromActor(Actor pActor);
public delegate string GetNextJobID();
public delegate List<Actor> GetWorldUnits();
public class Globals
	public const string HIDDEN_ID = "[HIDDEN]";
	public const int TOTAL_AGE_SLOTS = 8;
	public const long NEUTRAL_KINGDOM_NUMERIC_ID = 0L;
	public const int PAST_RULERS_LIMIT = 30;
	public const int TOTAL_RANKS = 10;
	public const float UNIT_COLOR_EFFECT_TIME = 0.3f;
	public const float PLOT_REMOVAL_EFFECT_TIME = 1f;
	public const int CITY_ITEMS_MAX = 15;
	public const int CITY_MIN_ISLAND_TILES = 300;
	public const int CITY_MIN_CAN_BE_FARMS_TILES = 5;
	public const float CITY_TIMER_SUPPLY_DEFAULT = 30f;
	public const float REGION_UPDATE_TIMEOUT = 0.5f;
	public const int DEFAULT_CONSTRUCTION_SPEED = 2;
	public const int HAPPINESS_FROM_BREEDING_ACTION = 40;
	public const float FAST_SWIMMING_SPEED_MULTIPLIER = 5f;
	public const int CULTURE_SPREAD_CHANCE_FROM_BOOK = 3;
	public const int CULTURE_SPREAD_CHANCE_FROM_TALK = 3;
	public const int LANGUAGE_SPREAD_CHANCE_FROM_TALK = 3;
	public const int LANGUAGE_SPREAD_CHANCE_FROM_BOOK = 3;
	public const int RELIGION_SPREAD_CHANCE_FROM_TALK = 3;
	public const int RELIGION_SPREAD_CHANCE_FROM_BOOK = 3;
	public const int CITY_POP_FOR_SETTLE_TARGET = 22;
	public static readonly bool AI_TEST_ACTIVE = true;
	public const float DEFAULT_SCALE_EFFECT = 0.25f;
	public const float DEFAULT_SCALE_UNIT = 0.1f;
	public const float DEFAULT_SCALE_BUILDING = 0.25f;
	public const float DEFAULT_ARROW_START_HEIGHT = 0.6f;
	public const float DEFAULT_PROJECTILE_START_HEIGHT = 0.2f;
	public const float DEFAULT_SLASH_POSITION = 0.5f;
	public const float DEFAULT_UNIT_SPEED = 10f;
	public const float DEFAULT_UNIT_SPEED_MIN = 4f;
	public const float SPEED_MULTIPLIER_IN_LIQUID_WITHOUT_STAMINA = 0.4f;
	public const float ACCURACY_MIN = 1f;
	public const float ACCURACY_MAX = 10f;
	public const float FIRE_EXTINGUISH_CHANCE_FROM_RAIN = 0.9f;
	public static readonly bool DIAGNOSTIC = false;
	public static readonly bool TRAILER_MODE = false;
	public static bool TRAILER_MODE_USE_RESOURCES = true;
	public static bool TRAILER_MODE_UPGRADE_BUILDINGS = true;
	public const int BOAT_TYPE_LIMIT_PER_DOCK = 1;
	public const int CAST_HEIGHT = 15;
	public const int UNITS_IN_SPAWNER_PER_REGION = 4;
	public const int PATHFINDER_REGION_LIMIT = 4;
	public const float DAYS_IN_YEAR = 360f;
	public const float DAYS_IN_MONTH = 30f;
	public const float MONTHS_IN_YEAR = 12f;
	public const float MONTH_TIME = 5f;
	public const float YEAR_TIME = 60f;
	public const int ATTRIBUTE_BAD = 4;
	public const int ATTRIBUTE_NORMAL = 9;
	public const int ATTRIBUTE_GOOD = 20;
	public const int BUILDING_TOWER_CAPTURE_POINTS = 10;
	public const int GENERATOR_MAX_TREES_PER_ZONE = 3;
	public const float MIN_ADS_INTERVAL_MINUTES = 2f;
	public const float ADS_INTERVAL_MINUTES = 5f;
	public static readonly bool specialAbstudio = false;
	public const float SAME_GRASS_CHANCE = 0.05f;
	public const int GREY_GOO_DAMAGE = 50;
	public const int DAMAGE_ACID = 20;
	public const int DAMAGE_HEAT = 50;
	public const int MINIMUM_UNITS_IN_CITY_BEFORE_POP_POINTS = 50;
	public const int CITIZEN_FOOD_COST = 1;
	public const int ZONES_BETWEEN_CITIES = 3;
	public const int BOMB_RANGE_ATOMIC_NUKE = 30;
	public const int BOMB_RANGE_CZAR_BOMB = 70;
	public const float SHAKE_DURATION = 0.3f;
	public const float SHAKE_INTERVAL = 0.01f;
	public const float SHAKE_INTENSITY = 2f;
	public const bool SHAKE_X = false;
	public const bool SHAKE_Y = true;
	public const float COUNTER_TWEEN_DURATION = 0.45f;
	public const int ANIMAL_BABY_MAKING_UNITS_AROUND_LIMIT = 6;
	public const int FOOD_FROM_FISH = 1;
	public const int FOOD_FROM_TILE = 1;
	public const int FOOD_FROM_FARM = 2;
	public const int FARM_DISTANCE_AREA = 9;
	public const int ANIMAL_GOOD_FOR_HUNTING_AGE = 3;
	public const int MAX_UNIT_LEVEL = 9999;
	public const int BOAT_UNITS_LIMIT = 100;
	public const int TRANSPORT_WAIT_TRY_LIMIT = 4;
	public const float COLORS_ZONE_ALPHA = 0.78f;
	public const int ISLAND_TILES_FOR_DOCKS = 2500;
	public const int FOOD_BUSH_REGROW_TIME = 90;
	public const int FOOD_BEEHIVE_FULL = 10;
	internal const int REWARD_MINUTES = 30;
	internal const int REWARD_MINUTES_CLOCK = 720;
	internal const int REWARD_HOURS_CLOCK = 12;
	internal const int REWARD_DURATION = 1800;
	internal const int REWARD_DURATION_CLOCK = 43200;
	internal const int REWARD_SAVESLOT_HOURS = 3;
	internal const int REWARD_SAVESLOT_DURATION = 10800;
	internal const int REWARDS_PER_GIFT = 3;
	internal const int FREE_SAVE_SLOTS = 15;
	internal const int REWARD_AD_SAVESLOTS_OLD = 6;
	internal const int REWARD_AD_SAVESLOTS_10HRS = 3;
	internal const int REWARD_AD_SAVESLOTS_20HRS = 6;
	internal const int DISCORD_MEMBERS = 560000;
	internal const int FACEBOOK_MEMBERS = 82000;
	internal const int TWITTER_MEMBERS = 56000;
	internal const int REDDIT_MEMBERS = 140000;
	internal const string WB_EXAMPLE_MAP = "WB-5555-1166-5555";
	public const int TIMEOUT_CONQUER = 300;
	public static readonly Vector3 POINT_IN_VOID = new Vector3(-1000000f, -1000000f);
	public static readonly Vector2 POINT_IN_VOID_2 = new Vector2(-1000000f, -1000000f);
	public const string NORMAL = "0";
	public const int RATE_US_ID = 12;
	public const string voteLink = "https://play.google.com/store/apps/details?id=com.mkarpenko.worldbox";
	internal static Vector3 emptyVector = new Vector3(-100000f, -10000f);
	public const int TOTAL_WORLD_AGE_SLOTS = 8;
public class GlobusPreview : MonoBehaviour
	public bool use_current_world_info;
	public Image main_image_1;
	public Image main_image_2;
	public GameObject images_parent;
	public Image clouds;
	public Sprite preview_default;
	private float _tweenSpeed = 18f;
	private float _gap_size = 25f;
	private float _box_size = 100f;
	private void OnEnable()
	private void startLoadCurrentSaveSlotSprite()
	private void setCurrentWorldSprite()
	private void setWorkshopSlotSprite()
	private void setSprites(Sprite pSprite)
	private void showDefaultImage()
	private IEnumerator loadSaveSlotImage()
	private void makeGradient(Sprite pSprite)
	private void startTweenGlobus()
	private void tweenLoop()
public class GlowParticles : MonoBehaviour
	private float cooldown;
	public ParticleSystem particles;
	private void Awake()
	private void Update()
	public void spawn(float pX, float pY, bool pRemoveCooldown = false)
	public void spawn(Vector3 pPos)
	public void clear()
public class GodFinger : BaseActorComponent
	public const float FLYING_SPEED = 8f;
	public const int MAX_TARGET_TILES = 1200;
	internal GodPower god_power;
	internal string brush;
	internal float flying_target = 8f;
	private float _rotate_wiggle = 30f;
	internal static string[] power_over_water = Toolbox.splitStringIntoArray("tile_high_soil#10", "tile_soil#10", "tile_hills", "tile_mountains", "tile_summit", "shovel_plus");
	internal static string[] power_over_ground = Toolbox.splitStringIntoArray("seeds_candy", "seeds_corrupted", "seeds_crystal", "seeds_desert", "seeds_enchanted", "seeds_grass", "seeds_infernal", "seeds_jungle", "seeds_lemon", "seeds_mushroom", "seeds_permafrost", "seeds_savanna", "seeds_swamp", "seeds_birch", "seeds_maple", "seeds_flower", "seeds_garlic", "seeds_rocklands", "seeds_celestial", "seeds_singularity", "seeds_clover", "seeds_paradox", "fertilizer_plants#4", "fertilizer_trees#4");
	internal HashSet<WorldTile> target_tiles = new HashSet<WorldTile>(1800);
	internal FingerTarget finger_target;
	private SpriteAnimation fingerTip;
	internal Color debug_color;
	private static Color[] _random_colors = (Color[])(object)new Color[20]
	internal bool is_drawing
	internal bool drawing_over_water => finger_target == FingerTarget.Water;
	internal bool drawing_over_ground => finger_target == FingerTarget.Ground;
	internal override void create(Actor pActor)
	internal void lightAction()
	public override void update(float pElapsed)
	private bool isInMapBounds(Vector3 pPos)
	public void drawOnTile(WorldTile pTile)
	public bool clearTargets(WorldTile pTile, string pPowerID)
	public bool fingerTile(WorldTile pTile, string pPowerID)
	public override void Dispose()
	internal static bool deathFlip(BaseSimObject pTarget, WorldTile pTile, float pElapsed)
	public static void debug_trail(GodFinger pFinger)
public class GodPower : Asset, IDescriptionAsset, ILocalizedAsset
	internal static List<PowerButton> powers_rank_0 = new List<PowerButton>();
	internal static List<PowerButton> powers_rank_1 = new List<PowerButton>();
	internal static List<PowerButton> powers_rank_2 = new List<PowerButton>();
	internal static List<PowerButton> powers_rank_3 = new List<PowerButton>();
	internal static List<PowerButton> powers_rank_4 = new List<PowerButton>();
	internal static List<PowerButton> premium_buttons = new List<PowerButton>();
	internal static List<GodPower> premium_powers = new List<GodPower>();
	internal static Dictionary<string, GodPower> god_powers_on_canvas = new Dictionary<string, GodPower>();
	public string name = "DEFAULT NAME";
	public bool requires_premium;
	public PowerRank rank;
	public string path_icon;
	public bool multiple_spawn_tip;
	public bool show_unit_stats_overview;
	public bool show_tool_sizes;
	public bool unselect_when_window;
	public bool make_buildings_transparent;
	public MetaType force_map_mode;
	public bool ignore_cursor_icon;
	public bool hold_action;
	public float click_interval;
	public float particle_interval;
	public float falling_chance = 0.95f;
	public string sound_drawing;
	public string sound_event;
	public string tile_type;
	internal TileType cached_tile_type_asset;
	public string top_tile_type;
	internal TopTileType cached_top_tile_type_asset;
	public string drop_id;
	internal DropAsset cached_drop_asset;
	public string force_brush;
	public bool terraform;
	public bool draw_lines;
	public PowerActionType type;
	public MouseHoldAnimation mouse_hold_animation;
	public bool highlight;
	public PowerActionWithID click_brush_action;
	public PowerActionWithID click_action;
	public PowerActionWithID click_special_action;
	public PowerAction click_power_brush_action;
	public PowerAction click_power_action;
	public PowerButtonClickAction select_button_action;
	public bool disabled_on_mobile;
	public string toggle_name;
	public bool multi_toggle;
	public PowerToggleAction toggle_action;
	public string actor_asset_id;
	public string[] actor_asset_ids;
	public float actor_spawn_height = 6f;
	public bool show_spawn_effect;
	public string printers_print;
	public bool ignore_fast_spawn;
	public bool set_used_camera_drag_on_long_move;
	public bool can_drag_map;
	public bool tester_enabled = true;
	public bool track_activity = true;
	public bool map_modes_switch;
	public bool allow_unit_selection;
	public bool show_close_actor;
	public bool activate_on_hotkey_select = true;
	public bool surprises_units = true;
	public Sprite sprite_icon;
	public bool has_sound_drawing => sound_drawing != null;
	public bool has_sound_event => sound_event != null;
	public OptionAsset option_asset => AssetManager.options_library.get(toggle_name);
	public bool isSelected()
	public bool isAvailable()
	internal static void addPower(GodPower pPower, PowerButton pButton)
	public Sprite getIconSprite()
	public static void diagnostic()
	private static void printRankedPowerButtons(string pID, List<PowerButton> pList)
	private static void printRankedPowers(string pID, List<GodPower> pList)
	public string getActorAssetID()
	public ActorAsset getActorAsset()
	public string getLocaleID()
	public string getDescriptionID()
	public string getTranslatedName()
	public string getTranslatedDescription()
public class GoogleInterstitialAd : IWorldBoxAd
	private InterstitialAd interstitial;
	private static string _last_error = "";
	private static string _last_id = "";
	private static int _loaded = 0;
	private static int _failed = 0;
	internal static int default_current = 2;
	private static int _current = 2;
	private const int max_current = 3;
	private static string _admob_id = string.Empty;
	public Action<string> logger { get; set; }
	public Action adResetCallback { get; set; }
	public Action adFailedCallback { get; set; }
	public Action adFinishedCallback { get; set; }
	public Action adStartedCallback { get; set; }
	public void Reset()
	private string getInterstitialAdUnitID()
	public void RequestAd()
	public void HandleOnAdLoaded()
	public void HandleOnAdFailedToLoad(LoadAdError pLoadAdError = null)
	public void HandleOnAdFailed(AdError pLoadAdError)
	public void HandleOnAdOpened()
	public void HandleOnAdClosed()
	public void HandleOnPaidEvent(AdValue pAdValue)
	public void KillAd()
	public bool IsReady()
	public void ShowAd()
	public bool HasAd()
	public string GetProviderName()
	public string GetColor()
	private void log(string pLog)
	public bool IsInitialized()
public class GoogleMobileAdsLoader : MonoBehaviour
	private static GoogleMobileAdsLoader instance;
	internal static bool initialized;
	public static void initAds()
	public void Start()
	private static void log(string pLog)
	public static string GetColor()
	public static bool shouldLoad()
namespace UnityEngine.Purchasing.Security;
public class GooglePlayTangle
	private static byte[] data = Convert.FromBase64String("dMZFZnRJQk1uwgzCs0lFRUVBREdEmfRYkbtqgRbn1uonvTwN/R8KFU6dxJq3OX0iF3cfyyJx8SV7RVGGxkVLRHTGRU5GxkVFRP5Y/5bFSR/VDy6kDuoXivfvEGyjKBQT+9rZmVyqpLrINBBIHwrgnBmw5oYPgCTQFfAkFYtqkxQ7rApQgWXHUO1Yazc8LKUBLugsGw9EnuaTejink6/77p3l5I8yLPPXoWzpZiaKULv3J2oWZA/rW+FQV6LIhhRwCV/P+f9WmvYdd6ZmDDpkn3tjgD+VREl/ATD2fsHxO5PI/rKsCQMWxPlMIo8bIhQj7mVfsjIQHaUvOw4F+T5WKYoyovWQkU1OkQpSqXwrq6UIHOp9hHP01aTEwqMk21zFcUZHRURF");
	private static int[] order = new int[15]
	private static int key = 68;
	public static readonly bool IsPopulated = true;
	public static byte[] Data()
public class GoogleRewardAd : IWorldBoxAd
	private RewardedAd rewardBasedVideo;
	private static int loaded = 0;
	private static int failed = 0;
	internal static int default_current = 2;
	private static int current = 2;
	private const int max_current = 3;
	private static string _admob_id = string.Empty;
	private bool started;
	private static string lastError = "";
	private static string lastID = "";
	public Action<string> logger { get; set; }
	public Action adResetCallback { get; set; }
	public Action adFailedCallback { get; set; }
	public Action adFinishedCallback { get; set; }
	public Action adStartedCallback { get; set; }
	public void Reset()
	private string getRewardAdUnitID()
	public void RequestAd()
	public void HandleRewardBasedVideoLoaded()
	public void HandleRewardBasedVideoFailedToLoad(LoadAdError pLoadAdError)
	public void HandleRewardBasedVideoOpened()
	public void HandleRewardedAdFailedToShow(AdError pAdError)
	public void HandleRewardBasedVideoRewarded(Reward pAdReward)
	public void HandleRewardBasedVideoClosed()
	public void HandleOnPaidEvent(AdValue pAdValue)
	public void KillAd()
	public bool IsReady()
	public void ShowAd()
	public bool HasAd()
	public string GetProviderName()
	public string GetColor()
	private void log(string pLog)
	public bool IsInitialized()
namespace ai.behaviours;
public enum GoToActorTargetType
public static class GPGSIds
	public const string achievement_10000_bombs = "CgkIia6M98wfEAIQBQ";
	public const string achievement_megapolis = "CgkIia6M98wfEAIQBg";
	public const string achievement_make_wilhelm_scream = "CgkIia6M98wfEAIQBw";
	public const string achievement_1000_creatures = "CgkIia6M98wfEAIQBA";
	public const string achievement_baby_tornado = "CgkIia6M98wfEAIQAw";
	public const string achievement_lava_strike = "CgkIia6M98wfEAIQAg";
public class GraphCategoriesContainer : MonoBehaviour
	public GraphController graph_controller;
	public GraphCategoryGroup category_group = GraphCategoryGroup.General;
	private GraphCategoryGroup _last_category_group;
	private GraphCategoryGroup _last_category_groups;
	private List<HistoryDataAsset> _current_list = new List<HistoryDataAsset>();
	private Dictionary<string, ButtonGraphCategory> _category_buttons = new Dictionary<string, ButtonGraphCategory>();
	private ButtonGraphCategory _prefab_button;
	private bool _is_initialized;
	private TabTogglesGroup _category_groups;
	private void init()
	public void apply()
	private void showCategoryGroups(GraphCategoryGroup pGroups)
	public void setCategoryEnabled(string pId, bool pEnabled)
public enum GraphCategoryGroup
public class GraphCompareMetaObject : MonoBehaviour, IDropHandler, IEventSystemHandler
	private GraphCompareWindow _graph_window;
	private GraphController _graph_controller;
	private MultiBannerPool _pool_drop_banners;
	public NanoObject current_item;
	public GameObject empty_drop_icon;
	public LocalizedText meta_title;
	public Text meta_name;
	private IBanner _current_banner;
	public static bool disable_raycasts;
	private bool _disable_raycasts;
	private List<Graphic> _raycast_children = new List<Graphic>();
	private bool _initialized;
	public void Awake()
	private void init()
	public void OnEnable()
	public void Update()
	public void disableRaycastChildren()
	public void enableRaycastChildren()
	public void OnDrop(PointerEventData pEventData)
	public void empty()
	public void clear()
	public void clearAndSetObject(NanoObject pObject)
	public void setObject(NanoObject pObject)
	private void setObjectAndUpdate(NanoObject pObject)
	private void removeOnClick()
	private void clearObject()
	private void releaseChild()
public class GraphCompareMetaSelector : MonoBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IDragHandler, IBeginDragHandler, IEndDragHandler, IDraggable
	private bool _spawn_particles_on_drag = true;
	private Vector3 _start_local_position;
	private Transform _start_parent;
	private ScrollableButton _scrollable_button;
	private readonly List<Graphic> _raycastables = new List<Graphic>();
	private Vector2 _first_position = Vector2.zero;
	private bool _dragging;
	private readonly List<RectTransform> _dropzones = new List<RectTransform>();
	private GraphCompareWindow _window;
	public bool spawn_particles_on_drag => _spawn_particles_on_drag;
	private Transform _attach_parent => World.world.drag_parent;
	private void Awake()
	private void showTooltip()
	public void addWindow(GraphCompareWindow pWindow)
	public void addDropzones(params RectTransform[] pDropzones)
	public bool isBeingDragged()
	public void OnInitializePotentialDrag(PointerEventData pEventData)
	public bool checkIfDragging(PointerEventData pEventData)
	public void OnBeginDrag(PointerEventData pEventData)
	public void OnDrag(PointerEventData pEventData)
	public void OnEndDrag(PointerEventData pEventData)
	public void resetDrag()
	private void disableRaycast()
	private void OnDisable()
	public void KillDrag()
public class GraphCompareWindow : MonoBehaviour
	public GraphCompareMetaObject meta_object_1;
	public GraphCompareMetaObject meta_object_2;
	public GraphCompareMetaObject meta_object_3;
	public GraphController graph_controller;
	private GameObject _empty_list_message;
	private RectTransform _meta_drag_object;
	private ObjectPoolGenericMono<RectTransform> _pool_drag_objects;
	private MultiBannerPool _pool_banners;
	private MultiBannerPool _pool_drop_banners;
	private Button _noos_button;
	private Image _noos_icon;
	private Transform _noos_list_container;
	private Transform _pool_banner_container;
	private Transform _pool_drop_banner_container;
	private MetaTypeAsset _current_asset;
	private List<MetaTypeAsset> _noos_list = new List<MetaTypeAsset>();
	private List<NanoObject> _noos_items = new List<NanoObject>();
	private Coroutine _load_noos_items;
	private const int VISIBLE_ITEMS = 6;
	private CanvasGroup[] _block_during_random;
	private bool _is_randomizing;
	private bool _stop_randomizer;
	private void Awake()
	internal MultiBannerPool getDropBannerPool()
	private void OnEnable()
	private IEnumerator selectNoosCoroutine()
	private IEnumerator updateGraph()
	private IEnumerator displaySelected(bool pUpdate = true)
	private void OnDisable()
	private void clearAsset()
	private void loadNoos()
	private bool hasAny()
	private void showItems(bool pShow)
	private void updateNoosIcon(MetaTypeAsset pAsset)
	public void clearNoosItems()
	private void resetNoosList()
	private void resetPoolsAndParents(string pID)
	public IEnumerator loadNoosItemsCoroutine(bool pSilent = false)
	public int countNoosItems()
	public static int sortByUnits(NanoObject pNanoObject1, NanoObject pNanoObject2)
	private void nextNoos()
	private void selectNoos(NanoObject pObject)
	private void selectNoos(MetaTypeAsset pAsset)
	public IBanner setupBanner(NanoObject pObject, Transform pBannerArea, MultiBannerPool pBannerPool)
	private IBanner setupDragBanner(NanoObject pObject, Transform pBannerArea, MultiBannerPool pBannerPool)
	private ListPool<NanoObject> getPossibleItems()
	internal void loadNoosItems(bool pSilent = false)
	private void selectRandom()
	public void randomizeSelection()
	private IEnumerator displayRandom()
	private IEnumerator randomizeCategories()
	private IEnumerator randomizeTimescale()
	public IEnumerator randomNoosItems()
public class GraphController : MonoBehaviour
	private sealed class _003C_003Ec
	public static MinMax min_max;
	public GraphChart chart;
	private MetaType _meta_type = MetaType.City;
	private GraphCategoriesContainer _container_graph_categories;
	private GraphTimeScaleContainer _container_time_scale;
	public bool clear_on_enable;
	public bool multi_chart;
	private VerticalAxis _vertical_axis;
	private HorizontalAxis _horizontal_axis;
	private List<HistoryDataAsset> _list_categories = new List<HistoryDataAsset>();
	private Dictionary<string, bool> _category_enabled = new Dictionary<string, bool>();
	private Dictionary<string, MinMax> _min_max_categories = new Dictionary<string, MinMax>();
	private long _min_timestamp = long.MinValue;
	private long _max_timestamp = long.MaxValue;
	private HashSet<MetaType> _current_types = new HashSet<MetaType>();
	private List<NanoObject> _current_objects = new List<NanoObject>();
	private Dictionary<NanoObject, HistoryTable> _last_data = new Dictionary<NanoObject, HistoryTable>();
	private GraphTimeAsset _current_sample;
	private HistoryInterval _current_interval;
	private Dictionary<string, CategoryData> _current_datas = new Dictionary<string, CategoryData>();
	private bool _events_hooked;
	private bool _loaded;
	private bool _categories_loaded;
	private long _last_timestamp = -1L;
	private void Awake()
	internal List<NanoObject> getObjects()
	internal List<HistoryDataAsset> getCategories()
	internal bool hasCategory(HistoryDataAsset pCategory)
	internal bool hasCategory(string pCategory)
	private static string getCategoryName(string pCategory)
	private NanoObject extractObject(string pCategory)
	internal bool isCategoryEnabled(string pCategory)
	internal string getActiveCategory()
	private void loadCategories()
	internal void addCategory(HistoryDataAsset pAsset, bool pEnabled = false)
	internal void disableAllCategories(string pExcept = null)
	internal void pickRandomCategory()
	internal void tryEnableCategory(string pCategory)
	internal void setCategoryEnabled(string pCategory, bool pIsOn, bool pUpdateGraph = true)
	private void hookEvents()
	private void multiChartHover(GraphEventArgs pArgs)
	private void singleChartHover(GraphEventArgs pArgs)
	public void resetAndUpdateGraph()
	public bool randomTimeScale()
	public void forceUpdateGraph()
	private void updateGraph()
	private void loadGraph()
	private void loadSingleChart()
	private void loadMultiChart()
	private void showCategory(string pCategory, NanoObject pObject)
	private (long tValue, long tPrevious) getCategoryValueAtTime(string pCategory, long pTime)
	private void colorCategory(HistoryDataAsset pHistoryDataAsset, NanoObject pObject, bool pColorFromObject = false)
	private MinMax getMinMax(string pCategoryName)
	internal void adjustCharts()
	private void loadSample()
	private void clearChartData()
	private void loadCategoryAndCharts()
	private void selectContainer(NanoObject pMetaObject)
	private void addContainer(NanoObject pMetaObject)
	private void clearGraph()
	internal void load()
	private void clear()
	private void OnEnable()
	private void OnDisable()
public static class GraphHelpers
	public static string getCategoryName(string pCategory)
	public static ListPool<string> bestCategories(Dictionary<string, MinMax> pCategoryStats)
	public static string horizontalFormatYears(double pValue, int pDigits)
	public static string verticalFormat(double pValue, int pDigits)
	public static long calculateNiceMaxAxisSize(double pLargestValue)
	public static int findVerticalDivision(long pValue)
	private static bool canDivideIntoWholeNumbers(long pTotalValue, int pSegments)
public enum GraphMetaType
public class GraphTextTimeScale : MonoBehaviour
	public GraphTimeScaleContainer graph_time_scale_container;
	private Text _text;
	public void Awake()
	public void Update()
public class GraphTimeAsset : Asset
	public GraphTimeScale scale_id;
	public HistoryInterval interval;
	public int max_time_frame;
public class GraphTimeLibrary : AssetLibrary<GraphTimeAsset>
	public override void init()
	public static long getMinTime(GraphTimeAsset pAsset)
	public static long getMaxTime(GraphTimeAsset pAsset)
	public override GraphTimeAsset add(GraphTimeAsset pAsset)
public enum GraphTimeScale
public class GraphTimeScaleContainer : MonoBehaviour
	public GraphTimeScale current_scale;
	private List<GraphTimeScale> _available_time_scales = new List<GraphTimeScale>();
	private GraphController _controller;
	public void calcBounds()
	public bool resetTimeScale()
	public void setTimeScale(GraphTimeScale pScale)
	public ListPool<GraphTimeScale> sharedTimeScales()
	public bool randomizeTimeScale()
	public void timeScaleMinus()
	public void timeScalePlus()
	public string getIndexString()
	public GraphTimeScale getCurrentScale()
public class GraphyCaller : MonoBehaviour
	private int clicked;
	public void click()
	public void clickConsole()
	private void OnEnable()
public class GreyGooLayer : BaseModule
	private const float SPREAD_CHANCE = 0.05f;
	private const float REMOVE_CHANCE = 0.09f;
	private const float INTERVAL = 0.08f;
	private List<WorldTile> _to_remove = new List<WorldTile>();
	private List<WorldTile> _to_add = new List<WorldTile>();
	private bool _initiated;
	internal override void create()
	internal override void clear()
	public bool isActive()
	private void init()
	public override void update(float pElapsed)
	private void updateGooTiles()
	private void removeFromHashset()
	private void addToHashset()
	private void checkAroundTiles(WorldTile pTile)
	private bool areAroundTilesEmpty(WorldTile pTile)
	private void makeGoo(WorldTile pTile)
	private void terraform(WorldTile pTile)
	public void remove(WorldTile pTile)
	public void add(WorldTile pTile)
namespace LayoutGroupExt;
public class GridLayoutGroupExtended : LayoutGroupExtended
	public enum Corner
	public enum Axis
	public enum Constraint
	private TweenerCore<Vector3, Vector3, VectorOptions>[] _axis_tween = new TweenerCore<Vector3, Vector3, VectorOptions>[2];
	protected Corner m_StartCorner;
	protected Axis m_StartAxis;
	protected Vector2 m_CellSize = new Vector2(100f, 100f);
	protected Vector2 m_Spacing = Vector2.zero;
	protected Constraint m_Constraint;
	protected int m_ConstraintCount = 2;
	public Corner startCorner
	public Axis startAxis
	public Vector2 cellSize
	public Vector2 spacing
	public Constraint constraint
	public int constraintCount
	protected GridLayoutGroupExtended()
	public override void CalculateLayoutInputHorizontal()
	public override void CalculateLayoutInputVertical()
	private void TweenLayoutInputForAxis(float totalMin, float totalPreferred, float totalFlexible, int axis)
	private TweenerCore<Vector3, Vector3, VectorOptions> DOPreferredSize(Vector3 endValue, float duration, int axis)
	protected override void OnDisable()
	public override void SetLayoutHorizontal()
	public override void SetLayoutVertical()
	private void SetCellsAlongAxis(int axis)
namespace EpPathFinding.cs;
public class GridPos : IEquatable<GridPos>
	public int x;
	public int y;
	public GridPos()
	public GridPos(int iX, int iY)
	public GridPos(GridPos b)
	public override int GetHashCode()
	public override bool Equals(object obj)
	public bool Equals(GridPos p)
	public static bool operator ==(GridPos a, GridPos b)
	public static bool operator !=(GridPos a, GridPos b)
	public GridPos Set(int iX, int iY)
	public override string ToString()
namespace EpPathFinding.cs;
public class GridRect
	public int minX;
	public int minY;
	public int maxX;
	public int maxY;
	public GridRect()
	public GridRect(int iMinX, int iMinY, int iMaxX, int iMaxY)
	public GridRect(GridRect b)
	public override int GetHashCode()
	public override bool Equals(object obj)
	public bool Equals(GridRect p)
	public static bool operator ==(GridRect a, GridRect b)
	public static bool operator !=(GridRect a, GridRect b)
	public GridRect Set(int iMinX, int iMinY, int iMaxX, int iMaxY)
public class GroupSpriteObject : MonoBehaviour
	internal EventInstance fmod_instance;
	internal Transform m_transform;
	internal SpriteRenderer sprite_renderer;
	private bool _has_sprite_renderer;
	private Vector2 _last_pos_v2 = new Vector2(-1f, -1f);
	private Vector2 _last_scale_v2 = new Vector2(-1f, -1f);
	private Vector3 _last_pos_v3 = new Vector3(-1f, -1f, -1f);
	private Vector3 _last_scale_v3 = new Vector3(-1f, -1f, -1f);
	private Vector3 _last_angles_v3 = new Vector3(-1f, -1f, -1f);
	private Color _last_color;
	private bool _last_flip_x;
	private int _last_sprite_hash_code = -1;
	private int _last_sprite_material = -1;
	public int last_id;
	public bool has_sprite_renderer => _has_sprite_renderer;
	private void Awake()
	protected void create()
	public void checkRotation(Vector3 pPos, BaseSimObject pSimObject, float pZ)
	public void setPosOnly(Vector2 pPosition)
	public void setPosOnly(ref Vector2 pPosition)
	public void setPosOnly(ref Vector3 pPosition)
	public void setRotation(ref Vector3 pVec)
	public void setLocalEulerAngles(Vector3 pVec)
	public void setSprite(Sprite pSprite)
	public void setFlipX(bool pFlipX)
	public void setSharedMat(Material pMaterial)
	public void setColor(ref Color pColor)
	public void setScale(float pScale)
	public void setScale(float pScaleX, float pScaleY)
	public void setScale(ref Vector3 pScaleVec)
	public void set(ref Vector2 pPosition, ref Vector3 pScale)
	public void set(ref Vector2 pPosition, float pScale)
	public void set(ref Vector3 pPosition, float pScale)
	public void set(ref Vector3 pPosition, ref Vector2 pScale)
	public void set(ref Vector3 pPosition, ref Vector3 pScale)
public delegate BuildingAsset GrowTypeSelector(WorldTile pTile);
public static class HandRendererTexturePreloader
	private static int _preloaded_items_counter;
	public static void launch()
	private static void preloadItemsIntoAtlas()
	private static void preloadSpritesUnitHands(Sprite[] pSprites, bool pUseColors)
	public static int getTotal()
public class HappinessAsset : Asset, ILocalizedAsset, IMultiLocalesAsset
	public HappinessDelegateCalc calc;
	public int value;
	public string pot_task_id;
	public int pot_amount;
	public int index;
	public string path_icon;
	public bool ignored_by_psychopaths;
	public bool show_change_happiness_effect = true;
	public int dialogs_amount = 4;
	private Sprite _cached_sprite;
	public virtual Sprite getSprite()
	public string getLocaleID()
	public IEnumerable<string> getLocaleIDs()
	public string getHappinnessDialogID()
	public string getTextSingleReport()
	public string getRandomTextSingleReportLocalized()
public class HappinessBarIcon : MonoBehaviour
	private Image _icon;
	private Actor _actor;
	private void Awake()
	public void load(Actor pActor)
	private void barUpdated(float pValue, float pMax)
	private void OnDisable()
public delegate int HappinessDelegateCalc(Actor pActor);
public static class HappinessHelper
	public static Sprite getSpriteBasedOnHappinessValue(int pValue)
public struct HappinessHistory
	public int index;
	public double timestamp;
	public int bonus;
	public HappinessAsset asset => AssetManager.happiness_library.list[index];
	public string getAgoString()
	public double elapsedSince()
public class HappinessLibrary : AssetLibrary<HappinessAsset>
	public override void init()
	public override void post_init()
	public override void editorDiagnosticLocales()
public class HashSetActor : HashSet<Actor>
public class HashSetBuilding : HashSet<Building>
public static class HashSetExtensions
	public static T GetRandom<T>(this HashSet<T> pHashSet)
	public static T[] ToArray<T>(this HashSet<T> pHashSet)
	public static bool Any<T>(this HashSet<T> pHashSet)
	public static bool RemoveAll<T>(this HashSet<T> pHashSet, ICollection<T> pToRemove)
	public static T Pop<T>(this HashSet<T> pHashSet)
	public static T Shift<T>(this HashSet<T> pHashSet)
		using (HashSet<T>.Enumerator enumerator = pHashSet.GetEnumerator())
			if (enumerator.MoveNext())
				T current = enumerator.Current;
public class HashSetMapRegion : HashSet<MapRegion>
public class HashSetRegionLink : HashSet<RegionLink>
public class HashSetTileZone : HashSet<TileZone>
public class HashSetWorldTile : HashSet<WorldTile>
public class HeaderContainer : MonoBehaviour, ILayoutController
	public RectTransform header_transform;
	public RectTransform content_transform;
	public RectTransform runes_container;
	public VerticalLayoutGroup content;
	private VerticalLayoutGroup _vertical_layout_group;
	private LayoutElement _layout_element;
	private int _default_top_padding;
	private RectOffset _default_padding;
	private void Awake()
	public void SetLayoutVertical()
	public void SetLayoutHorizontal()
	private IEnumerator toggleRunes()
	private bool hasAnyElementActive()
public class Heat
	public const int MAX_HEAT = 404;
	private float tickTimer;
	private List<WorldTile> tilesToRemove = new List<WorldTile>();
	private HashSetWorldTile tiles;
	internal void clear()
	internal void addTile(WorldTile pTile, int pHeat = 1)
	internal void update(float pElapsed)
public class HeatRayEffect : BaseAnimatedObject
	public SpriteAnimation ray;
	public SpriteAnimation heat;
	private bool active;
	private int ticksActive;
	private bool touchedGround;
	private float rayScaleY;
	private float rayWidth = 1f;
	public override void Awake()
	private void Update()
	internal bool isReady()
	public Vector2 getPosForLight()
	public override void update(float pElapsed)
	internal void play(Vector2 pPos, int pSize)
public class HelpButton : MonoBehaviour
	public void clickHelp()
namespace EpPathFinding.cs;
public class Heuristic
	public static float Manhattan(int iDx, int iDy)
	public static float Euclidean(int iDx, int iDy)
	public static float Chebyshev(int iDx, int iDy)
namespace EpPathFinding.cs;
public delegate float HeuristicDelegate(int iDx, int iDy);
namespace EpPathFinding.cs;
public enum HeuristicMode
public class HindiCorrector
	private static string[] hindi_letters = new string[178]
	private static string[] replace_letters = new string[178]
public class HistoryDataAsset : Asset, IDescriptionAsset, ILocalizedAsset
namespace db;
public delegate HistoryTable HistoryDataCollector(NanoObject pNanoObject);
public class HistoryDataLibrary : AssetLibrary<HistoryDataAsset>
public class HistoryGroupAsset : Asset, ILocalizedAsset
public class HistoryGroupLibrary : AssetLibrary<HistoryGroupAsset>
public class HistoryHud : MonoBehaviour
public class HistoryHudItem : MonoBehaviour
namespace db;
public enum HistoryInterval
namespace db;
public static class HistoryIntervalExtensions
namespace db;
public class HistoryMetaDataAsset : Asset
namespace db;
public class HistoryMetaDataLibrary : AssetLibrary<HistoryMetaDataAsset>
namespace LayoutGroupExt;
public class HorizontalLayoutGroupExtended : HorizontalOrVerticalLayoutGroupExtended
namespace LayoutGroupExt;
public abstract class HorizontalOrVerticalLayoutGroupExtended : LayoutGroupExtended
public class HorizontalToolbarArrow : ToolbarArrow
public delegate void HotkeyAction(HotkeyAsset pAsset);
public class HotkeyAsset : Asset
public class HotkeyLibrary : AssetLibrary<HotkeyAsset>
public static class HotkeysLocalized
public class HotkeyTabsData
public class HoveringBgIconManager : MonoBehaviour
public delegate IEnumerable<string> HoveringBGIconsGetter(WindowAsset pAsset);
public class HoveringIcon : MonoBehaviour
public enum HoverState
public interface IAnimationFrames
public interface IAugmentationsEditor
public interface IAugmentationsWindow<TEditor> where TEditor : IAugmentationsEditor
public interface IBanner : IBaseMono, IRefreshElement
public interface IBaseMetaBanners
public interface IBaseMono
public interface IBooksWindow
public class IceTower : BaseBuildingComponent
public interface IComponentList
public class IconClickRotator : MonoBehaviour
public delegate(Sprite icon, Color color) IconGetter();
public class IconOutline : MonoBehaviour
public delegate string IconPathGetter(IMetaObject pMeta);
public class IconRotationAnimation : MonoBehaviour
public interface ICoreObject
public interface IDescription2Asset : IDescriptionAsset, ILocalizedAsset
public interface IDescriptionAsset : ILocalizedAsset
public interface IDraggable : IEndDragHandler, IEventSystemHandler
public interface IEquipmentEditor : IAugmentationsEditor
public interface IEquipmentWindow : IAugmentationsWindow<IEquipmentEditor>
public interface IFavoriteable
public interface IHandRenderer
public interface IInterestingPeopleWindow
public interface ILibraryWithUnlockables
public class IllustrationFadeIn : MonoBehaviour
public interface ILoadable<TData>
public interface ILocalizedAsset
public class ImageRotator : MonoBehaviour
public interface IMetaObject : ICoreObject
public interface IMetaWindow
public interface IMetaWithFamiliesWindow
public enum ImpulseReachResult
public interface IMultiLocalesAsset
public class InAppManager : MonoBehaviour, IDetailedStoreListener, IStoreListener
public class InfoText : MonoBehaviour
public static class InitAds
public class InitLibraries : MonoBehaviour
public class InitStuff : MonoBehaviour
public static class InputHelpers
public static class InsultStringGenerator
public class InterestingPeopleElement : MonoBehaviour
public class InterestingPeopleTab : WindowMetaElementBase
namespace EpPathFinding.cs;
public class IntervalHeap<T> : CollectionValueBase<T>, IPriorityQueue<T>, IExtensible<T>, ICollectionValue<T>, IEnumerable<T>, IEnumerable, IShowable, IFormattable where T : class
	private struct Interval
	private class Handle : IPriorityQueueHandle<T>
public static class IntExtensions
public class IOSCheckTracking : MonoBehaviour
public interface IPlotsEditor : IAugmentationsEditor
public interface IPlotsWindow : IAugmentationsWindow<IPlotsEditor>
public interface IRefreshElement
public interface IRichTracker
public class IronSourceInterstitialAd : IWorldBoxAd
public class IronSourceMobileAdsLoader : MonoBehaviour
public class IronSourceRewardAd : IWorldBoxAd
public interface ISapient
public interface ISapientListComponent
public interface IScrollWindowShowEvent : IEventSystemHandler
public interface ISelectedContainerTrait
public interface ISelectedMetaWithUnit
public interface ISelectedTabBanners<T> where T : NanoObject
public interface IShakable
public interface IShouldRefreshWindow
public interface ISkipLocaleAsset
public class IslandsCalculator
public interface IStatsElement : IRefreshElement
public class Item : CoreSystemObject<ItemData>
public class ItemAsset : BaseAugmentationAsset, IDescriptionAsset, ILocalizedAsset, IMultiLocalesAsset
	public string name_class;
		return name_class + Item.getQualityString(pRarity);
public abstract class ItemAssetLibrary<T> : BaseLibraryWithUnlockables<T> where T : ItemAsset
public static class ItemCrafting
public class ItemData : BaseSystemData
public class ItemGroupAsset : BaseCategoryAsset
public class ItemGroupLibrary : BaseCategoryLibrary<ItemGroupAsset>
public enum ItemInHand
public class ItemLibrary : ItemAssetLibrary<EquipmentAsset>
		t.name_class = "item_class_armor";
		t.name_class = "item_class_armor";
		t.name_class = "item_class_armor";
		t.name_class = "item_class_accessory";
		t.name_class = "item_class_weapon";
public class ItemManager : CoreSystemManager<Item, ItemData>
		using (IEnumerator<Item> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				Item current = enumerator.Current;
public class ItemModAsset : ItemAsset
public class ItemModifierLibrary : ItemAssetLibrary<ItemModAsset>
public static class ItemRendering
public class ItemTools
public class ItemWindow : WindowMetaGeneric<Item, ItemData>
public interface ITraitsContainer<TTrait, TTraitButton> where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait>
public interface ITraitsEditor<TTrait> : IAugmentationsEditor where TTrait : BaseTrait<TTrait>
public interface ITraitsOwner<TTrait> where TTrait : BaseTrait<TTrait>
public interface ITraitWindow<TTrait, TTraitButton> : IAugmentationsWindow<ITraitsEditor<TTrait>> where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait>
public interface IWorldBoxAd
public class Job<T>
public delegate void JobAction();
public abstract class JobAsset<TCondition, TSimObject> : Asset where TCondition : BehaviourBaseCondition<TSimObject>
public class JobCityAsset : JobAsset<BehaviourCityCondition, City>
public static class JobConst
public class JobManagerActors : JobManagerBase<BatchActors, Actor>
public class JobManagerBase<TBatch, T> where TBatch : Batch<T>, new()
			item.Deconstruct(out var key, out var value);
public class JobManagerBuildings : JobManagerBase<BatchBuildings, Building>
public class JobTesterAsset : JobAsset<BehaviourTesterCondition, AutoTesterBot>
public enum JobType
public delegate void JobUpdater();
public static class JsonHelper
public class KarpenkosPromo : MonoBehaviour
public class KeyValueField : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, ISelectHandler, IDeselectHandler
public class Kingdom : MetaObjectWithTraits<KingdomData, KingdomTrait>
		using (IEnumerator<City> enumerator = getCities().GetEnumerator())
			if (enumerator.MoveNext())
				_ = enumerator.Current;
public class KingdomAlliesContainer : KingdomDiplomacyContainer<KingdomBanner, Kingdom, KingdomData>
public class KingdomAsset : Asset
public class KingdomBanner : BannerGeneric<Kingdom, KingdomData>
public class KingdomBannerLibrary : GenericBannerLibrary
namespace ai.behaviours;
public class KingdomBehCheckCapital : BehaviourActionKingdom
namespace ai.behaviours;
public class KingdomBehCheckKing : BehaviourActionKingdom
namespace ai.behaviours;
public class KingdomBehRandomWait : BehaviourActionKingdom
public class KingdomCapitalElement : KingdomElement
namespace ai.behaviours;
public class KingdomCheckAttackTarget : BehaviourActionKingdom
public class KingdomCheckCache
public class KingdomCitiesContainer : KingdomElement
public class KingdomColorsLibrary : ColorLibrary
public class KingdomCustomizeWindow : GenericCustomizeWindow<Kingdom, KingdomData, KingdomBanner>
public class KingdomData : MetaObjectData
public class KingdomDiplomacyContainer<TBanner, TMetaObject, TData> : KingdomElement where TBanner : BannerGeneric<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
public class KingdomElement : WindowMetaElement<Kingdom, KingdomData>
public class KingdomJob : JobAsset<BehaviourKingdomCondition, Kingdom>
public class KingdomJobLibrary : AssetLibrary<KingdomJob>
public class KingdomKingElement : KingdomElement
public class KingdomLibrary : AssetLibrary<KingdomAsset>
public class KingdomListComponent : ComponentListBase<KingdomListElement, Kingdom, KingdomData, KingdomListComponent>
public class KingdomListElement : WindowListElementBase<Kingdom, KingdomData>
public class KingdomManager : MetaSystemManager<Kingdom, KingdomData>
		using (IEnumerator<Kingdom> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				enumerator.Current.clearCursorOver();
		using IEnumerator<Kingdom> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.updateAge();
		using (IEnumerator<Kingdom> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				enumerator.Current.clearListCities();
		using IEnumerator<Kingdom> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearBuildingList();
public class KingdomMetaBanners : KingdomElement, IBaseMetaBanners
public class KingdomOpinion : IDisposable
public class KingdomsBannersContainer : BannersMetaContainer<KingdomBanner, Kingdom, KingdomData>
public class KingdomSelectedAlliesContainer : KingdomDiplomacyContainer<KingdomBanner, Kingdom, KingdomData>
public class KingdomSelectedContainerCities : SelectedElementBase<CityBanner>
public class KingdomSelectedContainerTraits : SelectedContainerTraits<KingdomTrait, KingdomTraitButton, KingdomTraitsContainer, KingdomTraitsEditor>
public class KingdomSelectedMetaBanners : KingdomMetaBanners, ISelectedTabBanners<Kingdom>
public class KingdomSelectedWarsContainer : KingdomDiplomacyContainer<WarBanner, War, WarData>
public class KingdomsMetaContainer : ListMetaContainer<KingdomListElement, Kingdom, KingdomData>
public class KingdomsNoItems : MetaListNoItems
public class KingdomStatsElement : KingdomElement, IStatsElement, IRefreshElement
public class KingdomTrait : BaseTrait<KingdomTrait>
public class KingdomTraitButton : TraitButton<KingdomTrait>
public class KingdomTraitEditorButton : TraitEditorButton<KingdomTraitButton, KingdomTrait>
public class KingdomTraitGroupAsset : BaseTraitGroupAsset
public class KingdomTraitGroupElement : TraitGroupElement<KingdomTrait, KingdomTraitButton, KingdomTraitEditorButton>
public class KingdomTraitGroupLibrary : BaseCategoryLibrary<KingdomTraitGroupAsset>
public class KingdomTraitLibrary : BaseTraitLibrary<KingdomTrait>
public class KingdomTraitsContainer : TraitsContainer<KingdomTrait, KingdomTraitButton>
public class KingdomTraitsEditor : TraitsEditor<KingdomTrait, KingdomTraitButton, KingdomTraitEditorButton, KingdomTraitGroupAsset, KingdomTraitGroupElement>
public class KingdomWarsContainer : KingdomDiplomacyContainer<WarBanner, War, WarData>
public class KingdomWindow : WindowMetaGeneric<Kingdom, KingdomData>, ITraitWindow<KingdomTrait, KingdomTraitButton>, IAugmentationsWindow<ITraitsEditor<KingdomTrait>>
public class KnowledgeAsset : Asset, ILocalizedAsset
public delegate void KnowledgeButtonLoader(Transform pButton, BaseUnlockableAsset pAsset);
public class KnowledgeElement : MonoBehaviour
public class KnowledgeLibrary : AssetLibrary<KnowledgeAsset>
public class KnowledgeWindow : TabbedWindow
public class Language : MetaObjectWithTraits<LanguageData, LanguageTrait>
public class LanguageBanner : BannerGeneric<Language, LanguageData>
public class LanguageBannerLibrary : GenericBannerLibrary
public class LanguageCustomizeWindow : GenericCustomizeWindow<Language, LanguageData, LanguageBanner>
public class LanguageData : MetaObjectData
	public LanguageStructure structure;
public class LanguageElement : WindowMetaElement<Language, LanguageData>
public class LanguageListComponent : ComponentListBase<LanguageListElement, Language, LanguageData, LanguageListComponent>
public class LanguageListElement : WindowListElementBase<Language, LanguageData>
public class LanguageManager : MetaSystemManager<Language, LanguageData>
		using IEnumerator<Language> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListKingdoms();
		using IEnumerator<Language> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListCities();
public class LanguagesColorsLibrary : ColorLibrary
public class LanguageSelectedContainerTraits : SelectedContainerTraits<LanguageTrait, LanguageTraitButton, LanguageTraitsContainer, LanguageTraitsEditor>
public class LanguageStatsElement : LanguageElement, IStatsElement, IRefreshElement
public class LanguageStructure
public static class LanguageStructureHelpers
public class LanguageTrait : BaseTrait<LanguageTrait>
public class LanguageTraitButton : TraitButton<LanguageTrait>
public class LanguageTraitEditorButton : TraitEditorButton<LanguageTraitButton, LanguageTrait>
public class LanguageTraitGroupAsset : BaseTraitGroupAsset
public class LanguageTraitGroupElement : TraitGroupElement<LanguageTrait, LanguageTraitButton, LanguageTraitEditorButton>
public class LanguageTraitGroupLibrary : BaseCategoryLibrary<LanguageTraitGroupAsset>
public class LanguageTraitLibrary : BaseTraitLibrary<LanguageTrait>
		t.addOpposite("nicely_structured_grammar");
			id = "nicely_structured_grammar",
public class LanguageTraitsContainer : TraitsContainer<LanguageTrait, LanguageTraitButton>
public class LanguageTraitsEditor : TraitsEditor<LanguageTrait, LanguageTraitButton, LanguageTraitEditorButton, LanguageTraitGroupAsset, LanguageTraitGroupElement>
public class LanguageWindow : WindowMetaGeneric<Language, LanguageData>, ITraitWindow<LanguageTrait, LanguageTraitButton>, IAugmentationsWindow<ITraitsEditor<LanguageTrait>>, IBooksWindow
public static class LavaHelper
public class LavaLayer : MapLayer
public class LavaRenderer : MonoBehaviour
namespace LayoutGroupExt;
public abstract class LayoutGroupExtended : LayoutGroup
public class LeaderEntry
public class LegendaryBG : MonoBehaviour
public class LevelPreviewButton : MonoBehaviour
public delegate ILibraryWithUnlockables LibraryGetter();
public class LibraryMaterials : MonoBehaviour
public class LibraryWindow : MonoBehaviour
public struct LightBlobData
public class LightRenderer : MonoBehaviour
public class LinguisticsAsset : Asset
public class LinguisticsLibrary : AssetLibrary<LinguisticsAsset>
internal enum LinkDirection
public static class List
internal static class ListAccessHelper
public delegate IComponentList ListComponentSetter(Transform pTransform);
public delegate MonoBehaviour ListElementPrefabGetter();
public static class ListExtensions
public enum ListItemsFilter
public class ListMetaContainer<TListElement, TMetaObject, TMetaData> : WindowMetaElementBase where TListElement : WindowListElementBase<TMetaObject, TMetaData> where TMetaObject : CoreSystemObject<TMetaData> where TMetaData : BaseSystemData
public sealed class ListPool<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>, IDisposable
	public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		using IEnumerator<T> enumerator = source.GetEnumerator();
		while (enumerator.MoveNext())
				items[num2] = enumerator.Current;
			AddWithResize(enumerator.Current);
public static class ListPoolExtensions
public class ListSorters
public class ListWindow : MonoBehaviour
public class ListWindowAsset : Asset, IMultiLocalesAsset
public class ListWindowLibrary : AssetLibrary<ListWindowAsset>
public class ListWindowStatistics : StatisticsRows
public class LivingIcon : MonoBehaviour
public class LoadingScreen : MonoBehaviour
public class LoadingScreenOut : MonoBehaviour
public class LoadingScreenSheepAnimation : MonoBehaviour
public class LoadWorldButton : MonoBehaviour
public delegate string LocaleGetter();
public class LocaleGroupAsset : Asset
public delegate bool LocaleGroupChecker(string pKey);
using strings;
public class LocaleGroupLibrary : AssetLibrary<LocaleGroupAsset>
		t.starts_with.Add("ui_class_");
public class LocalizationButton : MonoBehaviour
public class LocalizedText : UIBehaviour
public class LocalizedTextManager
public class LocalizedTextPrice : MonoBehaviour
public delegate void LocusClickEvent(LocusElement pLocusElement);
public class LocusDot : MonoBehaviour
public class LocusElement : ChainElement, IDropHandler, IEventSystemHandler
public enum LocusType
public class LogHandler : MonoBehaviour
public class LogHandlerInit : MonoBehaviour
public class Login
public class LoginData
public readonly struct LogItem
public class LogoButton : MonoBehaviour
public class LogText
public static class LongExtension
public class LongJsonConverter : JsonConverter
public class LongListJsonConverter : JsonConverter
public class LongTextLoader : MonoBehaviour
public class LoyaltyAsset : Asset, IMultiLocalesAsset
public static class LoyaltyCalculator
public delegate int LoyaltyDelegateCalc(City pCity = null);
public class LoyaltyLibrary : AssetLibrary<LoyaltyAsset>
public class Magnet
public class MagnetThrow
public class Map
public static class MapAction
public class MapBorder : BaseEffect
public class MapBox : MonoBehaviour
		Bench.bench("update_sprite_constructor", "game_total");
		Bench.benchEnd("update_sprite_constructor", "game_total", pSaveCounter: false, 0L);
			if (random2 != null && !random2.isUnderConstruction())
public class MapChunk : IDisposable
				tileType.Deconstruct(out key, out var value);
			item.Deconstruct(out key, out var value2);
public class MapChunkManager
public class MapDescription : MonoBehaviour
public class MapEdges
public static class MapGenerator
public class MapGenSettingsAsset : Asset, ILocalizedAsset
public delegate void MapGenSettingsDelegate(MapGenSettingsAsset pAsset);
public delegate bool MapGenSettingsDelegateBool(MapGenTemplate pAsset);
public delegate int MapGenSettingsDelegateGet();
public delegate void MapGenSettingsDelegateSet(int pValue);
public delegate void MapGenSettingsDelegateSwitch(MapGenSettingsAsset pAsset);
public class MapGenSettingsLibrary : AssetLibrary<MapGenSettingsAsset>
public class MapGenTemplate : Asset, IDescriptionAsset, ILocalizedAsset
public class MapGenTemplateLibrary : AssetLibrary<MapGenTemplate>
public class MapGenValues
public class MapId : MonoBehaviour
public class MapLayer : BaseMapObject
public delegate void MapLoaderAction();
internal class MapLoaderContainer
public class MapMetaData
	public int structures;
public class MapName : MonoBehaviour
public enum MapObjectType
public class MapPreviewImage : MonoBehaviour
public class MapRegion : IEquatable<MapRegion>
public class MapShowMeta : MonoBehaviour
public class MapSizeAsset : Asset, ILocalizedAsset
public class MapSizeLibrary : AssetLibrary<MapSizeAsset>
public class MapSizeTextUpdater : MonoBehaviour
public class MapStats
public class MapTag : MonoBehaviour
public class MapTagButton : MonoBehaviour
public enum MapTagType
public class MapTagWindow : MonoBehaviour
public static class MapUploader
public class MapUploadingWindow : MonoBehaviour
public class MapUploadReadyWindow : MonoBehaviour
public class MaskAutoEnabler : MonoBehaviour
public static class MB
	public const string onstructionBuildingStone = "event:/SFX/BUILDINGS/onstructionBuildingStone";
	public const string onstructionBuildingWood = "event:/SFX/BUILDINGS/onstructionBuildingWood";
	public const string onstructionBuildingGeneric = "event:/SFX/BUILDINGS/onstructionBuildingGeneric";
namespace ai.behaviours;
public enum MeatTargetType
public delegate IBanner MetaBanner(MetaCustomizationAsset pAsset, NanoObject pNanoObject, Transform pParent);
public class MetaBannerElement
public delegate bool MetaCheckUnitWindowAction(Actor pUnit);
public delegate void MetaCustomization();
public class MetaCustomizationAsset : Asset, IMultiLocalesAsset
public delegate ColorLibrary MetaCustomizationColorLibrary();
public delegate void MetaCustomizationComponent(GameObject pGameObject);
public delegate int MetaCustomizationCounter();
public class MetaCustomizationLibrary : AssetLibrary<MetaCustomizationAsset>
public delegate int MetaCustomizationOptionGet();
public delegate void MetaCustomizationOptionSet(int pValue);
public class MetaDialogueElement : MetaNeedsElementBase
public delegate NanoObject MetaGetter(long pId);
public static class MetaHelper
public delegate long MetaIdGetter(StatisticsAsset pAsset);
public delegate void MetaIncreaseRenown(int pAmount, MetaObjectData pObjectData);
public class MetaListNoItems : MonoBehaviour
public class MetaNeedsAndDialogueElement : MetaNeedsElementBase
public class MetaNeedsElementBase : WindowMetaElementBase, IRefreshElement
public class MetaNeedsElementUnit : UnitElement
public abstract class MetaObject<TData> : CoreSystemObject<TData>, IMetaObject, ICoreObject where TData : MetaObjectData
public class MetaObjectCounter<TObject, TData> where TObject : MetaObject<TData> where TData : MetaObjectData
public class MetaObjectData : BaseSystemData
public class MetaObjectWithTraits<TData, TBaseTrait> : MetaObject<TData>, ITraitsOwner<TBaseTrait> where TData : MetaObjectData where TBaseTrait : BaseTrait<TBaseTrait>
public class MetaRepresentationAsset : Asset, ILocalizedAsset
public class MetaRepresentationContainer : MetaRepresentationContainerBase
public class MetaRepresentationContainerBase : StatsRowsContainer
public class MetaRepresentationLibrary : AssetLibrary<MetaRepresentationAsset>
public class MetaRepresentationTotal : MetaRepresentationContainerBase
public delegate NanoObject MetaSelectedGetter();
public delegate void MetaSelectedSetter(NanoObject pElement);
public class MetaSpriteSwitcher : SpriteSwitcher
public delegate void MetaStatAction(long pMetaId, MonoBehaviour pField);
public class MetaSwitchButton : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
public class MetaSwitchManager : MonoBehaviour
	public enum Direction
public abstract class MetaSystemManager<TObject, TData> : CoreSystemManager<TObject, TData> where TObject : MetaObject<TData>, new() where TData : MetaObjectData, new()
		using IEnumerator<TObject> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			TObject current = enumerator.Current;
		using IEnumerator<TObject> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearLastYearStats();
		using IEnumerator<TObject> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			TObject current = enumerator.Current;
		using (IEnumerator<TObject> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				TObject current = enumerator.Current;
		using IEnumerator<TObject> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			TObject current = enumerator.Current;
public delegate bool MetaTextReportAction(IMetaObject pMetaObject);
public class MetaTextReportAsset : Asset, IMultiLocalesAsset
public class MetaTextReportHelper
public class MetaTextReportLibrary : AssetLibrary<MetaTextReportAsset>
public delegate void MetaTooltipShowAction(NanoObject pType);
public enum MetaType
public delegate void MetaTypeAction();
public delegate void MetaTypeActionAsset(MetaTypeAsset pAsset);
public class MetaTypeAsset : Asset
public static class MetaTypeExtensions
public delegate void MetaTypeHistoryAction(ref WindowHistoryData pHistoryData);
public class MetaTypeLibrary : AssetLibrary<MetaTypeAsset>
public delegate IEnumerable<NanoObject> MetaTypeListAction();
public delegate bool MetaTypeListHasAction();
public delegate ListPool<NanoObject> MetaTypeListPoolAction();
public delegate void MetaUnitSetMetaForWindow(Actor pUnit);
public delegate bool MetaZoneClickAction(WorldTile pTile, string pPower = null);
public delegate void MetaZoneDrawAction(MetaTypeAsset pAsset);
public delegate void MetaZoneDynamicAction();
public delegate IMetaObject MetaZoneGetMeta(TileZone pZone, int pZoneOption);
public delegate IMetaObject MetaZoneGetMetaSimple(TileZone pZone);
public delegate void MetaZoneHighlightAction(MetaTypeAsset pMetaTypeAsset, WorldTile pTile, QuantumSpriteAsset pAsset);
public delegate bool MetaZoneTooltipAction(TileZone pZone, MetaTypeAsset pAsset, int pZoneOption);
public class Meteorite : BaseEffect
namespace ai.behaviours;
public class MindLibrary : BehaviourTaskActorLibrary
public readonly struct MiniBench : IDisposable
public readonly struct MinMax
public class ModLoader : MonoBehaviour
				Debug.Log((object)("[" + text2 + "] classes inside the mod:"));
					Debug.LogError((object)("[" + text2 + "] Missing className: " + text2 + ".WorldBoxMod"));
public class MonthAsset : Asset, IDescriptionAsset, ILocalizedAsset
public class MonthLibrary : AssetLibrary<MonthAsset>
public class MoodAsset : Asset
public class MoodLibrary : AssetLibrary<MoodAsset>
public class MouseCursor : MonoBehaviour
public enum MouseHoldAnimation
public class MoveCamera : BaseMapObject
public class MultiBannerPool
public class MultiStackPool<T> where T : new()
public class MusicAsset : Asset
public delegate void MusicAssetDelegate(MusicBoxContainerUnits pContainer);
public class MusicBox : MonoBehaviour
public class MusicBoxContainerCivs
public class MusicBoxContainerTiles
public class MusicBoxContainerUnits
public class MusicBoxDebug
public class MusicBoxIdle
public class MusicBoxLibrary : AssetLibrary<MusicAsset>
public struct MusicBoxTileData
public enum MusicLayerPriority
public enum MusicState
public readonly struct NameEntry
public class NameGenerator
public class NameGeneratorAsset : Asset
public delegate bool NameGeneratorCheck(Actor pActor);
public static class NameGeneratorChecks
public delegate string NameGeneratorFinalizer(string pName);
public class NameGeneratorLibrary : AssetLibrary<NameGeneratorAsset>
		addDictPart("hatred", "Hatred,Dislike,Grudge,Detest,Despise,Death,Destruction,Oblivion,Silence,Obliteration");
public delegate void NameGeneratorReplacer(ref string pName, Actor pActor);
public delegate void NameGeneratorReplacerKingdom(ref string pName, Kingdom pKingdom);
public static class NameGeneratorReplacers
public static class NameGeneratorTests
public class NameInput : MonoBehaviour
public delegate bool NameplateAction(Culture pCulture = null, Alliance pAlliance = null, Kingdom pKingdom = null, City pCity = null, Clan pClan = null);
public class NameplateAsset : Asset
public delegate void NameplateBase(NameplateManager pManager, NameplateAsset pAsset);
public class NameplateLibrary : AssetLibrary<NameplateAsset>
public class NameplateManager : MonoBehaviour
public enum NameplateRenderingType
public class NameplateText : MonoBehaviour
public class NameSetAsset : Asset
public class NameSetsLibrary : AssetLibrary<NameSetAsset>
public class NanoObject : IComparable<NanoObject>, IEquatable<NanoObject>, IDisposable
public static class NanoObjectExtensions
public class NapalmFlash : BaseEffect
public class NerveImpulseElement : MonoBehaviour
public class NeuralLayerAsset : Asset, IDescriptionAsset, ILocalizedAsset
public static class NeuralLayerAssetExtensions
public class NeuralLayerLibrary : AssetLibrary<NeuralLayerAsset>
	private Dictionary<NeuroLayer, NeuralLayerAsset> _dict_enum_assets = new Dictionary<NeuroLayer, NeuralLayerAsset>();
			_dict_enum_assets.Add(item.layer, item);
		return _dict_enum_assets[pLayerID];
public enum NeuroLayer
public class NeuronElement : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IInitializePotentialDragHandler
public class NeuronsOverview : UnitElement, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IDragHandler, IEndDragHandler
namespace EpPathFinding.cs;
public class Node : IComparable<Node>, IDisposable
namespace EpPathFinding.cs;
public class NodePool
public class NotchMover : MonoBehaviour
public static class NucleobaseHelper
public class Nucleus
public class NukeFlash : BaseEffect
public class NullableLongJsonConverter : JsonConverter
public class NullableLongListJsonConverter : JsonConverter
public class ObjectContainer<T> : IEnumerable<T>, IEnumerable
public delegate void ObjectContainerAction<T>(ObjectContainer<T> pContainer);
public class ObjectPoolGenericMono<T> where T : Component
namespace tools;
public class OceanHelper
public delegate void OnChange();
public delegate void OnKnowledgeIconClick(KnowledgeAsset pAsset);
public class OnlineStats
public delegate void OnomasticsActionUpdate();
public class OnomasticsAsset : Asset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset
public class OnomasticsAssetButton : MonoBehaviour
public enum OnomasticsAssetType
public delegate void OnomasticsButtonAction();
public static class OnomasticsCache
public delegate bool OnomasticsCheckDelegate(OnomasticsAsset pAsset, OnomasticsData pData, StringBuilderPool pStringBuilder, string pLastPart, int pIndex, ActorSex pSex);
public class OnomasticsData : IDisposable
public class OnomasticsDataGroup
public class OnomasticsDropdown : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
public class OnomasticsEvolutionAsset : Asset
public class OnomasticsEvolutionLibrary : AssetLibrary<OnomasticsEvolutionAsset>
public static class OnomasticsEvolver
public class OnomasticsLibrary : AssetLibrary<OnomasticsAsset>
public class OnomasticsNameGenerator : MonoBehaviour
public delegate string OnomasticsNameMakerDelegate(OnomasticsAsset pAsset, OnomasticsData pData, StringBuilderPool pStringBuilder, string pLastPart, int pIndex, ActorSex pSex);
public delegate bool OnomasticsReplacerDelegate(OnomasticsEvolutionAsset pAsset, ref string pReplace);
public class OnomasticsReportGenerator
public class OnomasticsTab : OnomasticsNameGenerator
public delegate void OnWorldLoadAction();
public class OpinionAsset : Asset, IMultiLocalesAsset
public delegate int OpinionDelegateCalc(Kingdom pMain, Kingdom pTarget);
public class OpinionLibrary : AssetLibrary<OpinionAsset>
public class OptionAsset : Asset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset, IMultiLocalesAsset
public class OptionBool : MonoBehaviour
public class OptionButton : MonoBehaviour
public class OptionsLibrary : AssetLibrary<OptionAsset>
public enum OptionType
public class OrderedContractResolver : DefaultContractResolver
			return pType.IsSubclassOf(typeof(Delegate));
public static class ParallelHelper
namespace EpPathFinding.cs;
public abstract class ParamBase
namespace EpPathFinding.cs;
public class PartialGridWPool : BaseGrid
public delegate bool PassableZoneChecker(TileZone pZone, TileZone pZoneCenter = null);
public class PatchLogElement : MonoBehaviour
public class PatchLogEntry
public class PatchLogLoader : MonoBehaviour
public class PatchLogTitle : MonoBehaviour
public enum PathFinderResult
public class PathfinderTools
public class PathFindingVisualiser : MapLayer
public class PauseButton : MonoBehaviour
public class PerlinReplaceContainer
public class PerlinReplaceOption
public class PersonalityAsset : Asset, ILocalizedAsset
public class PersonalityLibrary : AssetLibrary<PersonalityAsset>
public class PhenotypeAsset : BaseAugmentationAsset, ISkipLocaleAsset
public class PhenotypeLibrary : AssetLibrary<PhenotypeAsset>
public enum PivotPresets
public struct Pixel
public class PixelBag
public static class PixelBagManager
public static class PixelDetector
public class PixelFlashEffects : MapLayer
public class PlatformRemover : MonoBehaviour
public class PlayCounterMapQueue : QueueItem
public class PlayerConfig
public class PlayerConfigData
public class PlayerControl
public class PlayerNameInput : MonoBehaviour
public delegate void PlayerOptionAction(PlayerOptionData pOption);
public class PlayerOptionData
public class PlayInterstitialAd : MonoBehaviour
public class Plot : MetaObject<PlotData>
public delegate bool PlotAction(Actor pActor);
public delegate int PlotActorDelegate(Actor pActor);
public delegate bool PlotActorPlotDelegate(Actor pActor, Plot pPlot);
public class PlotAsset : BaseAugmentationAsset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset
public class PlotBanner : BannerGeneric<Plot, PlotData>
public class PlotButton : AugmentationButton<PlotAsset>
public class PlotCategoryAsset : BaseCategoryAsset
public class PlotCategoryLibrary : BaseCategoryLibrary<PlotCategoryAsset>
public delegate bool PlotCheckerDelegate(Actor pActor);
public class PlotData : MetaObjectData
public delegate string PlotDescription(Plot pPlot);
public class PlotEditorButton : AugmentationEditorButton<PlotButton, PlotAsset>
public class PlotElement : WindowMetaElement<Plot, PlotData>
public class PlotGroupElement : AugmentationCategory<PlotAsset, PlotButton, PlotEditorButton>
public struct PlotIconData
public class PlotListComponent : ComponentListBase<PlotListElement, Plot, PlotData, PlotListComponent>
public class PlotListElement : WindowListElementBase<Plot, PlotData>
public class PlotManager : MetaSystemManager<Plot, PlotData>
		using IEnumerator<Plot> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.updateProgress(pElapsed);
		using IEnumerator<Plot> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.updateAnimations(pElapsed);
		using IEnumerator<Plot> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			Plot current = enumerator.Current;
		using IEnumerator<Plot> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			Plot current = enumerator.Current;
		using (IEnumerator<Plot> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				Plot current = enumerator.Current;
public class PlotMembers : PlotElement
public delegate bool PlotRetryAction();
public class PlotsEditor : AugmentationsEditor<PlotAsset, PlotButton, PlotEditorButton, PlotCategoryAsset, PlotGroupElement, IPlotsWindow, IPlotsEditor>, IPlotsEditor, IAugmentationsEditor
public class PlotsLibrary : BaseLibraryWithUnlockables<PlotAsset>
public delegate bool PlotStart(Actor pActor, PlotAsset pPlotAsset);
public enum PlotState
public delegate bool PlotTryToStart(Actor pActor, PlotAsset pPlotAsset, bool pForced);
public class PlotWindow : WindowMetaGeneric<Plot, PlotData>
public class Poop : BaseBuildingComponent
public class PopulationPyramidController : MonoBehaviour
public class PopulationPyramidItem : MonoBehaviour
public class PopulationPyramidRow : MonoBehaviour
public enum PossessionActionMode
public class PossessionModeButton : MonoBehaviour
public class PossessionUI : MonoBehaviour
public class PossessionUnitInfo : MonoBehaviour
public delegate bool PowerAction(WorldTile pTile, GodPower pPower);
public enum PowerActionType
public delegate bool PowerActionWithID(WorldTile pTile, string pPowerID);
public class PowerButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IInitializePotentialDragHandler, IScrollHandler
public delegate bool PowerButtonClickAction(string pPower);
public class PowerButtonSelector : MonoBehaviour
public enum PowerButtonType
public class PowerClockButton : MonoBehaviour
using strings;
public class PowerLibrary : AssetLibrary<GodPower>
		addDestruction();
	private void addDestruction()
public enum PowerRank
public class PowersTab : MonoBehaviour
public delegate void PowerTabAction(PowerTabAsset pPowerTabAsset);
public delegate bool PowerTabActionCheck(PowerTabAsset pPowerTabAsset);
public class PowerTabAsset : Asset, IDescriptionAsset, ILocalizedAsset
public class PowerTabController : MonoBehaviour
public delegate PowersTab PowerTabGetter();
public class PowerTabLibrary : AssetLibrary<PowerTabAsset>
			id = "destruction",
public delegate string PowerTabWorldtipAction(PowerTabAsset pPowerTabAsset);
public delegate void PowerToggleAction(string pPower);
internal class PowerTracker : MonoBehaviour
public class PreciseLocale
	private interface PlatformBridge
	private class EditorBridge : PlatformBridge
	private class PreciseLocaleWindows : PlatformBridge
public class PrefabLibrary : MonoBehaviour
public class PrefabUnitElement : WindowListElementBaseActor, IPointerMoveHandler, IEventSystemHandler
	private sealed class _003C_003Ec
public class PrefixesSettings : StructureSettings
public static class PreloadHelpers
public class PremiumElementsChecker : MonoBehaviour
public class PremiumUnlockAnimation : MonoBehaviour
public class PremiumWindow : MonoBehaviour
public static class PreviewHelper
public static class PreviewUploader
public class PrintLibrary : MonoBehaviour
public struct PrintStep
public class PrintTemplate
public class ProfessionAsset : Asset
public class ProfessionLibrary : AssetLibrary<ProfessionAsset>
	public static readonly UnitProfession[] list_enum_profession_ids = (UnitProfession[])Enum.GetValues(typeof(UnitProfession));
public class Projectile : CoreSystemObject<ProjectileData>
public class ProjectileAsset : Asset
public class ProjectileData : BaseSystemData
public class ProjectileLibrary : AssetLibrary<ProjectileAsset>
public class ProjectileManager : CoreSystemManager<Projectile, ProjectileData>
public enum ProjectileState
public class QualityChanger : MonoBehaviour
public class QuantumSprite : GroupSpriteObject
public class QuantumSpriteAnimated : QuantumSpriteArrows
public class QuantumSpriteArrows : QuantumSprite
public class QuantumSpriteAsset : Asset
public class QuantumSpriteCacheData
public delegate void QuantumSpriteCreate(QuantumSpriteAsset pAsset, QuantumSprite pMark);
public class QuantumSpriteGroupSystem : SpriteGroupSystem<QuantumSprite>
public class QuantumSpriteLibrary : AssetLibrary<QuantumSpriteAsset>
			if (item.is_visible && item.isUsable() && !item.isUnderConstruction())
public static class QuantumSpriteManager
public delegate void QuantumSpriteUpdater(QuantumSpriteAsset pAsset);
public class QuantumSpriteWithText : QuantumSprite
public class QueueItem
public delegate List<string> RainListGetter();
public enum RainState
public delegate RainState RainStateGetter();
public delegate void RainStateSetter(RainState pState);
public class RainSwitcherButton : MonoBehaviour
public struct RandomArrayEnumerator<T> : IEnumerator<T>, IEnumerator, IDisposable, IEnumerable<T>, IEnumerable
public struct RandomListEnumerator<T> : IEnumerator<T>, IEnumerator, IDisposable, IEnumerable<T>, IEnumerable
public static class Randy
		IEnumerable<T> enumerable;
					enumerable = list2.LoopRandom();
					enumerable = tPool.LoopRandom();
				enumerable = array.LoopRandom(array.Length);
			enumerable = list.LoopRandom();
			foreach (T item in enumerable)
		IEnumerable<T> enumerable;
					enumerable = list2.LoopRandom(pMax);
					enumerable = tPool.LoopRandom(pMax);
				enumerable = array.LoopRandom(array.Length, pMax);
			enumerable = list.LoopRandom(pMax);
			foreach (T item in enumerable)
public enum Rarity
public class RarityAsset : Asset, ILocalizedAsset
public static class RarityExtensions
public class RarityLibrary : AssetLibrary<RarityAsset>
public class RateCounter
internal struct RateCounterData
public class RateUsChecker : MonoBehaviour
public class RateUsRemover : MonoBehaviour
public static class RectExtensions
public static class RectTransformExtensions
public class RegionLink : IEquatable<RegionLink>
public static class RegionLinkHashes
public class RegionPathFinder
public class RegionsContainer : ObjectContainer<MapRegion>
public class Register
public class RegisterButton : MonoBehaviour
public class RegisterDetails : MonoBehaviour
public class RegisterQueue : QueueItem
public class RegisterUsername : MonoBehaviour
public class Religion : MetaObjectWithTraits<ReligionData, ReligionTrait>
public class ReligionBanner : BannerGeneric<Religion, ReligionData>
public class ReligionBannerLibrary : GenericBannerLibrary
public class ReligionColorsLibrary : ColorLibrary
public class ReligionCustomizeWindow : GenericCustomizeWindow<Religion, ReligionData, ReligionBanner>
public class ReligionData : MetaObjectData
public class ReligionElement : WindowMetaElement<Religion, ReligionData>
public class ReligionListComponent : ComponentListBase<ReligionListElement, Religion, ReligionData, ReligionListComponent>
public class ReligionListElement : WindowListElementBase<Religion, ReligionData>
public class ReligionManager : MetaSystemManager<Religion, ReligionData>
		using IEnumerator<Religion> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListKingdoms();
		using IEnumerator<Religion> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearListCities();
public class ReligionSelectedContainerTraits : SelectedContainerTraits<ReligionTrait, ReligionTraitButton, ReligionTraitsContainer, ReligionTraitsEditor>
public class ReligionStatsElement : ReligionElement, IStatsElement, IRefreshElement
public class ReligionTrait : BaseTrait<ReligionTrait>
public class ReligionTraitButton : TraitButton<ReligionTrait>
public class ReligionTraitEditorButton : TraitEditorButton<ReligionTraitButton, ReligionTrait>
public class ReligionTraitGroupAsset : BaseTraitGroupAsset
public class ReligionTraitGroupElement : TraitGroupElement<ReligionTrait, ReligionTraitButton, ReligionTraitEditorButton>
public class ReligionTraitGroupLibrary : BaseCategoryLibrary<ReligionTraitGroupAsset>
			id = "destruction",
			name = "trait_group_destruction",
public class ReligionTraitLibrary : BaseTraitLibrary<ReligionTrait>
			group_id = "destruction",
			group_id = "destruction",
			group_id = "destruction",
			group_id = "destruction",
			group_id = "destruction",
			group_id = "destruction",
		t.group_id = "destruction";
		t.group_id = "destruction";
		t.group_id = "destruction";
public class ReligionTraitsContainer : TraitsContainer<ReligionTrait, ReligionTraitButton>
public class ReligionTraitsEditor : TraitsEditor<ReligionTrait, ReligionTraitButton, ReligionTraitEditorButton, ReligionTraitGroupAsset, ReligionTraitGroupElement>
public class ReligionWindow : WindowMetaGeneric<Religion, ReligionData>, ITraitWindow<ReligionTrait, ReligionTraitButton>, IAugmentationsWindow<ITraitsEditor<ReligionTrait>>, IBooksWindow
public delegate bool RenderEffectCheck(ActorAsset pAsset);
public class ReplacerAchievements : MonoBehaviour
public class ReplacerTutorialBear : MonoBehaviour
public class ReplacerWorldLawIllustration : MonoBehaviour
public class ReplacerWorldLawsCursed : MonoBehaviour
public class ReportMapQueue : QueueItem
public enum ReproductiveStrategy
public class RequestHelper
public enum RequireCondition
public delegate void ResizeAction(float pWidth, float pHeight);
public delegate void ResizeUIAction(float pUISize);
public class ResolutionDropdown : MonoBehaviour
public class ResourceAsset : Asset, ILocalizedAsset, IHandRenderer
public struct ResourceContainer
public delegate void ResourceEatAction(ResourceAsset pAsset);
public class ResourceLibrary : AssetLibrary<ResourceAsset>
public readonly struct ResourceThrowData
public class ResourceThrowManager
public enum ResType
public class RewardAnimation : MonoBehaviour
internal enum RewardAnimationState
public class RewardedAds : MonoBehaviour
public class RewardedPower
public class RewardPowerWindow : MonoBehaviour
internal sealed class RewardTester
public class RewardUI : MonoBehaviour
public class RewardWindowController : MonoBehaviour
public class RoadGenerator
public class RoadsCalculator : BaseModule
public class RotateOnHover : MonoBehaviour
public enum RotationDirection
public class RunningIcon : MonoBehaviour, IDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IScrollHandler, IPointerClickHandler, IDraggable
public delegate void RunningIconCallback(Transform pIcon);
public class RunningIcons : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
	public enum Direction
public class S3Manager : MonoBehaviour
public class Santa : BaseEffect
public class SantaAnimation : BaseMapObject
public enum SapientListFilter
public class SapientListWindow : ListWindow
public static class SaveConverter
public class SaveCustomData : BaseSystemData
public class SavedMap
		mapMetaData.structures = num7;
public class SaveFileToImage : MonoBehaviour
public class SaveManager : MonoBehaviour
public class SaveSlotManager : MonoBehaviour
public class SaveSlotWindow : MonoBehaviour
public class SaveWindowIcons : MonoBehaviour
public class SaveWorldButton : MonoBehaviour
public class ScrollableButton : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IInitializePotentialDragHandler, IScrollHandler
public class ScrollableSlider : MonoBehaviour, IScrollHandler, IEventSystemHandler
public class ScrollHandleFixer : MonoBehaviour, ILayoutSelfController, ILayoutController
public static class ScrollingHelper
public class ScrollRectExtended : UIBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutElement, ILayoutGroup, ILayoutController
	public enum MovementType
	public enum ScrollbarVisibility
	public class ScrollRectEvent : UnityEvent<Vector2>
public class ScrollWindow : MonoBehaviour, IShakable
public delegate void ScrollWindowAction();
public delegate void ScrollWindowNameAction(string pWindowID);
public class SelectedAlliance : SelectedMeta<Alliance, AllianceData>
public class SelectedArmy : SelectedMetaWithUnit<Army, ArmyData>
public class SelectedCity : SelectedMetaWithUnit<City, CityData>
public class SelectedClan : SelectedMetaWithUnit<Clan, ClanData>
public class SelectedContainerTraits<TTrait, TTraitButton, TTraitContainer, TTraitEditor> : SelectedElementBase<TTraitButton>, ISelectedContainerTrait where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait> where TTraitContainer : ITraitsContainer<TTrait, TTraitButton> where TTraitEditor : ITraitsEditor<TTrait>
public class SelectedCulture : SelectedMeta<Culture, CultureData>
public class SelectedElementBase<TComponent> : MonoBehaviour where TComponent : Component
public class SelectedFamily : SelectedMetaWithUnit<Family, FamilyData>
public class SelectedKingdom : SelectedMetaWithUnit<Kingdom, KingdomData>
public class SelectedLanguage : SelectedMeta<Language, LanguageData>
public class SelectedMeta<TMeta, TMetaData> : SelectedNano<TMeta> where TMeta : MetaObject<TMetaData>, IFavoriteable where TMetaData : MetaObjectData
public static class SelectedMetas
public class SelectedMetaUnitElement : MonoBehaviour
public class SelectedMetaWithUnit<TMeta, TMetaData> : SelectedMeta<TMeta, TMetaData>, ISelectedMetaWithUnit where TMeta : MetaObject<TMetaData>, IFavoriteable where TMetaData : MetaObjectData
public class SelectedMultipleUnitsTab : SelectedNano<Actor>, ISelectedMetaWithUnit
public class SelectedNano<TNanoObject> : SelectedNanoBase where TNanoObject : NanoObject, IFavoriteable
public class SelectedNanoBase : MonoBehaviour
public static class SelectedObjects
public class SelectedObjectsGraph : IEnumerable<NanoObject>, IEnumerable
		using (IEnumerator<NanoObject> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				NanoObject current = enumerator.Current;
		using (IEnumerator<NanoObject> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				if (enumerator.Current == pObject)
public class SelectedPowerTabTopButtons : MonoBehaviour
public class SelectedPowerTabTopContainer : MonoBehaviour
public class SelectedReligion : SelectedMeta<Religion, ReligionData>
public class SelectedSubspecies : SelectedMeta<Subspecies, SubspeciesData>
public class SelectedTabsHistory
public static class SelectedUnit
public delegate void SelectedUnitClearEvent();
public class SelectedUnitRefresher<T>
public class SelectedUnitTab : SelectedNano<Actor>
public sealed class SemanticVersion : IComparable, IComparable<SemanticVersion>, IEquatable<SemanticVersion>
		using IEnumerator<string> enumerator = version1.GetEnumerator();
		using IEnumerator<string> enumerator2 = version2.GetEnumerator();
		bool flag = enumerator.MoveNext();
		bool flag2 = enumerator2.MoveNext();
			num = CompareRelease(enumerator.Current, enumerator2.Current);
			flag = enumerator.MoveNext();
			flag2 = enumerator2.MoveNext();
public class SentenceAsset : Asset
public class SentencesLibrary : AssetLibrary<SentenceAsset>
public class SettingsWindow : TabbedWindow
public class Sfx : MonoBehaviour
public class ShadowEditor : MonoBehaviour
public class ShadowEnabler : MonoBehaviour
public delegate void SignalAction(object pObject = null);
public class SignalAsset : Asset
public delegate bool SignalBanCheckAction(object pObject = null);
public class SignalLibrary : AssetLibrary<SignalAsset>
public class SignalManager
public class SignButton : MonoBehaviour
public class SignoutButton : MonoBehaviour
public class SimGlobalAsset : Asset
public class SimGlobals : AssetLibrary<SimGlobalAsset>
public class SimObjectsZones
public class SimpleMod
public abstract class SimSystemManager<TObject, TData> : SystemManager<TObject, TData>, IEnumerable<TObject>, IEnumerable where TObject : BaseSimObject, ILoadable<TData>, new() where TData : BaseObjectData, new()
		using IEnumerator<TObject> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			TObject current = enumerator.Current;
public class SingleAction<TTask, TAction> where TTask : BehaviourTaskBase<TAction> where TAction : BehaviourElementAI
public delegate void SliderEndedEvent();
public class SliderExtended : Slider, IEndDragHandler, IEventSystemHandler
public delegate void SliderPointerDownEvent();
public class SlotButtonCallback : MonoBehaviour
internal struct SlotDrawAmount
public class Smoke : BaseEffect
public static class SmoothLoader
public enum SocialType
public class SortButton : MonoBehaviour
public delegate void SortButtonAction();
public delegate void SortButtonClearAction(SortButton pButton);
public class SortButtonContainer : MonoBehaviour
public enum SortButtonState
public class SortingTab : MonoBehaviour
public static class SoundBox
public class SoundController : MonoBehaviour
public class SparkEffect : BaseEffect
public class SpawnEffect : BaseEffect
public class SpectateUnit : MonoBehaviour
public class SpellAsset : Asset
public class SpellHolder
public class SpellLibrary : AssetLibrary<SpellAsset>
public enum SplitPathStatus
public class Spores : BaseEffect
public class SpriteAnimation : MonoBehaviour
public class SpriteAnimationSimple : MonoBehaviour
public class SpriteElement : MonoBehaviour
public delegate Sprite SpriteGetter(BaseUnlockableAsset pAsset);
public class SpriteGroupSystem<T> : MonoBehaviour where T : GroupSpriteObject
public class SpritePool
public class SpriteSet
public class SpriteShadow : MonoBehaviour
public static class SpriteSortingHelper
public class SpriteSwitcher : MonoBehaviour
public static class SpriteTextureLoader
namespace SQLite;
public static class SQLiteExtensions
public class StackEffects : BaseMapObject
public class StackPool<T> where T : new()
public class StatBar : MonoBehaviour
public delegate void StatBarUpdated(float pValue, float pMax);
namespace EpPathFinding.cs;
public class StaticGrid : BaseGrid
public class StatIconDarkToggle : MonoBehaviour
public class StatisticsAsset : Asset, IDescriptionAsset, ILocalizedAsset
public class StatisticsLibrary : AssetLibrary<StatisticsAsset>
public delegate long StatisticsLongAction(StatisticsAsset pAsset);
public class StatisticsRows : MonoBehaviour
public delegate string StatisticsStringAction(StatisticsAsset pAsset);
internal static class StatsHelper
public class StatsIcon : MonoBehaviour
public class StatsIconContainer : MonoBehaviour
public class StatsMetaRowsContainer : StatsRowsContainer
public class StatsRowsContainer : MonoBehaviour
public class StatsWindow : TabbedWindow
public static class StatTool
public class Status : CoreSystemObject<StatusData>
public class StatusAsset : Asset, IDescriptionAsset, ILocalizedAsset
public class StatusData : BaseSystemData
public class StatusEffectButton : MonoBehaviour
public class StatusLibrary : AssetLibrary<StatusAsset>
public class StatusManager : CoreSystemManager<Status, StatusData>
public class StatusParticle : BaseEffect
public enum StatusTier
internal static class SteamAchievements
public class SteamSDK : MonoBehaviour
public class SteamTracker : MonoBehaviour, IRichTracker
public class StorageBooks : IDisposable
public class StoryAsset : Asset
public class StoryLibrary : AssetLibrary<StoryAsset>
			language.data.structure = languageStructure;
		if (pLanguage.data.structure == null)
			LanguageStructure structure = new LanguageStructure();
			pLanguage.data.structure = structure;
		LanguageStructure structure = pLanguage.data.structure;
				if (simple.word_type != WordType.None && structure.settings_articles.enabled[word_type])
					array = structure.settings_articles.sets[word_type];
					listPool.Add(structure.settings_articles.separator[word_type]);
				string text = AssetManager.words_library.getSimple(random).getWordInLanguage(structure, simple, 0);
namespace System.Text;
public static class StringBuilderExtensions
public class StringBuilderPool : IDisposable, IEquatable<StringBuilderPool>, IEquatable<StringBuilder>
public static class StringExtension
public class StructureSettings
public class Subspecies : MetaObjectWithTraits<SubspeciesData, SubspeciesTrait>, ISapient
public class SubspeciesActorBirthTraits : ITraitsOwner<ActorTrait>
public class SubspeciesBanner : BannerGeneric<Subspecies, SubspeciesData>
public class SubspeciesBannerLibrary : GenericBannerLibrary
public class SubspeciesBirthTraitsContainer : MonoBehaviour, ITraitsContainer<ActorTrait, ActorTraitButton>
public class SubspeciesBirthTraitsEditor : TraitsEditor<ActorTrait, ActorTraitButton, ActorTraitEditorButton, ActorTraitGroupAsset, ActorTraitGroupElement>
public class SubspeciesColorsLibrary : ColorLibrary
public class SubspeciesCustomizeWindow : GenericCustomizeWindow<Subspecies, SubspeciesData, SubspeciesBanner>
public class SubspeciesData : MetaObjectData
public class SubspeciesElement : WindowMetaElement<Subspecies, SubspeciesData>
public class SubspeciesListComponent : ComponentListSapient<SubspeciesListElement, Subspecies, SubspeciesData, SubspeciesListComponent>
public class SubspeciesListElement : WindowListElementBase<Subspecies, SubspeciesData>
public class SubspeciesManager : MetaSystemManager<Subspecies, SubspeciesData>
public class SubspeciesSelectedContainerBirthTraits : SelectedContainerTraits<ActorTrait, ActorTraitButton, SubspeciesBirthTraitsContainer, SubspeciesBirthTraitsEditor>
public class SubspeciesSelectedContainerTraits : SelectedContainerTraits<SubspeciesTrait, SubspeciesTraitButton, SubspeciesTraitsContainer, SubspeciesTraitsEditor>
public class SubspeciesStatsElement : SubspeciesElement, IStatsElement, IRefreshElement
public class SubspeciesTrait : BaseTrait<SubspeciesTrait>, IAnimationFrames
public class SubspeciesTraitButton : TraitButton<SubspeciesTrait>
public class SubspeciesTraitEditorButton : TraitEditorButton<SubspeciesTraitButton, SubspeciesTrait>
public class SubspeciesTraitGroupAsset : BaseTraitGroupAsset
public class SubspeciesTraitGroupElement : TraitGroupElement<SubspeciesTrait, SubspeciesTraitButton, SubspeciesTraitEditorButton>
public class SubspeciesTraitGroupLibrary : BaseCategoryLibrary<SubspeciesTraitGroupAsset>
using strings;
public class SubspeciesTraitLibrary : BaseTraitLibrary<SubspeciesTrait>
		t.base_stats_meta["construction_speed"] = 2f;
		t.base_stats_meta["construction_speed"] = -1f;
public class SubspeciesTraitsContainer : TraitsContainer<SubspeciesTrait, SubspeciesTraitButton>
public class SubspeciesTraitsEditor : TraitsEditor<SubspeciesTrait, SubspeciesTraitButton, SubspeciesTraitEditorButton, SubspeciesTraitGroupAsset, SubspeciesTraitGroupElement>
public class SubspeciesWindow : WindowMetaGeneric<Subspecies, SubspeciesData>, ITraitWindow<SubspeciesTrait, SubspeciesTraitButton>, IAugmentationsWindow<ITraitsEditor<SubspeciesTrait>>
public static class SuccessionTool
public class SuffixesSettings : StructureSettings
public class SwitchButton : MonoBehaviour
public class SwitchStateButton : MonoBehaviour
public delegate void SwitchWindowsAction(MetaSwitchManager.Direction pDirection);
public abstract class SystemManager<TObject, TData> : BaseSystemManager where TObject : NanoObject, ILoadable<TData>, new() where TData : BaseSystemData, new()
public class TabbedWindow : MonoBehaviour
public class TabCenterer : MonoBehaviour
public delegate void TabHideAction();
public struct TabHistoryData
public delegate void TabShowAction(WindowMetaTab pCurrentTab);
public class TabToggle : MonoBehaviour
public delegate void TabToggleAction();
public delegate void TabToggleClearAction(TabToggle pToggle);
public class TabToggleContainer : MonoBehaviour
public class TabTogglesGroup : MonoBehaviour
public enum TabToggleState
public class TagButton : MonoBehaviour
public class TaskContainer<TCondition, TSimObject> where TCondition : BehaviourBaseCondition<TSimObject>
public static class TaskExtensions
namespace ai.behaviours;
public class TaskLibrary : BehaviourTaskActorLibrary
public delegate void TaskSwitchAction();
namespace life.taxi;
public class TaxiManager
namespace life.taxi;
public class TaxiRequest
namespace life.taxi;
public enum TaxiRequestState
namespace life.taxi;
public enum TaxiRequestType
public class TaxonomyRowsContainer : StatsRowsContainer
		showTaxonomicRank("taxonomy_class");
internal readonly struct TemperatureMod
public struct TempLinkStruct
public class TerraformLibrary : AssetLibrary<TerraformOptions>
public class TerraformOptions : Asset
public class TestActorGameObject : MonoBehaviour
public class TestActorSimpleObject
internal enum TestEnum
public class Tester : MonoBehaviour
public class TesterBehChangeWorldLaw : BehaviourActionTester
public class TesterBehChangeWorldSpeed : BehaviourActionTester
public class TesterBehCheckWorld : BehaviourActionTester
public class TesterBehClearFavorites : BehaviourActionTester
public class TesterBehClearWindowTest : BehaviourActionTester
public class TesterBehClickRandomButton : BehaviourActionTester
public class TesterBehCloseWindows : BehaviourActionTester
public class TesterBehCopyCurrentLanguage : BehaviourActionTester
public class TesterBehCullMobs : BehaviourActionTester
public class TesterBehCullUnits : BehaviourActionTester
public class TesterBehDestroySimObjects : BehaviourActionTester
public class TesterBehEndAutoTester : BehaviourActionTester
public class TesterBehEndJobTest : BehaviourActionTester
public class TesterBehFillWorld : BehaviourActionTester
public class TesterBehFindTileForCity : BehaviourActionTester
public class TesterBehGenerateMap : BehaviourActionTester
public class TesterBehLoadWorld : BehaviourActionTester
public class TesterBehLog : BehaviourActionTester
public class TesterBehOpenNextWindow : BehaviourActionTester
public class TesterBehOpenWindow : BehaviourActionTester
public class TesterBehOpenWindowTab : BehaviourActionTester
public class TesterBehPause : BehaviourActionTester
public class TesterBehPickRandomRace : BehaviourActionTester
public class TesterBehRandomMetaSwitch : BehaviourActionTester
public class TesterBehRandomWindowTab : BehaviourActionTester
public class TesterBehRequire : BehaviourActionTester
public class TesterBehRequireGroundRatio : BehaviourActionTester
public class TesterBehRequireUnits : BehaviourActionTester
public class TesterBehResetSeeds : BehaviourActionTester
public class TesterBehResetTweens : BehaviourActionTester
public class TesterBehRestartJobTest : BehaviourActionTester
public class TesterBehRestartTask : BehaviourActionTester
public class TesterBehSaveWorldIfEmpty : BehaviourActionTester
public class TesterBehScreenshotFolder : BehaviourActionTester
public class TesterBehScreenshotTooltips : BehaviourActionTester
public class TesterBehScreenshotWindow : BehaviourActionTester
public class TesterBehScrollWindow : BehaviourActionTester
public class TesterBehSelectRandomMetaObjects : BehaviourActionTester
public class TesterBehSetNextLanguage : BehaviourActionTester
public class TesterBehSetResolution : BehaviourActionTester
public class TesterBehSetupWindowTest : BehaviourActionTester
public class TesterBehShutdown : BehaviourActionTester
public class TesterBehSpawnPower : BehaviourActionTester
public class TesterBehSpawnPowerActor : TesterBehSpawnPower
public class TesterBehSpawnRandomBoat : TesterBehSpawnRandomUnit
public class TesterBehSpawnRandomBomb : TesterBehSpawnPower
public class TesterBehSpawnRandomBuilding : BehaviourActionTester
public class TesterBehSpawnRandomCivUnit : TesterBehSpawnRandomUnit
public class TesterBehSpawnRandomKingdomUnit : BehaviourActionTester
public class TesterBehSpawnRandomPower : TesterBehSpawnPower
public class TesterBehSpawnRandomSpecialUnit : TesterBehSpawnRandomUnit
public class TesterBehSpawnRandomUnit : BehaviourActionTester
public class TesterBehSpawnRandomZombie : TesterBehSpawnRandomUnit
public class TesterBehSuperDamageToUnits : BehaviourActionTester
public class TesterBehTaskLibrary : AssetLibrary<BehaviourTaskTester>
public class TesterBehWait : BehaviourActionTester
public class TesterBehWaitFor : BehaviourActionTester
public class TesterBehWaitForYear : BehaviourActionTester
public class TesterBehWaitYears : BehaviourActionTester
public class TesterJobLibrary : AssetLibrary<JobTesterAsset>
public class TesterMutateActorStatus : BehaviourActionTester
public class TesterMutateActorTraits : BehaviourActionTester
public class TesterMutateSubspeciesGenes : BehaviourActionTester
public class TesterMutateSubspeciesTraits : BehaviourActionTester
internal static class TestingCB
public class TestingEvent
public enum TestingEventType
public static class TestMaps
public enum TestStage
public static class TextExtension
public class TextSortingLayer : MonoBehaviour
public static class Texture2DStorage
public static class TextureExtensions
public class TextureRotator
public class TextureScale
	public class ThreadData
public class ThreadHelper : MonoBehaviour
public class ThunderFlash : BaseEffect
public static class TileActionLibrary
public enum TileDirection
public class TileEffect : BaseEffect
public class TileEffectAsset : Asset
public class TileEffectsLibrary : AssetLibrary<TileEffectAsset>
namespace ai.behaviours;
public enum TileFinderType
public sealed class TileIsland
public enum TileLayerType
public class TileLibrary : TileLibraryMain<TileType>
public class TileLibraryMain<T> : AssetLibrary<T> where T : TileTypeBase
public class TileManager
public class TilemapExtended : MonoBehaviour
public enum TileRank
public class TileSprites
public delegate bool TileStepAction(WorldTile pTile, Actor pActor);
public class TileType : TileTypeBase
public class TileTypeBase : Asset
public enum TileZIndexes
public class TileZone : IDisposable
internal class TimelineInfo
public class TipButton : MonoBehaviour
public enum TipStatus
public class ToggleButton : MonoBehaviour
public delegate void ToggleButtonAction();
public delegate void ToggleButtonSelectAction(ToggleButton pButton);
public class ToggleIcon : MonoBehaviour
public class ToggleObjects : MonoBehaviour
public delegate void ToggleRainStateAction();
public class ToolbarArrow : MonoBehaviour
public class ToolbarButtons : MonoBehaviour, IShakable
public class ToolBenchmarkData
public static class Toolbox
public class Tooltip : MonoBehaviour
public delegate void TooltipAction();
public class TooltipActorEquipmentsRow : TooltipItemsRow<TooltipOutlineItem>
public class TooltipActorTraitsRow : TooltipTraitsRow<ActorTrait>
public class TooltipAsset : Asset
public class TooltipClanTraitsRow : TooltipTraitsRow<ClanTrait>
public class TooltipCultureTraitsRow : TooltipTraitsRow<CultureTrait>
public class TooltipData : IDisposable
public delegate TooltipData TooltipDataGetter();
public class TooltipDebugHelper
public enum TooltipDirection
public class TooltipIconsRow : TooltipItemsRow<Image>
public class TooltipItemsRow<TComponent> : MonoBehaviour where TComponent : MonoBehaviour
public class TooltipKingdomTraitsRow : TooltipTraitsRow<KingdomTrait>
public class TooltipLanguageTraitsRow : TooltipTraitsRow<LanguageTrait>
public class TooltipLibrary : AssetLibrary<TooltipAsset>
		pTooltip.addLineText("class", pAsset.getTaxonomyRank("taxonomy_class"), ColorStyleLibrary.m.taxonomy_class, pPercent: false, pLocalize: false);
public readonly struct TooltipModContainerInfo
public readonly struct TooltipOpinionInfo
public class TooltipOutlineItem : MonoBehaviour
public class TooltipReligionTraitsRow : TooltipTraitsRow<ReligionTrait>
public enum TooltipScreenshotState
public delegate void TooltipShowAction(Tooltip pTooltip, string pType, TooltipData pData);
public class TooltipSpeciesSpawnTraitsRow : TooltipTraitsRow<SubspeciesTrait>
public class TooltipSubspeciesTraitsRow : TooltipTraitsRow<SubspeciesTrait>
public class TooltipTraitsRow<TTrait> : TooltipItemsRow<Image> where TTrait : BaseTrait<TTrait>
public delegate bool TopicCheck(Actor pActor);
public delegate void TopicPotFill(Actor pActor, ListPool<Sprite> pPotSprites);
public class TopPremiumButtonMover : MonoBehaviour
public class TopTileLibrary : TileLibraryMain<TopTileType>
public class TopTileType : TileTypeBase
public class TornadoEffect : BaseEffect
public class TouchCamera : MonoBehaviour
public class TouchPossessionController : MonoBehaviour
public static class TownPlans
public class TrailerModeSettings
public class TrailerMonolith : MonoBehaviour
public class TraitButton<TTrait> : AugmentationButton<TTrait> where TTrait : BaseTrait<TTrait>
public class TraitEditorButton<TTraitButton, TTrait> : AugmentationEditorButton<TTraitButton, TTrait> where TTraitButton : TraitButton<TTrait> where TTrait : BaseTrait<TTrait>
public class TraitGroupElement<TTrait, TTraitButton, TTraitEditorButton> : AugmentationCategory<TTrait, TTraitButton, TTraitEditorButton> where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait> where TTraitEditorButton : TraitEditorButton<TTraitButton, TTrait>
public class TraitRainAsset : Asset
public class TraitRainLibrary : AssetLibrary<TraitRainAsset>
public class TraitsContainer<TTrait, TTraitButton> : MonoBehaviour, ITraitsContainer<TTrait, TTraitButton> where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait>
public abstract class TraitsEditor<TTrait, TTraitButton, TTraitEditorButton, TTraitGroupAsset, TTraitGroup> : AugmentationsEditor<TTrait, TTraitButton, TTraitEditorButton, TTraitGroupAsset, TTraitGroup, ITraitWindow<TTrait, TTraitButton>, ITraitsEditor<TTrait>>, ITraitsEditor<TTrait>, IAugmentationsEditor where TTrait : BaseTrait<TTrait> where TTraitButton : TraitButton<TTrait> where TTraitEditorButton : TraitEditorButton<TTraitButton, TTrait> where TTraitGroupAsset : BaseTraitGroupAsset where TTraitGroup : TraitGroupElement<TTrait, TTraitButton, TTraitEditorButton>
public class TraitsGrid : MonoBehaviour, ILayoutController
public static class TraitTools
public enum TraitType
public static class TransformExtensions
public class Tutorial : MonoBehaviour
public class TutorialPage
public class TweenedColoredText : MonoBehaviour
public static class TweenExtensions
public static class TypeExtensions
public class UFO : BaseActorComponent
public class UiActionElement : MonoBehaviour
public class UiAutoTesterButton : MonoBehaviour
public class UiButtonHoverAnimation : MonoBehaviour
public class UiCityEquipment : CitySortableElement
public class UICityResources : CitySortableElement
public class UiCreature : MonoBehaviour
public class UiDebugButton : MonoBehaviour
public class UiDebugButtonBatchSize : MonoBehaviour
public class UiDebugWindow : TabbedWindow
public class UiGameStat : MonoBehaviour
public class UiGameStats : StatisticsRows
public class UiInputCounter : MonoBehaviour
public class UiMover : MonoBehaviour
public class UiPanelInfo : MonoBehaviour
public class UiSizeDropdown : MonoBehaviour
public class UiUnitAvatarElement : MonoBehaviour, IBanner, IBaseMono, IRefreshElement
public class UiWindowStretch : EventTrigger
public class UiWorldAgeInfo : MonoBehaviour
public delegate void UnfoldAction(bool pUnfold = false);
public class UnfoldButton : MonoBehaviour
public delegate bool UnfoldCheck(Actor pActor);
public class UnitAvatarLoader : MonoBehaviour
public class UnitBarsElement : UnitElement
public class UnitCityElement : UnitElement
public abstract class UnitElement : WindowMetaElementBase, IRefreshElement
public class UnitEquipmentContainer : UnitElement
public class UnitFamilyOriginElement : UnitElement
public class UnitGenealogyElement : UnitElement
public class UnitHandToolAsset : Asset, IHandRenderer
public class UnitHandToolLibrary : AssetLibrary<UnitHandToolAsset>
public class UnitHealthBarElement : UnitElement
public class UnitHouseElement : UnitElement
public class UnitLayer : MapLayer
public class UnitLoverElement : UnitElement
public class UnitMetaBanners : UnitElement, IBaseMetaBanners
public enum UnitProfession
public class UnitSelectionEffect : BaseAnimatedObject
public class UnitSpawner : BaseBuildingComponent
public class UnitSpiteConstructorDebug : MonoBehaviour
public class UnitSpriteAnimationData
public class UnitSpriteConstructorAtlas
	public UnitSpriteConstructorAtlas(UnitTextureAtlasID pID, bool pBigAtlas)
public class UnitStatsElement : UnitElement, IStatsElement, IRefreshElement
public class UnitStatusContainer : UnitElement
namespace ai.behaviours;
public class UnitTasks : BehaviourTaskActorLibrary
public class UnitTextManager : MonoBehaviour
public class UnitTextPhrases : MonoBehaviour
public enum UnitTextureAtlasID
public class UnitWindow : StatsWindow, ITraitWindow<ActorTrait, ActorTraitButton>, IAugmentationsWindow<ITraitsEditor<ActorTrait>>, IEquipmentWindow, IAugmentationsWindow<IEquipmentEditor>, IPlotsWindow, IAugmentationsWindow<IPlotsEditor>
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
	private struct MonoScriptData
public class UploadedMapDeleteManager
public class UploadedMapDeleteProgressWindow : MonoBehaviour
public class UploadedMapDownloadCounter
public class UploadedMapPlayCounter
public class UploadedMapReportManager
public class UploadedMapReportWindow : MonoBehaviour
public class UploadManager : MonoBehaviour
public class UploadMapQueue : QueueItem
public class UserForgotPasswordWindow : MonoBehaviour
public class UserLoginWindow : MonoBehaviour
public class Username
public class UserRegisterWindow : MonoBehaviour
public class UserSubscriptionWindow : MonoBehaviour
namespace EpPathFinding.cs;
public class Util
public class UtilityBasedDecisionSystem
public class ValueHolder
public enum VegetationType
internal static class VersionCallbacks
internal static class VersionCheck
public class VersionText : MonoBehaviour
public class VersionTextUpdater : MonoBehaviour
public class VertArrow : MonoBehaviour
namespace LayoutGroupExt;
public class VerticalLayoutGroupExtended : HorizontalOrVerticalLayoutGroupExtended
public class VerticalToolbarArrow : ToolbarArrow
public class ViewRainfall : MapLayer
public class ViewTemperature : MapLayer
public static class VortexAction
internal struct VortexSwitchHelper
public static class VowelSeparator
public class VS
internal class WallFrameContainer
public static class WallHelper
public class War : MetaObject<WarData>
		using (IEnumerator<Kingdom> enumerator = (hasEnded() ? getAllAttackers() : getAttackers()).GetEnumerator())
			if (enumerator.MoveNext())
				return enumerator.Current.getColor();
		using (IEnumerator<Kingdom> enumerator = (hasEnded() ? getAllDefenders() : getDefenders()).GetEnumerator())
			if (enumerator.MoveNext())
				return enumerator.Current.getColor();
		using (IEnumerator<Kingdom> enumerator = (hasEnded() ? getAllAttackers() : getAttackers()).GetEnumerator())
			if (enumerator.MoveNext())
				return enumerator.Current.getColor().color_text;
public class WarAttackersContainer : WarBannersContainer
public class WarBanner : BannerGeneric<War, WarData>
public class WarBannersContainer : WarElement
public class WarData : MetaObjectData
public class WarDefendersContainer : WarBannersContainer
public class WarElement : WindowMetaElement<War, WarData>
public class WarListComponent : ComponentListBase<WarListElement, War, WarData, WarListComponent>
public class WarListElement : WindowListElementBase<War, WarData>
public class WarManager : MetaSystemManager<War, WarData>
		using (IEnumerator<War> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				War current = enumerator.Current;
		using (IEnumerator<War> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				War current = enumerator.Current;
			using IEnumerator<War> enumerator = GetEnumerator();
			while (enumerator.MoveNext())
				War current2 = enumerator.Current;
		using (IEnumerator<War> enumerator = GetEnumerator())
			while (enumerator.MoveNext())
				War current = enumerator.Current;
		using (IEnumerator<War> enumerator = getWars(pKingdom).GetEnumerator())
			if (enumerator.MoveNext())
				_ = enumerator.Current;
		using (IEnumerator<War> enumerator = getWars(pAlliance).GetEnumerator())
			if (enumerator.MoveNext())
				_ = enumerator.Current;
		using (IEnumerator<War> enumerator = getWars(pKingdom, pRandom: true).GetEnumerator())
			if (enumerator.MoveNext())
				return enumerator.Current;
		using IEnumerator<War> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			War current = enumerator.Current;
		using (IEnumerator<War> enumerator = getActiveWars().GetEnumerator())
			if (enumerator.MoveNext())
				_ = enumerator.Current;
public class WarStatsElement : WarElement, IStatsElement, IRefreshElement
public class WarTooltipBannersContainer : MonoBehaviour
public class WarTypeAsset : Asset, IMultiLocalesAsset
public class WarTypeLibrary : AssetLibrary<WarTypeAsset>
public class WarWindow : WindowMetaGeneric<War, WarData>
public enum WarWinner
public static class WarWinnerExtensions
public enum WeaponType
public class Wheat : BaseBuildingComponent
internal enum WhooshState
public class WildKingdomsManager : MetaSystemManager<Kingdom, KingdomData>
		using IEnumerator<Kingdom> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			Kingdom current = enumerator.Current;
		using IEnumerator<Kingdom> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
			enumerator.Current.clearBuildingList();
public class WindowAsset : Asset
public class WindowBackground : MonoBehaviour
public class WindowFavorites : WindowListBaseActor
public class WindowHeader : MonoBehaviour
public class WindowHistory
public struct WindowHistoryData
internal class WindowKeyboardHighlighter : MonoBehaviour
public class WindowLibrary : AssetLibrary<WindowAsset>
public class WindowListBase<TListElement, TMetaObject, TData> : MonoBehaviour, IShouldRefreshWindow where TListElement : WindowListElementBase<TMetaObject, TData> where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
public class WindowListBaseActor : MonoBehaviour, IComponentList, IShouldRefreshWindow
public class WindowListElementBase<TMetaObject, TData> : MonoBehaviour, IPointerMoveHandler, IEventSystemHandler where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
	private sealed class _003C_003Ec
public class WindowListElementBaseActor : MonoBehaviour
public class WindowMetaElement<TMetaObject, TData> : WindowMetaElementBase where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
public abstract class WindowMetaElementBase : MonoBehaviour, IShouldRefreshWindow
public class WindowMetaGeneric<TMetaObject, TData> : StatsWindow, IMetaWindow, IInterestingPeopleWindow, IMetaWithFamiliesWindow where TMetaObject : CoreSystemObject<TData> where TData : BaseSystemData
public class WindowMetaTab : MonoBehaviour
public class WindowMetaTabButtonsContainer : MonoBehaviour
public class WindowMetaTabEvent : UnityEvent<WindowMetaTab>
public static class WindowPreloader
public class WindowPremiumRestoreHelper : MonoBehaviour
		"Reattaching soul bindings", "Refreshing mythos", "Loading universal constants", "Aligning timelines", "Resetting divine counters", "Auditing reality logs", "Reinitializing worldframe", "Binding laws of physics", "Sealing causality breaches", "Decoding fate instructions",
public struct WindowStats
public class WindowToolbar : MonoBehaviour, IShakable
public class WindowWelcome : MonoBehaviour
public class WordAsset : Asset
public class WordsLibrary : AssetLibrary<WordAsset>
public enum WordType
internal class WorkshopAchievements
public class WorkshopEmptyListWindow : MonoBehaviour
public class WorkshopHelpers : MonoBehaviour
public class WorkshopInfoIcons : MonoBehaviour
public class WorkshopMapData
public class WorkshopMapElement : MonoBehaviour
public class WorkshopMapListWindow : MonoBehaviour
public class WorkshopMapMetaData
public static class WorkshopMaps
public class WorkshopOpenSteamWorkshop : MonoBehaviour
public class WorkshopPlayMap : MonoBehaviour
public class WorkshopUploadingWorldWindow : MonoBehaviour
internal class WorkshopUploadProgress : IProgress<float>
public class WorkshopUploadWorldButton : MonoBehaviour
public static class World
public delegate bool WorldAction(BaseSimObject pTarget = null, WorldTile pTile = null);
public delegate bool WorldActionTrait(NanoObject pTarget, BaseAugmentationAsset pTrait);
public delegate void WorldAgeAction();
public class WorldAgeAsset : Asset, IDescriptionAsset, ILocalizedAsset
public class WorldAgeButton : BaseWorldAgeElement
public class WorldAgeEffects : MonoBehaviour
public delegate void WorldAgeElementAction(BaseWorldAgeElement pElement);
public class WorldAgeLibrary : AssetLibrary<WorldAgeAsset>
public class WorldAgeManager
public class WorldAgesParticles : MonoBehaviour
public class WorldAgesWindow : MonoBehaviour
public class WorldAgeWheel : MonoBehaviour
public class WorldAgeWheelPiece : BaseWorldAgeElement, IDropHandler, IEventSystemHandler
public class WorldBehaviour
public delegate void WorldBehaviourAction();
public class WorldBehaviourActionBiomes : WorldBehaviourTilesRunner
public static class WorldBehaviourActionBurnedTiles
public class WorldBehaviourActionCreepBiomass
public static class WorldBehaviourActionCreepDecay
public static class WorldBehaviourActionErosion
using strings;
public static class WorldBehaviourActionFire
public static class WorldBehaviourActionInferno
public class WorldBehaviourActionLava : WorldBehaviourTilesRunner
public static class WorldBehaviourActions
public static class WorldBehaviourActionSingularity
public static class WorldBehaviourActionSwampAnimation
public class WorldBehaviourAsset : Asset
public class WorldBehaviourClouds
public class WorldBehaviourLibrary : AssetLibrary<WorldBehaviourAsset>
public static class WorldBehaviourOcean
public class WorldBehaviourTileEffects
public class WorldBehaviourTilesRunner
public class WorldBehaviourTilesTemperatureFreeze : WorldBehaviourTilesRunner
public static class WorldBehaviourTilesTemperatureFreezeWaves
public class WorldBehaviourTilesTemperatureUnFreeze : WorldBehaviourTilesRunner
public class WorldBehaviourUnitTemperatures
public class WorldButton : MonoBehaviour
public enum WorldConstructionState
	UnderConstruction,
public class WorldElement : MonoBehaviour
public class WorldLanguagesWindow : MonoBehaviour
public class WorldLawAsset : BaseAugmentationAsset, IDescription2Asset, IDescriptionAsset, ILocalizedAsset
public class WorldLawCategory : MonoBehaviour
public class WorldLawElement : MonoBehaviour
public class WorldLawGroupAsset : BaseCategoryAsset
public class WorldLawGroupLibrary : BaseCategoryLibrary<WorldLawGroupAsset>
public class WorldLawLibrary : BaseLibraryWithUnlockables<WorldLawAsset>
public class WorldLaws
public class WorldLawsCursedStar : MonoBehaviour
public class WorldLawsCursedStars : MonoBehaviour
public class WorldLawsEditor : MonoBehaviour
public class WorldLawsTextInsult : MonoBehaviour
public class WorldLawsWindow : TabbedWindow
public class WorldLayer : MapLayer
public class WorldLayerEdges : MapLayer
public class WorldListByTag : MonoBehaviour
public class WorldListWindow : MonoBehaviour
internal class WorldLoader : MonoBehaviour
public class WorldLog
public class WorldLogAsset : Asset, IMultiLocalesAsset
public class WorldLogElement : MonoBehaviour
public class WorldLogLibrary : AssetLibrary<WorldLogAsset>
public class WorldLogMessage
public static class WorldLogMessageExtensions
public delegate void WorldLogTextFormatter(WorldLogMessage pMessage, ref string pText);
public class WorldLogWindow : MonoBehaviour
public struct WorldNetVersion
public class WorldNetWindow : MonoBehaviour
public class WorldObject : NanoObject, IMetaObject, ICoreObject
public class WorldStats : StatisticsRows
public enum WorldStatsTabs
public class WorldStatus : MonoBehaviour
public class WorldTemplateButton : MonoBehaviour
public class WorldTemplatesWindow : MonoBehaviour
public class WorldTile : IEquatable<WorldTile>, IDisposable
public class WorldTileContainer : ObjectContainer<WorldTile>
public class WorldTileData
public readonly struct WorldTileDataStruct : IEquatable<WorldTileDataStruct>
public class WorldTilemap : BaseMapObject
public class WorldTileZoneBorder
public class WorldTimer
public class WorldTimeScaleAsset : Asset, ILocalizedAsset
public class WorldTimeScaleLibrary : AssetLibrary<WorldTimeScaleAsset>
public class WorldTip : MonoBehaviour
public class WorldWindow : TabbedWindow, IInterestingPeopleWindow
public class XtwitterText : MonoBehaviour
public class ZoneCalculator : MapLayer
public class ZoneCamera
public readonly struct ZoneConnection : IEquatable<ZoneConnection>
public class ZoneData
public class ZoneFlash : BaseEffect
public struct ZoneMetaData
public static class ZoneMetaDataVisualizer
public static class Zones